"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/devices/elem/page",{

/***/ "(app-pages-browser)/./src/app/dashboard/devices/elem/page.tsx":
/*!*************************************************!*\
  !*** ./src/app/dashboard/devices/elem/page.tsx ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Page; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _src_app_lib_devicesUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/src/app/lib/devicesUtils */ \"(app-pages-browser)/./src/app/lib/devicesUtils.ts\");\n/* harmony import */ var _src_app_lib_token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/src/app/lib/token */ \"(app-pages-browser)/./src/app/lib/token.ts\");\n/* harmony import */ var _src_app_ui_dashboard_devicesCharts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/src/app/ui/dashboard/devicesCharts */ \"(app-pages-browser)/./src/app/ui/dashboard/devicesCharts.jsx\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeftIcon,ArrowPathIcon,EnvelopeIcon,GlobeAltIcon,MapPinIcon,PlusCircleIcon,WifiIcon,XMarkIcon!=!@heroicons/react/24/outline */ \"(app-pages-browser)/./node_modules/@heroicons/react/24/outline/esm/ArrowLeftIcon.js\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeftIcon,ArrowPathIcon,EnvelopeIcon,GlobeAltIcon,MapPinIcon,PlusCircleIcon,WifiIcon,XMarkIcon!=!@heroicons/react/24/outline */ \"(app-pages-browser)/./node_modules/@heroicons/react/24/outline/esm/MapPinIcon.js\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeftIcon,ArrowPathIcon,EnvelopeIcon,GlobeAltIcon,MapPinIcon,PlusCircleIcon,WifiIcon,XMarkIcon!=!@heroicons/react/24/outline */ \"(app-pages-browser)/./node_modules/@heroicons/react/24/outline/esm/PlusCircleIcon.js\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeftIcon,ArrowPathIcon,EnvelopeIcon,GlobeAltIcon,MapPinIcon,PlusCircleIcon,WifiIcon,XMarkIcon!=!@heroicons/react/24/outline */ \"(app-pages-browser)/./node_modules/@heroicons/react/24/outline/esm/XMarkIcon.js\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeftIcon,ArrowPathIcon,EnvelopeIcon,GlobeAltIcon,MapPinIcon,PlusCircleIcon,WifiIcon,XMarkIcon!=!@heroicons/react/24/outline */ \"(app-pages-browser)/./node_modules/@heroicons/react/24/outline/esm/ArrowPathIcon.js\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeftIcon,ArrowPathIcon,EnvelopeIcon,GlobeAltIcon,MapPinIcon,PlusCircleIcon,WifiIcon,XMarkIcon!=!@heroicons/react/24/outline */ \"(app-pages-browser)/./node_modules/@heroicons/react/24/outline/esm/WifiIcon.js\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeftIcon,ArrowPathIcon,EnvelopeIcon,GlobeAltIcon,MapPinIcon,PlusCircleIcon,WifiIcon,XMarkIcon!=!@heroicons/react/24/outline */ \"(app-pages-browser)/./node_modules/@heroicons/react/24/outline/esm/EnvelopeIcon.js\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeftIcon,ArrowPathIcon,EnvelopeIcon,GlobeAltIcon,MapPinIcon,PlusCircleIcon,WifiIcon,XMarkIcon!=!@heroicons/react/24/outline */ \"(app-pages-browser)/./node_modules/@heroicons/react/24/outline/esm/GlobeAltIcon.js\");\n/* harmony import */ var _barrel_optimize_names_Dialog_DialogTitle_mui_material__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=Dialog,DialogTitle!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/Dialog/Dialog.js\");\n/* harmony import */ var _barrel_optimize_names_Dialog_DialogTitle_mui_material__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Dialog,DialogTitle!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/DialogTitle/DialogTitle.js\");\n/* harmony import */ var cookies_next__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cookies-next */ \"(app-pages-browser)/./node_modules/cookies-next/lib/index.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\nfunction Page() {\n    _s();\n    const [deviceId, setDeviceId] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(null);\n    const [device, setDevice] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)({});\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_5__.useRouter)();\n    (0,react__WEBPACK_IMPORTED_MODULE_6__.useEffect)(()=>{\n        const verifyToken = async (token)=>{\n            let res = await (0,_src_app_lib_token__WEBPACK_IMPORTED_MODULE_2__.checkToken)(token);\n            if (!res) {\n                router.push(\"/login\");\n            }\n        };\n        // Verificar el token de autenticaciÃ³n\n        const token = (0,cookies_next__WEBPACK_IMPORTED_MODULE_4__.getCookie)(\"token\");\n        if (token === undefined) {\n            router.push(\"/login\");\n        }\n        verifyToken(token);\n        // Recuperar el identificador del dispositivo de la URL\n        const url = new URL(window.location.href);\n        let id = url.searchParams.get(\"id\");\n        if (id === null) {\n            router.push(\"/dashboard/devices\");\n        }\n        setDeviceId(id);\n        // Obtener los datos del dispositivo\n        const fetchDeviceInfo = async (id, token)=>{\n            let deviceInfo = await (0,_src_app_lib_devicesUtils__WEBPACK_IMPORTED_MODULE_1__.getDeviceInfo)(id, token);\n            setDevice(deviceInfo);\n        };\n        fetchDeviceInfo(id, token);\n    }, [\n        deviceId\n    ]);\n    // ------------------------------ ROTATION ------------------------------\n    const [rotation, setRotation] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(0);\n    //-----------------------------------------------------------------------\n    //------------------------------- Update Info ---------------------------\n    const updateInfo = async ()=>{\n        const token = (0,cookies_next__WEBPACK_IMPORTED_MODULE_4__.getCookie)(\"token\");\n        let deviceInfo = await (0,_src_app_lib_devicesUtils__WEBPACK_IMPORTED_MODULE_1__.getDeviceInfo)(deviceId, token);\n        setDevice(deviceInfo);\n        setRotation(rotation + 180);\n    };\n    //-----------------------------------------------------------------------\n    // ------------------------------ Eliminar dispositivo ------------------\n    const [IsOpenDeleteDeviceDialog, setIsOpenDeleteDeviceDialog] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(false);\n    const closeDeleteDeviceDialog = ()=>{\n        setIsOpenDeleteDeviceDialog(false);\n    };\n    const deleteDeviceButton = async ()=>{\n        setIsOpenDeleteDeviceDialog(true);\n    };\n    const confirmDeleteDevice = async ()=>{\n        const token = (0,cookies_next__WEBPACK_IMPORTED_MODULE_4__.getCookie)(\"token\");\n        // Eliminar el dispositivo\n        let res = await (0,_src_app_lib_devicesUtils__WEBPACK_IMPORTED_MODULE_1__.deleteDevice)(deviceId, token);\n        if (res) {\n            alert(\"Dispositivo eliminado correctamente\");\n        } else {\n            alert(\"Error al eliminar el dispositivo\");\n        }\n        // Cerrar el diÃ¡logo\n        closeDeleteDeviceDialog();\n        // Redirigir a la pÃ¡gina de dispositivos\n        if (res) {\n            router.push(\"/dashboard/devices\");\n        }\n    };\n    const deleteDeviceDialog = ()=>{\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Dialog_DialogTitle_mui_material__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n            open: IsOpenDeleteDeviceDialog,\n            onClose: closeDeleteDeviceDialog,\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Dialog_DialogTitle_mui_material__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                    className: \"w-full h-full\",\n                    children: \"\\xbfSeguro que deseas eliminar este dispositivo?\"\n                }, void 0, false, {\n                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                    lineNumber: 94,\n                    columnNumber: 17\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex flex-row p-4 gap-4\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            onClick: closeDeleteDeviceDialog,\n                            className: \"w-1/2 h-12 text-white bg-indigo-600 rounded-md hover:bg-indigo-500 duration-150\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                children: \"Cancelar\"\n                            }, void 0, false, {\n                                fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                lineNumber: 97,\n                                columnNumber: 25\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                            lineNumber: 96,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            onClick: confirmDeleteDevice,\n                            className: \"w-1/2 h-12 text-white rounded-md bg-red-600 hover:bg-red-500 duration-150\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                children: \"Eliminar\"\n                            }, void 0, false, {\n                                fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                lineNumber: 100,\n                                columnNumber: 25\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                            lineNumber: 99,\n                            columnNumber: 21\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                    lineNumber: 95,\n                    columnNumber: 17\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n            lineNumber: 93,\n            columnNumber: 13\n        }, this);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"h-full w-full\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"w-full h-full p-4 flex flex-col gap-3\",\n            children: [\n                deleteDeviceDialog(),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"w-full h-12 flex flex-row flex-grow gap-3\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: \"shadow-md rounded-md h-12 w-12 flex justify-center items-center border border-indigo-600 hover:bg-gray-100 duration-150\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                onClick: ()=>{\n                                    router.push(\"/dashboard/devices\");\n                                },\n                                className: \"w-6 text-indigo-600\"\n                            }, void 0, false, {\n                                fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                lineNumber: 114,\n                                columnNumber: 25\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                            lineNumber: 113,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex gap-3 justify-end flex-grow\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    className: \"shadow-md rounded-md h-12 w-12 flex justify-center items-center border border-indigo-600 hover:bg-gray-100 duration-150\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                                        className: \"w-6 text-indigo-600\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                        lineNumber: 120,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                    lineNumber: 119,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    className: \"shadow-md rounded-md h-12 w-12 flex justify-center items-center border border-indigo-600 hover:bg-gray-100 duration-150\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                        className: \"w-6 text-indigo-600\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                        lineNumber: 123,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                    lineNumber: 122,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: ()=>{\n                                        deleteDeviceButton();\n                                    },\n                                    className: \"shadow-md rounded-md h-12 w-12 flex justify-center items-center border hover:bg-gray-50 border-red-500 duration-150\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                                        className: \"w-6 text-red-500\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                        lineNumber: 128,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                    lineNumber: 125,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    className: \"shadow-md rounded-md h-12 w-12 flex justify-center items-center border border-indigo-600 hover:bg-gray-100 duration-150\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_13__[\"default\"], {\n                                        className: \"w-6 text-indigo-600\",\n                                        onClick: ()=>{\n                                            updateInfo();\n                                        },\n                                        style: {\n                                            transition: \"transform 0.7s ease\",\n                                            transform: \"rotate(\".concat(rotation, \"deg)\")\n                                        }\n                                    }, void 0, false, {\n                                        fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                        lineNumber: 131,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                    lineNumber: 130,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                            lineNumber: 118,\n                            columnNumber: 21\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                    lineNumber: 112,\n                    columnNumber: 17\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"w-full h-full flex flex-col gap-3\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"w-full h-16 flex flex-row gap-3 items-center justify-center\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-50 h-full flex flex-row gap-4 px-5 items-center border shadow-md rounded-md\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_14__[\"default\"], {\n                                            className: \"w-8 text-indigo-600\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                            lineNumber: 141,\n                                            columnNumber: 29\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"flex flex-col justify-center\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    className: \"px-2 text-sm text-slate-400\",\n                                                    children: \"Estado\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                                    lineNumber: 143,\n                                                    columnNumber: 33\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    className: \"min-w-24 max-w-40 h-1/2 px-2 text-sm rounded-xl shadow-sm \".concat(device.available == true ? \"bg-green-300 text-green-600\" : \"bg-red-300 text-red-600\", \" flex items-center\"),\n                                                    children: device.available == true ? \" Connected\" : \" Not Connected\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                                    lineNumber: 144,\n                                                    columnNumber: 33\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                            lineNumber: 142,\n                                            columnNumber: 29\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                    lineNumber: 140,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-50 h-full flex flex-row gap-4 px-5 items-center border shadow-md rounded-md\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_15__[\"default\"], {\n                                            className: \"w-8 text-indigo-600\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                            lineNumber: 154,\n                                            columnNumber: 29\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"flex flex-col justify-center\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    className: \"text-sm text-slate-400\",\n                                                    children: \"Direcci\\xf3n IP\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                                    lineNumber: 156,\n                                                    columnNumber: 33\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    children: device.ip\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                                    lineNumber: 157,\n                                                    columnNumber: 33\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                            lineNumber: 155,\n                                            columnNumber: 29\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                    lineNumber: 153,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-50 h-full flex flex-row gap-4 px-5 items-center border shadow-md rounded-md\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeftIcon_ArrowPathIcon_EnvelopeIcon_GlobeAltIcon_MapPinIcon_PlusCircleIcon_WifiIcon_XMarkIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_16__[\"default\"], {\n                                            className: \"w-8 text-indigo-600\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                            lineNumber: 161,\n                                            columnNumber: 29\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"flex flex-col justify-center\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    className: \"text-sm text-slate-400\",\n                                                    children: \"Localizacion\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                                    lineNumber: 163,\n                                                    columnNumber: 33\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    children: \"(En obras)\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                                    lineNumber: 164,\n                                                    columnNumber: 33\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                            lineNumber: 162,\n                                            columnNumber: 29\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                    lineNumber: 160,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                            lineNumber: 139,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"w-full h-full flex flex-row gap-3 items-center justify-center\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-full h-full border shadow-md rounded-md\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_app_ui_dashboard_devicesCharts__WEBPACK_IMPORTED_MODULE_3__.CandleStickChart, {}, void 0, false, {\n                                        fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                        lineNumber: 170,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                    lineNumber: 169,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-full h-full border shadow-md rounded-md\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                    lineNumber: 172,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                            lineNumber: 168,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"w-full h-full flex flex-row gap-3 items-center justify-center\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-full h-full border shadow-md rounded-md\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                    lineNumber: 177,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-full h-full border shadow-md rounded-md\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                                    lineNumber: 180,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                            lineNumber: 176,\n                            columnNumber: 21\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n                    lineNumber: 138,\n                    columnNumber: 17\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n            lineNumber: 110,\n            columnNumber: 13\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/dashboard/devices/elem/page.tsx\",\n        lineNumber: 109,\n        columnNumber: 9\n    }, this);\n}\n_s(Page, \"diNrpZuj/bNvUbwXPg87H0Pp+q4=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_5__.useRouter\n    ];\n});\n_c = Page;\nvar _c;\n$RefreshReg$(_c, \"Page\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGFzaGJvYXJkL2RldmljZXMvZWxlbS9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDeUU7QUFDeEI7QUFDdUI7QUFFZ0Y7QUFDcEc7QUFDWDtBQUNHO0FBQ0E7QUFFN0IsU0FBU2tCOztJQUNwQixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR0gsK0NBQVFBLENBQWdCO0lBQ3hELE1BQU0sQ0FBQ0ksUUFBUUMsVUFBVSxHQUFHTCwrQ0FBUUEsQ0FBQyxDQUFDO0lBRXRDLE1BQU1NLFNBQVNSLDBEQUFTQTtJQUV4QkMsZ0RBQVNBLENBQUM7UUFDTixNQUFNUSxjQUFjLE9BQU9DO1lBQ3ZCLElBQUlDLE1BQU0sTUFBTXhCLDhEQUFVQSxDQUFDdUI7WUFDM0IsSUFBSSxDQUFDQyxLQUFLO2dCQUNOSCxPQUFPSSxJQUFJLENBQUM7WUFDaEI7UUFDSjtRQUVBLHNDQUFzQztRQUN0QyxNQUFNRixRQUFRWCx1REFBU0EsQ0FBQztRQUN4QixJQUFJVyxVQUFVRyxXQUFXO1lBQ3JCTCxPQUFPSSxJQUFJLENBQUM7UUFDaEI7UUFDQUgsWUFBWUM7UUFHWix1REFBdUQ7UUFDdkQsTUFBTUksTUFBTSxJQUFJQyxJQUFJQyxPQUFPQyxRQUFRLENBQUNDLElBQUk7UUFDeEMsSUFBSUMsS0FBS0wsSUFBSU0sWUFBWSxDQUFDQyxHQUFHLENBQUM7UUFDOUIsSUFBSUYsT0FBTyxNQUFNO1lBQ2JYLE9BQU9JLElBQUksQ0FBQztRQUNoQjtRQUNBUCxZQUFZYztRQUVaLG9DQUFvQztRQUNwQyxNQUFNRyxrQkFBa0IsT0FBT0gsSUFBWVQ7WUFDdkMsSUFBSWEsYUFBYSxNQUFNckMsd0VBQWFBLENBQUNpQyxJQUFJVDtZQUN6Q0gsVUFBVWdCO1FBQ2Q7UUFDQUQsZ0JBQWdCSCxJQUFjVDtJQUNsQyxHQUFHO1FBQUNOO0tBQVM7SUFFYix5RUFBeUU7SUFDekUsTUFBTSxDQUFDb0IsVUFBVUMsWUFB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QU8sZUFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhDQUkvQyw4REFBQ1I7b0NBQUlELFdBQVU7O3NEQUNYLDhEQUFDekMsNkxBQVlBOzRDQUFDeUMsV0FBVTs7Ozs7O3NEQUN4Qiw4REFBQ0M7NENBQUlELFdBQVU7OzhEQUNYLDhEQUFDSTtvREFBRUosV0FBVTs4REFBeUI7Ozs7Ozs4REFDdEMsOERBQUNJOzhEQUFHbEMsT0FBT3dDLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4Q0FHckIsOERBQUNUO29DQUFJRCxXQUFVOztzREFDWCw4REFBQzFDLDZMQUFZQTs0Q0FBQzBDLFdBQVU7Ozs7OztzREFDeEIsOERBQUNDOzRDQUFJRCxXQUFVOzs4REFDWCw4REFBQ0k7b0RBQUVKLFdBQVU7OERBQXlCOzs7Ozs7OERBQ3RDLDhEQUFDSTs4REFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NDQUlmLDhEQUFDSDs0QkFBSUQsV0FBVTs7OENBQ1gsOERBQUNDO29DQUFJRCxXQUFVOzhDQUNYLDRFQUFDaEQsaUZBQWdCQTs7Ozs7Ozs7Ozs4Q0FFckIsOERBQUNpRDtvQ0FBSUQsV0FBVTs7Ozs7Ozs7Ozs7O3NDQUluQiw4REFBQ0M7NEJBQUlELFdBQVU7OzhDQUNYLDhEQUFDQztvQ0FBSUQsV0FBVTs7Ozs7OzhDQUdmLDhEQUFDQztvQ0FBSUQsV0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRdkM7R0FoTHdCakM7O1FBSUxILHNEQUFTQTs7O0tBSkpHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvZGFzaGJvYXJkL2RldmljZXMvZWxlbS9wYWdlLnRzeD9lYTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0IHsgZGVsZXRlRGV2aWNlLCBnZXREZXZpY2VJbmZvIH0gZnJvbSBcIkAvc3JjL2FwcC9saWIvZGV2aWNlc1V0aWxzXCI7XG5pbXBvcnQgeyBjaGVja1Rva2VuIH0gZnJvbSBcIkAvc3JjL2FwcC9saWIvdG9rZW5cIjtcbmltcG9ydCB7IENhbmRsZVN0aWNrQ2hhcnQgfSBmcm9tIFwiQC9zcmMvYXBwL3VpL2Rhc2hib2FyZC9kZXZpY2VzQ2hhcnRzXCI7XG5cbmltcG9ydCB7IEFycm93UGF0aEljb24sIEFycm93TGVmdEljb24sIFhNYXJrSWNvbiwgTWFwUGluSWNvbiwgUGx1c0NpcmNsZUljb24sIEdsb2JlQWx0SWNvbiwgRW52ZWxvcGVJY29uLCBXaWZpSWNvbiB9IGZyb20gXCJAaGVyb2ljb25zL3JlYWN0LzI0L291dGxpbmVcIjtcbmltcG9ydCB7IERpYWxvZywgRGlhbG9nVGl0bGUgfSBmcm9tIFwiQG11aS9tYXRlcmlhbFwiO1xuaW1wb3J0IHsgZ2V0Q29va2llIH0gZnJvbSBcImNvb2tpZXMtbmV4dFwiO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWdlKCkge1xuICAgIGNvbnN0IFtkZXZpY2VJZCwgc2V0RGV2aWNlSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW2RldmljZSwgc2V0RGV2aWNlXSA9IHVzZVN0YXRlKHt9KTtcbiAgICBcbiAgICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZlcmlmeVRva2VuID0gYXN5bmMgKHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGxldCByZXMgPSBhd2FpdCBjaGVja1Rva2VuKHRva2VuKVxuICAgICAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgICAgICByb3V0ZXIucHVzaChcIi9sb2dpblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcmlmaWNhciBlbCB0b2tlbiBkZSBhdXRlbnRpY2FjacOzblxuICAgICAgICBjb25zdCB0b2tlbiA9IGdldENvb2tpZShcInRva2VuXCIpO1xuICAgICAgICBpZiAodG9rZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcm91dGVyLnB1c2goXCIvbG9naW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmVyaWZ5VG9rZW4odG9rZW4gYXMgc3RyaW5nKTtcbiAgICAgICAgXG5cbiAgICAgICAgLy8gUmVjdXBlcmFyIGVsIGlkZW50aWZpY2Fkb3IgZGVsIGRpc3Bvc2l0aXZvIGRlIGxhIFVSTFxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgICBsZXQgaWQgPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcImlkXCIpXG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcm91dGVyLnB1c2goXCIvZGFzaGJvYXJkL2RldmljZXNcIilcbiAgICAgICAgfVxuICAgICAgICBzZXREZXZpY2VJZChpZClcblxuICAgICAgICAvLyBPYnRlbmVyIGxvcyBkYXRvcyBkZWwgZGlzcG9zaXRpdm9cbiAgICAgICAgY29uc3QgZmV0Y2hEZXZpY2VJbmZvID0gYXN5bmMgKGlkOiBzdHJpbmcsIHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGxldCBkZXZpY2VJbmZvID0gYXdhaXQgZ2V0RGV2aWNlSW5mbyhpZCwgdG9rZW4pXG4gICAgICAgICAgICBzZXREZXZpY2UoZGV2aWNlSW5mbylcbiAgICAgICAgfVxuICAgICAgICBmZXRjaERldmljZUluZm8oaWQgYXMgc3RyaW5nLCB0b2tlbiBhcyBzdHJpbmcpXG4gICAgfSwgW2RldmljZUlkXSkgXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUk9UQVRJT04gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY29uc3QgW3JvdGF0aW9uLCBzZXRSb3RhdGlvbl0gPSB1c2VTdGF0ZSgwKTtcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFVwZGF0ZSBJbmZvIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0IHVwZGF0ZUluZm8gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gZ2V0Q29va2llKFwidG9rZW5cIik7XG4gICAgICAgIGxldCBkZXZpY2VJbmZvID0gYXdhaXQgZ2V0RGV2aWNlSW5mbyhkZXZpY2VJZCBhcyBzdHJpbmcsIHRva2VuIGFzIHN0cmluZylcbiAgICAgICAgc2V0RGV2aWNlKGRldmljZUluZm8pXG4gICAgICAgIHNldFJvdGF0aW9uKHJvdGF0aW9uICsgMTgwKVxuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVsaW1pbmFyIGRpc3Bvc2l0aXZvIC0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0IFtJc09wZW5EZWxldGVEZXZpY2VEaWFsb2csIHNldElzT3BlbkRlbGV0ZURldmljZURpYWxvZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCBjbG9zZURlbGV0ZURldmljZURpYWxvZyA9ICgpID0+IHtcbiAgICAgICAgc2V0SXNPcGVuRGVsZXRlRGV2aWNlRGlhbG9nKGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWxldGVEZXZpY2VCdXR0b24gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHNldElzT3BlbkRlbGV0ZURldmljZURpYWxvZyh0cnVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25maXJtRGVsZXRlRGV2aWNlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGdldENvb2tpZShcInRva2VuXCIpO1xuICAgICAgICAvLyBFbGltaW5hciBlbCBkaXNwb3NpdGl2b1xuICAgICAgICBsZXQgcmVzID0gYXdhaXQgZGVsZXRlRGV2aWNlKGRldmljZUlkIGFzIHN0cmluZywgdG9rZW4gYXMgc3RyaW5nKVxuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBhbGVydChcIkRpc3Bvc2l0aXZvIGVsaW1pbmFkbyBjb3JyZWN0YW1lbnRlXCIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGVydChcIkVycm9yIGFsIGVsaW1pbmFyIGVsIGRpc3Bvc2l0aXZvXCIpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDZXJyYXIgZWwgZGnDoWxvZ29cbiAgICAgICAgY2xvc2VEZWxldGVEZXZpY2VEaWFsb2coKTtcblxuICAgICAgICAvLyBSZWRpcmlnaXIgYSBsYSBww6FnaW5hIGRlIGRpc3Bvc2l0aXZvc1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICByb3V0ZXIucHVzaChcIi9kYXNoYm9hcmQvZGV2aWNlc1wiKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZGVsZXRlRGV2aWNlRGlhbG9nID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPERpYWxvZyBvcGVuPXtJc09wZW5EZWxldGVEZXZpY2VEaWFsb2d9IG9uQ2xvc2U9e2Nsb3NlRGVsZXRlRGV2aWNlRGlhbG9nfT5cbiAgICAgICAgICAgICAgICA8RGlhbG9nVGl0bGUgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbFwiPsK/U2VndXJvIHF1ZSBkZXNlYXMgZWxpbWluYXIgZXN0ZSBkaXNwb3NpdGl2bz88L0RpYWxvZ1RpdGxlPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LXJvdyBwLTQgZ2FwLTRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtjbG9zZURlbGV0ZURldmljZURpYWxvZ30gY2xhc3NOYW1lPVwidy0xLzIgaC0xMiB0ZXh0LXdoaXRlIGJnLWluZGlnby02MDAgcm91bmRlZC1tZCBob3ZlcjpiZy1pbmRpZ28tNTAwIGR1cmF0aW9uLTE1MFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHA+Q2FuY2VsYXI8L3A+XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2NvbmZpcm1EZWxldGVEZXZpY2V9IGNsYXNzTmFtZT1cInctMS8yIGgtMTIgdGV4dC13aGl0ZSByb3VuZGVkLW1kIGJnLXJlZC02MDAgaG92ZXI6YmctcmVkLTUwMCBkdXJhdGlvbi0xNTBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwPkVsaW1pbmFyPC9wPlxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9EaWFsb2c+XG4gICAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8bWFpbiBjbGFzc05hbWU9XCJoLWZ1bGwgdy1mdWxsXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgcC00IGZsZXggZmxleC1jb2wgZ2FwLTNcIj5cbiAgICAgICAgICAgICAgICB7ZGVsZXRlRGV2aWNlRGlhbG9nKCl9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC0xMiBmbGV4IGZsZXgtcm93IGZsZXgtZ3JvdyBnYXAtM1wiPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT17YHNoYWRvdy1tZCByb3VuZGVkLW1kIGgtMTIgdy0xMiBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBib3JkZXIgYm9yZGVyLWluZGlnby02MDAgaG92ZXI6YmctZ3JheS0xMDAgZHVyYXRpb24tMTUwYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8QXJyb3dMZWZ0SWNvbiBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyLnB1c2goXCIvZGFzaGJvYXJkL2RldmljZXNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH19IGNsYXNzTmFtZT17YHctNiB0ZXh0LWluZGlnby02MDBgfS8+XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZ2FwLTMganVzdGlmeS1lbmQgZmxleC1ncm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT17YHNoYWRvdy1tZCByb3VuZGVkLW1kIGgtMTIgdy0xMiBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBib3JkZXIgYm9yZGVyLWluZGlnby02MDAgaG92ZXI6YmctZ3JheS0xMDAgZHVyYXRpb24tMTUwYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1hcFBpbkljb24gY2xhc3NOYW1lPXtgdy02IHRleHQtaW5kaWdvLTYwMGB9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2BzaGFkb3ctbWQgcm91bmRlZC1tZCBoLTEyIHctMTIgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgYm9yZGVyIGJvcmRlci1pbmRpZ28tNjAwIGhvdmVyOmJnLWdyYXktMTAwIGR1cmF0aW9uLTE1MGB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxQbHVzQ2lyY2xlSWNvbiBjbGFzc05hbWU9e2B3LTYgdGV4dC1pbmRpZ28tNjAwYH0vPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge2RlbGV0ZURldmljZUJ1dHRvbigpfX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgc2hhZG93LW1kIHJvdW5kZWQtbWQgaC0xMiB3LTEyIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIGJvcmRlciBob3ZlcjpiZy1ncmF5LTUwIGJvcmRlci1yZWQtNTAwIGR1cmF0aW9uLTE1MGB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxYTWFya0ljb24gY2xhc3NOYW1lPXtgdy02IHRleHQtcmVkLTUwMGB9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2BzaGFkb3ctbWQgcm91bmRlZC1tZCBoLTEyIHctMTIgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgYm9yZGVyIGJvcmRlci1pbmRpZ28tNjAwIGhvdmVyOmJnLWdyYXktMTAwIGR1cmF0aW9uLTE1MGB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxBcnJvd1BhdGhJY29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgdy02IHRleHQtaW5kaWdvLTYwMGB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge3VwZGF0ZUluZm8oKX19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAwLjdzIGVhc2UnLCB0cmFuc2Zvcm06IGByb3RhdGUoJHtyb3RhdGlvbn1kZWcpYH19Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgZmxleCBmbGV4LWNvbCBnYXAtM1wiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBoLTE2IGZsZXggZmxleC1yb3cgZ2FwLTMgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctNTAgaC1mdWxsIGZsZXggZmxleC1yb3cgZ2FwLTQgcHgtNSBpdGVtcy1jZW50ZXIgYm9yZGVyIHNoYWRvdy1tZCByb3VuZGVkLW1kXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFdpZmlJY29uIGNsYXNzTmFtZT1cInctOCB0ZXh0LWluZGlnby02MDBcIj48L1dpZmlJY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJweC0yIHRleHQtc20gdGV4dC1zbGF0ZS00MDBcIj5Fc3RhZG88L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT17YG1pbi13LTI0IG1heC13LTQwIGgtMS8yIHB4LTIgdGV4dC1zbSByb3VuZGVkLXhsIHNoYWRvdy1zbSAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZS5hdmFpbGFibGUgPT0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiYmctZ3JlZW4tMzAwIHRleHQtZ3JlZW4tNjAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImJnLXJlZC0zMDAgdGV4dC1yZWQtNjAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmxleCBpdGVtcy1jZW50ZXJgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZGV2aWNlLmF2YWlsYWJsZSA9PSB0cnVlID8gXCIgQ29ubmVjdGVkXCIgOiBcIiBOb3QgQ29ubmVjdGVkXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTUwIGgtZnVsbCBmbGV4IGZsZXgtcm93IGdhcC00IHB4LTUgaXRlbXMtY2VudGVyIGJvcmRlciBzaGFkb3ctbWQgcm91bmRlZC1tZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxFbnZlbG9wZUljb24gY2xhc3NOYW1lPVwidy04IHRleHQtaW5kaWdvLTYwMFwiPjwvRW52ZWxvcGVJY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtc2xhdGUtNDAwXCI+RGlyZWNjacOzbiBJUDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+e2RldmljZS5pcH08L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy01MCBoLWZ1bGwgZmxleCBmbGV4LXJvdyBnYXAtNCBweC01IGl0ZW1zLWNlbnRlciBib3JkZXIgc2hhZG93LW1kIHJvdW5kZWQtbWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8R2xvYmVBbHRJY29uIGNsYXNzTmFtZT1cInctOCB0ZXh0LWluZGlnby02MDBcIj48L0dsb2JlQWx0SWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wganVzdGlmeS1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LXNsYXRlLTQwMFwiPkxvY2FsaXphY2lvbjwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+KEVuIG9icmFzKTwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIGZsZXggZmxleC1yb3cgZ2FwLTMgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgYm9yZGVyIHNoYWRvdy1tZCByb3VuZGVkLW1kXCIgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDYW5kbGVTdGlja0NoYXJ0PjwvQ2FuZGxlU3RpY2tDaGFydD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIGJvcmRlciBzaGFkb3ctbWQgcm91bmRlZC1tZFwiPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCBmbGV4IGZsZXgtcm93IGdhcC0zIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIGJvcmRlciBzaGFkb3ctbWQgcm91bmRlZC1tZFwiPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCBib3JkZXIgc2hhZG93LW1kIHJvdW5kZWQtbWRcIj5cblxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbWFpbj5cbiAgICApO1xufSJdLCJuYW1lcyI6WyJkZWxldGVEZXZpY2UiLCJnZXREZXZpY2VJbmZvIiwiY2hlY2tUb2tlbiIsIkNhbmRsZVN0aWNrQ2hhcnQiLCJBcnJvd1BhdGhJY29uIiwiQXJyb3dMZWZ0SWNvbiIsIlhNYXJrSWNvbiIsIk1hcFBpbkljb24iLCJQbHVzQ2lyY2xlSWNvbiIsIkdsb2JlQWx0SWNvbiIsIkVudmVsb3BlSWNvbiIsIldpZmlJY29uIiwiRGlhbG9nIiwiRGlhbG9nVGl0bGUiLCJnZXRDb29raWUiLCJ1c2VSb3V0ZXIiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIlBhZ2UiLCJkZXZpY2VJZCIsInNldERldmljZUlkIiwiZGV2aWNlIiwic2V0RGV2aWNlIiwicm91dGVyIiwidmVyaWZ5VG9rZW4iLCJ0b2tlbiIsInJlcyIsInB1c2giLCJ1bmRlZmluZWQiLCJ1cmwiLCJVUkwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJpZCIsInNlYXJjaFBhcmFtcyIsImdldCIsImZldGNoRGV2aWNlSW5mbyIsImRldmljZUluZm8iLCJyb3RhdGlvbiIsInNldFJvdGF0aW9uIiwidXBkYXRlSW5mbyIsIklzT3BlbkRlbGV0ZURldmljZURpYWxvZyIsInNldElzT3BlbkRlbGV0ZURldmljZURpYWxvZyIsImNsb3NlRGVsZXRlRGV2aWNlRGlhbG9nIiwiZGVsZXRlRGV2aWNlQnV0dG9uIiwiY29uZmlybURlbGV0ZURldmljZSIsImFsZXJ0IiwiZGVsZXRlRGV2aWNlRGlhbG9nIiwib3BlbiIsIm9uQ2xvc2UiLCJjbGFzc05hbWUiLCJkaXYiLCJidXR0b24iLCJvbkNsaWNrIiwicCIsIm1haW4iLCJzdHlsZSIsInRyYW5zaXRpb24iLCJ0cmFuc2Zvcm0iLCJhdmFpbGFibGUiLCJpcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dashboard/devices/elem/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/ui/dashboard/devicesCharts.jsx":
/*!************************************************!*\
  !*** ./src/app/ui/dashboard/devicesCharts.jsx ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandleStickChart: function() { return /* binding */ CandleStickChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n// import { createChart } from \"lightweight-charts\"\n// export const deviceCpuTemperatureChart = (divId: string, width: number, height: number) => {\n//     const chart = createChart(document.getElementById(divId) as HTMLElement, {width: width, height: height})\n//     const lineSeries = chart.addLineSeries();\n//     lineSeries.setData([\n//         { time: '2019-04-11', value: 80.01 },\n//         { time: '2019-04-12', value: 96.63 },\n//         { time: '2019-04-13', value: 76.64 },\n//         { time: '2019-04-14', value: 81.89 },\n//         { time: '2019-04-15', value: 74.43 },\n//         { time: '2019-04-16', value: 80.01 },\n//         { time: '2019-04-17', value: 96.63 },\n//         { time: '2019-04-18', value: 76.64 },\n//         { time: '2019-04-19', value: 81.89 },\n//         { time: '2019-04-20', value: 74.43 },\n//     ])\n//     return chart\n// }\n\nvar _s = $RefreshSig$();\n\n\nconst CandleStickChart = ()=>{\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_1__.createChart)(chartContainerRef.current, {\n            width: 700,\n            height: 400,\n            timeScale: {\n                timeVisible: true,\n                secondsVisible: false,\n                fixLeftEdge: true,\n                fixRightEdge: true\n            },\n            crosshair: {\n                mode: lightweight_charts__WEBPACK_IMPORTED_MODULE_1__.CrosshairMode.Normal\n            }\n        });\n        const candleSeries = chart.addCandlestickSeries({});\n        candleSeries.setData([\n            {\n                time: \"2019-04-11\",\n                value: 80.01\n            },\n            {\n                time: \"2019-04-12\",\n                value: 96.63\n            },\n            {\n                time: \"2019-04-13\",\n                value: 76.64\n            },\n            {\n                time: \"2019-04-14\",\n                value: 81.89\n            },\n            {\n                time: \"2019-04-15\",\n                value: 74.43\n            },\n            {\n                time: \"2019-04-16\",\n                value: 80.01\n            },\n            {\n                time: \"2019-04-17\",\n                value: 96.63\n            },\n            {\n                time: \"2019-04-18\",\n                value: 76.64\n            },\n            {\n                time: \"2019-04-19\",\n                value: 81.89\n            },\n            {\n                time: \"2019-04-20\",\n                value: 74.43\n            }\n        ]);\n        return ()=>{\n            chart.remove();\n        };\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef\n    }, void 0, false, {\n        fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/ui/dashboard/devicesCharts.jsx\",\n        lineNumber: 61,\n        columnNumber: 12\n    }, undefined);\n};\n_s(CandleStickChart, \"ZI1LdXO604IZpmh0kAttG3FSLiA=\");\n_c = CandleStickChart;\nvar _c;\n$RefreshReg$(_c, \"CandleStickChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdWkvZGFzaGJvYXJkL2RldmljZXNDaGFydHMuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsbURBQW1EO0FBRW5ELCtGQUErRjtBQUMvRiwrR0FBK0c7QUFDL0csZ0RBQWdEO0FBQ2hELDJCQUEyQjtBQUMzQixnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsU0FBUztBQUNULG1CQUFtQjtBQUNuQixJQUFJOzs7QUFFNEQ7QUFDdEI7QUFFbkMsTUFBTUksbUJBQW1COztJQUM1QixNQUFNQyxvQkFBb0JGLDZDQUFNQSxDQUFDO0lBRWpDRCxnREFBU0EsQ0FBQztRQUNOLE1BQU1JLFFBQVFOLCtEQUFXQSxDQUFDSyxrQkFBa0JFLE9BQU8sRUFBRTtZQUNqREMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLFdBQVc7Z0JBQ1BDLGFBQWE7Z0JBQ2JDLGdCQUFnQjtnQkFDaEJDLGFBQWE7Z0JBQ2JDLGNBQWM7WUFDbEI7WUFDQUMsV0FBVztnQkFDUEMsTUFBTWYsNkRBQWFBLENBQUNnQixNQUFNO1lBQzlCO1FBQ0o7UUFDQSxNQUFNQyxlQUFlWixNQUFNYSxvQkFBb0IsQ0FBQyxDQUFDO1FBRWpERCxhQUFhRSxPQUFPLENBQUM7WUFDVDtnQkFBRUMsTUFBTTtnQkFBY0MsT0FBTztZQUFNO1lBQ25DO2dCQUFFRCxNQUFNO2dCQUFjQyxPQUFPO1lBQU07WUFDbkM7Z0JBQUVELE1BQU07Z0JBQWNDLE9BQU87WUFBTTtZQUNuQztnQkFBRUQsTUFBTTtnQkFBY0MsT0FBTztZQUFNO1lBQ25DO2dCQUFFRCxNQUFNO2dCQUFjQyxPQUFPO1lBQU07WUFDbkM7Z0JBQUVELE1BQU07Z0JBQWNDLE9BQU87WUFBTTtZQUNuQztnQkFBRUQsTUFBTTtnQkFBY0MsT0FBTztZQUFNO1lBQ25DO2dCQUFFRCxNQUFNO2dCQUFjQyxPQUFPO1lBQU07WUFDbkM7Z0JBQUVELE1BQU07Z0JBQWNDLE9BQU87WUFBTTtZQUNuQztnQkFBRUQsTUFBTTtnQkFBY0MsT0FBTztZQUFNO1NBQ3RDO1FBRVQsT0FBTztZQUNIaEIsTUFBTWlCLE1BQU07UUFDaEI7SUFDSjtJQUVBLHFCQUFPLDhEQUFDQztRQUFJQyxLQUFLcEI7Ozs7OztBQUNyQixFQUFFO0dBdENXRDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3VpL2Rhc2hib2FyZC9kZXZpY2VzQ2hhcnRzLmpzeD81NTVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydCB7IGNyZWF0ZUNoYXJ0IH0gZnJvbSBcImxpZ2h0d2VpZ2h0LWNoYXJ0c1wiXG5cbi8vIGV4cG9ydCBjb25zdCBkZXZpY2VDcHVUZW1wZXJhdHVyZUNoYXJ0ID0gKGRpdklkOiBzdHJpbmcsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSA9PiB7XG4vLyAgICAgY29uc3QgY2hhcnQgPSBjcmVhdGVDaGFydChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkaXZJZCkgYXMgSFRNTEVsZW1lbnQsIHt3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0fSlcbi8vICAgICBjb25zdCBsaW5lU2VyaWVzID0gY2hhcnQuYWRkTGluZVNlcmllcygpO1xuLy8gICAgIGxpbmVTZXJpZXMuc2V0RGF0YShbXG4vLyAgICAgICAgIHsgdGltZTogJzIwMTktMDQtMTEnLCB2YWx1ZTogODAuMDEgfSxcbi8vICAgICAgICAgeyB0aW1lOiAnMjAxOS0wNC0xMicsIHZhbHVlOiA5Ni42MyB9LFxuLy8gICAgICAgICB7IHRpbWU6ICcyMDE5LTA0LTEzJywgdmFsdWU6IDc2LjY0IH0sXG4vLyAgICAgICAgIHsgdGltZTogJzIwMTktMDQtMTQnLCB2YWx1ZTogODEuODkgfSxcbi8vICAgICAgICAgeyB0aW1lOiAnMjAxOS0wNC0xNScsIHZhbHVlOiA3NC40MyB9LFxuLy8gICAgICAgICB7IHRpbWU6ICcyMDE5LTA0LTE2JywgdmFsdWU6IDgwLjAxIH0sXG4vLyAgICAgICAgIHsgdGltZTogJzIwMTktMDQtMTcnLCB2YWx1ZTogOTYuNjMgfSxcbi8vICAgICAgICAgeyB0aW1lOiAnMjAxOS0wNC0xOCcsIHZhbHVlOiA3Ni42NCB9LFxuLy8gICAgICAgICB7IHRpbWU6ICcyMDE5LTA0LTE5JywgdmFsdWU6IDgxLjg5IH0sXG4vLyAgICAgICAgIHsgdGltZTogJzIwMTktMDQtMjAnLCB2YWx1ZTogNzQuNDMgfSxcbi8vICAgICBdKVxuLy8gICAgIHJldHVybiBjaGFydFxuLy8gfVxuXG5pbXBvcnQgeyBjcmVhdGVDaGFydCwgQ3Jvc3NoYWlyTW9kZSB9IGZyb20gJ2xpZ2h0d2VpZ2h0LWNoYXJ0cyc7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGNvbnN0IENhbmRsZVN0aWNrQ2hhcnQgPSAoKSA9PiB7XG4gICAgY29uc3QgY2hhcnRDb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGFydCA9IGNyZWF0ZUNoYXJ0KGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgIHdpZHRoOiA3MDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDQwMCxcbiAgICAgICAgICAgIHRpbWVTY2FsZToge1xuICAgICAgICAgICAgICAgIHRpbWVWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNlY29uZHNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmaXhMZWZ0RWRnZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmaXhSaWdodEVkZ2U6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3Jvc3NoYWlyOiB7XG4gICAgICAgICAgICAgICAgbW9kZTogQ3Jvc3NoYWlyTW9kZS5Ob3JtYWwsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FuZGxlU2VyaWVzID0gY2hhcnQuYWRkQ2FuZGxlc3RpY2tTZXJpZXMoe30pO1xuXG4gICAgICAgIGNhbmRsZVNlcmllcy5zZXREYXRhKFtcbiAgICAgICAgICAgICAgICAgICAgeyB0aW1lOiAnMjAxOS0wNC0xMScsIHZhbHVlOiA4MC4wMSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHRpbWU6ICcyMDE5LTA0LTEyJywgdmFsdWU6IDk2LjYzIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdGltZTogJzIwMTktMDQtMTMnLCB2YWx1ZTogNzYuNjQgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB0aW1lOiAnMjAxOS0wNC0xNCcsIHZhbHVlOiA4MS44OSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHRpbWU6ICcyMDE5LTA0LTE1JywgdmFsdWU6IDc0LjQzIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdGltZTogJzIwMTktMDQtMTYnLCB2YWx1ZTogODAuMDEgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB0aW1lOiAnMjAxOS0wNC0xNycsIHZhbHVlOiA5Ni42MyB9LFxuICAgICAgICAgICAgICAgICAgICB7IHRpbWU6ICcyMDE5LTA0LTE4JywgdmFsdWU6IDc2LjY0IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdGltZTogJzIwMTktMDQtMTknLCB2YWx1ZTogODEuODkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB0aW1lOiAnMjAxOS0wNC0yMCcsIHZhbHVlOiA3NC40MyB9LFxuICAgICAgICAgICAgICAgIF0pXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNoYXJ0LnJlbW92ZSgpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIDxkaXYgcmVmPXtjaGFydENvbnRhaW5lclJlZn0gLz47XG59OyJdLCJuYW1lcyI6WyJjcmVhdGVDaGFydCIsIkNyb3NzaGFpck1vZGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJDYW5kbGVTdGlja0NoYXJ0IiwiY2hhcnRDb250YWluZXJSZWYiLCJjaGFydCIsImN1cnJlbnQiLCJ3aWR0aCIsImhlaWdodCIsInRpbWVTY2FsZSIsInRpbWVWaXNpYmxlIiwic2Vjb25kc1Zpc2libGUiLCJmaXhMZWZ0RWRnZSIsImZpeFJpZ2h0RWRnZSIsImNyb3NzaGFpciIsIm1vZGUiLCJOb3JtYWwiLCJjYW5kbGVTZXJpZXMiLCJhZGRDYW5kbGVzdGlja1NlcmllcyIsInNldERhdGEiLCJ0aW1lIiwidmFsdWUiLCJyZW1vdmUiLCJkaXYiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/ui/dashboard/devicesCharts.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fancy-canvas/canvas-element-bitmap-size.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/fancy-canvas/canvas-element-bitmap-size.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bindTo: function() { return /* binding */ bindTo; }\n/* harmony export */ });\n/* harmony import */ var _size_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./size.mjs */ \"(app-pages-browser)/./node_modules/fancy-canvas/size.mjs\");\n/* harmony import */ var _device_pixel_ratio_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./device-pixel-ratio.mjs */ \"(app-pages-browser)/./node_modules/fancy-canvas/device-pixel-ratio.mjs\");\n\n\nvar DevicePixelContentBoxBinding = /** @class */ function() {\n    function DevicePixelContentBoxBinding(canvasElement, transformBitmapSize, options) {\n        var _a;\n        this._canvasElement = null;\n        this._bitmapSizeChangedListeners = [];\n        this._suggestedBitmapSize = null;\n        this._suggestedBitmapSizeChangedListeners = [];\n        // devicePixelRatio approach\n        this._devicePixelRatioObservable = null;\n        // ResizeObserver approach\n        this._canvasElementResizeObserver = null;\n        this._canvasElement = canvasElement;\n        this._canvasElementClientSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: this._canvasElement.clientWidth,\n            height: this._canvasElement.clientHeight\n        });\n        this._transformBitmapSize = transformBitmapSize !== null && transformBitmapSize !== void 0 ? transformBitmapSize : function(size) {\n            return size;\n        };\n        this._allowResizeObserver = (_a = options === null || options === void 0 ? void 0 : options.allowResizeObserver) !== null && _a !== void 0 ? _a : true;\n        this._chooseAndInitObserver();\n    // we MAY leave the constuctor without any bitmap size observation mechanics initialized\n    }\n    DevicePixelContentBoxBinding.prototype.dispose = function() {\n        var _a, _b;\n        if (this._canvasElement === null) {\n            throw new Error(\"Object is disposed\");\n        }\n        (_a = this._canvasElementResizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n        this._canvasElementResizeObserver = null;\n        (_b = this._devicePixelRatioObservable) === null || _b === void 0 ? void 0 : _b.dispose();\n        this._devicePixelRatioObservable = null;\n        this._suggestedBitmapSizeChangedListeners.length = 0;\n        this._bitmapSizeChangedListeners.length = 0;\n        this._canvasElement = null;\n    };\n    Object.defineProperty(DevicePixelContentBoxBinding.prototype, \"canvasElement\", {\n        get: function() {\n            if (this._canvasElement === null) {\n                throw new Error(\"Object is disposed\");\n            }\n            return this._canvasElement;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DevicePixelContentBoxBinding.prototype, \"canvasElementClientSize\", {\n        get: function() {\n            return this._canvasElementClientSize;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DevicePixelContentBoxBinding.prototype, \"bitmapSize\", {\n        get: function() {\n            return (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n                width: this.canvasElement.width,\n                height: this.canvasElement.height\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Use this function to change canvas element client size until binding is disposed\n     * @param clientSize New client size for bound HTMLCanvasElement\n     */ DevicePixelContentBoxBinding.prototype.resizeCanvasElement = function(clientSize) {\n        this._canvasElementClientSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)(clientSize);\n        this.canvasElement.style.width = \"\".concat(this._canvasElementClientSize.width, \"px\");\n        this.canvasElement.style.height = \"\".concat(this._canvasElementClientSize.height, \"px\");\n        this._invalidateBitmapSize();\n    };\n    DevicePixelContentBoxBinding.prototype.subscribeBitmapSizeChanged = function(listener) {\n        this._bitmapSizeChangedListeners.push(listener);\n    };\n    DevicePixelContentBoxBinding.prototype.unsubscribeBitmapSizeChanged = function(listener) {\n        this._bitmapSizeChangedListeners = this._bitmapSizeChangedListeners.filter(function(l) {\n            return l !== listener;\n        });\n    };\n    Object.defineProperty(DevicePixelContentBoxBinding.prototype, \"suggestedBitmapSize\", {\n        get: function() {\n            return this._suggestedBitmapSize;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DevicePixelContentBoxBinding.prototype.subscribeSuggestedBitmapSizeChanged = function(listener) {\n        this._suggestedBitmapSizeChangedListeners.push(listener);\n    };\n    DevicePixelContentBoxBinding.prototype.unsubscribeSuggestedBitmapSizeChanged = function(listener) {\n        this._suggestedBitmapSizeChangedListeners = this._suggestedBitmapSizeChangedListeners.filter(function(l) {\n            return l !== listener;\n        });\n    };\n    DevicePixelContentBoxBinding.prototype.applySuggestedBitmapSize = function() {\n        if (this._suggestedBitmapSize === null) {\n            // nothing to apply\n            return;\n        }\n        var oldSuggestedSize = this._suggestedBitmapSize;\n        this._suggestedBitmapSize = null;\n        this._resizeBitmap(oldSuggestedSize);\n        this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, this._suggestedBitmapSize);\n    };\n    DevicePixelContentBoxBinding.prototype._resizeBitmap = function(newSize) {\n        var oldSize = this.bitmapSize;\n        if ((0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(oldSize, newSize)) {\n            return;\n        }\n        this.canvasElement.width = newSize.width;\n        this.canvasElement.height = newSize.height;\n        this._emitBitmapSizeChanged(oldSize, newSize);\n    };\n    DevicePixelContentBoxBinding.prototype._emitBitmapSizeChanged = function(oldSize, newSize) {\n        var _this = this;\n        this._bitmapSizeChangedListeners.forEach(function(listener) {\n            return listener.call(_this, oldSize, newSize);\n        });\n    };\n    DevicePixelContentBoxBinding.prototype._suggestNewBitmapSize = function(newSize) {\n        var oldSuggestedSize = this._suggestedBitmapSize;\n        var finalNewSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)(this._transformBitmapSize(newSize, this._canvasElementClientSize));\n        var newSuggestedSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this.bitmapSize, finalNewSize) ? null : finalNewSize;\n        if (oldSuggestedSize === null && newSuggestedSize === null) {\n            return;\n        }\n        if (oldSuggestedSize !== null && newSuggestedSize !== null && (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(oldSuggestedSize, newSuggestedSize)) {\n            return;\n        }\n        this._suggestedBitmapSize = newSuggestedSize;\n        this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, newSuggestedSize);\n    };\n    DevicePixelContentBoxBinding.prototype._emitSuggestedBitmapSizeChanged = function(oldSize, newSize) {\n        var _this = this;\n        this._suggestedBitmapSizeChangedListeners.forEach(function(listener) {\n            return listener.call(_this, oldSize, newSize);\n        });\n    };\n    DevicePixelContentBoxBinding.prototype._chooseAndInitObserver = function() {\n        var _this = this;\n        if (!this._allowResizeObserver) {\n            this._initDevicePixelRatioObservable();\n            return;\n        }\n        isDevicePixelContentBoxSupported().then(function(isSupported) {\n            return isSupported ? _this._initResizeObserver() : _this._initDevicePixelRatioObservable();\n        });\n    };\n    // devicePixelRatio approach\n    DevicePixelContentBoxBinding.prototype._initDevicePixelRatioObservable = function() {\n        var _this = this;\n        if (this._canvasElement === null) {\n            // it looks like we are already dead\n            return;\n        }\n        var win = canvasElementWindow(this._canvasElement);\n        if (win === null) {\n            throw new Error(\"No window is associated with the canvas\");\n        }\n        this._devicePixelRatioObservable = (0,_device_pixel_ratio_mjs__WEBPACK_IMPORTED_MODULE_1__.createObservable)(win);\n        this._devicePixelRatioObservable.subscribe(function() {\n            return _this._invalidateBitmapSize();\n        });\n        this._invalidateBitmapSize();\n    };\n    DevicePixelContentBoxBinding.prototype._invalidateBitmapSize = function() {\n        var _a, _b;\n        if (this._canvasElement === null) {\n            // it looks like we are already dead\n            return;\n        }\n        var win = canvasElementWindow(this._canvasElement);\n        if (win === null) {\n            return;\n        }\n        var ratio = (_b = (_a = this._devicePixelRatioObservable) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : win.devicePixelRatio;\n        var canvasRects = this._canvasElement.getClientRects();\n        var newSize = // eslint-disable-next-line no-negated-condition\n        canvasRects[0] !== undefined ? predictedBitmapSize(canvasRects[0], ratio) : (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: this._canvasElementClientSize.width * ratio,\n            height: this._canvasElementClientSize.height * ratio\n        });\n        this._suggestNewBitmapSize(newSize);\n    };\n    // ResizeObserver approach\n    DevicePixelContentBoxBinding.prototype._initResizeObserver = function() {\n        var _this = this;\n        if (this._canvasElement === null) {\n            // it looks like we are already dead\n            return;\n        }\n        this._canvasElementResizeObserver = new ResizeObserver(function(entries) {\n            var entry = entries.find(function(entry) {\n                return entry.target === _this._canvasElement;\n            });\n            if (!entry || !entry.devicePixelContentBoxSize || !entry.devicePixelContentBoxSize[0]) {\n                return;\n            }\n            var entrySize = entry.devicePixelContentBoxSize[0];\n            var newSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n                width: entrySize.inlineSize,\n                height: entrySize.blockSize\n            });\n            _this._suggestNewBitmapSize(newSize);\n        });\n        this._canvasElementResizeObserver.observe(this._canvasElement, {\n            box: \"device-pixel-content-box\"\n        });\n    };\n    return DevicePixelContentBoxBinding;\n}();\nfunction bindTo(canvasElement, target) {\n    if (target.type === \"device-pixel-content-box\") {\n        return new DevicePixelContentBoxBinding(canvasElement, target.transform, target.options);\n    }\n    throw new Error(\"Unsupported binding target\");\n}\nfunction canvasElementWindow(canvasElement) {\n    // According to DOM Level 2 Core specification, ownerDocument should never be null for HTMLCanvasElement\n    // see https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#node-ownerDoc\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return canvasElement.ownerDocument.defaultView;\n}\nfunction isDevicePixelContentBoxSupported() {\n    return new Promise(function(resolve) {\n        var ro = new ResizeObserver(function(entries) {\n            resolve(entries.every(function(entry) {\n                return \"devicePixelContentBoxSize\" in entry;\n            }));\n            ro.disconnect();\n        });\n        ro.observe(document.body, {\n            box: \"device-pixel-content-box\"\n        });\n    }).catch(function() {\n        return false;\n    });\n}\nfunction predictedBitmapSize(canvasRect, ratio) {\n    return (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n        width: Math.round(canvasRect.left * ratio + canvasRect.width * ratio) - Math.round(canvasRect.left * ratio),\n        height: Math.round(canvasRect.top * ratio + canvasRect.height * ratio) - Math.round(canvasRect.top * ratio)\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYW5jeS1jYW52YXMvY2FudmFzLWVsZW1lbnQtYml0bWFwLXNpemUubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QztBQUNrRDtBQUNoRyxJQUFJSSwrQkFBK0IsV0FBVyxHQUFJO0lBQzlDLFNBQVNBLDZCQUE2QkMsYUFBYSxFQUFFQyxtQkFBbUIsRUFBRUMsT0FBTztRQUM3RSxJQUFJQztRQUNKLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsMkJBQTJCLEdBQUcsRUFBRTtRQUNyQyxJQUFJLENBQUNDLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ0Msb0NBQW9DLEdBQUcsRUFBRTtRQUM5Qyw0QkFBNEI7UUFDNUIsSUFBSSxDQUFDQywyQkFBMkIsR0FBRztRQUNuQywwQkFBMEI7UUFDMUIsSUFBSSxDQUFDQyw0QkFBNEIsR0FBRztRQUNwQyxJQUFJLENBQUNMLGNBQWMsR0FBR0o7UUFDdEIsSUFBSSxDQUFDVSx3QkFBd0IsR0FBR2QsK0NBQUlBLENBQUM7WUFDakNlLE9BQU8sSUFBSSxDQUFDUCxjQUFjLENBQUNRLFdBQVc7WUFDdENDLFFBQVEsSUFBSSxDQUFDVCxjQUFjLENBQUNVLFlBQVk7UUFDNUM7UUFDQSxJQUFJLENBQUNDLG9CQUFvQixHQUFHZCx3QkFBd0IsUUFBUUEsd0JBQXdCLEtBQUssSUFBSUEsc0JBQXVCLFNBQVVMLElBQUk7WUFBSSxPQUFPQTtRQUFNO1FBQ25KLElBQUksQ0FBQ29CLG9CQUFvQixHQUFHLENBQUNiLEtBQUtELFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRZSxtQkFBbUIsTUFBTSxRQUFRZCxPQUFPLEtBQUssSUFBSUEsS0FBSztRQUNsSixJQUFJLENBQUNlLHNCQUFzQjtJQUMzQix3RkFBd0Y7SUFDNUY7SUFDQW5CLDZCQUE2Qm9CLFNBQVMsQ0FBQ0MsT0FBTyxHQUFHO1FBQzdDLElBQUlqQixJQUFJa0I7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RSxPQUFPQSxjQUFjc0YsYUFBYSxDQUFDQyxXQUFXO0FBQ2xEO0FBQ0EsU0FBUzdCO0lBQ0wsT0FBTyxJQUFJOEIsUUFBUSxTQUFVQyxPQUFPO1FBQ2hDLElBQUlDLEtBQUssSUFBSWxCLGVBQWUsU0FBVUMsT0FBTztZQUN6Q2dCLFFBQVFoQixRQUFRa0IsS0FBSyxDQUFDLFNBQVVqQixLQUFLO2dCQUFJLE9BQU8sK0JBQStCQTtZQUFPO1lBQ3RGZ0IsR0FBR25FLFVBQVU7UUFDakI7UUFDQW1FLEdBQUdULE9BQU8sQ0FBQ1csU0FBU0MsSUFBSSxFQUFFO1lBQUVYLEtBQUs7UUFBMkI7SUFDaEUsR0FDS1ksS0FBSyxDQUFDO1FBQWMsT0FBTztJQUFPO0FBQzNDO0FBQ0EsU0FBU3ZCLG9CQUFvQndCLFVBQVUsRUFBRTlCLEtBQUs7SUFDMUMsT0FBT3JFLCtDQUFJQSxDQUFDO1FBQ1JlLE9BQU9xRixLQUFLQyxLQUFLLENBQUNGLFdBQVdHLElBQUksR0FBR2pDLFFBQVE4QixXQUFXcEYsS0FBSyxHQUFHc0QsU0FDM0QrQixLQUFLQyxLQUFLLENBQUNGLFdBQVdHLElBQUksR0FBR2pDO1FBQ2pDcEQsUUFBUW1GLEtBQUtDLEtBQUssQ0FBQ0YsV0FBV0ksR0FBRyxHQUFHbEMsUUFBUThCLFdBQVdsRixNQUFNLEdBQUdvRCxTQUM1RCtCLEtBQUtDLEtBQUssQ0FBQ0YsV0FBV0ksR0FBRyxHQUFHbEM7SUFDcEM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFuY3ktY2FudmFzL2NhbnZhcy1lbGVtZW50LWJpdG1hcC1zaXplLm1qcz9kOTJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVxdWFsU2l6ZXMsIHNpemUgfSBmcm9tIFwiLi9zaXplLm1qc1wiO1xuaW1wb3J0IHsgY3JlYXRlT2JzZXJ2YWJsZSBhcyBjcmVhdGVEZXZpY2VQaXhlbFJhdGlvT2JzZXJ2YWJsZSB9IGZyb20gXCIuL2RldmljZS1waXhlbC1yYXRpby5tanNcIjtcbnZhciBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcoY2FudmFzRWxlbWVudCwgdHJhbnNmb3JtQml0bWFwU2l6ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuX2NhbnZhc0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9iaXRtYXBTaXplQ2hhbmdlZExpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLl9zdWdnZXN0ZWRCaXRtYXBTaXplID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgLy8gZGV2aWNlUGl4ZWxSYXRpbyBhcHByb2FjaFxuICAgICAgICB0aGlzLl9kZXZpY2VQaXhlbFJhdGlvT2JzZXJ2YWJsZSA9IG51bGw7XG4gICAgICAgIC8vIFJlc2l6ZU9ic2VydmVyIGFwcHJvYWNoXG4gICAgICAgIHRoaXMuX2NhbnZhc0VsZW1lbnRSZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NhbnZhc0VsZW1lbnQgPSBjYW52YXNFbGVtZW50O1xuICAgICAgICB0aGlzLl9jYW52YXNFbGVtZW50Q2xpZW50U2l6ZSA9IHNpemUoe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMuX2NhbnZhc0VsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuX2NhbnZhc0VsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtQml0bWFwU2l6ZSA9IHRyYW5zZm9ybUJpdG1hcFNpemUgIT09IG51bGwgJiYgdHJhbnNmb3JtQml0bWFwU2l6ZSAhPT0gdm9pZCAwID8gdHJhbnNmb3JtQml0bWFwU2l6ZSA6IChmdW5jdGlvbiAoc2l6ZSkgeyByZXR1cm4gc2l6ZTsgfSk7XG4gICAgICAgIHRoaXMuX2FsbG93UmVzaXplT2JzZXJ2ZXIgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWxsb3dSZXNpemVPYnNlcnZlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2hvb3NlQW5kSW5pdE9ic2VydmVyKCk7XG4gICAgICAgIC8vIHdlIE1BWSBsZWF2ZSB0aGUgY29uc3R1Y3RvciB3aXRob3V0IGFueSBiaXRtYXAgc2l6ZSBvYnNlcnZhdGlvbiBtZWNoYW5pY3MgaW5pdGlhbGl6ZWRcbiAgICB9XG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhc0VsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IGlzIGRpc3Bvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fY2FudmFzRWxlbWVudFJlc2l6ZU9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLl9jYW52YXNFbGVtZW50UmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICAoX2IgPSB0aGlzLl9kZXZpY2VQaXhlbFJhdGlvT2JzZXJ2YWJsZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fZGV2aWNlUGl4ZWxSYXRpb09ic2VydmFibGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZExpc3RlbmVycy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9iaXRtYXBTaXplQ2hhbmdlZExpc3RlbmVycy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9jYW52YXNFbGVtZW50ID0gbnVsbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZSwgXCJjYW52YXNFbGVtZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FudmFzRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IGlzIGRpc3Bvc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzRWxlbWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZSwgXCJjYW52YXNFbGVtZW50Q2xpZW50U2l6ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc0VsZW1lbnRDbGllbnRTaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLCBcImJpdG1hcFNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5jYW52YXNFbGVtZW50LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5jYW52YXNFbGVtZW50LmhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgZnVuY3Rpb24gdG8gY2hhbmdlIGNhbnZhcyBlbGVtZW50IGNsaWVudCBzaXplIHVudGlsIGJpbmRpbmcgaXMgZGlzcG9zZWRcbiAgICAgKiBAcGFyYW0gY2xpZW50U2l6ZSBOZXcgY2xpZW50IHNpemUgZm9yIGJvdW5kIEhUTUxDYW52YXNFbGVtZW50XG4gICAgICovXG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUucmVzaXplQ2FudmFzRWxlbWVudCA9IGZ1bmN0aW9uIChjbGllbnRTaXplKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhc0VsZW1lbnRDbGllbnRTaXplID0gc2l6ZShjbGllbnRTaXplKTtcbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQodGhpcy5fY2FudmFzRWxlbWVudENsaWVudFNpemUud2lkdGgsIFwicHhcIik7XG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdCh0aGlzLl9jYW52YXNFbGVtZW50Q2xpZW50U2l6ZS5oZWlnaHQsIFwicHhcIik7XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGVCaXRtYXBTaXplKCk7XG4gICAgfTtcbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS5zdWJzY3JpYmVCaXRtYXBTaXplQ2hhbmdlZCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9iaXRtYXBTaXplQ2hhbmdlZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLnVuc3Vic2NyaWJlQml0bWFwU2l6ZUNoYW5nZWQgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYml0bWFwU2l6ZUNoYW5nZWRMaXN0ZW5lcnMgPSB0aGlzLl9iaXRtYXBTaXplQ2hhbmdlZExpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwgIT09IGxpc3RlbmVyOyB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZSwgXCJzdWdnZXN0ZWRCaXRtYXBTaXplXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3VnZ2VzdGVkQml0bWFwU2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLnN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX3N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH07XG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUudW5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9zdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZExpc3RlbmVycyA9IHRoaXMuX3N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkTGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAobCkgeyByZXR1cm4gbCAhPT0gbGlzdGVuZXI7IH0pO1xuICAgIH07XG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUuYXBwbHlTdWdnZXN0ZWRCaXRtYXBTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc3VnZ2VzdGVkQml0bWFwU2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBhcHBseVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGRTdWdnZXN0ZWRTaXplID0gdGhpcy5fc3VnZ2VzdGVkQml0bWFwU2l6ZTtcbiAgICAgICAgdGhpcy5fc3VnZ2VzdGVkQml0bWFwU2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUJpdG1hcChvbGRTdWdnZXN0ZWRTaXplKTtcbiAgICAgICAgdGhpcy5fZW1pdFN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkKG9sZFN1Z2dlc3RlZFNpemUsIHRoaXMuX3N1Z2dlc3RlZEJpdG1hcFNpemUpO1xuICAgIH07XG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUuX3Jlc2l6ZUJpdG1hcCA9IGZ1bmN0aW9uIChuZXdTaXplKSB7XG4gICAgICAgIHZhciBvbGRTaXplID0gdGhpcy5iaXRtYXBTaXplO1xuICAgICAgICBpZiAoZXF1YWxTaXplcyhvbGRTaXplLCBuZXdTaXplKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudC53aWR0aCA9IG5ld1NpemUud2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudC5oZWlnaHQgPSBuZXdTaXplLmhlaWdodDtcbiAgICAgICAgdGhpcy5fZW1pdEJpdG1hcFNpemVDaGFuZ2VkKG9sZFNpemUsIG5ld1NpemUpO1xuICAgIH07XG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUuX2VtaXRCaXRtYXBTaXplQ2hhbmdlZCA9IGZ1bmN0aW9uIChvbGRTaXplLCBuZXdTaXplKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2JpdG1hcFNpemVDaGFuZ2VkTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lci5jYWxsKF90aGlzLCBvbGRTaXplLCBuZXdTaXplKTsgfSk7XG4gICAgfTtcbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS5fc3VnZ2VzdE5ld0JpdG1hcFNpemUgPSBmdW5jdGlvbiAobmV3U2l6ZSkge1xuICAgICAgICB2YXIgb2xkU3VnZ2VzdGVkU2l6ZSA9IHRoaXMuX3N1Z2dlc3RlZEJpdG1hcFNpemU7XG4gICAgICAgIHZhciBmaW5hbE5ld1NpemUgPSBzaXplKHRoaXMuX3RyYW5zZm9ybUJpdG1hcFNpemUobmV3U2l6ZSwgdGhpcy5fY2FudmFzRWxlbWVudENsaWVudFNpemUpKTtcbiAgICAgICAgdmFyIG5ld1N1Z2dlc3RlZFNpemUgPSBlcXVhbFNpemVzKHRoaXMuYml0bWFwU2l6ZSwgZmluYWxOZXdTaXplKSA/IG51bGwgOiBmaW5hbE5ld1NpemU7XG4gICAgICAgIGlmIChvbGRTdWdnZXN0ZWRTaXplID09PSBudWxsICYmIG5ld1N1Z2dlc3RlZFNpemUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkU3VnZ2VzdGVkU2l6ZSAhPT0gbnVsbCAmJiBuZXdTdWdnZXN0ZWRTaXplICE9PSBudWxsXG4gICAgICAgICAgICAmJiBlcXVhbFNpemVzKG9sZFN1Z2dlc3RlZFNpemUsIG5ld1N1Z2dlc3RlZFNpemUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3VnZ2VzdGVkQml0bWFwU2l6ZSA9IG5ld1N1Z2dlc3RlZFNpemU7XG4gICAgICAgIHRoaXMuX2VtaXRTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZChvbGRTdWdnZXN0ZWRTaXplLCBuZXdTdWdnZXN0ZWRTaXplKTtcbiAgICB9O1xuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLl9lbWl0U3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQgPSBmdW5jdGlvbiAob2xkU2l6ZSwgbmV3U2l6ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9zdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIuY2FsbChfdGhpcywgb2xkU2l6ZSwgbmV3U2l6ZSk7IH0pO1xuICAgIH07XG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUuX2Nob29zZUFuZEluaXRPYnNlcnZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9hbGxvd1Jlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGV2aWNlUGl4ZWxSYXRpb09ic2VydmFibGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpc0RldmljZVBpeGVsQ29udGVudEJveFN1cHBvcnRlZCgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1N1cHBvcnRlZCA/XG4gICAgICAgICAgICAgICAgX3RoaXMuX2luaXRSZXNpemVPYnNlcnZlcigpIDpcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5pdERldmljZVBpeGVsUmF0aW9PYnNlcnZhYmxlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gZGV2aWNlUGl4ZWxSYXRpbyBhcHByb2FjaFxuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLl9pbml0RGV2aWNlUGl4ZWxSYXRpb09ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9jYW52YXNFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBpdCBsb29rcyBsaWtlIHdlIGFyZSBhbHJlYWR5IGRlYWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2luID0gY2FudmFzRWxlbWVudFdpbmRvdyh0aGlzLl9jYW52YXNFbGVtZW50KTtcbiAgICAgICAgaWYgKHdpbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB3aW5kb3cgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjYW52YXMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZXZpY2VQaXhlbFJhdGlvT2JzZXJ2YWJsZSA9IGNyZWF0ZURldmljZVBpeGVsUmF0aW9PYnNlcnZhYmxlKHdpbik7XG4gICAgICAgIHRoaXMuX2RldmljZVBpeGVsUmF0aW9PYnNlcnZhYmxlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faW52YWxpZGF0ZUJpdG1hcFNpemUoKTsgfSk7XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGVCaXRtYXBTaXplKCk7XG4gICAgfTtcbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS5faW52YWxpZGF0ZUJpdG1hcFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLl9jYW52YXNFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBpdCBsb29rcyBsaWtlIHdlIGFyZSBhbHJlYWR5IGRlYWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2luID0gY2FudmFzRWxlbWVudFdpbmRvdyh0aGlzLl9jYW52YXNFbGVtZW50KTtcbiAgICAgICAgaWYgKHdpbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYXRpbyA9IChfYiA9IChfYSA9IHRoaXMuX2RldmljZVBpeGVsUmF0aW9PYnNlcnZhYmxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHdpbi5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICB2YXIgY2FudmFzUmVjdHMgPSB0aGlzLl9jYW52YXNFbGVtZW50LmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIHZhciBuZXdTaXplID0gXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZWdhdGVkLWNvbmRpdGlvblxuICAgICAgICBjYW52YXNSZWN0c1swXSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHByZWRpY3RlZEJpdG1hcFNpemUoY2FudmFzUmVjdHNbMF0sIHJhdGlvKSA6XG4gICAgICAgICAgICBzaXplKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5fY2FudmFzRWxlbWVudENsaWVudFNpemUud2lkdGggKiByYXRpbyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuX2NhbnZhc0VsZW1lbnRDbGllbnRTaXplLmhlaWdodCAqIHJhdGlvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3N1Z2dlc3ROZXdCaXRtYXBTaXplKG5ld1NpemUpO1xuICAgIH07XG4gICAgLy8gUmVzaXplT2JzZXJ2ZXIgYXBwcm9hY2hcbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS5faW5pdFJlc2l6ZU9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fY2FudmFzRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaXQgbG9va3MgbGlrZSB3ZSBhcmUgYWxyZWFkeSBkZWFkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FudmFzRWxlbWVudFJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS50YXJnZXQgPT09IF90aGlzLl9jYW52YXNFbGVtZW50OyB9KTtcbiAgICAgICAgICAgIGlmICghZW50cnkgfHwgIWVudHJ5LmRldmljZVBpeGVsQ29udGVudEJveFNpemUgfHwgIWVudHJ5LmRldmljZVBpeGVsQ29udGVudEJveFNpemVbMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZW50cnlTaXplID0gZW50cnkuZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZVswXTtcbiAgICAgICAgICAgIHZhciBuZXdTaXplID0gc2l6ZSh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGVudHJ5U2l6ZS5pbmxpbmVTaXplLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZW50cnlTaXplLmJsb2NrU2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuX3N1Z2dlc3ROZXdCaXRtYXBTaXplKG5ld1NpemUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY2FudmFzRWxlbWVudFJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5fY2FudmFzRWxlbWVudCwgeyBib3g6ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmc7XG59KCkpO1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRUbyhjYW52YXNFbGVtZW50LCB0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0LnR5cGUgPT09ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZyhjYW52YXNFbGVtZW50LCB0YXJnZXQudHJhbnNmb3JtLCB0YXJnZXQub3B0aW9ucyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYmluZGluZyB0YXJnZXQnKTtcbn1cbmZ1bmN0aW9uIGNhbnZhc0VsZW1lbnRXaW5kb3coY2FudmFzRWxlbWVudCkge1xuICAgIC8vIEFjY29yZGluZyB0byBET00gTGV2ZWwgMiBDb3JlIHNwZWNpZmljYXRpb24sIG93bmVyRG9jdW1lbnQgc2hvdWxkIG5ldmVyIGJlIG51bGwgZm9yIEhUTUxDYW52YXNFbGVtZW50XG4gICAgLy8gc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAwL1JFQy1ET00tTGV2ZWwtMi1Db3JlLTIwMDAxMTEzL2NvcmUuaHRtbCNub2RlLW93bmVyRG9jXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICByZXR1cm4gY2FudmFzRWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xufVxuZnVuY3Rpb24gaXNEZXZpY2VQaXhlbENvbnRlbnRCb3hTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciBybyA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgICAgcmVzb2x2ZShlbnRyaWVzLmV2ZXJ5KGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gJ2RldmljZVBpeGVsQ29udGVudEJveFNpemUnIGluIGVudHJ5OyB9KSk7XG4gICAgICAgICAgICByby5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICByby5vYnNlcnZlKGRvY3VtZW50LmJvZHksIHsgYm94OiAnZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94JyB9KTtcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xufVxuZnVuY3Rpb24gcHJlZGljdGVkQml0bWFwU2l6ZShjYW52YXNSZWN0LCByYXRpbykge1xuICAgIHJldHVybiBzaXplKHtcbiAgICAgICAgd2lkdGg6IE1hdGgucm91bmQoY2FudmFzUmVjdC5sZWZ0ICogcmF0aW8gKyBjYW52YXNSZWN0LndpZHRoICogcmF0aW8pIC1cbiAgICAgICAgICAgIE1hdGgucm91bmQoY2FudmFzUmVjdC5sZWZ0ICogcmF0aW8pLFxuICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQoY2FudmFzUmVjdC50b3AgKiByYXRpbyArIGNhbnZhc1JlY3QuaGVpZ2h0ICogcmF0aW8pIC1cbiAgICAgICAgICAgIE1hdGgucm91bmQoY2FudmFzUmVjdC50b3AgKiByYXRpbyksXG4gICAgfSk7XG59XG4iXSwibmFtZXMiOlsiZXF1YWxTaXplcyIsInNpemUiLCJjcmVhdGVPYnNlcnZhYmxlIiwiY3JlYXRlRGV2aWNlUGl4ZWxSYXRpb09ic2VydmFibGUiLCJEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nIiwiY2FudmFzRWxlbWVudCIsInRyYW5zZm9ybUJpdG1hcFNpemUiLCJvcHRpb25zIiwiX2EiLCJfY2FudmFzRWxlbWVudCIsIl9iaXRtYXBTaXplQ2hhbmdlZExpc3RlbmVycyIsIl9zdWdnZXN0ZWRCaXRtYXBTaXplIiwiX3N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkTGlzdGVuZXJzIiwiX2RldmljZVBpeGVsUmF0aW9PYnNlcnZhYmxlIiwiX2NhbnZhc0VsZW1lbnRSZXNpemVPYnNlcnZlciIsIl9jYW52YXNFbGVtZW50Q2xpZW50U2l6ZSIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJfdHJhbnNmb3JtQml0bWFwU2l6ZSIsIl9hbGxvd1Jlc2l6ZU9ic2VydmVyIiwiYWxsb3dSZXNpemVPYnNlcnZlciIsIl9jaG9vc2VBbmRJbml0T2JzZXJ2ZXIiLCJwcm90b3R5cGUiLCJkaXNwb3NlIiwiX2IiLCJFcnJvciIsImRpc2Nvbm5lY3QiLCJsZW5ndGgiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJyZXNpemVDYW52YXNFbGVtZW50IiwiY2xpZW50U2l6ZSIsInN0eWxlIiwiY29uY2F0IiwiX2ludmFsaWRhdGVCaXRtYXBTaXplIiwic3Vic2NyaWJlQml0bWFwU2l6ZUNoYW5nZWQiLCJsaXN0ZW5lciIsInB1c2giLCJ1bnN1YnNjcmliZUJpdG1hcFNpemVDaGFuZ2VkIiwiZmlsdGVyIiwibCIsInN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkIiwidW5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCIsImFwcGx5U3VnZ2VzdGVkQml0bWFwU2l6ZSIsIm9sZFN1Z2dlc3RlZFNpemUiLCJfcmVzaXplQml0bWFwIiwiX2VtaXRTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCIsIm5ld1NpemUiLCJvbGRTaXplIiwiYml0bWFwU2l6ZSIsIl9lbWl0Qml0bWFwU2l6ZUNoYW5nZWQiLCJfdGhpcyIsImZvckVhY2giLCJjYWxsIiwiX3N1Z2dlc3ROZXdCaXRtYXBTaXplIiwiZmluYWxOZXdTaXplIiwibmV3U3VnZ2VzdGVkU2l6ZSIsIl9pbml0RGV2aWNlUGl4ZWxSYXRpb09ic2VydmFibGUiLCJpc0RldmljZVBpeGVsQ29udGVudEJveFN1cHBvcnRlZCIsInRoZW4iLCJpc1N1cHBvcnRlZCIsIl9pbml0UmVzaXplT2JzZXJ2ZXIiLCJ3aW4iLCJjYW52YXNFbGVtZW50V2luZG93Iiwic3Vic2NyaWJlIiwicmF0aW8iLCJ2YWx1ZSIsImRldmljZVBpeGVsUmF0aW8iLCJjYW52YXNSZWN0cyIsImdldENsaWVudFJlY3RzIiwidW5kZWZpbmVkIiwicHJlZGljdGVkQml0bWFwU2l6ZSIsIlJlc2l6ZU9ic2VydmVyIiwiZW50cmllcyIsImVudHJ5IiwiZmluZCIsInRhcmdldCIsImRldmljZVBpeGVsQ29udGVudEJveFNpemUiLCJlbnRyeVNpemUiLCJpbmxpbmVTaXplIiwiYmxvY2tTaXplIiwib2JzZXJ2ZSIsImJveCIsImJpbmRUbyIsInR5cGUiLCJ0cmFuc2Zvcm0iLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJQcm9taXNlIiwicmVzb2x2ZSIsInJvIiwiZXZlcnkiLCJkb2N1bWVudCIsImJvZHkiLCJjYXRjaCIsImNhbnZhc1JlY3QiLCJNYXRoIiwicm91bmQiLCJsZWZ0IiwidG9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fancy-canvas/canvas-element-bitmap-size.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fancy-canvas/canvas-rendering-target.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/fancy-canvas/canvas-rendering-target.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanvasRenderingTarget2D: function() { return /* binding */ CanvasRenderingTarget2D; },\n/* harmony export */   createCanvasRenderingTarget2D: function() { return /* binding */ createCanvasRenderingTarget2D; },\n/* harmony export */   tryCreateCanvasRenderingTarget2D: function() { return /* binding */ tryCreateCanvasRenderingTarget2D; }\n/* harmony export */ });\n/**\n * @experimental\n */ var CanvasRenderingTarget2D = /** @class */ function() {\n    function CanvasRenderingTarget2D(context, mediaSize, bitmapSize) {\n        if (mediaSize.width === 0 || mediaSize.height === 0) {\n            throw new TypeError(\"Rendering target could only be created on a media with positive width and height\");\n        }\n        this._mediaSize = mediaSize;\n        // !Number.isInteger(bitmapSize.width) || !Number.isInteger(bitmapSize.height)\n        if (bitmapSize.width === 0 || bitmapSize.height === 0) {\n            throw new TypeError(\"Rendering target could only be created using a bitmap with positive integer width and height\");\n        }\n        this._bitmapSize = bitmapSize;\n        this._context = context;\n    }\n    CanvasRenderingTarget2D.prototype.useMediaCoordinateSpace = function(f) {\n        try {\n            this._context.save();\n            // do not use resetTransform to support old versions of Edge\n            this._context.setTransform(1, 0, 0, 1, 0, 0);\n            this._context.scale(this._horizontalPixelRatio, this._verticalPixelRatio);\n            return f({\n                context: this._context,\n                mediaSize: this._mediaSize\n            });\n        } finally{\n            this._context.restore();\n        }\n    };\n    CanvasRenderingTarget2D.prototype.useBitmapCoordinateSpace = function(f) {\n        try {\n            this._context.save();\n            // do not use resetTransform to support old versions of Edge\n            this._context.setTransform(1, 0, 0, 1, 0, 0);\n            return f({\n                context: this._context,\n                mediaSize: this._mediaSize,\n                bitmapSize: this._bitmapSize,\n                horizontalPixelRatio: this._horizontalPixelRatio,\n                verticalPixelRatio: this._verticalPixelRatio\n            });\n        } finally{\n            this._context.restore();\n        }\n    };\n    Object.defineProperty(CanvasRenderingTarget2D.prototype, \"_horizontalPixelRatio\", {\n        get: function() {\n            return this._bitmapSize.width / this._mediaSize.width;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CanvasRenderingTarget2D.prototype, \"_verticalPixelRatio\", {\n        get: function() {\n            return this._bitmapSize.height / this._mediaSize.height;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return CanvasRenderingTarget2D;\n}();\n\n/**\n * @experimental\n */ function createCanvasRenderingTarget2D(binding, contextOptions) {\n    var mediaSize = binding.canvasElementClientSize;\n    var bitmapSize = binding.bitmapSize;\n    var context = binding.canvasElement.getContext(\"2d\", contextOptions);\n    if (context === null) {\n        throw new Error(\"Could not get 2d drawing context from bound canvas element. Has the canvas already been set to a different context mode?\");\n    }\n    return new CanvasRenderingTarget2D(context, mediaSize, bitmapSize);\n}\n/**\n * @experimental\n */ function tryCreateCanvasRenderingTarget2D(binding, contextOptions) {\n    var mediaSize = binding.canvasElementClientSize;\n    if (mediaSize.width === 0 || mediaSize.height === 0) {\n        return null;\n    }\n    var bitmapSize = binding.bitmapSize;\n    if (bitmapSize.width === 0 || bitmapSize.height === 0) {\n        return null;\n    }\n    var context = binding.canvasElement.getContext(\"2d\", contextOptions);\n    if (context === null) {\n        return null;\n    }\n    return new CanvasRenderingTarget2D(context, mediaSize, bitmapSize);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYW5jeS1jYW52YXMvY2FudmFzLXJlbmRlcmluZy10YXJnZXQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztDQUVDLEdBQ0QsSUFBSUEsMEJBQTBCLFdBQVcsR0FBSTtJQUN6QyxTQUFTQSx3QkFBd0JDLE9BQU8sRUFBRUMsU0FBUyxFQUFFQyxVQUFVO1FBQzNELElBQUlELFVBQVVFLEtBQUssS0FBSyxLQUFLRixVQUFVRyxNQUFNLEtBQUssR0FBRztZQUNqRCxNQUFNLElBQUlDLFVBQVU7UUFDeEI7UUFDQSxJQUFJLENBQUNDLFVBQVUsR0FBR0w7UUFDbEIsOEVBQThFO1FBQzlFLElBQUlDLFdBQVdDLEtBQUssS0FBSyxLQUFLRCxXQUFXRSxNQUFNLEtBQUssR0FBRztZQUNuRCxNQUFNLElBQUlDLFVBQVU7UUFDeEI7UUFDQSxJQUFJLENBQUNFLFdBQVcsR0FBR0w7UUFDbkIsSUFBSSxDQUFDTSxRQUFRLEdBQUdSO0lBQ3BCO0lBQ0FELHdCQUF3QlUsU0FBUyxDQUFDQyx1QkFBdUIsR0FBRyxTQUFVQyxDQUFDO1FBQ25FLElBQUk7WUFDQSxJQUFJLENBQUNILFFBQVEsQ0FBQ0ksSUFBSTtZQUNsQiw0REFBNEQ7WUFDNUQsSUFBSSxDQUFDSixRQUFRLENBQUNLLFlBQVksQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7WUFDMUMsSUFBSSxDQUFDTCxRQUFRLENBQUNNLEtBQUssQ0FBQyxJQUFJLENBQUNDLHFCQUFxQixFQUFFLElBQUksQ0FBQ0MsbUJBQW1CO1lBQ3hFLE9BQU9MLEVBQUU7Z0JBQ0xYLFNBQVMsSUFBSSxDQUFDUSxRQUFRO2dCQUN0QlAsV0FBVyxJQUFJLENBQUNLLFVBQVU7WUFDOUI7UUFDSixTQUNRO1lBQ0osSUFBSSxDQUFDRSxRQUFRLENBQUNTLE9BQU87UUFDekI7SUFDSjtJQUNBbEIsd0JBQXdCVSxTQUFTLENBQUNTLHdCQUF3QixHQUFHLFNBQVVQLENBQUM7UUFDcEUsSUFBSTtZQUNBLElBQUksQ0FBQ0gsUUFBUSxDQUFDSSxJQUFJO1lBQ2xCLDREQUE0RDtZQUM1RCxJQUFJLENBQUNKLFFBQVEsQ0FBQ0ssWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztZQUMxQyxPQUFPRixFQUFFO2dCQUNMWCxTQUFTLElBQUksQ0FBQ1EsUUFBUTtnQkFDdEJQLFdBQVcsSUFBSSxDQUFDSyxVQUFVO2dCQUMxQkosWUFBWSxJQUFJLENBQUNLLFdBQVc7Z0JBQzVCWSxzQkFBc0IsSUFBSSxDQUFDSixxQkFBcUI7Z0JBQ2hESyxvQkFBb0IsSUFBSSxDQUFDSixtQkFBbUI7WUFDaEQ7UUFDSixTQUNRO1lBQ0osSUFBSSxDQUFDUixRQUFRLENBQUNTLE9BQU87UUFDekI7SUFDSjtJQUNBSSxPQUFPQyxjQUFjLENBQUN2Qix3QkFBd0JVLFNBQVMsRUFBRSx5QkFBeUI7UUFDOUVjLEtBQUs7WUFDRCxPQUFPLElBQUksQ0FBQ2hCLFdBQVcsQ0FBQ0osS0FBSyxHQUFHLElBQUksQ0FBQ0csVUFBVSxDQUFDSCxLQUFLO1FBQ3pEO1FBQ0FxQixZQUFZO1FBQ1pDLGNBQWM7SUFDbEI7SUFDQUosT0FBT0MsY0FBYyxDQUFDdkIsd0JBQXdCVSxTQUFTLEVBQUUsdUJBQXVCO1FBQzVFYyxLQUFLO1lBQ0QsT0FBTyxJQUFJLENBQUNoQixXQUFXLENBQUNILE1BQU0sR0FBRyxJQUFJLENBQUNFLFVBQVUsQ0FBQ0YsTUFBTTtRQUMzRDtRQUNBb0IsWUFBWTtRQUNaQyxjQUFjO0lBQ2xCO0lBQ0EsT0FBTzFCO0FBQ1g7QUFDbUM7QUFDbkM7O0NBRUMsR0FDTSxTQUFTMkIsOEJBQThCQyxPQUFPLEVBQUVDLGNBQWM7SUFDakUsSUFBSTNCLFlBQVkwQixRQUFRRSx1QkFBdUI7SUFDL0MsSUFBSTNCLGFBQWF5QixRQUFRekIsVUFBVTtJQUNuQyxJQUFJRixVQUFVMkIsUUFBUUcsYUFBYSxDQUFDQyxVQUFVLENBQUMsTUFBTUg7SUFDckQsSUFBSTVCLFlBQVksTUFBTTtRQUNsQixNQUFNLElBQUlnQyxNQUFNO0lBQ3BCO0lBQ0EsT0FBTyxJQUFJakMsd0JBQXdCQyxTQUFTQyxXQUFXQztBQUMzRDtBQUNBOztDQUVDLEdBQ00sU0FBUytCLGlDQUFpQ04sT0FBTyxFQUFFQyxjQUFjO0lBQ3BFLElBQUkzQixZQUFZMEIsUUFBUUUsdUJBQXVCO0lBQy9DLElBQUk1QixVQUFVRSxLQUFLLEtBQUssS0FBS0YsVUFBVUcsTUFBTSxLQUFLLEdBQUc7UUFDakQsT0FBTztJQUNYO0lBQ0EsSUFBSUYsYUFBYXlCLFFBQVF6QixVQUFVO0lBQ25DLElBQUlBLFdBQVdDLEtBQUssS0FBSyxLQUFLRCxXQUFXRSxNQUFNLEtBQUssR0FBRztRQUNuRCxPQUFPO0lBQ1g7SUFDQSxJQUFJSixVQUFVMkIsUUFBUUcsYUFBYSxDQUFDQyxVQUFVLENBQUMsTUFBTUg7SUFDckQsSUFBSTVCLFlBQVksTUFBTTtRQUNsQixPQUFPO0lBQ1g7SUFDQSxPQUFPLElBQUlELHdCQUF3QkMsU0FBU0MsV0FBV0M7QUFDM0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhbmN5LWNhbnZhcy9jYW52YXMtcmVuZGVyaW5nLXRhcmdldC5tanM/NjQ1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xudmFyIENhbnZhc1JlbmRlcmluZ1RhcmdldDJEID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmluZ1RhcmdldDJEKGNvbnRleHQsIG1lZGlhU2l6ZSwgYml0bWFwU2l6ZSkge1xuICAgICAgICBpZiAobWVkaWFTaXplLndpZHRoID09PSAwIHx8IG1lZGlhU2l6ZS5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlbmRlcmluZyB0YXJnZXQgY291bGQgb25seSBiZSBjcmVhdGVkIG9uIGEgbWVkaWEgd2l0aCBwb3NpdGl2ZSB3aWR0aCBhbmQgaGVpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWVkaWFTaXplID0gbWVkaWFTaXplO1xuICAgICAgICAvLyAhTnVtYmVyLmlzSW50ZWdlcihiaXRtYXBTaXplLndpZHRoKSB8fCAhTnVtYmVyLmlzSW50ZWdlcihiaXRtYXBTaXplLmhlaWdodClcbiAgICAgICAgaWYgKGJpdG1hcFNpemUud2lkdGggPT09IDAgfHwgYml0bWFwU2l6ZS5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlbmRlcmluZyB0YXJnZXQgY291bGQgb25seSBiZSBjcmVhdGVkIHVzaW5nIGEgYml0bWFwIHdpdGggcG9zaXRpdmUgaW50ZWdlciB3aWR0aCBhbmQgaGVpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYml0bWFwU2l6ZSA9IGJpdG1hcFNpemU7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBDYW52YXNSZW5kZXJpbmdUYXJnZXQyRC5wcm90b3R5cGUudXNlTWVkaWFDb29yZGluYXRlU3BhY2UgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAvLyBkbyBub3QgdXNlIHJlc2V0VHJhbnNmb3JtIHRvIHN1cHBvcnQgb2xkIHZlcnNpb25zIG9mIEVkZ2VcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zY2FsZSh0aGlzLl9ob3Jpem9udGFsUGl4ZWxSYXRpbywgdGhpcy5fdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIHJldHVybiBmKHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLl9jb250ZXh0LFxuICAgICAgICAgICAgICAgIG1lZGlhU2l6ZTogdGhpcy5fbWVkaWFTaXplLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQucHJvdG90eXBlLnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIC8vIGRvIG5vdCB1c2UgcmVzZXRUcmFuc2Zvcm0gdG8gc3VwcG9ydCBvbGQgdmVyc2lvbnMgb2YgRWRnZVxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gZih7XG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5fY29udGV4dCxcbiAgICAgICAgICAgICAgICBtZWRpYVNpemU6IHRoaXMuX21lZGlhU2l6ZSxcbiAgICAgICAgICAgICAgICBiaXRtYXBTaXplOiB0aGlzLl9iaXRtYXBTaXplLFxuICAgICAgICAgICAgICAgIGhvcml6b250YWxQaXhlbFJhdGlvOiB0aGlzLl9ob3Jpem9udGFsUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbFBpeGVsUmF0aW86IHRoaXMuX3ZlcnRpY2FsUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYW52YXNSZW5kZXJpbmdUYXJnZXQyRC5wcm90b3R5cGUsIFwiX2hvcml6b250YWxQaXhlbFJhdGlvXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYml0bWFwU2l6ZS53aWR0aCAvIHRoaXMuX21lZGlhU2l6ZS53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYW52YXNSZW5kZXJpbmdUYXJnZXQyRC5wcm90b3R5cGUsIFwiX3ZlcnRpY2FsUGl4ZWxSYXRpb1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpdG1hcFNpemUuaGVpZ2h0IC8gdGhpcy5fbWVkaWFTaXplLmhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBDYW52YXNSZW5kZXJpbmdUYXJnZXQyRDtcbn0oKSk7XG5leHBvcnQgeyBDYW52YXNSZW5kZXJpbmdUYXJnZXQyRCB9O1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYW52YXNSZW5kZXJpbmdUYXJnZXQyRChiaW5kaW5nLCBjb250ZXh0T3B0aW9ucykge1xuICAgIHZhciBtZWRpYVNpemUgPSBiaW5kaW5nLmNhbnZhc0VsZW1lbnRDbGllbnRTaXplO1xuICAgIHZhciBiaXRtYXBTaXplID0gYmluZGluZy5iaXRtYXBTaXplO1xuICAgIHZhciBjb250ZXh0ID0gYmluZGluZy5jYW52YXNFbGVtZW50LmdldENvbnRleHQoJzJkJywgY29udGV4dE9wdGlvbnMpO1xuICAgIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCAyZCBkcmF3aW5nIGNvbnRleHQgZnJvbSBib3VuZCBjYW52YXMgZWxlbWVudC4gSGFzIHRoZSBjYW52YXMgYWxyZWFkeSBiZWVuIHNldCB0byBhIGRpZmZlcmVudCBjb250ZXh0IG1vZGU/Jyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQoY29udGV4dCwgbWVkaWFTaXplLCBiaXRtYXBTaXplKTtcbn1cbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJ5Q3JlYXRlQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQoYmluZGluZywgY29udGV4dE9wdGlvbnMpIHtcbiAgICB2YXIgbWVkaWFTaXplID0gYmluZGluZy5jYW52YXNFbGVtZW50Q2xpZW50U2l6ZTtcbiAgICBpZiAobWVkaWFTaXplLndpZHRoID09PSAwIHx8IG1lZGlhU2l6ZS5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBiaXRtYXBTaXplID0gYmluZGluZy5iaXRtYXBTaXplO1xuICAgIGlmIChiaXRtYXBTaXplLndpZHRoID09PSAwIHx8IGJpdG1hcFNpemUuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgY29udGV4dCA9IGJpbmRpbmcuY2FudmFzRWxlbWVudC5nZXRDb250ZXh0KCcyZCcsIGNvbnRleHRPcHRpb25zKTtcbiAgICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDYW52YXNSZW5kZXJpbmdUYXJnZXQyRChjb250ZXh0LCBtZWRpYVNpemUsIGJpdG1hcFNpemUpO1xufVxuIl0sIm5hbWVzIjpbIkNhbnZhc1JlbmRlcmluZ1RhcmdldDJEIiwiY29udGV4dCIsIm1lZGlhU2l6ZSIsImJpdG1hcFNpemUiLCJ3aWR0aCIsImhlaWdodCIsIlR5cGVFcnJvciIsIl9tZWRpYVNpemUiLCJfYml0bWFwU2l6ZSIsIl9jb250ZXh0IiwicHJvdG90eXBlIiwidXNlTWVkaWFDb29yZGluYXRlU3BhY2UiLCJmIiwic2F2ZSIsInNldFRyYW5zZm9ybSIsInNjYWxlIiwiX2hvcml6b250YWxQaXhlbFJhdGlvIiwiX3ZlcnRpY2FsUGl4ZWxSYXRpbyIsInJlc3RvcmUiLCJ1c2VCaXRtYXBDb29yZGluYXRlU3BhY2UiLCJob3Jpem9udGFsUGl4ZWxSYXRpbyIsInZlcnRpY2FsUGl4ZWxSYXRpbyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJEIiwiYmluZGluZyIsImNvbnRleHRPcHRpb25zIiwiY2FudmFzRWxlbWVudENsaWVudFNpemUiLCJjYW52YXNFbGVtZW50IiwiZ2V0Q29udGV4dCIsIkVycm9yIiwidHJ5Q3JlYXRlQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fancy-canvas/canvas-rendering-target.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fancy-canvas/device-pixel-ratio.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/fancy-canvas/device-pixel-ratio.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createObservable: function() { return /* binding */ createObservable; }\n/* harmony export */ });\nvar Observable = /** @class */ function() {\n    function Observable(win) {\n        var _this = this;\n        this._resolutionListener = function() {\n            return _this._onResolutionChanged();\n        };\n        this._resolutionMediaQueryList = null;\n        this._observers = [];\n        this._window = win;\n        this._installResolutionListener();\n    }\n    Observable.prototype.dispose = function() {\n        this._uninstallResolutionListener();\n        this._window = null;\n    };\n    Object.defineProperty(Observable.prototype, \"value\", {\n        get: function() {\n            return this._window.devicePixelRatio;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Observable.prototype.subscribe = function(next) {\n        var _this = this;\n        var observer = {\n            next: next\n        };\n        this._observers.push(observer);\n        return {\n            unsubscribe: function() {\n                _this._observers = _this._observers.filter(function(o) {\n                    return o !== observer;\n                });\n            }\n        };\n    };\n    Observable.prototype._installResolutionListener = function() {\n        if (this._resolutionMediaQueryList !== null) {\n            throw new Error(\"Resolution listener is already installed\");\n        }\n        var dppx = this._window.devicePixelRatio;\n        this._resolutionMediaQueryList = this._window.matchMedia(\"all and (resolution: \".concat(dppx, \"dppx)\"));\n        // IE and some versions of Edge do not support addEventListener/removeEventListener, and we are going to use the deprecated addListener/removeListener\n        this._resolutionMediaQueryList.addListener(this._resolutionListener);\n    };\n    Observable.prototype._uninstallResolutionListener = function() {\n        if (this._resolutionMediaQueryList !== null) {\n            // IE and some versions of Edge do not support addEventListener/removeEventListener, and we are going to use the deprecated addListener/removeListener\n            this._resolutionMediaQueryList.removeListener(this._resolutionListener);\n            this._resolutionMediaQueryList = null;\n        }\n    };\n    Observable.prototype._reinstallResolutionListener = function() {\n        this._uninstallResolutionListener();\n        this._installResolutionListener();\n    };\n    Observable.prototype._onResolutionChanged = function() {\n        var _this = this;\n        this._observers.forEach(function(observer) {\n            return observer.next(_this._window.devicePixelRatio);\n        });\n        this._reinstallResolutionListener();\n    };\n    return Observable;\n}();\nfunction createObservable(win) {\n    return new Observable(win);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYW5jeS1jYW52YXMvZGV2aWNlLXBpeGVsLXJhdGlvLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUEsYUFBYSxXQUFXLEdBQUk7SUFDNUIsU0FBU0EsV0FBV0MsR0FBRztRQUNuQixJQUFJQyxRQUFRLElBQUk7UUFDaEIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztZQUFjLE9BQU9ELE1BQU1FLG9CQUFvQjtRQUFJO1FBQzlFLElBQUksQ0FBQ0MseUJBQXlCLEdBQUc7UUFDakMsSUFBSSxDQUFDQyxVQUFVLEdBQUcsRUFBRTtRQUNwQixJQUFJLENBQUNDLE9BQU8sR0FBR047UUFDZixJQUFJLENBQUNPLDBCQUEwQjtJQUNuQztJQUNBUixXQUFXUyxTQUFTLENBQUNDLE9BQU8sR0FBRztRQUMzQixJQUFJLENBQUNDLDRCQUE0QjtRQUNqQyxJQUFJLENBQUNKLE9BQU8sR0FBRztJQUNuQjtJQUNBSyxPQUFPQyxjQUFjLENBQUNiLFdBQVdTLFNBQVMsRUFBRSxTQUFTO1FBQ2pESyxLQUFLO1lBQ0QsT0FBTyxJQUFJLENBQUNQLE9BQU8sQ0FBQ1EsZ0JBQWdCO1FBQ3hDO1FBQ0FDLFlBQVk7UUFDWkMsY0FBYztJQUNsQjtJQUNBakIsV0FBV1MsU0FBUyxDQUFDUyxTQUFTLEdBQUcsU0FBVUMsSUFBSTtRQUMzQyxJQUFJakIsUUFBUSxJQUFJO1FBQ2hCLElBQUlrQixXQUFXO1lBQUVELE1BQU1BO1FBQUs7UUFDNUIsSUFBSSxDQUFDYixVQUFVLENBQUNlLElBQUksQ0FBQ0Q7UUFDckIsT0FBTztZQUNIRSxhQUFhO2dCQUNUcEIsTUFBTUksVUFBVSxHQUFHSixNQUFNSSxVQUFVLENBQUNpQixNQUFNLENBQUMsU0FBVUMsQ0FBQztvQkFBSSxPQUFPQSxNQUFNSjtnQkFBVTtZQUNyRjtRQUNKO0lBQ0o7SUFDQXBCLFdBQVdTLFNBQVMsQ0FBQ0QsMEJBQTBCLEdBQUc7UUFDOUMsSUFBSSxJQUFJLENBQUNILHlCQUF5QixLQUFLLE1BQU07WUFDekMsTUFBTSxJQUFJb0IsTUFBTTtRQUNwQjtRQUNBLElBQUlDLE9BQU8sSUFBSSxDQUFDbkIsT0FBTyxDQUFDUSxnQkFBZ0I7UUFDeEMsSUFBSSxDQUFDVix5QkFBeUIsR0FBRyxJQUFJLENBQUNFLE9BQU8sQ0FBQ29CLFVBQVUsQ0FBQyx3QkFBd0JDLE1BQU0sQ0FBQ0YsTUFBTTtRQUM5RixzSkFBc0o7UUFDdEosSUFBSSxDQUFDckIseUJBQXlCLENBQUN3QixXQUFXLENBQUMsSUFBSSxDQUFDMUIsbUJBQW1CO0lBQ3ZFO0lBQ0FILFdBQVdTLFNBQVMsQ0FBQ0UsNEJBQTRCLEdBQUc7UUFDaEQsSUFBSSxJQUFJLENBQUNOLHlCQUF5QixLQUFLLE1BQU07WUFDekMsc0pBQXNKO1lBQ3RKLElBQUksQ0FBQ0EseUJBQXlCLENBQUN5QixjQUFjLENBQUMsSUFBSSxDQUFDM0IsbUJBQW1CO1lBQ3RFLElBQUksQ0FBQ0UseUJBQXlCLEdBQUc7UUFDckM7SUFDSjtJQUNBTCxXQUFXUyxTQUFTLENBQUNzQiw0QkFBNEIsR0FBRztRQUNoRCxJQUFJLENBQUNwQiw0QkFBNEI7UUFDakMsSUFBSSxDQUFDSCwwQkFBMEI7SUFDbkM7SUFDQVIsV0FBV1MsU0FBUyxDQUFDTCxvQkFBb0IsR0FBRztRQUN4QyxJQUFJRixRQUFRLElBQUk7UUFDaEIsSUFBSSxDQUFDSSxVQUFVLENBQUMwQixPQUFPLENBQUMsU0FBVVosUUFBUTtZQUFJLE9BQU9BLFNBQVNELElBQUksQ0FBQ2pCLE1BQU1LLE9BQU8sQ0FBQ1EsZ0JBQWdCO1FBQUc7UUFDcEcsSUFBSSxDQUFDZ0IsNEJBQTRCO0lBQ3JDO0lBQ0EsT0FBTy9CO0FBQ1g7QUFDTyxTQUFTaUMsaUJBQWlCaEMsR0FBRztJQUNoQyxPQUFPLElBQUlELFdBQVdDO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYW5jeS1jYW52YXMvZGV2aWNlLXBpeGVsLXJhdGlvLm1qcz9mMTY3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBPYnNlcnZhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUod2luKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vblJlc29sdXRpb25DaGFuZ2VkKCk7IH07XG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb25NZWRpYVF1ZXJ5TGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX29ic2VydmVycyA9IFtdO1xuICAgICAgICB0aGlzLl93aW5kb3cgPSB3aW47XG4gICAgICAgIHRoaXMuX2luc3RhbGxSZXNvbHV0aW9uTGlzdGVuZXIoKTtcbiAgICB9XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdW5pbnN0YWxsUmVzb2x1dGlvbkxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuX3dpbmRvdyA9IG51bGw7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JzZXJ2YWJsZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHsgbmV4dDogbmV4dCB9O1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9vYnNlcnZlcnMgPSBfdGhpcy5fb2JzZXJ2ZXJzLmZpbHRlcihmdW5jdGlvbiAobykgeyByZXR1cm4gbyAhPT0gb2JzZXJ2ZXI7IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl9pbnN0YWxsUmVzb2x1dGlvbkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVzb2x1dGlvbk1lZGlhUXVlcnlMaXN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdXRpb24gbGlzdGVuZXIgaXMgYWxyZWFkeSBpbnN0YWxsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHBweCA9IHRoaXMuX3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICB0aGlzLl9yZXNvbHV0aW9uTWVkaWFRdWVyeUxpc3QgPSB0aGlzLl93aW5kb3cubWF0Y2hNZWRpYShcImFsbCBhbmQgKHJlc29sdXRpb246IFwiLmNvbmNhdChkcHB4LCBcImRwcHgpXCIpKTtcbiAgICAgICAgLy8gSUUgYW5kIHNvbWUgdmVyc2lvbnMgb2YgRWRnZSBkbyBub3Qgc3VwcG9ydCBhZGRFdmVudExpc3RlbmVyL3JlbW92ZUV2ZW50TGlzdGVuZXIsIGFuZCB3ZSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBkZXByZWNhdGVkIGFkZExpc3RlbmVyL3JlbW92ZUxpc3RlbmVyXG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb25NZWRpYVF1ZXJ5TGlzdC5hZGRMaXN0ZW5lcih0aGlzLl9yZXNvbHV0aW9uTGlzdGVuZXIpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3VuaW5zdGFsbFJlc29sdXRpb25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdXRpb25NZWRpYVF1ZXJ5TGlzdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSUUgYW5kIHNvbWUgdmVyc2lvbnMgb2YgRWRnZSBkbyBub3Qgc3VwcG9ydCBhZGRFdmVudExpc3RlbmVyL3JlbW92ZUV2ZW50TGlzdGVuZXIsIGFuZCB3ZSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBkZXByZWNhdGVkIGFkZExpc3RlbmVyL3JlbW92ZUxpc3RlbmVyXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHV0aW9uTWVkaWFRdWVyeUxpc3QucmVtb3ZlTGlzdGVuZXIodGhpcy5fcmVzb2x1dGlvbkxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdXRpb25NZWRpYVF1ZXJ5TGlzdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl9yZWluc3RhbGxSZXNvbHV0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3VuaW5zdGFsbFJlc29sdXRpb25MaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLl9pbnN0YWxsUmVzb2x1dGlvbkxpc3RlbmVyKCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fb25SZXNvbHV0aW9uQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7IHJldHVybiBvYnNlcnZlci5uZXh0KF90aGlzLl93aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7IH0pO1xuICAgICAgICB0aGlzLl9yZWluc3RhbGxSZXNvbHV0aW9uTGlzdGVuZXIoKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZhYmxlO1xufSgpKTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlKHdpbikge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSh3aW4pO1xufVxuIl0sIm5hbWVzIjpbIk9ic2VydmFibGUiLCJ3aW4iLCJfdGhpcyIsIl9yZXNvbHV0aW9uTGlzdGVuZXIiLCJfb25SZXNvbHV0aW9uQ2hhbmdlZCIsIl9yZXNvbHV0aW9uTWVkaWFRdWVyeUxpc3QiLCJfb2JzZXJ2ZXJzIiwiX3dpbmRvdyIsIl9pbnN0YWxsUmVzb2x1dGlvbkxpc3RlbmVyIiwicHJvdG90eXBlIiwiZGlzcG9zZSIsIl91bmluc3RhbGxSZXNvbHV0aW9uTGlzdGVuZXIiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImRldmljZVBpeGVsUmF0aW8iLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwic3Vic2NyaWJlIiwibmV4dCIsIm9ic2VydmVyIiwicHVzaCIsInVuc3Vic2NyaWJlIiwiZmlsdGVyIiwibyIsIkVycm9yIiwiZHBweCIsIm1hdGNoTWVkaWEiLCJjb25jYXQiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiX3JlaW5zdGFsbFJlc29sdXRpb25MaXN0ZW5lciIsImZvckVhY2giLCJjcmVhdGVPYnNlcnZhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fancy-canvas/device-pixel-ratio.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fancy-canvas/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/fancy-canvas/index.mjs ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanvasRenderingTarget2D: function() { return /* reexport safe */ _canvas_rendering_target_mjs__WEBPACK_IMPORTED_MODULE_2__.CanvasRenderingTarget2D; },\n/* harmony export */   bindCanvasElementBitmapSizeTo: function() { return /* reexport safe */ _canvas_element_bitmap_size_mjs__WEBPACK_IMPORTED_MODULE_1__.bindTo; },\n/* harmony export */   createCanvasRenderingTarget2D: function() { return /* reexport safe */ _canvas_rendering_target_mjs__WEBPACK_IMPORTED_MODULE_2__.createCanvasRenderingTarget2D; },\n/* harmony export */   equalSizes: function() { return /* reexport safe */ _size_mjs__WEBPACK_IMPORTED_MODULE_0__.equalSizes; },\n/* harmony export */   size: function() { return /* reexport safe */ _size_mjs__WEBPACK_IMPORTED_MODULE_0__.size; },\n/* harmony export */   tryCreateCanvasRenderingTarget2D: function() { return /* reexport safe */ _canvas_rendering_target_mjs__WEBPACK_IMPORTED_MODULE_2__.tryCreateCanvasRenderingTarget2D; }\n/* harmony export */ });\n/* harmony import */ var _size_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./size.mjs */ \"(app-pages-browser)/./node_modules/fancy-canvas/size.mjs\");\n/* harmony import */ var _canvas_element_bitmap_size_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvas-element-bitmap-size.mjs */ \"(app-pages-browser)/./node_modules/fancy-canvas/canvas-element-bitmap-size.mjs\");\n/* harmony import */ var _canvas_rendering_target_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canvas-rendering-target.mjs */ \"(app-pages-browser)/./node_modules/fancy-canvas/canvas-rendering-target.mjs\");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYW5jeS1jYW52YXMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE4QztBQUM4QztBQUM4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFuY3ktY2FudmFzL2luZGV4Lm1qcz9hOTE2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IHNpemUsIGVxdWFsU2l6ZXMgfSBmcm9tIFwiLi9zaXplLm1qc1wiO1xuZXhwb3J0IHsgYmluZFRvIGFzIGJpbmRDYW52YXNFbGVtZW50Qml0bWFwU2l6ZVRvLCB9IGZyb20gXCIuL2NhbnZhcy1lbGVtZW50LWJpdG1hcC1zaXplLm1qc1wiO1xuZXhwb3J0IHsgQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQsIGNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJELCB0cnlDcmVhdGVDYW52YXNSZW5kZXJpbmdUYXJnZXQyRCwgfSBmcm9tIFwiLi9jYW52YXMtcmVuZGVyaW5nLXRhcmdldC5tanNcIjtcbiJdLCJuYW1lcyI6WyJzaXplIiwiZXF1YWxTaXplcyIsImJpbmRUbyIsImJpbmRDYW52YXNFbGVtZW50Qml0bWFwU2l6ZVRvIiwiQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQiLCJjcmVhdGVDYW52YXNSZW5kZXJpbmdUYXJnZXQyRCIsInRyeUNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fancy-canvas/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fancy-canvas/size.mjs":
/*!********************************************!*\
  !*** ./node_modules/fancy-canvas/size.mjs ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   equalSizes: function() { return /* binding */ equalSizes; },\n/* harmony export */   size: function() { return /* binding */ size; }\n/* harmony export */ });\nfunction size(_a) {\n    var width = _a.width, height = _a.height;\n    if (width < 0) {\n        throw new Error(\"Negative width is not allowed for Size\");\n    }\n    if (height < 0) {\n        throw new Error(\"Negative height is not allowed for Size\");\n    }\n    return {\n        width: width,\n        height: height\n    };\n}\nfunction equalSizes(first, second) {\n    return first.width === second.width && first.height === second.height;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYW5jeS1jYW52YXMvc2l6ZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSxLQUFLQyxFQUFFO0lBQ25CLElBQUlDLFFBQVFELEdBQUdDLEtBQUssRUFBRUMsU0FBU0YsR0FBR0UsTUFBTTtJQUN4QyxJQUFJRCxRQUFRLEdBQUc7UUFDWCxNQUFNLElBQUlFLE1BQU07SUFDcEI7SUFDQSxJQUFJRCxTQUFTLEdBQUc7UUFDWixNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQSxPQUFPO1FBQ0hGLE9BQU9BO1FBQ1BDLFFBQVFBO0lBQ1o7QUFDSjtBQUNPLFNBQVNFLFdBQVdDLEtBQUssRUFBRUMsTUFBTTtJQUNwQyxPQUFPLE1BQU9MLEtBQUssS0FBS0ssT0FBT0wsS0FBSyxJQUMvQkksTUFBTUgsTUFBTSxLQUFLSSxPQUFPSixNQUFNO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYW5jeS1jYW52YXMvc2l6ZS5tanM/NGViMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gc2l6ZShfYSkge1xuICAgIHZhciB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZ2F0aXZlIHdpZHRoIGlzIG5vdCBhbGxvd2VkIGZvciBTaXplJyk7XG4gICAgfVxuICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVnYXRpdmUgaGVpZ2h0IGlzIG5vdCBhbGxvd2VkIGZvciBTaXplJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbFNpemVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICByZXR1cm4gKGZpcnN0LndpZHRoID09PSBzZWNvbmQud2lkdGgpICYmXG4gICAgICAgIChmaXJzdC5oZWlnaHQgPT09IHNlY29uZC5oZWlnaHQpO1xufVxuIl0sIm5hbWVzIjpbInNpemUiLCJfYSIsIndpZHRoIiwiaGVpZ2h0IiwiRXJyb3IiLCJlcXVhbFNpemVzIiwiZmlyc3QiLCJzZWNvbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fancy-canvas/size.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColorType: function() { return /* binding */ ColorType; },\n/* harmony export */   CrosshairMode: function() { return /* binding */ CrosshairMode; },\n/* harmony export */   LastPriceAnimationMode: function() { return /* binding */ LastPriceAnimationMode; },\n/* harmony export */   LineStyle: function() { return /* binding */ LineStyle; },\n/* harmony export */   LineType: function() { return /* binding */ LineType; },\n/* harmony export */   MismatchDirection: function() { return /* binding */ MismatchDirection; },\n/* harmony export */   PriceLineSource: function() { return /* binding */ PriceLineSource; },\n/* harmony export */   PriceScaleMode: function() { return /* binding */ PriceScaleMode; },\n/* harmony export */   TickMarkType: function() { return /* binding */ TickMarkType; },\n/* harmony export */   TrackingModeExitMode: function() { return /* binding */ TrackingModeExitMode; },\n/* harmony export */   createChart: function() { return /* binding */ createChart; },\n/* harmony export */   createChartEx: function() { return /* binding */ createChartEx; },\n/* harmony export */   customSeriesDefaultOptions: function() { return /* binding */ customSeriesDefaultOptions; },\n/* harmony export */   isBusinessDay: function() { return /* binding */ isBusinessDay; },\n/* harmony export */   isUTCTimestamp: function() { return /* binding */ isUTCTimestamp; },\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\n/* harmony import */ var fancy_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fancy-canvas */ \"(app-pages-browser)/./node_modules/fancy-canvas/index.mjs\");\n/*!\n * @license\n * TradingView Lightweight Chartsâ¢ v4.1.2\n * Copyright (c) 2024 TradingView, Inc.\n * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0\n */ \nconst candlestickStyleDefaults = {\n    upColor: \"#26a69a\",\n    downColor: \"#ef5350\",\n    wickVisible: true,\n    borderVisible: true,\n    borderColor: \"#378658\",\n    borderUpColor: \"#26a69a\",\n    borderDownColor: \"#ef5350\",\n    wickColor: \"#737375\",\n    wickUpColor: \"#26a69a\",\n    wickDownColor: \"#ef5350\"\n};\nconst barStyleDefaults = {\n    upColor: \"#26a69a\",\n    downColor: \"#ef5350\",\n    openVisible: true,\n    thinBars: true\n};\nconst lineStyleDefaults = {\n    color: \"#2196f3\",\n    lineStyle: 0 /* LineStyle.Solid */ ,\n    lineWidth: 3,\n    lineType: 0 /* LineType.Simple */ ,\n    lineVisible: true,\n    crosshairMarkerVisible: true,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: \"\",\n    crosshairMarkerBorderWidth: 2,\n    crosshairMarkerBackgroundColor: \"\",\n    lastPriceAnimation: 0 /* LastPriceAnimationMode.Disabled */ ,\n    pointMarkersVisible: false\n};\nconst areaStyleDefaults = {\n    topColor: \"rgba( 46, 220, 135, 0.4)\",\n    bottomColor: \"rgba( 40, 221, 100, 0)\",\n    invertFilledArea: false,\n    lineColor: \"#33D778\",\n    lineStyle: 0 /* LineStyle.Solid */ ,\n    lineWidth: 3,\n    lineType: 0 /* LineType.Simple */ ,\n    lineVisible: true,\n    crosshairMarkerVisible: true,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: \"\",\n    crosshairMarkerBorderWidth: 2,\n    crosshairMarkerBackgroundColor: \"\",\n    lastPriceAnimation: 0 /* LastPriceAnimationMode.Disabled */ ,\n    pointMarkersVisible: false\n};\nconst baselineStyleDefaults = {\n    baseValue: {\n        type: \"price\",\n        price: 0\n    },\n    topFillColor1: \"rgba(38, 166, 154, 0.28)\",\n    topFillColor2: \"rgba(38, 166, 154, 0.05)\",\n    topLineColor: \"rgba(38, 166, 154, 1)\",\n    bottomFillColor1: \"rgba(239, 83, 80, 0.05)\",\n    bottomFillColor2: \"rgba(239, 83, 80, 0.28)\",\n    bottomLineColor: \"rgba(239, 83, 80, 1)\",\n    lineWidth: 3,\n    lineStyle: 0 /* LineStyle.Solid */ ,\n    lineType: 0 /* LineType.Simple */ ,\n    lineVisible: true,\n    crosshairMarkerVisible: true,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: \"\",\n    crosshairMarkerBorderWidth: 2,\n    crosshairMarkerBackgroundColor: \"\",\n    lastPriceAnimation: 0 /* LastPriceAnimationMode.Disabled */ ,\n    pointMarkersVisible: false\n};\nconst histogramStyleDefaults = {\n    color: \"#26a69a\",\n    base: 0\n};\nconst customStyleDefaults = {\n    color: \"#2196f3\"\n};\nconst seriesOptionsDefaults = {\n    title: \"\",\n    visible: true,\n    lastValueVisible: true,\n    priceLineVisible: true,\n    priceLineSource: 0 /* PriceLineSource.LastBar */ ,\n    priceLineWidth: 1,\n    priceLineColor: \"\",\n    priceLineStyle: 2 /* LineStyle.Dashed */ ,\n    baseLineVisible: true,\n    baseLineWidth: 1,\n    baseLineColor: \"#B2B5BE\",\n    baseLineStyle: 0 /* LineStyle.Solid */ ,\n    priceFormat: {\n        type: \"price\",\n        precision: 2,\n        minMove: 0.01\n    }\n};\n/**\n * Represents the possible line types.\n */ var LineType;\n(function(LineType) {\n    /**\n     * A line.\n     */ LineType[LineType[\"Simple\"] = 0] = \"Simple\";\n    /**\n     * A stepped line.\n     */ LineType[LineType[\"WithSteps\"] = 1] = \"WithSteps\";\n    /**\n     * A curved line.\n     */ LineType[LineType[\"Curved\"] = 2] = \"Curved\";\n})(LineType || (LineType = {}));\n/**\n * Represents the possible line styles.\n */ var LineStyle;\n(function(LineStyle) {\n    /**\n     * A solid line.\n     */ LineStyle[LineStyle[\"Solid\"] = 0] = \"Solid\";\n    /**\n     * A dotted line.\n     */ LineStyle[LineStyle[\"Dotted\"] = 1] = \"Dotted\";\n    /**\n     * A dashed line.\n     */ LineStyle[LineStyle[\"Dashed\"] = 2] = \"Dashed\";\n    /**\n     * A dashed line with bigger dashes.\n     */ LineStyle[LineStyle[\"LargeDashed\"] = 3] = \"LargeDashed\";\n    /**\n     * A dotted line with more space between dots.\n     */ LineStyle[LineStyle[\"SparseDotted\"] = 4] = \"SparseDotted\";\n})(LineStyle || (LineStyle = {}));\nfunction setLineStyle(ctx, style) {\n    const dashPatterns = {\n        [0 /* LineStyle.Solid */ ]: [],\n        [1 /* LineStyle.Dotted */ ]: [\n            ctx.lineWidth,\n            ctx.lineWidth\n        ],\n        [2 /* LineStyle.Dashed */ ]: [\n            2 * ctx.lineWidth,\n            2 * ctx.lineWidth\n        ],\n        [3 /* LineStyle.LargeDashed */ ]: [\n            6 * ctx.lineWidth,\n            6 * ctx.lineWidth\n        ],\n        [4 /* LineStyle.SparseDotted */ ]: [\n            ctx.lineWidth,\n            4 * ctx.lineWidth\n        ]\n    };\n    const dashPattern = dashPatterns[style];\n    ctx.setLineDash(dashPattern);\n}\nfunction drawHorizontalLine(ctx, y, left, right) {\n    ctx.beginPath();\n    const correction = ctx.lineWidth % 2 ? 0.5 : 0;\n    ctx.moveTo(left, y + correction);\n    ctx.lineTo(right, y + correction);\n    ctx.stroke();\n}\nfunction drawVerticalLine(ctx, x, top, bottom) {\n    ctx.beginPath();\n    const correction = ctx.lineWidth % 2 ? 0.5 : 0;\n    ctx.moveTo(x + correction, top);\n    ctx.lineTo(x + correction, bottom);\n    ctx.stroke();\n}\nfunction strokeInPixel(ctx, drawFunction) {\n    ctx.save();\n    if (ctx.lineWidth % 2) {\n        ctx.translate(0.5, 0.5);\n    }\n    drawFunction();\n    ctx.restore();\n}\n/**\n * Checks an assertion. Throws if the assertion is failed.\n *\n * @param condition - Result of the assertion evaluation\n * @param message - Text to include in the exception message\n */ function assert(condition, message) {\n    if (!condition) {\n        throw new Error(\"Assertion failed\" + (message ? \": \" + message : \"\"));\n    }\n}\nfunction ensureDefined(value) {\n    if (value === undefined) {\n        throw new Error(\"Value is undefined\");\n    }\n    return value;\n}\nfunction ensureNotNull(value) {\n    if (value === null) {\n        throw new Error(\"Value is null\");\n    }\n    return value;\n}\nfunction ensure(value) {\n    return ensureNotNull(ensureDefined(value));\n}\n/**\n * Compile time check for never\n */ function ensureNever(value) {}\n/**\n * Note this object should be explicitly marked as public so that dts-bundle-generator does not mangle the property names.\n *\n * @public\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value\n */ const namedColorRgbHexStrings = {\n    // The order of properties in this Record is not important for the internal logic.\n    // It's just GZIPped better when props follows this order.\n    // Please add new colors to the end of the record.\n    khaki: \"#f0e68c\",\n    azure: \"#f0ffff\",\n    aliceblue: \"#f0f8ff\",\n    ghostwhite: \"#f8f8ff\",\n    gold: \"#ffd700\",\n    goldenrod: \"#daa520\",\n    gainsboro: \"#dcdcdc\",\n    gray: \"#808080\",\n    green: \"#008000\",\n    honeydew: \"#f0fff0\",\n    floralwhite: \"#fffaf0\",\n    lightblue: \"#add8e6\",\n    lightcoral: \"#f08080\",\n    lemonchiffon: \"#fffacd\",\n    hotpink: \"#ff69b4\",\n    lightyellow: \"#ffffe0\",\n    greenyellow: \"#adff2f\",\n    lightgoldenrodyellow: \"#fafad2\",\n    limegreen: \"#32cd32\",\n    linen: \"#faf0e6\",\n    lightcyan: \"#e0ffff\",\n    magenta: \"#f0f\",\n    maroon: \"#800000\",\n    olive: \"#808000\",\n    orange: \"#ffa500\",\n    oldlace: \"#fdf5e6\",\n    mediumblue: \"#0000cd\",\n    transparent: \"#0000\",\n    lime: \"#0f0\",\n    lightpink: \"#ffb6c1\",\n    mistyrose: \"#ffe4e1\",\n    moccasin: \"#ffe4b5\",\n    midnightblue: \"#191970\",\n    orchid: \"#da70d6\",\n    mediumorchid: \"#ba55d3\",\n    mediumturquoise: \"#48d1cc\",\n    orangered: \"#ff4500\",\n    royalblue: \"#4169e1\",\n    powderblue: \"#b0e0e6\",\n    red: \"#f00\",\n    coral: \"#ff7f50\",\n    turquoise: \"#40e0d0\",\n    white: \"#fff\",\n    whitesmoke: \"#f5f5f5\",\n    wheat: \"#f5deb3\",\n    teal: \"#008080\",\n    steelblue: \"#4682b4\",\n    bisque: \"#ffe4c4\",\n    aquamarine: \"#7fffd4\",\n    aqua: \"#0ff\",\n    sienna: \"#a0522d\",\n    silver: \"#c0c0c0\",\n    springgreen: \"#00ff7f\",\n    antiquewhite: \"#faebd7\",\n    burlywood: \"#deb887\",\n    brown: \"#a52a2a\",\n    beige: \"#f5f5dc\",\n    chocolate: \"#d2691e\",\n    chartreuse: \"#7fff00\",\n    cornflowerblue: \"#6495ed\",\n    cornsilk: \"#fff8dc\",\n    crimson: \"#dc143c\",\n    cadetblue: \"#5f9ea0\",\n    tomato: \"#ff6347\",\n    fuchsia: \"#f0f\",\n    blue: \"#00f\",\n    salmon: \"#fa8072\",\n    blanchedalmond: \"#ffebcd\",\n    slateblue: \"#6a5acd\",\n    slategray: \"#708090\",\n    thistle: \"#d8bfd8\",\n    tan: \"#d2b48c\",\n    cyan: \"#0ff\",\n    darkblue: \"#00008b\",\n    darkcyan: \"#008b8b\",\n    darkgoldenrod: \"#b8860b\",\n    darkgray: \"#a9a9a9\",\n    blueviolet: \"#8a2be2\",\n    black: \"#000\",\n    darkmagenta: \"#8b008b\",\n    darkslateblue: \"#483d8b\",\n    darkkhaki: \"#bdb76b\",\n    darkorchid: \"#9932cc\",\n    darkorange: \"#ff8c00\",\n    darkgreen: \"#006400\",\n    darkred: \"#8b0000\",\n    dodgerblue: \"#1e90ff\",\n    darkslategray: \"#2f4f4f\",\n    dimgray: \"#696969\",\n    deepskyblue: \"#00bfff\",\n    firebrick: \"#b22222\",\n    forestgreen: \"#228b22\",\n    indigo: \"#4b0082\",\n    ivory: \"#fffff0\",\n    lavenderblush: \"#fff0f5\",\n    feldspar: \"#d19275\",\n    indianred: \"#cd5c5c\",\n    lightgreen: \"#90ee90\",\n    lightgrey: \"#d3d3d3\",\n    lightskyblue: \"#87cefa\",\n    lightslategray: \"#789\",\n    lightslateblue: \"#8470ff\",\n    snow: \"#fffafa\",\n    lightseagreen: \"#20b2aa\",\n    lightsalmon: \"#ffa07a\",\n    darksalmon: \"#e9967a\",\n    darkviolet: \"#9400d3\",\n    mediumpurple: \"#9370d8\",\n    mediumaquamarine: \"#66cdaa\",\n    skyblue: \"#87ceeb\",\n    lavender: \"#e6e6fa\",\n    lightsteelblue: \"#b0c4de\",\n    mediumvioletred: \"#c71585\",\n    mintcream: \"#f5fffa\",\n    navajowhite: \"#ffdead\",\n    navy: \"#000080\",\n    olivedrab: \"#6b8e23\",\n    palevioletred: \"#d87093\",\n    violetred: \"#d02090\",\n    yellow: \"#ff0\",\n    yellowgreen: \"#9acd32\",\n    lawngreen: \"#7cfc00\",\n    pink: \"#ffc0cb\",\n    paleturquoise: \"#afeeee\",\n    palegoldenrod: \"#eee8aa\",\n    darkolivegreen: \"#556b2f\",\n    darkseagreen: \"#8fbc8f\",\n    darkturquoise: \"#00ced1\",\n    peachpuff: \"#ffdab9\",\n    deeppink: \"#ff1493\",\n    violet: \"#ee82ee\",\n    palegreen: \"#98fb98\",\n    mediumseagreen: \"#3cb371\",\n    peru: \"#cd853f\",\n    saddlebrown: \"#8b4513\",\n    sandybrown: \"#f4a460\",\n    rosybrown: \"#bc8f8f\",\n    purple: \"#800080\",\n    seagreen: \"#2e8b57\",\n    seashell: \"#fff5ee\",\n    papayawhip: \"#ffefd5\",\n    mediumslateblue: \"#7b68ee\",\n    plum: \"#dda0dd\",\n    mediumspringgreen: \"#00fa9a\"\n};\nfunction normalizeRgbComponent(component) {\n    if (component < 0) {\n        return 0;\n    }\n    if (component > 255) {\n        return 255;\n    }\n    // NaN values are treated as 0\n    return Math.round(component) || 0;\n}\nfunction normalizeAlphaComponent(component) {\n    return !(component <= 0) && !(component > 0) ? 0 : component < 0 ? 0 : component > 1 ? 1 : // limit the precision of all numbers to at most 4 digits in fractional part\n    Math.round(component * 10000) / 10000;\n}\n/**\n * @example\n * #fb0\n * @example\n * #f0f\n * @example\n * #f0fa\n */ const shortHexRe = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i;\n/**\n * @example\n * #00ff00\n * @example\n * #336699\n * @example\n * #336699FA\n */ const hexRe = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;\n/**\n * @example\n * rgb(123, 234, 45)\n * @example\n * rgb(255,234,245)\n */ const rgbRe = /^rgb\\(\\s*(-?\\d{1,10})\\s*,\\s*(-?\\d{1,10})\\s*,\\s*(-?\\d{1,10})\\s*\\)$/;\n/**\n * @example\n * rgba(123, 234, 45, 1)\n * @example\n * rgba(255,234,245,0.1)\n */ const rgbaRe = /^rgba\\(\\s*(-?\\d{1,10})\\s*,\\s*(-?\\d{1,10})\\s*,\\s*(-?\\d{1,10})\\s*,\\s*(-?[\\d]{0,10}(?:\\.\\d+)?)\\s*\\)$/;\nfunction colorStringToRgba(colorString) {\n    colorString = colorString.toLowerCase();\n    // eslint-disable-next-line no-restricted-syntax\n    if (colorString in namedColorRgbHexStrings) {\n        colorString = namedColorRgbHexStrings[colorString];\n    }\n    {\n        const matches = rgbaRe.exec(colorString) || rgbRe.exec(colorString);\n        if (matches) {\n            return [\n                normalizeRgbComponent(parseInt(matches[1], 10)),\n                normalizeRgbComponent(parseInt(matches[2], 10)),\n                normalizeRgbComponent(parseInt(matches[3], 10)),\n                normalizeAlphaComponent(matches.length < 5 ? 1 : parseFloat(matches[4]))\n            ];\n        }\n    }\n    {\n        const matches = hexRe.exec(colorString);\n        if (matches) {\n            return [\n                normalizeRgbComponent(parseInt(matches[1], 16)),\n                normalizeRgbComponent(parseInt(matches[2], 16)),\n                normalizeRgbComponent(parseInt(matches[3], 16)),\n                1\n            ];\n        }\n    }\n    {\n        const matches = shortHexRe.exec(colorString);\n        if (matches) {\n            return [\n                normalizeRgbComponent(parseInt(matches[1], 16) * 0x11),\n                normalizeRgbComponent(parseInt(matches[2], 16) * 0x11),\n                normalizeRgbComponent(parseInt(matches[3], 16) * 0x11),\n                1\n            ];\n        }\n    }\n    throw new Error(\"Cannot parse color: \".concat(colorString));\n}\nfunction rgbaToGrayscale(rgbValue) {\n    // Originally, the NTSC RGB to YUV formula\n    // perfected by @eugene-korobko's black magic\n    const redComponentGrayscaleWeight = 0.199;\n    const greenComponentGrayscaleWeight = 0.687;\n    const blueComponentGrayscaleWeight = 0.114;\n    return redComponentGrayscaleWeight * rgbValue[0] + greenComponentGrayscaleWeight * rgbValue[1] + blueComponentGrayscaleWeight * rgbValue[2];\n}\nfunction applyAlpha(color, alpha) {\n    // special case optimization\n    if (color === \"transparent\") {\n        return color;\n    }\n    const originRgba = colorStringToRgba(color);\n    const originAlpha = originRgba[3];\n    return \"rgba(\".concat(originRgba[0], \", \").concat(originRgba[1], \", \").concat(originRgba[2], \", \").concat(alpha * originAlpha, \")\");\n}\nfunction generateContrastColors(backgroundColor) {\n    const rgb = colorStringToRgba(backgroundColor);\n    return {\n        _internal_background: \"rgb(\".concat(rgb[0], \", \").concat(rgb[1], \", \").concat(rgb[2], \")\"),\n        _internal_foreground: rgbaToGrayscale(rgb) > 160 ? \"black\" : \"white\"\n    };\n}\nfunction gradientColorAtPercent(topColor, bottomColor, percent) {\n    const [topR, topG, topB, topA] = colorStringToRgba(topColor);\n    const [bottomR, bottomG, bottomB, bottomA] = colorStringToRgba(bottomColor);\n    const resultRgba = [\n        normalizeRgbComponent(topR + percent * (bottomR - topR)),\n        normalizeRgbComponent(topG + percent * (bottomG - topG)),\n        normalizeRgbComponent(topB + percent * (bottomB - topB)),\n        normalizeAlphaComponent(topA + percent * (bottomA - topA))\n    ];\n    return \"rgba(\".concat(resultRgba[0], \", \").concat(resultRgba[1], \", \").concat(resultRgba[2], \", \").concat(resultRgba[3], \")\");\n}\nclass Delegate {\n    _internal_subscribe(callback, linkedObject, singleshot) {\n        const listener = {\n            _internal_callback: callback,\n            _internal_linkedObject: linkedObject,\n            _internal_singleshot: singleshot === true\n        };\n        this._private__listeners.push(listener);\n    }\n    _internal_unsubscribe(callback) {\n        const index = this._private__listeners.findIndex((listener)=>callback === listener._internal_callback);\n        if (index > -1) {\n            this._private__listeners.splice(index, 1);\n        }\n    }\n    _internal_unsubscribeAll(linkedObject) {\n        this._private__listeners = this._private__listeners.filter((listener)=>listener._internal_linkedObject !== linkedObject);\n    }\n    _internal_fire(param1, param2, param3) {\n        const listenersSnapshot = [\n            ...this._private__listeners\n        ];\n        this._private__listeners = this._private__listeners.filter((listener)=>!listener._internal_singleshot);\n        listenersSnapshot.forEach((listener)=>listener._internal_callback(param1, param2, param3));\n    }\n    _internal_hasListeners() {\n        return this._private__listeners.length > 0;\n    }\n    _internal_destroy() {\n        this._private__listeners = [];\n    }\n    constructor(){\n        this._private__listeners = [];\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction merge(dst) {\n    for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        sources[_key - 1] = arguments[_key];\n    }\n    for (const src of sources){\n        // eslint-disable-next-line no-restricted-syntax\n        for(const i in src){\n            if (src[i] === undefined) {\n                continue;\n            }\n            if (\"object\" !== typeof src[i] || dst[i] === undefined || Array.isArray(src[i])) {\n                dst[i] = src[i];\n            } else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                merge(dst[i], src[i]);\n            }\n        }\n    }\n    return dst;\n}\nfunction isNumber(value) {\n    return typeof value === \"number\" && isFinite(value);\n}\nfunction isInteger(value) {\n    return typeof value === \"number\" && value % 1 === 0;\n}\nfunction isString(value) {\n    return typeof value === \"string\";\n}\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\nfunction clone(object) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const o = object;\n    if (!o || \"object\" !== typeof o) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return o;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let c;\n    if (Array.isArray(o)) {\n        c = [];\n    } else {\n        c = {};\n    }\n    let p;\n    let v;\n    // eslint-disable-next-line no-restricted-syntax\n    for(p in o){\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,no-prototype-builtins\n        if (o.hasOwnProperty(p)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            v = o[p];\n            if (v && \"object\" === typeof v) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                c[p] = clone(v);\n            } else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                c[p] = v;\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return c;\n}\nfunction notNull(t) {\n    return t !== null;\n}\nfunction undefinedIfNull(t) {\n    return t === null ? undefined : t;\n}\n/**\n * Default font family.\n * Must be used to generate font string when font is not specified.\n */ const defaultFontFamily = \"-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif\";\n/**\n * Generates a font string, which can be used to set in canvas' font property.\n * If no family provided, {@link defaultFontFamily} will be used.\n *\n * @param size - Font size in pixels.\n * @param family - Optional font family.\n * @param style - Optional font style.\n * @returns The font string.\n */ function makeFont(size, family, style) {\n    if (style !== undefined) {\n        style = \"\".concat(style, \" \");\n    } else {\n        style = \"\";\n    }\n    if (family === undefined) {\n        family = defaultFontFamily;\n    }\n    return \"\".concat(style).concat(size, \"px \").concat(family);\n}\nclass PriceAxisRendererOptionsProvider {\n    _internal_options() {\n        const rendererOptions = this._private__rendererOptions;\n        const currentFontSize = this._private__fontSize();\n        const currentFontFamily = this._private__fontFamily();\n        if (rendererOptions._internal_fontSize !== currentFontSize || rendererOptions._internal_fontFamily !== currentFontFamily) {\n            rendererOptions._internal_fontSize = currentFontSize;\n            rendererOptions._internal_fontFamily = currentFontFamily;\n            rendererOptions._internal_font = makeFont(currentFontSize, currentFontFamily);\n            rendererOptions._internal_paddingTop = 2.5 / 12 * currentFontSize; // 2.5 px for 12px font\n            rendererOptions._internal_paddingBottom = rendererOptions._internal_paddingTop;\n            rendererOptions._internal_paddingInner = currentFontSize / 12 * rendererOptions._internal_tickLength;\n            rendererOptions._internal_paddingOuter = currentFontSize / 12 * rendererOptions._internal_tickLength;\n            rendererOptions._internal_baselineOffset = 0;\n        }\n        rendererOptions._internal_color = this._private__textColor();\n        rendererOptions._internal_paneBackgroundColor = this._private__paneBackgroundColor();\n        return this._private__rendererOptions;\n    }\n    _private__textColor() {\n        return this._private__chartModel._internal_options().layout.textColor;\n    }\n    _private__paneBackgroundColor() {\n        return this._private__chartModel._internal_backgroundTopColor();\n    }\n    _private__fontSize() {\n        return this._private__chartModel._internal_options().layout.fontSize;\n    }\n    _private__fontFamily() {\n        return this._private__chartModel._internal_options().layout.fontFamily;\n    }\n    constructor(chartModel){\n        this._private__rendererOptions = {\n            _internal_borderSize: 1 /* RendererConstants.BorderSize */ ,\n            _internal_tickLength: 5 /* RendererConstants.TickLength */ ,\n            _internal_fontSize: NaN,\n            _internal_font: \"\",\n            _internal_fontFamily: \"\",\n            _internal_color: \"\",\n            _internal_paneBackgroundColor: \"\",\n            _internal_paddingBottom: 0,\n            _internal_paddingInner: 0,\n            _internal_paddingOuter: 0,\n            _internal_paddingTop: 0,\n            _internal_baselineOffset: 0\n        };\n        this._private__chartModel = chartModel;\n    }\n}\nclass CompositeRenderer {\n    _internal_setRenderers(renderers) {\n        this._private__renderers = renderers;\n    }\n    _internal_draw(target, isHovered, hitTestData) {\n        this._private__renderers.forEach((r)=>{\n            r._internal_draw(target, isHovered, hitTestData);\n        });\n    }\n    constructor(){\n        this._private__renderers = [];\n    }\n}\nclass MediaCoordinatesPaneRenderer {\n    _internal_draw(target, isHovered, hitTestData) {\n        target.useMediaCoordinateSpace((scope)=>this._internal__drawImpl(scope, isHovered, hitTestData));\n    }\n    _internal_drawBackground(target, isHovered, hitTestData) {\n        target.useMediaCoordinateSpace((scope)=>this._internal__drawBackgroundImpl(scope, isHovered, hitTestData));\n    }\n    _internal__drawBackgroundImpl(renderingScope, isHovered, hitTestData) {}\n}\nclass PaneRendererMarks extends MediaCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._internal__data = data;\n    }\n    _internal__drawImpl(param) {\n        let { context: ctx } = param;\n        if (this._internal__data === null || this._internal__data._internal_visibleRange === null) {\n            return;\n        }\n        const visibleRange = this._internal__data._internal_visibleRange;\n        const data = this._internal__data;\n        const draw = (radius)=>{\n            ctx.beginPath();\n            for(let i = visibleRange.to - 1; i >= visibleRange.from; --i){\n                const point = data._internal_items[i];\n                ctx.moveTo(point._internal_x, point._internal_y);\n                ctx.arc(point._internal_x, point._internal_y, radius, 0, Math.PI * 2);\n            }\n            ctx.fill();\n        };\n        if (data._internal_lineWidth > 0) {\n            ctx.fillStyle = data._internal_backColor;\n            draw(data._internal_radius + data._internal_lineWidth);\n        }\n        ctx.fillStyle = data._internal_lineColor;\n        draw(data._internal_radius);\n    }\n    constructor(){\n        super(...arguments);\n        this._internal__data = null;\n    }\n}\nfunction createEmptyMarkerData() {\n    return {\n        _internal_items: [\n            {\n                _internal_x: 0,\n                _internal_y: 0,\n                _internal_time: 0,\n                _internal_price: 0\n            }\n        ],\n        _internal_lineColor: \"\",\n        _internal_backColor: \"\",\n        _internal_radius: 0,\n        _internal_lineWidth: 0,\n        _internal_visibleRange: null\n    };\n}\nconst rangeForSinglePoint = {\n    from: 0,\n    to: 1\n};\nclass CrosshairMarksPaneView {\n    _internal_update(updateType) {\n        const serieses = this._private__chartModel._internal_serieses();\n        if (serieses.length !== this._private__markersRenderers.length) {\n            this._private__markersData = serieses.map(createEmptyMarkerData);\n            this._private__markersRenderers = this._private__markersData.map((data)=>{\n                const res = new PaneRendererMarks();\n                res._internal_setData(data);\n                return res;\n            });\n            this._private__compositeRenderer._internal_setRenderers(this._private__markersRenderers);\n        }\n        this._private__invalidated = true;\n    }\n    _internal_renderer() {\n        if (this._private__invalidated) {\n            this._private__updateImpl();\n            this._private__invalidated = false;\n        }\n        return this._private__compositeRenderer;\n    }\n    _private__updateImpl() {\n        const forceHidden = this._private__crosshair._internal_options().mode === 2 /* CrosshairMode.Hidden */ ;\n        const serieses = this._private__chartModel._internal_serieses();\n        const timePointIndex = this._private__crosshair._internal_appliedIndex();\n        const timeScale = this._private__chartModel._internal_timeScale();\n        serieses.forEach((s, index)=>{\n            var _a;\n            const data = this._private__markersData[index];\n            const seriesData = s._internal_markerDataAtIndex(timePointIndex);\n            if (forceHidden || seriesData === null || !s._internal_visible()) {\n                data._internal_visibleRange = null;\n                return;\n            }\n            const firstValue = ensureNotNull(s._internal_firstValue());\n            data._internal_lineColor = seriesData._internal_backgroundColor;\n            data._internal_radius = seriesData._internal_radius;\n            data._internal_lineWidth = seriesData._internal_borderWidth;\n            data._internal_items[0]._internal_price = seriesData._internal_price;\n            data._internal_items[0]._internal_y = s._internal_priceScale()._internal_priceToCoordinate(seriesData._internal_price, firstValue._internal_value);\n            data._internal_backColor = (_a = seriesData._internal_borderColor) !== null && _a !== void 0 ? _a : this._private__chartModel._internal_backgroundColorAtYPercentFromTop(data._internal_items[0]._internal_y / s._internal_priceScale()._internal_height());\n            data._internal_items[0]._internal_time = timePointIndex;\n            data._internal_items[0]._internal_x = timeScale._internal_indexToCoordinate(timePointIndex);\n            data._internal_visibleRange = rangeForSinglePoint;\n        });\n    }\n    constructor(chartModel, crosshair){\n        this._private__compositeRenderer = new CompositeRenderer();\n        this._private__markersRenderers = [];\n        this._private__markersData = [];\n        this._private__invalidated = true;\n        this._private__chartModel = chartModel;\n        this._private__crosshair = crosshair;\n        this._private__compositeRenderer._internal_setRenderers(this._private__markersRenderers);\n    }\n}\nclass BitmapCoordinatesPaneRenderer {\n    _internal_draw(target, isHovered, hitTestData) {\n        target.useBitmapCoordinateSpace((scope)=>this._internal__drawImpl(scope, isHovered, hitTestData));\n    }\n}\nclass CrosshairRenderer extends BitmapCoordinatesPaneRenderer {\n    _internal__drawImpl(param) {\n        let { context: ctx, bitmapSize, horizontalPixelRatio, verticalPixelRatio } = param;\n        if (this._private__data === null) {\n            return;\n        }\n        const vertLinesVisible = this._private__data._internal_vertLine._internal_visible;\n        const horzLinesVisible = this._private__data._internal_horzLine._internal_visible;\n        if (!vertLinesVisible && !horzLinesVisible) {\n            return;\n        }\n        const x = Math.round(this._private__data._internal_x * horizontalPixelRatio);\n        const y = Math.round(this._private__data._internal_y * verticalPixelRatio);\n        ctx.lineCap = \"butt\";\n        if (vertLinesVisible && x >= 0) {\n            ctx.lineWidth = Math.floor(this._private__data._internal_vertLine._internal_lineWidth * horizontalPixelRatio);\n            ctx.strokeStyle = this._private__data._internal_vertLine._internal_color;\n            ctx.fillStyle = this._private__data._internal_vertLine._internal_color;\n            setLineStyle(ctx, this._private__data._internal_vertLine._internal_lineStyle);\n            drawVerticalLine(ctx, x, 0, bitmapSize.height);\n        }\n        if (horzLinesVisible && y >= 0) {\n            ctx.lineWidth = Math.floor(this._private__data._internal_horzLine._internal_lineWidth * verticalPixelRatio);\n            ctx.strokeStyle = this._private__data._internal_horzLine._internal_color;\n            ctx.fillStyle = this._private__data._internal_horzLine._internal_color;\n            setLineStyle(ctx, this._private__data._internal_horzLine._internal_lineStyle);\n            drawHorizontalLine(ctx, y, 0, bitmapSize.width);\n        }\n    }\n    constructor(data){\n        super();\n        this._private__data = data;\n    }\n}\nclass CrosshairPaneView {\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_renderer() {\n        if (this._private__invalidated) {\n            this._private__updateImpl();\n            this._private__invalidated = false;\n        }\n        return this._private__renderer;\n    }\n    _private__updateImpl() {\n        const visible = this._private__source._internal_visible();\n        const pane = ensureNotNull(this._private__source._internal_pane());\n        const crosshairOptions = pane._internal_model()._internal_options().crosshair;\n        const data = this._private__rendererData;\n        if (crosshairOptions.mode === 2 /* CrosshairMode.Hidden */ ) {\n            data._internal_horzLine._internal_visible = false;\n            data._internal_vertLine._internal_visible = false;\n            return;\n        }\n        data._internal_horzLine._internal_visible = visible && this._private__source._internal_horzLineVisible(pane);\n        data._internal_vertLine._internal_visible = visible && this._private__source._internal_vertLineVisible();\n        data._internal_horzLine._internal_lineWidth = crosshairOptions.horzLine.width;\n        data._internal_horzLine._internal_lineStyle = crosshairOptions.horzLine.style;\n        data._internal_horzLine._internal_color = crosshairOptions.horzLine.color;\n        data._internal_vertLine._internal_lineWidth = crosshairOptions.vertLine.width;\n        data._internal_vertLine._internal_lineStyle = crosshairOptions.vertLine.style;\n        data._internal_vertLine._internal_color = crosshairOptions.vertLine.color;\n        data._internal_x = this._private__source._internal_appliedX();\n        data._internal_y = this._private__source._internal_appliedY();\n    }\n    constructor(source){\n        this._private__invalidated = true;\n        this._private__rendererData = {\n            _internal_vertLine: {\n                _internal_lineWidth: 1,\n                _internal_lineStyle: 0,\n                _internal_color: \"\",\n                _internal_visible: false\n            },\n            _internal_horzLine: {\n                _internal_lineWidth: 1,\n                _internal_lineStyle: 0,\n                _internal_color: \"\",\n                _internal_visible: false\n            },\n            _internal_x: 0,\n            _internal_y: 0\n        };\n        this._private__renderer = new CrosshairRenderer(this._private__rendererData);\n        this._private__source = source;\n    }\n}\n/**\n * Fills rectangle's inner border (so, all the filled area is limited by the [x, x + width]*[y, y + height] region)\n * ```\n * (x, y)\n * O***********************|*****\n * |        border         |  ^\n * |   *****************   |  |\n * |   |               |   |  |\n * | b |               | b |  h\n * | o |               | o |  e\n * | r |               | r |  i\n * | d |               | d |  g\n * | e |               | e |  h\n * | r |               | r |  t\n * |   |               |   |  |\n * |   *****************   |  |\n * |        border         |  v\n * |***********************|*****\n * |                       |\n * |<------- width ------->|\n * ```\n *\n * @param ctx - Context to draw on\n * @param x - Left side of the target rectangle\n * @param y - Top side of the target rectangle\n * @param width - Width of the target rectangle\n * @param height - Height of the target rectangle\n * @param borderWidth - Width of border to fill, must be less than width and height of the target rectangle\n */ function fillRectInnerBorder(ctx, x, y, width, height, borderWidth) {\n    // horizontal (top and bottom) edges\n    ctx.fillRect(x + borderWidth, y, width - borderWidth * 2, borderWidth);\n    ctx.fillRect(x + borderWidth, y + height - borderWidth, width - borderWidth * 2, borderWidth);\n    // vertical (left and right) edges\n    ctx.fillRect(x, y, borderWidth, height);\n    ctx.fillRect(x + width - borderWidth, y, borderWidth, height);\n}\nfunction clearRect(ctx, x, y, w, h, clearColor) {\n    ctx.save();\n    ctx.globalCompositeOperation = \"copy\";\n    ctx.fillStyle = clearColor;\n    ctx.fillRect(x, y, w, h);\n    ctx.restore();\n}\nfunction changeBorderRadius(borderRadius, offset) {\n    return borderRadius.map((x)=>x === 0 ? x : x + offset);\n}\nfunction drawRoundRect(// eslint:disable-next-line:max-params\nctx, x, y, w, h, radii) {\n    /**\n     * As of May 2023, all of the major browsers now support ctx.roundRect() so we should\n     * be able to switch to the native version soon.\n     */ ctx.beginPath();\n    ctx.lineTo(x + w - radii[1], y);\n    if (radii[1] !== 0) {\n        ctx.arcTo(x + w, y, x + w, y + radii[1], radii[1]);\n    }\n    ctx.lineTo(x + w, y + h - radii[2]);\n    if (radii[2] !== 0) {\n        ctx.arcTo(x + w, y + h, x + w - radii[2], y + h, radii[2]);\n    }\n    ctx.lineTo(x + radii[3], y + h);\n    if (radii[3] !== 0) {\n        ctx.arcTo(x, y + h, x, y + h - radii[3], radii[3]);\n    }\n    ctx.lineTo(x, y + radii[0]);\n    if (radii[0] !== 0) {\n        ctx.arcTo(x, y, x + radii[0], y, radii[0]);\n    }\n}\n// eslint-disable-next-line max-params\nfunction drawRoundRectWithInnerBorder(ctx, left, top, width, height, backgroundColor) {\n    let borderWidth = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0, borderRadius = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : [\n        0,\n        0,\n        0,\n        0\n    ], borderColor = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : \"\";\n    ctx.save();\n    if (!borderWidth || !borderColor || borderColor === backgroundColor) {\n        drawRoundRect(ctx, left, top, width, height, borderRadius);\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n        return;\n    }\n    const halfBorderWidth = borderWidth / 2;\n    // Draw body\n    if (backgroundColor !== \"transparent\") {\n        const innerRadii = changeBorderRadius(borderRadius, -borderWidth);\n        drawRoundRect(ctx, left + borderWidth, top + borderWidth, width - borderWidth * 2, height - borderWidth * 2, innerRadii);\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n    }\n    // Draw border\n    if (borderColor !== \"transparent\") {\n        const outerRadii = changeBorderRadius(borderRadius, -halfBorderWidth);\n        drawRoundRect(ctx, left + halfBorderWidth, top + halfBorderWidth, width - borderWidth, height - borderWidth, outerRadii);\n        ctx.lineWidth = borderWidth;\n        ctx.strokeStyle = borderColor;\n        ctx.closePath();\n        ctx.stroke();\n    }\n    ctx.restore();\n}\n// eslint-disable-next-line max-params\nfunction clearRectWithGradient(ctx, x, y, w, h, topColor, bottomColor) {\n    ctx.save();\n    ctx.globalCompositeOperation = \"copy\";\n    const gradient = ctx.createLinearGradient(0, 0, 0, h);\n    gradient.addColorStop(0, topColor);\n    gradient.addColorStop(1, bottomColor);\n    ctx.fillStyle = gradient;\n    ctx.fillRect(x, y, w, h);\n    ctx.restore();\n}\nclass PriceAxisViewRenderer {\n    _internal_setData(data, commonData) {\n        this._private__data = data;\n        this._private__commonData = commonData;\n    }\n    _internal_height(rendererOptions, useSecondLine) {\n        if (!this._private__data._internal_visible) {\n            return 0;\n        }\n        return rendererOptions._internal_fontSize + rendererOptions._internal_paddingTop + rendererOptions._internal_paddingBottom;\n    }\n    _internal_draw(target, rendererOptions, textWidthCache, align) {\n        if (!this._private__data._internal_visible || this._private__data._internal_text.length === 0) {\n            return;\n        }\n        const textColor = this._private__data._internal_color;\n        const backgroundColor = this._private__commonData._internal_background;\n        const geometry = target.useBitmapCoordinateSpace((scope)=>{\n            const ctx = scope.context;\n            ctx.font = rendererOptions._internal_font;\n            const geom = this._private__calculateGeometry(scope, rendererOptions, textWidthCache, align);\n            const gb = geom._internal_bitmap;\n            const drawLabelBody = (labelBackgroundColor, labelBorderColor)=>{\n                if (geom._internal_alignRight) {\n                    drawRoundRectWithInnerBorder(ctx, gb._internal_xOutside, gb._internal_yTop, gb._internal_totalWidth, gb._internal_totalHeight, labelBackgroundColor, gb._internal_horzBorder, [\n                        gb._internal_radius,\n                        0,\n                        0,\n                        gb._internal_radius\n                    ], labelBorderColor);\n                } else {\n                    drawRoundRectWithInnerBorder(ctx, gb._internal_xInside, gb._internal_yTop, gb._internal_totalWidth, gb._internal_totalHeight, labelBackgroundColor, gb._internal_horzBorder, [\n                        0,\n                        gb._internal_radius,\n                        gb._internal_radius,\n                        0\n                    ], labelBorderColor);\n                }\n            };\n            // draw border\n            // draw label background\n            drawLabelBody(backgroundColor, \"transparent\");\n            // draw tick\n            if (this._private__data._internal_tickVisible) {\n                ctx.fillStyle = textColor;\n                ctx.fillRect(gb._internal_xInside, gb._internal_yMid, gb._internal_xTick - gb._internal_xInside, gb._internal_tickHeight);\n            }\n            // draw label border above the tick\n            drawLabelBody(\"transparent\", backgroundColor);\n            // draw separator\n            if (this._private__data._internal_borderVisible) {\n                ctx.fillStyle = rendererOptions._internal_paneBackgroundColor;\n                ctx.fillRect(geom._internal_alignRight ? gb._internal_right - gb._internal_horzBorder : 0, gb._internal_yTop, gb._internal_horzBorder, gb._internal_yBottom - gb._internal_yTop);\n            }\n            return geom;\n        });\n        target.useMediaCoordinateSpace((param)=>{\n            let { context: ctx } = param;\n            const gm = geometry._internal_media;\n            ctx.font = rendererOptions._internal_font;\n            ctx.textAlign = geometry._internal_alignRight ? \"right\" : \"left\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillStyle = textColor;\n            ctx.fillText(this._private__data._internal_text, gm._internal_xText, (gm._internal_yTop + gm._internal_yBottom) / 2 + gm._internal_textMidCorrection);\n        });\n    }\n    _private__calculateGeometry(scope, rendererOptions, textWidthCache, align) {\n        var _a;\n        const { context: ctx, bitmapSize, mediaSize, horizontalPixelRatio, verticalPixelRatio } = scope;\n        const tickSize = this._private__data._internal_tickVisible || !this._private__data._internal_moveTextToInvisibleTick ? rendererOptions._internal_tickLength : 0;\n        const horzBorder = this._private__data._internal_separatorVisible ? rendererOptions._internal_borderSize : 0;\n        const paddingTop = rendererOptions._internal_paddingTop + this._private__commonData._internal_additionalPaddingTop;\n        const paddingBottom = rendererOptions._internal_paddingBottom + this._private__commonData._internal_additionalPaddingBottom;\n        const paddingInner = rendererOptions._internal_paddingInner;\n        const paddingOuter = rendererOptions._internal_paddingOuter;\n        const text = this._private__data._internal_text;\n        const actualTextHeight = rendererOptions._internal_fontSize;\n        const textMidCorrection = textWidthCache._internal_yMidCorrection(ctx, text);\n        const textWidth = Math.ceil(textWidthCache._internal_measureText(ctx, text));\n        const totalHeight = actualTextHeight + paddingTop + paddingBottom;\n        const totalWidth = rendererOptions._internal_borderSize + paddingInner + paddingOuter + textWidth + tickSize;\n        const tickHeightBitmap = Math.max(1, Math.floor(verticalPixelRatio));\n        let totalHeightBitmap = Math.round(totalHeight * verticalPixelRatio);\n        if (totalHeightBitmap % 2 !== tickHeightBitmap % 2) {\n            totalHeightBitmap += 1;\n        }\n        const horzBorderBitmap = horzBorder > 0 ? Math.max(1, Math.floor(horzBorder * horizontalPixelRatio)) : 0;\n        const totalWidthBitmap = Math.round(totalWidth * horizontalPixelRatio);\n        // tick overlaps scale border\n        const tickSizeBitmap = Math.round(tickSize * horizontalPixelRatio);\n        const yMid = (_a = this._private__commonData._internal_fixedCoordinate) !== null && _a !== void 0 ? _a : this._private__commonData._internal_coordinate;\n        const yMidBitmap = Math.round(yMid * verticalPixelRatio) - Math.floor(verticalPixelRatio * 0.5);\n        const yTopBitmap = Math.floor(yMidBitmap + tickHeightBitmap / 2 - totalHeightBitmap / 2);\n        const yBottomBitmap = yTopBitmap + totalHeightBitmap;\n        const alignRight = align === \"right\";\n        const xInside = alignRight ? mediaSize.width - horzBorder : horzBorder;\n        const xInsideBitmap = alignRight ? bitmapSize.width - horzBorderBitmap : horzBorderBitmap;\n        let xOutsideBitmap;\n        let xTickBitmap;\n        let xText;\n        if (alignRight) {\n            // 2               1\n            //\n            //              6  5\n            //\n            // 3               4\n            xOutsideBitmap = xInsideBitmap - totalWidthBitmap;\n            xTickBitmap = xInsideBitmap - tickSizeBitmap;\n            xText = xInside - tickSize - paddingInner - horzBorder;\n        } else {\n            // 1               2\n            //\n            // 6  5\n            //\n            // 4               3\n            xOutsideBitmap = xInsideBitmap + totalWidthBitmap;\n            xTickBitmap = xInsideBitmap + tickSizeBitmap;\n            xText = xInside + tickSize + paddingInner;\n        }\n        return {\n            _internal_alignRight: alignRight,\n            _internal_bitmap: {\n                _internal_yTop: yTopBitmap,\n                _internal_yMid: yMidBitmap,\n                _internal_yBottom: yBottomBitmap,\n                _internal_totalWidth: totalWidthBitmap,\n                _internal_totalHeight: totalHeightBitmap,\n                // TODO: it is better to have different horizontal and vertical radii\n                _internal_radius: 2 * horizontalPixelRatio,\n                _internal_horzBorder: horzBorderBitmap,\n                _internal_xOutside: xOutsideBitmap,\n                _internal_xInside: xInsideBitmap,\n                _internal_xTick: xTickBitmap,\n                _internal_tickHeight: tickHeightBitmap,\n                _internal_right: bitmapSize.width\n            },\n            _internal_media: {\n                _internal_yTop: yTopBitmap / verticalPixelRatio,\n                _internal_yBottom: yBottomBitmap / verticalPixelRatio,\n                _internal_xText: xText,\n                _internal_textMidCorrection: textMidCorrection\n            }\n        };\n    }\n    constructor(data, commonData){\n        this._internal_setData(data, commonData);\n    }\n}\nclass PriceAxisView {\n    _internal_text() {\n        this._private__updateRendererDataIfNeeded();\n        return this._private__axisRendererData._internal_text;\n    }\n    _internal_coordinate() {\n        this._private__updateRendererDataIfNeeded();\n        return this._private__commonRendererData._internal_coordinate;\n    }\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_height(rendererOptions) {\n        let useSecondLine = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        return Math.max(this._private__axisRenderer._internal_height(rendererOptions, useSecondLine), this._private__paneRenderer._internal_height(rendererOptions, useSecondLine));\n    }\n    _internal_getFixedCoordinate() {\n        return this._private__commonRendererData._internal_fixedCoordinate || 0;\n    }\n    _internal_setFixedCoordinate(value) {\n        this._private__commonRendererData._internal_fixedCoordinate = value;\n    }\n    _internal_isVisible() {\n        this._private__updateRendererDataIfNeeded();\n        return this._private__axisRendererData._internal_visible || this._private__paneRendererData._internal_visible;\n    }\n    _internal_isAxisLabelVisible() {\n        this._private__updateRendererDataIfNeeded();\n        return this._private__axisRendererData._internal_visible;\n    }\n    _internal_renderer(priceScale) {\n        this._private__updateRendererDataIfNeeded();\n        // force update tickVisible state from price scale options\n        // because we don't have and we can't have price axis in other methods\n        // (like paneRenderer or any other who call _updateRendererDataIfNeeded)\n        this._private__axisRendererData._internal_tickVisible = this._private__axisRendererData._internal_tickVisible && priceScale._internal_options().ticksVisible;\n        this._private__paneRendererData._internal_tickVisible = this._private__paneRendererData._internal_tickVisible && priceScale._internal_options().ticksVisible;\n        this._private__axisRenderer._internal_setData(this._private__axisRendererData, this._private__commonRendererData);\n        this._private__paneRenderer._internal_setData(this._private__paneRendererData, this._private__commonRendererData);\n        return this._private__axisRenderer;\n    }\n    _internal_paneRenderer() {\n        this._private__updateRendererDataIfNeeded();\n        this._private__axisRenderer._internal_setData(this._private__axisRendererData, this._private__commonRendererData);\n        this._private__paneRenderer._internal_setData(this._private__paneRendererData, this._private__commonRendererData);\n        return this._private__paneRenderer;\n    }\n    _private__updateRendererDataIfNeeded() {\n        if (this._private__invalidated) {\n            this._private__axisRendererData._internal_tickVisible = true;\n            this._private__paneRendererData._internal_tickVisible = false;\n            this._internal__updateRendererData(this._private__axisRendererData, this._private__paneRendererData, this._private__commonRendererData);\n        }\n    }\n    constructor(ctor){\n        this._private__commonRendererData = {\n            _internal_coordinate: 0,\n            _internal_background: \"#000\",\n            _internal_additionalPaddingBottom: 0,\n            _internal_additionalPaddingTop: 0\n        };\n        this._private__axisRendererData = {\n            _internal_text: \"\",\n            _internal_visible: false,\n            _internal_tickVisible: true,\n            _internal_moveTextToInvisibleTick: false,\n            _internal_borderColor: \"\",\n            _internal_color: \"#FFF\",\n            _internal_borderVisible: false,\n            _internal_separatorVisible: false\n        };\n        this._private__paneRendererData = {\n            _internal_text: \"\",\n            _internal_visible: false,\n            _internal_tickVisible: false,\n            _internal_moveTextToInvisibleTick: true,\n            _internal_borderColor: \"\",\n            _internal_color: \"#FFF\",\n            _internal_borderVisible: true,\n            _internal_separatorVisible: true\n        };\n        this._private__invalidated = true;\n        this._private__axisRenderer = new (ctor || PriceAxisViewRenderer)(this._private__axisRendererData, this._private__commonRendererData);\n        this._private__paneRenderer = new (ctor || PriceAxisViewRenderer)(this._private__paneRendererData, this._private__commonRendererData);\n    }\n}\nclass CrosshairPriceAxisView extends PriceAxisView {\n    _internal__updateRendererData(axisRendererData, paneRendererData, commonRendererData) {\n        axisRendererData._internal_visible = false;\n        if (this._private__source._internal_options().mode === 2 /* CrosshairMode.Hidden */ ) {\n            return;\n        }\n        const options = this._private__source._internal_options().horzLine;\n        if (!options.labelVisible) {\n            return;\n        }\n        const firstValue = this._private__priceScale._internal_firstValue();\n        if (!this._private__source._internal_visible() || this._private__priceScale._internal_isEmpty() || firstValue === null) {\n            return;\n        }\n        const colors = generateContrastColors(options.labelBackgroundColor);\n        commonRendererData._internal_background = colors._internal_background;\n        axisRendererData._internal_color = colors._internal_foreground;\n        const additionalPadding = 2 / 12 * this._private__priceScale._internal_fontSize();\n        commonRendererData._internal_additionalPaddingTop = additionalPadding;\n        commonRendererData._internal_additionalPaddingBottom = additionalPadding;\n        const value = this._private__valueProvider(this._private__priceScale);\n        commonRendererData._internal_coordinate = value._internal_coordinate;\n        axisRendererData._internal_text = this._private__priceScale._internal_formatPrice(value._internal_price, firstValue);\n        axisRendererData._internal_visible = true;\n    }\n    constructor(source, priceScale, valueProvider){\n        super();\n        this._private__source = source;\n        this._private__priceScale = priceScale;\n        this._private__valueProvider = valueProvider;\n    }\n}\nconst optimizationReplacementRe = /[1-9]/g;\nconst radius$1 = 2;\nclass TimeAxisViewRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal_draw(target, rendererOptions) {\n        if (this._private__data === null || this._private__data._internal_visible === false || this._private__data._internal_text.length === 0) {\n            return;\n        }\n        const textWidth = target.useMediaCoordinateSpace((param)=>{\n            let { context: ctx } = param;\n            ctx.font = rendererOptions._internal_font;\n            return Math.round(rendererOptions._internal_widthCache._internal_measureText(ctx, ensureNotNull(this._private__data)._internal_text, optimizationReplacementRe));\n        });\n        if (textWidth <= 0) {\n            return;\n        }\n        const horzMargin = rendererOptions._internal_paddingHorizontal;\n        const labelWidth = textWidth + 2 * horzMargin;\n        const labelWidthHalf = labelWidth / 2;\n        const timeScaleWidth = this._private__data._internal_width;\n        let coordinate = this._private__data._internal_coordinate;\n        let x1 = Math.floor(coordinate - labelWidthHalf) + 0.5;\n        if (x1 < 0) {\n            coordinate = coordinate + Math.abs(0 - x1);\n            x1 = Math.floor(coordinate - labelWidthHalf) + 0.5;\n        } else if (x1 + labelWidth > timeScaleWidth) {\n            coordinate = coordinate - Math.abs(timeScaleWidth - (x1 + labelWidth));\n            x1 = Math.floor(coordinate - labelWidthHalf) + 0.5;\n        }\n        const x2 = x1 + labelWidth;\n        const y1 = 0;\n        const y2 = Math.ceil(y1 + rendererOptions._internal_borderSize + rendererOptions._internal_tickLength + rendererOptions._internal_paddingTop + rendererOptions._internal_fontSize + rendererOptions._internal_paddingBottom);\n        target.useBitmapCoordinateSpace((param)=>{\n            let { context: ctx, horizontalPixelRatio, verticalPixelRatio } = param;\n            const data = ensureNotNull(this._private__data);\n            ctx.fillStyle = data._internal_background;\n            const x1scaled = Math.round(x1 * horizontalPixelRatio);\n            const y1scaled = Math.round(y1 * verticalPixelRatio);\n            const x2scaled = Math.round(x2 * horizontalPixelRatio);\n            const y2scaled = Math.round(y2 * verticalPixelRatio);\n            const radiusScaled = Math.round(radius$1 * horizontalPixelRatio);\n            ctx.beginPath();\n            ctx.moveTo(x1scaled, y1scaled);\n            ctx.lineTo(x1scaled, y2scaled - radiusScaled);\n            ctx.arcTo(x1scaled, y2scaled, x1scaled + radiusScaled, y2scaled, radiusScaled);\n            ctx.lineTo(x2scaled - radiusScaled, y2scaled);\n            ctx.arcTo(x2scaled, y2scaled, x2scaled, y2scaled - radiusScaled, radiusScaled);\n            ctx.lineTo(x2scaled, y1scaled);\n            ctx.fill();\n            if (data._internal_tickVisible) {\n                const tickX = Math.round(data._internal_coordinate * horizontalPixelRatio);\n                const tickTop = y1scaled;\n                const tickBottom = Math.round((tickTop + rendererOptions._internal_tickLength) * verticalPixelRatio);\n                ctx.fillStyle = data._internal_color;\n                const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n                const tickOffset = Math.floor(horizontalPixelRatio * 0.5);\n                ctx.fillRect(tickX - tickOffset, tickTop, tickWidth, tickBottom - tickTop);\n            }\n        });\n        target.useMediaCoordinateSpace((param)=>{\n            let { context: ctx } = param;\n            const data = ensureNotNull(this._private__data);\n            const yText = y1 + rendererOptions._internal_borderSize + rendererOptions._internal_tickLength + rendererOptions._internal_paddingTop + rendererOptions._internal_fontSize / 2;\n            ctx.font = rendererOptions._internal_font;\n            ctx.textAlign = \"left\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillStyle = data._internal_color;\n            const textYCorrection = rendererOptions._internal_widthCache._internal_yMidCorrection(ctx, \"Apr0\");\n            ctx.translate(x1 + horzMargin, yText + textYCorrection);\n            ctx.fillText(data._internal_text, 0, 0);\n        });\n    }\n    constructor(){\n        this._private__data = null;\n    }\n}\nclass CrosshairTimeAxisView {\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_renderer() {\n        if (this._private__invalidated) {\n            this._private__updateImpl();\n            this._private__invalidated = false;\n        }\n        this._private__renderer._internal_setData(this._private__rendererData);\n        return this._private__renderer;\n    }\n    _private__updateImpl() {\n        const data = this._private__rendererData;\n        data._internal_visible = false;\n        if (this._private__crosshair._internal_options().mode === 2 /* CrosshairMode.Hidden */ ) {\n            return;\n        }\n        const options = this._private__crosshair._internal_options().vertLine;\n        if (!options.labelVisible) {\n            return;\n        }\n        const timeScale = this._private__model._internal_timeScale();\n        if (timeScale._internal_isEmpty()) {\n            return;\n        }\n        data._internal_width = timeScale._internal_width();\n        const value = this._private__valueProvider();\n        if (value === null) {\n            return;\n        }\n        data._internal_coordinate = value._internal_coordinate;\n        const currentTime = timeScale._internal_indexToTimeScalePoint(this._private__crosshair._internal_appliedIndex());\n        data._internal_text = timeScale._internal_formatDateTime(ensureNotNull(currentTime));\n        data._internal_visible = true;\n        const colors = generateContrastColors(options.labelBackgroundColor);\n        data._internal_background = colors._internal_background;\n        data._internal_color = colors._internal_foreground;\n        data._internal_tickVisible = timeScale._internal_options().ticksVisible;\n    }\n    constructor(crosshair, model, valueProvider){\n        this._private__invalidated = true;\n        this._private__renderer = new TimeAxisViewRenderer();\n        this._private__rendererData = {\n            _internal_visible: false,\n            _internal_background: \"#4c525e\",\n            _internal_color: \"white\",\n            _internal_text: \"\",\n            _internal_width: 0,\n            _internal_coordinate: NaN,\n            _internal_tickVisible: true\n        };\n        this._private__crosshair = crosshair;\n        this._private__model = model;\n        this._private__valueProvider = valueProvider;\n    }\n}\nclass DataSource {\n    _internal_zorder() {\n        return this._private__zorder;\n    }\n    _internal_setZorder(zorder) {\n        this._private__zorder = zorder;\n    }\n    _internal_priceScale() {\n        return this._internal__priceScale;\n    }\n    _internal_setPriceScale(priceScale) {\n        this._internal__priceScale = priceScale;\n    }\n    _internal_labelPaneViews(pane) {\n        return [];\n    }\n    _internal_timeAxisViews() {\n        return [];\n    }\n    _internal_visible() {\n        return true;\n    }\n    constructor(){\n        this._internal__priceScale = null;\n        this._private__zorder = 0;\n    }\n}\n/**\n * Represents the crosshair mode.\n */ var CrosshairMode;\n(function(CrosshairMode) {\n    /**\n     * This mode allows crosshair to move freely on the chart.\n     */ CrosshairMode[CrosshairMode[\"Normal\"] = 0] = \"Normal\";\n    /**\n     * This mode sticks crosshair's horizontal line to the price value of a single-value series or to the close price of OHLC-based series.\n     */ CrosshairMode[CrosshairMode[\"Magnet\"] = 1] = \"Magnet\";\n    /**\n     * This mode disables rendering of the crosshair.\n     */ CrosshairMode[CrosshairMode[\"Hidden\"] = 2] = \"Hidden\";\n})(CrosshairMode || (CrosshairMode = {}));\nclass Crosshair extends DataSource {\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_saveOriginCoord(x, y) {\n        this._private__originX = x;\n        this._private__originY = y;\n    }\n    _internal_clearOriginCoord() {\n        this._private__originX = NaN;\n        this._private__originY = NaN;\n    }\n    _internal_originCoordX() {\n        return this._private__originX;\n    }\n    _internal_originCoordY() {\n        return this._private__originY;\n    }\n    _internal_setPosition(index, price, pane) {\n        if (!this._private__subscribed) {\n            this._private__subscribed = true;\n        }\n        this._private__visible = true;\n        this._private__tryToUpdateViews(index, price, pane);\n    }\n    _internal_appliedIndex() {\n        return this._private__index;\n    }\n    _internal_appliedX() {\n        return this._private__x;\n    }\n    _internal_appliedY() {\n        return this._private__y;\n    }\n    _internal_visible() {\n        return this._private__visible;\n    }\n    _internal_clearPosition() {\n        this._private__visible = false;\n        this._private__setIndexToLastSeriesBarIndex();\n        this._private__price = NaN;\n        this._private__x = NaN;\n        this._private__y = NaN;\n        this._private__pane = null;\n        this._internal_clearOriginCoord();\n    }\n    _internal_paneViews(pane) {\n        return this._private__pane !== null ? [\n            this._private__paneView,\n            this._private__markersPaneView\n        ] : [];\n    }\n    _internal_horzLineVisible(pane) {\n        return pane === this._private__pane && this._private__options.horzLine.visible;\n    }\n    _internal_vertLineVisible() {\n        return this._private__options.vertLine.visible;\n    }\n    _internal_priceAxisViews(pane, priceScale) {\n        if (!this._private__visible || this._private__pane !== pane) {\n            this._private__priceAxisViews.clear();\n        }\n        const views = [];\n        if (this._private__pane === pane) {\n            views.push(this._private__createPriceAxisViewOnDemand(this._private__priceAxisViews, priceScale, this._private__currentPosPriceProvider));\n        }\n        return views;\n    }\n    _internal_timeAxisViews() {\n        return this._private__visible ? [\n            this._private__timeAxisView\n        ] : [];\n    }\n    _internal_pane() {\n        return this._private__pane;\n    }\n    _internal_updateAllViews() {\n        this._private__paneView._internal_update();\n        this._private__priceAxisViews.forEach((value)=>value._internal_update());\n        this._private__timeAxisView._internal_update();\n        this._private__markersPaneView._internal_update();\n    }\n    _private__priceScaleByPane(pane) {\n        if (pane && !pane._internal_defaultPriceScale()._internal_isEmpty()) {\n            return pane._internal_defaultPriceScale();\n        }\n        return null;\n    }\n    _private__tryToUpdateViews(index, price, pane) {\n        if (this._private__tryToUpdateData(index, price, pane)) {\n            this._internal_updateAllViews();\n        }\n    }\n    _private__tryToUpdateData(newIndex, newPrice, newPane) {\n        const oldX = this._private__x;\n        const oldY = this._private__y;\n        const oldPrice = this._private__price;\n        const oldIndex = this._private__index;\n        const oldPane = this._private__pane;\n        const priceScale = this._private__priceScaleByPane(newPane);\n        this._private__index = newIndex;\n        this._private__x = isNaN(newIndex) ? NaN : this._private__model._internal_timeScale()._internal_indexToCoordinate(newIndex);\n        this._private__pane = newPane;\n        const firstValue = priceScale !== null ? priceScale._internal_firstValue() : null;\n        if (priceScale !== null && firstValue !== null) {\n            this._private__price = newPrice;\n            this._private__y = priceScale._internal_priceToCoordinate(newPrice, firstValue);\n        } else {\n            this._private__price = NaN;\n            this._private__y = NaN;\n        }\n        return oldX !== this._private__x || oldY !== this._private__y || oldIndex !== this._private__index || oldPrice !== this._private__price || oldPane !== this._private__pane;\n    }\n    _private__setIndexToLastSeriesBarIndex() {\n        const lastIndexes = this._private__model._internal_serieses().map((s)=>s._internal_bars()._internal_lastIndex()).filter(notNull);\n        const lastBarIndex = lastIndexes.length === 0 ? null : Math.max(...lastIndexes);\n        this._private__index = lastBarIndex !== null ? lastBarIndex : NaN;\n    }\n    _private__createPriceAxisViewOnDemand(map, priceScale, valueProvider) {\n        let view = map.get(priceScale);\n        if (view === undefined) {\n            view = new CrosshairPriceAxisView(this, priceScale, valueProvider);\n            map.set(priceScale, view);\n        }\n        return view;\n    }\n    constructor(model, options){\n        super();\n        this._private__pane = null;\n        this._private__price = NaN;\n        this._private__index = 0;\n        this._private__visible = true;\n        this._private__priceAxisViews = new Map();\n        this._private__subscribed = false;\n        this._private__x = NaN;\n        this._private__y = NaN;\n        this._private__originX = NaN;\n        this._private__originY = NaN;\n        this._private__model = model;\n        this._private__options = options;\n        this._private__markersPaneView = new CrosshairMarksPaneView(model, this);\n        const valuePriceProvider = (rawPriceProvider, rawCoordinateProvider)=>{\n            return (priceScale)=>{\n                const coordinate = rawCoordinateProvider();\n                const rawPrice = rawPriceProvider();\n                if (priceScale === ensureNotNull(this._private__pane)._internal_defaultPriceScale()) {\n                    // price must be defined\n                    return {\n                        _internal_price: rawPrice,\n                        _internal_coordinate: coordinate\n                    };\n                } else {\n                    // always convert from coordinate\n                    const firstValue = ensureNotNull(priceScale._internal_firstValue());\n                    const price = priceScale._internal_coordinateToPrice(coordinate, firstValue);\n                    return {\n                        _internal_price: price,\n                        _internal_coordinate: coordinate\n                    };\n                }\n            };\n        };\n        const valueTimeProvider = (rawIndexProvider, rawCoordinateProvider)=>{\n            return ()=>{\n                const time = this._private__model._internal_timeScale()._internal_indexToTime(rawIndexProvider());\n                const coordinate = rawCoordinateProvider();\n                if (!time || !Number.isFinite(coordinate)) {\n                    return null;\n                }\n                return {\n                    _internal_time: time,\n                    _internal_coordinate: coordinate\n                };\n            };\n        };\n        // for current position always return both price and coordinate\n        this._private__currentPosPriceProvider = valuePriceProvider(()=>this._private__price, ()=>this._private__y);\n        const currentPosTimeProvider = valueTimeProvider(()=>this._private__index, ()=>this._internal_appliedX());\n        this._private__timeAxisView = new CrosshairTimeAxisView(this, model, currentPosTimeProvider);\n        this._private__paneView = new CrosshairPaneView(this);\n    }\n}\nfunction isDefaultPriceScale(priceScaleId) {\n    return priceScaleId === \"left\" /* DefaultPriceScaleId.Left */  || priceScaleId === \"right\" /* DefaultPriceScaleId.Right */ ;\n}\nfunction mergePaneInvalidation(beforeValue, newValue) {\n    if (beforeValue === undefined) {\n        return newValue;\n    }\n    const level = Math.max(beforeValue._internal_level, newValue._internal_level);\n    const autoScale = beforeValue._internal_autoScale || newValue._internal_autoScale;\n    return {\n        _internal_level: level,\n        _internal_autoScale: autoScale\n    };\n}\nclass InvalidateMask {\n    _internal_invalidatePane(paneIndex, invalidation) {\n        const prevValue = this._private__invalidatedPanes.get(paneIndex);\n        const newValue = mergePaneInvalidation(prevValue, invalidation);\n        this._private__invalidatedPanes.set(paneIndex, newValue);\n    }\n    _internal_fullInvalidation() {\n        return this._private__globalLevel;\n    }\n    _internal_invalidateForPane(paneIndex) {\n        const paneInvalidation = this._private__invalidatedPanes.get(paneIndex);\n        if (paneInvalidation === undefined) {\n            return {\n                _internal_level: this._private__globalLevel\n            };\n        }\n        return {\n            _internal_level: Math.max(this._private__globalLevel, paneInvalidation._internal_level),\n            _internal_autoScale: paneInvalidation._internal_autoScale\n        };\n    }\n    _internal_setFitContent() {\n        this._internal_stopTimeScaleAnimation();\n        // modifies both bar spacing and right offset\n        this._private__timeScaleInvalidations = [\n            {\n                _internal_type: 0 /* TimeScaleInvalidationType.FitContent */ \n            }\n        ];\n    }\n    _internal_applyRange(range) {\n        this._internal_stopTimeScaleAnimation();\n        // modifies both bar spacing and right offset\n        this._private__timeScaleInvalidations = [\n            {\n                _internal_type: 1 /* TimeScaleInvalidationType.ApplyRange */ ,\n                _internal_value: range\n            }\n        ];\n    }\n    _internal_setTimeScaleAnimation(animation) {\n        this._private__removeTimeScaleAnimation();\n        this._private__timeScaleInvalidations.push({\n            _internal_type: 5 /* TimeScaleInvalidationType.Animation */ ,\n            _internal_value: animation\n        });\n    }\n    _internal_stopTimeScaleAnimation() {\n        this._private__removeTimeScaleAnimation();\n        this._private__timeScaleInvalidations.push({\n            _internal_type: 6 /* TimeScaleInvalidationType.StopAnimation */ \n        });\n    }\n    _internal_resetTimeScale() {\n        this._internal_stopTimeScaleAnimation();\n        // modifies both bar spacing and right offset\n        this._private__timeScaleInvalidations = [\n            {\n                _internal_type: 4 /* TimeScaleInvalidationType.Reset */ \n            }\n        ];\n    }\n    _internal_setBarSpacing(barSpacing) {\n        this._internal_stopTimeScaleAnimation();\n        this._private__timeScaleInvalidations.push({\n            _internal_type: 2 /* TimeScaleInvalidationType.ApplyBarSpacing */ ,\n            _internal_value: barSpacing\n        });\n    }\n    _internal_setRightOffset(offset) {\n        this._internal_stopTimeScaleAnimation();\n        this._private__timeScaleInvalidations.push({\n            _internal_type: 3 /* TimeScaleInvalidationType.ApplyRightOffset */ ,\n            _internal_value: offset\n        });\n    }\n    _internal_timeScaleInvalidations() {\n        return this._private__timeScaleInvalidations;\n    }\n    _internal_merge(other) {\n        for (const tsInvalidation of other._private__timeScaleInvalidations){\n            this._private__applyTimeScaleInvalidation(tsInvalidation);\n        }\n        this._private__globalLevel = Math.max(this._private__globalLevel, other._private__globalLevel);\n        other._private__invalidatedPanes.forEach((invalidation, index)=>{\n            this._internal_invalidatePane(index, invalidation);\n        });\n    }\n    static _internal_light() {\n        return new InvalidateMask(2 /* InvalidationLevel.Light */ );\n    }\n    static _internal_full() {\n        return new InvalidateMask(3 /* InvalidationLevel.Full */ );\n    }\n    _private__applyTimeScaleInvalidation(invalidation) {\n        switch(invalidation._internal_type){\n            case 0 /* TimeScaleInvalidationType.FitContent */ :\n                this._internal_setFitContent();\n                break;\n            case 1 /* TimeScaleInvalidationType.ApplyRange */ :\n                this._internal_applyRange(invalidation._internal_value);\n                break;\n            case 2 /* TimeScaleInvalidationType.ApplyBarSpacing */ :\n                this._internal_setBarSpacing(invalidation._internal_value);\n                break;\n            case 3 /* TimeScaleInvalidationType.ApplyRightOffset */ :\n                this._internal_setRightOffset(invalidation._internal_value);\n                break;\n            case 4 /* TimeScaleInvalidationType.Reset */ :\n                this._internal_resetTimeScale();\n                break;\n            case 5 /* TimeScaleInvalidationType.Animation */ :\n                this._internal_setTimeScaleAnimation(invalidation._internal_value);\n                break;\n            case 6 /* TimeScaleInvalidationType.StopAnimation */ :\n                this._private__removeTimeScaleAnimation();\n        }\n    }\n    _private__removeTimeScaleAnimation() {\n        const index = this._private__timeScaleInvalidations.findIndex((inv)=>inv._internal_type === 5 /* TimeScaleInvalidationType.Animation */ );\n        if (index !== -1) {\n            this._private__timeScaleInvalidations.splice(index, 1);\n        }\n    }\n    constructor(globalLevel){\n        this._private__invalidatedPanes = new Map();\n        this._private__timeScaleInvalidations = [];\n        this._private__globalLevel = globalLevel;\n    }\n}\nconst formatterOptions = {\n    _internal_decimalSign: \".\",\n    _internal_decimalSignFractional: \"'\"\n};\n/**\n * @param value - The number of convert.\n * @param length - The length. Must be between 0 and 16 inclusive.\n */ function numberToStringWithLeadingZero(value, length) {\n    if (!isNumber(value)) {\n        return \"n/a\";\n    }\n    if (!isInteger(length)) {\n        throw new TypeError(\"invalid length\");\n    }\n    if (length < 0 || length > 16) {\n        throw new TypeError(\"invalid length\");\n    }\n    if (length === 0) {\n        return value.toString();\n    }\n    const dummyString = \"0000000000000000\";\n    return (dummyString + value.toString()).slice(-length);\n}\nclass PriceFormatter {\n    format(price) {\n        // \\u2212 is unicode's minus sign https://www.fileformat.info/info/unicode/char/2212/index.htm\n        // we should use it because it has the same width as plus sign +\n        const sign = price < 0 ? \"â\" : \"\";\n        price = Math.abs(price);\n        return sign + this._private__formatAsDecimal(price);\n    }\n    _private__calculateDecimal() {\n        // check if this._base is power of 10\n        // for double fractional _fractionalLength if for the main fractional only\n        this._internal__fractionalLength = 0;\n        if (this._private__priceScale > 0 && this._private__minMove > 0) {\n            let base = this._private__priceScale;\n            while(base > 1){\n                base /= 10;\n                this._internal__fractionalLength++;\n            }\n        }\n    }\n    _private__formatAsDecimal(price) {\n        const base = this._private__priceScale / this._private__minMove;\n        let intPart = Math.floor(price);\n        let fracString = \"\";\n        const fracLength = this._internal__fractionalLength !== undefined ? this._internal__fractionalLength : NaN;\n        if (base > 1) {\n            let fracPart = +(Math.round(price * base) - intPart * base).toFixed(this._internal__fractionalLength);\n            if (fracPart >= base) {\n                fracPart -= base;\n                intPart += 1;\n            }\n            fracString = formatterOptions._internal_decimalSign + numberToStringWithLeadingZero(+fracPart.toFixed(this._internal__fractionalLength) * this._private__minMove, fracLength);\n        } else {\n            // should round int part to min move\n            intPart = Math.round(intPart * base) / base;\n            // if min move > 1, fractional part is always = 0\n            if (fracLength > 0) {\n                fracString = formatterOptions._internal_decimalSign + numberToStringWithLeadingZero(0, fracLength);\n            }\n        }\n        return intPart.toFixed(0) + fracString;\n    }\n    constructor(priceScale, minMove){\n        if (!minMove) {\n            minMove = 1;\n        }\n        if (!isNumber(priceScale) || !isInteger(priceScale)) {\n            priceScale = 100;\n        }\n        if (priceScale < 0) {\n            throw new TypeError(\"invalid base\");\n        }\n        this._private__priceScale = priceScale;\n        this._private__minMove = minMove;\n        this._private__calculateDecimal();\n    }\n}\nclass PercentageFormatter extends PriceFormatter {\n    format(price) {\n        return \"\".concat(super.format(price), \"%\");\n    }\n    constructor(priceScale = 100){\n        super(priceScale);\n    }\n}\nclass VolumeFormatter {\n    format(vol) {\n        let sign = \"\";\n        if (vol < 0) {\n            sign = \"-\";\n            vol = -vol;\n        }\n        if (vol < 995) {\n            return sign + this._private__formatNumber(vol);\n        } else if (vol < 999995) {\n            return sign + this._private__formatNumber(vol / 1000) + \"K\";\n        } else if (vol < 999999995) {\n            vol = 1000 * Math.round(vol / 1000);\n            return sign + this._private__formatNumber(vol / 1000000) + \"M\";\n        } else {\n            vol = 1000000 * Math.round(vol / 1000000);\n            return sign + this._private__formatNumber(vol / 1000000000) + \"B\";\n        }\n    }\n    _private__formatNumber(value) {\n        let res;\n        const priceScale = Math.pow(10, this._private__precision);\n        value = Math.round(value * priceScale) / priceScale;\n        if (value >= 1e-15 && value < 1) {\n            res = value.toFixed(this._private__precision).replace(/\\.?0+$/, \"\"); // regex removes trailing zeroes\n        } else {\n            res = String(value);\n        }\n        return res.replace(/(\\.[1-9]*)0+$/, (e, p1)=>p1);\n    }\n    constructor(precision){\n        this._private__precision = precision;\n    }\n}\n// eslint-disable-next-line max-params, complexity\nfunction walkLine(renderingScope, items, lineType, visibleRange, barWidth, // the values returned by styleGetter are compared using the operator !==,\n// so if styleGetter returns objects, then styleGetter should return the same object for equal styles\nstyleGetter, finishStyledArea) {\n    if (items.length === 0 || visibleRange.from >= items.length || visibleRange.to <= 0) {\n        return;\n    }\n    const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = renderingScope;\n    const firstItem = items[visibleRange.from];\n    let currentStyle = styleGetter(renderingScope, firstItem);\n    let currentStyleFirstItem = firstItem;\n    if (visibleRange.to - visibleRange.from < 2) {\n        const halfBarWidth = barWidth / 2;\n        ctx.beginPath();\n        const item1 = {\n            _internal_x: firstItem._internal_x - halfBarWidth,\n            _internal_y: firstItem._internal_y\n        };\n        const item2 = {\n            _internal_x: firstItem._internal_x + halfBarWidth,\n            _internal_y: firstItem._internal_y\n        };\n        ctx.moveTo(item1._internal_x * horizontalPixelRatio, item1._internal_y * verticalPixelRatio);\n        ctx.lineTo(item2._internal_x * horizontalPixelRatio, item2._internal_y * verticalPixelRatio);\n        finishStyledArea(renderingScope, currentStyle, item1, item2);\n    } else {\n        const changeStyle = (newStyle, currentItem)=>{\n            finishStyledArea(renderingScope, currentStyle, currentStyleFirstItem, currentItem);\n            ctx.beginPath();\n            currentStyle = newStyle;\n            currentStyleFirstItem = currentItem;\n        };\n        let currentItem = currentStyleFirstItem;\n        ctx.beginPath();\n        ctx.moveTo(firstItem._internal_x * horizontalPixelRatio, firstItem._internal_y * verticalPixelRatio);\n        for(let i = visibleRange.from + 1; i < visibleRange.to; ++i){\n            currentItem = items[i];\n            const itemStyle = styleGetter(renderingScope, currentItem);\n            switch(lineType){\n                case 0 /* LineType.Simple */ :\n                    ctx.lineTo(currentItem._internal_x * horizontalPixelRatio, currentItem._internal_y * verticalPixelRatio);\n                    break;\n                case 1 /* LineType.WithSteps */ :\n                    ctx.lineTo(currentItem._internal_x * horizontalPixelRatio, items[i - 1]._internal_y * verticalPixelRatio);\n                    if (itemStyle !== currentStyle) {\n                        changeStyle(itemStyle, currentItem);\n                        ctx.lineTo(currentItem._internal_x * horizontalPixelRatio, items[i - 1]._internal_y * verticalPixelRatio);\n                    }\n                    ctx.lineTo(currentItem._internal_x * horizontalPixelRatio, currentItem._internal_y * verticalPixelRatio);\n                    break;\n                case 2 /* LineType.Curved */ :\n                    {\n                        const [cp1, cp2] = getControlPoints(items, i - 1, i);\n                        ctx.bezierCurveTo(cp1._internal_x * horizontalPixelRatio, cp1._internal_y * verticalPixelRatio, cp2._internal_x * horizontalPixelRatio, cp2._internal_y * verticalPixelRatio, currentItem._internal_x * horizontalPixelRatio, currentItem._internal_y * verticalPixelRatio);\n                        break;\n                    }\n            }\n            if (lineType !== 1 /* LineType.WithSteps */  && itemStyle !== currentStyle) {\n                changeStyle(itemStyle, currentItem);\n                ctx.moveTo(currentItem._internal_x * horizontalPixelRatio, currentItem._internal_y * verticalPixelRatio);\n            }\n        }\n        if (currentStyleFirstItem !== currentItem || currentStyleFirstItem === currentItem && lineType === 1 /* LineType.WithSteps */ ) {\n            finishStyledArea(renderingScope, currentStyle, currentStyleFirstItem, currentItem);\n        }\n    }\n}\nconst curveTension = 6;\nfunction subtract(p1, p2) {\n    return {\n        _internal_x: p1._internal_x - p2._internal_x,\n        _internal_y: p1._internal_y - p2._internal_y\n    };\n}\nfunction add(p1, p2) {\n    return {\n        _internal_x: p1._internal_x + p2._internal_x,\n        _internal_y: p1._internal_y + p2._internal_y\n    };\n}\nfunction divide(p1, n) {\n    return {\n        _internal_x: p1._internal_x / n,\n        _internal_y: p1._internal_y / n\n    };\n}\n/**\n * @returns Two control points that can be used as arguments to {@link CanvasRenderingContext2D.bezierCurveTo} to draw a curved line between `points[fromPointIndex]` and `points[toPointIndex]`.\n */ function getControlPoints(points, fromPointIndex, toPointIndex) {\n    const beforeFromPointIndex = Math.max(0, fromPointIndex - 1);\n    const afterToPointIndex = Math.min(points.length - 1, toPointIndex + 1);\n    const cp1 = add(points[fromPointIndex], divide(subtract(points[toPointIndex], points[beforeFromPointIndex]), curveTension));\n    const cp2 = subtract(points[toPointIndex], divide(subtract(points[afterToPointIndex], points[fromPointIndex]), curveTension));\n    return [\n        cp1,\n        cp2\n    ];\n}\nfunction finishStyledArea$1(baseLevelCoordinate, scope, style, areaFirstItem, newAreaFirstItem) {\n    const { context, horizontalPixelRatio, verticalPixelRatio } = scope;\n    context.lineTo(newAreaFirstItem._internal_x * horizontalPixelRatio, baseLevelCoordinate * verticalPixelRatio);\n    context.lineTo(areaFirstItem._internal_x * horizontalPixelRatio, baseLevelCoordinate * verticalPixelRatio);\n    context.closePath();\n    context.fillStyle = style;\n    context.fill();\n}\nclass PaneRendererAreaBase extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._internal__data = data;\n    }\n    _internal__drawImpl(renderingScope) {\n        var _a;\n        if (this._internal__data === null) {\n            return;\n        }\n        const { _internal_items: items, _internal_visibleRange: visibleRange, _internal_barWidth: barWidth, _internal_lineWidth: lineWidth, _internal_lineStyle: lineStyle, _internal_lineType: lineType } = this._internal__data;\n        const baseLevelCoordinate = (_a = this._internal__data._internal_baseLevelCoordinate) !== null && _a !== void 0 ? _a : this._internal__data._internal_invertFilledArea ? 0 : renderingScope.mediaSize.height;\n        if (visibleRange === null) {\n            return;\n        }\n        const ctx = renderingScope.context;\n        ctx.lineCap = \"butt\";\n        ctx.lineJoin = \"round\";\n        ctx.lineWidth = lineWidth;\n        setLineStyle(ctx, lineStyle);\n        // walk lines with width=1 to have more accurate gradient's filling\n        ctx.lineWidth = 1;\n        walkLine(renderingScope, items, lineType, visibleRange, barWidth, this._internal__fillStyle.bind(this), finishStyledArea$1.bind(null, baseLevelCoordinate));\n    }\n    constructor(){\n        super(...arguments);\n        this._internal__data = null;\n    }\n}\nfunction clamp(value, minVal, maxVal) {\n    return Math.min(Math.max(value, minVal), maxVal);\n}\nfunction isBaseDecimal(value) {\n    if (value < 0) {\n        return false;\n    }\n    for(let current = value; current > 1; current /= 10){\n        if (current % 10 !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction greaterOrEqual(x1, x2, epsilon) {\n    return x2 - x1 <= epsilon;\n}\nfunction equal(x1, x2, epsilon) {\n    return Math.abs(x1 - x2) < epsilon;\n}\n// We can't use Math.min(...arr) because that would only support arrays shorter than 65536 items.\nfunction min(arr) {\n    if (arr.length < 1) {\n        throw Error(\"array is empty\");\n    }\n    let minVal = arr[0];\n    for(let i = 1; i < arr.length; ++i){\n        if (arr[i] < minVal) {\n            minVal = arr[i];\n        }\n    }\n    return minVal;\n}\nfunction ceiledEven(x) {\n    const ceiled = Math.ceil(x);\n    return ceiled % 2 !== 0 ? ceiled - 1 : ceiled;\n}\nfunction ceiledOdd(x) {\n    const ceiled = Math.ceil(x);\n    return ceiled % 2 === 0 ? ceiled - 1 : ceiled;\n}\nclass GradientStyleCache {\n    _internal_get(scope, params) {\n        const cachedParams = this._private__params;\n        const { _internal_topColor1: topColor1, _internal_topColor2: topColor2, _internal_bottomColor1: bottomColor1, _internal_bottomColor2: bottomColor2, _internal_bottom: bottom, _internal_baseLevelCoordinate: baseLevelCoordinate } = params;\n        if (this._private__cachedValue === undefined || cachedParams === undefined || cachedParams._internal_topColor1 !== topColor1 || cachedParams._internal_topColor2 !== topColor2 || cachedParams._internal_bottomColor1 !== bottomColor1 || cachedParams._internal_bottomColor2 !== bottomColor2 || cachedParams._internal_baseLevelCoordinate !== baseLevelCoordinate || cachedParams._internal_bottom !== bottom) {\n            const gradient = scope.context.createLinearGradient(0, 0, 0, bottom);\n            gradient.addColorStop(0, topColor1);\n            if (baseLevelCoordinate != null) {\n                const baselinePercent = clamp(baseLevelCoordinate * scope.verticalPixelRatio / bottom, 0, 1);\n                gradient.addColorStop(baselinePercent, topColor2);\n                gradient.addColorStop(baselinePercent, bottomColor1);\n            }\n            gradient.addColorStop(1, bottomColor2);\n            this._private__cachedValue = gradient;\n            this._private__params = params;\n        }\n        return this._private__cachedValue;\n    }\n}\nclass PaneRendererArea extends PaneRendererAreaBase {\n    _internal__fillStyle(renderingScope, item) {\n        return this._private__fillCache._internal_get(renderingScope, {\n            _internal_topColor1: item._internal_topColor,\n            _internal_topColor2: \"\",\n            _internal_bottomColor1: \"\",\n            _internal_bottomColor2: item._internal_bottomColor,\n            _internal_bottom: renderingScope.bitmapSize.height\n        });\n    }\n    constructor(){\n        super(...arguments);\n        this._private__fillCache = new GradientStyleCache();\n    }\n}\nfunction drawSeriesPointMarkers(renderingScope, items, pointMarkersRadius, visibleRange, // the values returned by styleGetter are compared using the operator !==,\n// so if styleGetter returns objects, then styleGetter should return the same object for equal styles\nstyleGetter) {\n    const { horizontalPixelRatio, verticalPixelRatio, context } = renderingScope;\n    let prevStyle = null;\n    const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n    const correction = tickWidth % 2 / 2;\n    const radius = pointMarkersRadius * verticalPixelRatio + correction;\n    for(let i = visibleRange.to - 1; i >= visibleRange.from; --i){\n        const point = items[i];\n        if (point) {\n            const style = styleGetter(renderingScope, point);\n            if (style !== prevStyle) {\n                context.beginPath();\n                if (prevStyle !== null) {\n                    context.fill();\n                }\n                context.fillStyle = style;\n                prevStyle = style;\n            }\n            const centerX = Math.round(point._internal_x * horizontalPixelRatio) + correction; // correct x coordinate only\n            const centerY = point._internal_y * verticalPixelRatio;\n            context.moveTo(centerX, centerY);\n            context.arc(centerX, centerY, radius, 0, Math.PI * 2);\n        }\n    }\n    context.fill();\n}\nfunction finishStyledArea(scope, style) {\n    const ctx = scope.context;\n    ctx.strokeStyle = style;\n    ctx.stroke();\n}\nclass PaneRendererLineBase extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._internal__data = data;\n    }\n    _internal__drawImpl(renderingScope) {\n        if (this._internal__data === null) {\n            return;\n        }\n        const { _internal_items: items, _internal_visibleRange: visibleRange, _internal_barWidth: barWidth, _internal_lineType: lineType, _internal_lineWidth: lineWidth, _internal_lineStyle: lineStyle, _internal_pointMarkersRadius: pointMarkersRadius } = this._internal__data;\n        if (visibleRange === null) {\n            return;\n        }\n        const ctx = renderingScope.context;\n        ctx.lineCap = \"butt\";\n        ctx.lineWidth = lineWidth * renderingScope.verticalPixelRatio;\n        setLineStyle(ctx, lineStyle);\n        ctx.lineJoin = \"round\";\n        const styleGetter = this._internal__strokeStyle.bind(this);\n        if (lineType !== undefined) {\n            walkLine(renderingScope, items, lineType, visibleRange, barWidth, styleGetter, finishStyledArea);\n        }\n        if (pointMarkersRadius) {\n            drawSeriesPointMarkers(renderingScope, items, pointMarkersRadius, visibleRange, styleGetter);\n        }\n    }\n    constructor(){\n        super(...arguments);\n        this._internal__data = null;\n    }\n}\nclass PaneRendererLine extends PaneRendererLineBase {\n    _internal__strokeStyle(renderingScope, item) {\n        return item._internal_lineColor;\n    }\n}\n/**\n * Binary function that accepts two arguments (the first of the type of array elements, and the second is always val), and returns a value convertible to bool.\n * The value returned indicates whether the first argument is considered to go before the second.\n * The function shall not modify any of its arguments.\n */ function boundCompare(lower, arr, value, compare) {\n    let start = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, to = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : arr.length;\n    let count = to - start;\n    while(0 < count){\n        const count2 = count >> 1;\n        const mid = start + count2;\n        if (compare(arr[mid], value) === lower) {\n            start = mid + 1;\n            count -= count2 + 1;\n        } else {\n            count = count2;\n        }\n    }\n    return start;\n}\nconst lowerBound = boundCompare.bind(null, true);\nconst upperBound = boundCompare.bind(null, false);\nfunction lowerBoundItemsCompare(item, time) {\n    return item._internal_time < time;\n}\nfunction upperBoundItemsCompare(item, time) {\n    return time < item._internal_time;\n}\nfunction visibleTimedValues(items, range, extendedRange) {\n    const firstBar = range._internal_left();\n    const lastBar = range._internal_right();\n    const from = lowerBound(items, firstBar, lowerBoundItemsCompare);\n    const to = upperBound(items, lastBar, upperBoundItemsCompare);\n    if (!extendedRange) {\n        return {\n            from,\n            to\n        };\n    }\n    let extendedFrom = from;\n    let extendedTo = to;\n    if (from > 0 && from < items.length && items[from]._internal_time >= firstBar) {\n        extendedFrom = from - 1;\n    }\n    if (to > 0 && to < items.length && items[to - 1]._internal_time <= lastBar) {\n        extendedTo = to + 1;\n    }\n    return {\n        from: extendedFrom,\n        to: extendedTo\n    };\n}\nclass SeriesPaneViewBase {\n    _internal_update(updateType) {\n        this._internal__invalidated = true;\n        if (updateType === \"data\") {\n            this._internal__dataInvalidated = true;\n        }\n        if (updateType === \"options\") {\n            this._internal__optionsInvalidated = true;\n        }\n    }\n    _internal_renderer() {\n        if (!this._internal__series._internal_visible()) {\n            return null;\n        }\n        this._private__makeValid();\n        return this._internal__itemsVisibleRange === null ? null : this._internal__renderer;\n    }\n    _internal__updateOptions() {\n        this._internal__items = this._internal__items.map((item)=>Object.assign(Object.assign({}, item), this._internal__series._internal_barColorer()._internal_barStyle(item._internal_time)));\n    }\n    _internal__clearVisibleRange() {\n        this._internal__itemsVisibleRange = null;\n    }\n    _private__makeValid() {\n        if (this._internal__dataInvalidated) {\n            this._internal__fillRawPoints();\n            this._internal__dataInvalidated = false;\n        }\n        if (this._internal__optionsInvalidated) {\n            this._internal__updateOptions();\n            this._internal__optionsInvalidated = false;\n        }\n        if (this._internal__invalidated) {\n            this._private__makeValidImpl();\n            this._internal__invalidated = false;\n        }\n    }\n    _private__makeValidImpl() {\n        const priceScale = this._internal__series._internal_priceScale();\n        const timeScale = this._internal__model._internal_timeScale();\n        this._internal__clearVisibleRange();\n        if (timeScale._internal_isEmpty() || priceScale._internal_isEmpty()) {\n            return;\n        }\n        const visibleBars = timeScale._internal_visibleStrictRange();\n        if (visibleBars === null) {\n            return;\n        }\n        if (this._internal__series._internal_bars()._internal_size() === 0) {\n            return;\n        }\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return;\n        }\n        this._internal__itemsVisibleRange = visibleTimedValues(this._internal__items, visibleBars, this._private__extendedVisibleRange);\n        this._internal__convertToCoordinates(priceScale, timeScale, firstValue._internal_value);\n        this._internal__prepareRendererData();\n    }\n    constructor(series, model, extendedVisibleRange){\n        this._internal__invalidated = true;\n        this._internal__dataInvalidated = true;\n        this._internal__optionsInvalidated = true;\n        this._internal__items = [];\n        this._internal__itemsVisibleRange = null;\n        this._internal__series = series;\n        this._internal__model = model;\n        this._private__extendedVisibleRange = extendedVisibleRange;\n    }\n}\nclass LinePaneViewBase extends SeriesPaneViewBase {\n    _internal__convertToCoordinates(priceScale, timeScale, firstValue) {\n        timeScale._internal_indexesToCoordinates(this._internal__items, undefinedIfNull(this._internal__itemsVisibleRange));\n        priceScale._internal_pointsArrayToCoordinates(this._internal__items, firstValue, undefinedIfNull(this._internal__itemsVisibleRange));\n    }\n    _internal__createRawItemBase(time, price) {\n        return {\n            _internal_time: time,\n            _internal_price: price,\n            _internal_x: NaN,\n            _internal_y: NaN\n        };\n    }\n    _internal__fillRawPoints() {\n        const colorer = this._internal__series._internal_barColorer();\n        this._internal__items = this._internal__series._internal_bars()._internal_rows().map((row)=>{\n            const value = row._internal_value[3 /* PlotRowValueIndex.Close */ ];\n            return this._internal__createRawItem(row._internal_index, value, colorer);\n        });\n    }\n    constructor(series, model){\n        super(series, model, true);\n    }\n}\nclass SeriesAreaPaneView extends LinePaneViewBase {\n    _internal__createRawItem(time, price, colorer) {\n        return Object.assign(Object.assign({}, this._internal__createRawItemBase(time, price)), colorer._internal_barStyle(time));\n    }\n    _internal__prepareRendererData() {\n        const options = this._internal__series._internal_options();\n        this._private__areaRenderer._internal_setData({\n            _internal_lineType: options.lineType,\n            _internal_items: this._internal__items,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineWidth: options.lineWidth,\n            _internal_baseLevelCoordinate: null,\n            _internal_invertFilledArea: options.invertFilledArea,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: this._internal__model._internal_timeScale()._internal_barSpacing()\n        });\n        this._private__lineRenderer._internal_setData({\n            _internal_lineType: options.lineVisible ? options.lineType : undefined,\n            _internal_items: this._internal__items,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineWidth: options.lineWidth,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            _internal_pointMarkersRadius: options.pointMarkersVisible ? options.pointMarkersRadius || options.lineWidth / 2 + 2 : undefined\n        });\n    }\n    constructor(series, model){\n        super(series, model);\n        this._internal__renderer = new CompositeRenderer();\n        this._private__areaRenderer = new PaneRendererArea();\n        this._private__lineRenderer = new PaneRendererLine();\n        this._internal__renderer._internal_setRenderers([\n            this._private__areaRenderer,\n            this._private__lineRenderer\n        ]);\n    }\n}\nfunction optimalBarWidth(barSpacing, pixelRatio) {\n    return Math.floor(barSpacing * 0.3 * pixelRatio);\n}\nfunction optimalCandlestickWidth(barSpacing, pixelRatio) {\n    const barSpacingSpecialCaseFrom = 2.5;\n    const barSpacingSpecialCaseTo = 4;\n    const barSpacingSpecialCaseCoeff = 3;\n    if (barSpacing >= barSpacingSpecialCaseFrom && barSpacing <= barSpacingSpecialCaseTo) {\n        return Math.floor(barSpacingSpecialCaseCoeff * pixelRatio);\n    }\n    // coeff should be 1 on small barspacing and go to 0.8 while groing bar spacing\n    const barSpacingReducingCoeff = 0.2;\n    const coeff = 1 - barSpacingReducingCoeff * Math.atan(Math.max(barSpacingSpecialCaseTo, barSpacing) - barSpacingSpecialCaseTo) / (Math.PI * 0.5);\n    const res = Math.floor(barSpacing * coeff * pixelRatio);\n    const scaledBarSpacing = Math.floor(barSpacing * pixelRatio);\n    const optimal = Math.min(res, scaledBarSpacing);\n    return Math.max(Math.floor(pixelRatio), optimal);\n}\nclass PaneRendererBars extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    // eslint-disable-next-line complexity\n    _internal__drawImpl(param) {\n        let { context: ctx, horizontalPixelRatio, verticalPixelRatio } = param;\n        if (this._private__data === null || this._private__data._internal_bars.length === 0 || this._private__data._internal_visibleRange === null) {\n            return;\n        }\n        this._private__barWidth = this._private__calcBarWidth(horizontalPixelRatio);\n        // grid and crosshair have line width = Math.floor(pixelRatio)\n        // if this value is odd, we have to make bars' width odd\n        // if this value is even, we have to make bars' width even\n        // in order of keeping crosshair-over-bar drawing symmetric\n        if (this._private__barWidth >= 2) {\n            const lineWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n            if (lineWidth % 2 !== this._private__barWidth % 2) {\n                this._private__barWidth--;\n            }\n        }\n        // if scale is compressed, bar could become less than 1 CSS pixel\n        this._private__barLineWidth = this._private__data._internal_thinBars ? Math.min(this._private__barWidth, Math.floor(horizontalPixelRatio)) : this._private__barWidth;\n        let prevColor = null;\n        const drawOpenClose = this._private__barLineWidth <= this._private__barWidth && this._private__data._internal_barSpacing >= Math.floor(1.5 * horizontalPixelRatio);\n        for(let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; ++i){\n            const bar = this._private__data._internal_bars[i];\n            if (prevColor !== bar._internal_barColor) {\n                ctx.fillStyle = bar._internal_barColor;\n                prevColor = bar._internal_barColor;\n            }\n            const bodyWidthHalf = Math.floor(this._private__barLineWidth * 0.5);\n            const bodyCenter = Math.round(bar._internal_x * horizontalPixelRatio);\n            const bodyLeft = bodyCenter - bodyWidthHalf;\n            const bodyWidth = this._private__barLineWidth;\n            const bodyRight = bodyLeft + bodyWidth - 1;\n            const high = Math.min(bar._internal_highY, bar._internal_lowY);\n            const low = Math.max(bar._internal_highY, bar._internal_lowY);\n            const bodyTop = Math.round(high * verticalPixelRatio) - bodyWidthHalf;\n            const bodyBottom = Math.round(low * verticalPixelRatio) + bodyWidthHalf;\n            const bodyHeight = Math.max(bodyBottom - bodyTop, this._private__barLineWidth);\n            ctx.fillRect(bodyLeft, bodyTop, bodyWidth, bodyHeight);\n            const sideWidth = Math.ceil(this._private__barWidth * 1.5);\n            if (drawOpenClose) {\n                if (this._private__data._internal_openVisible) {\n                    const openLeft = bodyCenter - sideWidth;\n                    let openTop = Math.max(bodyTop, Math.round(bar._internal_openY * verticalPixelRatio) - bodyWidthHalf);\n                    let openBottom = openTop + bodyWidth - 1;\n                    if (openBottom > bodyTop + bodyHeight - 1) {\n                        openBottom = bodyTop + bodyHeight - 1;\n                        openTop = openBottom - bodyWidth + 1;\n                    }\n                    ctx.fillRect(openLeft, openTop, bodyLeft - openLeft, openBottom - openTop + 1);\n                }\n                const closeRight = bodyCenter + sideWidth;\n                let closeTop = Math.max(bodyTop, Math.round(bar._internal_closeY * verticalPixelRatio) - bodyWidthHalf);\n                let closeBottom = closeTop + bodyWidth - 1;\n                if (closeBottom > bodyTop + bodyHeight - 1) {\n                    closeBottom = bodyTop + bodyHeight - 1;\n                    closeTop = closeBottom - bodyWidth + 1;\n                }\n                ctx.fillRect(bodyRight + 1, closeTop, closeRight - bodyRight, closeBottom - closeTop + 1);\n            }\n        }\n    }\n    _private__calcBarWidth(pixelRatio) {\n        const limit = Math.floor(pixelRatio);\n        return Math.max(limit, Math.floor(optimalBarWidth(ensureNotNull(this._private__data)._internal_barSpacing, pixelRatio)));\n    }\n    constructor(){\n        super(...arguments);\n        this._private__data = null;\n        this._private__barWidth = 0;\n        this._private__barLineWidth = 0;\n    }\n}\nclass BarsPaneViewBase extends SeriesPaneViewBase {\n    _internal__convertToCoordinates(priceScale, timeScale, firstValue) {\n        timeScale._internal_indexesToCoordinates(this._internal__items, undefinedIfNull(this._internal__itemsVisibleRange));\n        priceScale._internal_barPricesToCoordinates(this._internal__items, firstValue, undefinedIfNull(this._internal__itemsVisibleRange));\n    }\n    _internal__createDefaultItem(time, bar, colorer) {\n        return {\n            _internal_time: time,\n            _internal_open: bar._internal_value[0 /* PlotRowValueIndex.Open */ ],\n            _internal_high: bar._internal_value[1 /* PlotRowValueIndex.High */ ],\n            _internal_low: bar._internal_value[2 /* PlotRowValueIndex.Low */ ],\n            _internal_close: bar._internal_value[3 /* PlotRowValueIndex.Close */ ],\n            _internal_x: NaN,\n            _internal_openY: NaN,\n            _internal_highY: NaN,\n            _internal_lowY: NaN,\n            _internal_closeY: NaN\n        };\n    }\n    _internal__fillRawPoints() {\n        const colorer = this._internal__series._internal_barColorer();\n        this._internal__items = this._internal__series._internal_bars()._internal_rows().map((row)=>this._internal__createRawItem(row._internal_index, row, colorer));\n    }\n    constructor(series, model){\n        super(series, model, false);\n    }\n}\nclass SeriesBarsPaneView extends BarsPaneViewBase {\n    _internal__createRawItem(time, bar, colorer) {\n        return Object.assign(Object.assign({}, this._internal__createDefaultItem(time, bar, colorer)), colorer._internal_barStyle(time));\n    }\n    _internal__prepareRendererData() {\n        const barStyleProps = this._internal__series._internal_options();\n        this._internal__renderer._internal_setData({\n            _internal_bars: this._internal__items,\n            _internal_barSpacing: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            _internal_openVisible: barStyleProps.openVisible,\n            _internal_thinBars: barStyleProps.thinBars,\n            _internal_visibleRange: this._internal__itemsVisibleRange\n        });\n    }\n    constructor(){\n        super(...arguments);\n        this._internal__renderer = new PaneRendererBars();\n    }\n}\nclass PaneRendererBaselineArea extends PaneRendererAreaBase {\n    _internal__fillStyle(renderingScope, item) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const data = this._internal__data;\n        return this._private__fillCache._internal_get(renderingScope, {\n            _internal_topColor1: item._internal_topFillColor1,\n            _internal_topColor2: item._internal_topFillColor2,\n            _internal_bottomColor1: item._internal_bottomFillColor1,\n            _internal_bottomColor2: item._internal_bottomFillColor2,\n            _internal_bottom: renderingScope.bitmapSize.height,\n            _internal_baseLevelCoordinate: data._internal_baseLevelCoordinate\n        });\n    }\n    constructor(){\n        super(...arguments);\n        this._private__fillCache = new GradientStyleCache();\n    }\n}\nclass PaneRendererBaselineLine extends PaneRendererLineBase {\n    _internal__strokeStyle(renderingScope, item) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const data = this._internal__data;\n        return this._private__strokeCache._internal_get(renderingScope, {\n            _internal_topColor1: item._internal_topLineColor,\n            _internal_topColor2: item._internal_topLineColor,\n            _internal_bottomColor1: item._internal_bottomLineColor,\n            _internal_bottomColor2: item._internal_bottomLineColor,\n            _internal_bottom: renderingScope.bitmapSize.height,\n            _internal_baseLevelCoordinate: data._internal_baseLevelCoordinate\n        });\n    }\n    constructor(){\n        super(...arguments);\n        this._private__strokeCache = new GradientStyleCache();\n    }\n}\nclass SeriesBaselinePaneView extends LinePaneViewBase {\n    _internal__createRawItem(time, price, colorer) {\n        return Object.assign(Object.assign({}, this._internal__createRawItemBase(time, price)), colorer._internal_barStyle(time));\n    }\n    _internal__prepareRendererData() {\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return;\n        }\n        const options = this._internal__series._internal_options();\n        const baseLevelCoordinate = this._internal__series._internal_priceScale()._internal_priceToCoordinate(options.baseValue.price, firstValue._internal_value);\n        const barWidth = this._internal__model._internal_timeScale()._internal_barSpacing();\n        this._private__baselineAreaRenderer._internal_setData({\n            _internal_items: this._internal__items,\n            _internal_lineWidth: options.lineWidth,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineType: options.lineType,\n            _internal_baseLevelCoordinate: baseLevelCoordinate,\n            _internal_invertFilledArea: false,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: barWidth\n        });\n        this._private__baselineLineRenderer._internal_setData({\n            _internal_items: this._internal__items,\n            _internal_lineWidth: options.lineWidth,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineType: options.lineVisible ? options.lineType : undefined,\n            _internal_pointMarkersRadius: options.pointMarkersVisible ? options.pointMarkersRadius || options.lineWidth / 2 + 2 : undefined,\n            _internal_baseLevelCoordinate: baseLevelCoordinate,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: barWidth\n        });\n    }\n    constructor(series, model){\n        super(series, model);\n        this._internal__renderer = new CompositeRenderer();\n        this._private__baselineAreaRenderer = new PaneRendererBaselineArea();\n        this._private__baselineLineRenderer = new PaneRendererBaselineLine();\n        this._internal__renderer._internal_setRenderers([\n            this._private__baselineAreaRenderer,\n            this._private__baselineLineRenderer\n        ]);\n    }\n}\nclass PaneRendererCandlesticks extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal__drawImpl(renderingScope) {\n        if (this._private__data === null || this._private__data._internal_bars.length === 0 || this._private__data._internal_visibleRange === null) {\n            return;\n        }\n        const { horizontalPixelRatio } = renderingScope;\n        // now we know pixelRatio and we could calculate barWidth effectively\n        this._private__barWidth = optimalCandlestickWidth(this._private__data._internal_barSpacing, horizontalPixelRatio);\n        // grid and crosshair have line width = Math.floor(pixelRatio)\n        // if this value is odd, we have to make candlesticks' width odd\n        // if this value is even, we have to make candlesticks' width even\n        // in order of keeping crosshair-over-candlesticks drawing symmetric\n        if (this._private__barWidth >= 2) {\n            const wickWidth = Math.floor(horizontalPixelRatio);\n            if (wickWidth % 2 !== this._private__barWidth % 2) {\n                this._private__barWidth--;\n            }\n        }\n        const bars = this._private__data._internal_bars;\n        if (this._private__data._internal_wickVisible) {\n            this._private__drawWicks(renderingScope, bars, this._private__data._internal_visibleRange);\n        }\n        if (this._private__data._internal_borderVisible) {\n            this._private__drawBorder(renderingScope, bars, this._private__data._internal_visibleRange);\n        }\n        const borderWidth = this._private__calculateBorderWidth(horizontalPixelRatio);\n        if (!this._private__data._internal_borderVisible || this._private__barWidth > borderWidth * 2) {\n            this._private__drawCandles(renderingScope, bars, this._private__data._internal_visibleRange);\n        }\n    }\n    _private__drawWicks(renderingScope, bars, visibleRange) {\n        if (this._private__data === null) {\n            return;\n        }\n        const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = renderingScope;\n        let prevWickColor = \"\";\n        let wickWidth = Math.min(Math.floor(horizontalPixelRatio), Math.floor(this._private__data._internal_barSpacing * horizontalPixelRatio));\n        wickWidth = Math.max(Math.floor(horizontalPixelRatio), Math.min(wickWidth, this._private__barWidth));\n        const wickOffset = Math.floor(wickWidth * 0.5);\n        let prevEdge = null;\n        for(let i = visibleRange.from; i < visibleRange.to; i++){\n            const bar = bars[i];\n            if (bar._internal_barWickColor !== prevWickColor) {\n                ctx.fillStyle = bar._internal_barWickColor;\n                prevWickColor = bar._internal_barWickColor;\n            }\n            const top = Math.round(Math.min(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            const bottom = Math.round(Math.max(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            const high = Math.round(bar._internal_highY * verticalPixelRatio);\n            const low = Math.round(bar._internal_lowY * verticalPixelRatio);\n            const scaledX = Math.round(horizontalPixelRatio * bar._internal_x);\n            let left = scaledX - wickOffset;\n            const right = left + wickWidth - 1;\n            if (prevEdge !== null) {\n                left = Math.max(prevEdge + 1, left);\n                left = Math.min(left, right);\n            }\n            const width = right - left + 1;\n            ctx.fillRect(left, high, width, top - high);\n            ctx.fillRect(left, bottom + 1, width, low - bottom);\n            prevEdge = right;\n        }\n    }\n    _private__calculateBorderWidth(pixelRatio) {\n        let borderWidth = Math.floor(1 /* Constants.BarBorderWidth */  * pixelRatio);\n        if (this._private__barWidth <= 2 * borderWidth) {\n            borderWidth = Math.floor((this._private__barWidth - 1) * 0.5);\n        }\n        const res = Math.max(Math.floor(pixelRatio), borderWidth);\n        if (this._private__barWidth <= res * 2) {\n            // do not draw bodies, restore original value\n            return Math.max(Math.floor(pixelRatio), Math.floor(1 /* Constants.BarBorderWidth */  * pixelRatio));\n        }\n        return res;\n    }\n    _private__drawBorder(renderingScope, bars, visibleRange) {\n        if (this._private__data === null) {\n            return;\n        }\n        const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = renderingScope;\n        let prevBorderColor = \"\";\n        const borderWidth = this._private__calculateBorderWidth(horizontalPixelRatio);\n        let prevEdge = null;\n        for(let i = visibleRange.from; i < visibleRange.to; i++){\n            const bar = bars[i];\n            if (bar._internal_barBorderColor !== prevBorderColor) {\n                ctx.fillStyle = bar._internal_barBorderColor;\n                prevBorderColor = bar._internal_barBorderColor;\n            }\n            let left = Math.round(bar._internal_x * horizontalPixelRatio) - Math.floor(this._private__barWidth * 0.5);\n            // this is important to calculate right before patching left\n            const right = left + this._private__barWidth - 1;\n            const top = Math.round(Math.min(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            const bottom = Math.round(Math.max(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            if (prevEdge !== null) {\n                left = Math.max(prevEdge + 1, left);\n                left = Math.min(left, right);\n            }\n            if (this._private__data._internal_barSpacing * horizontalPixelRatio > 2 * borderWidth) {\n                fillRectInnerBorder(ctx, left, top, right - left + 1, bottom - top + 1, borderWidth);\n            } else {\n                const width = right - left + 1;\n                ctx.fillRect(left, top, width, bottom - top + 1);\n            }\n            prevEdge = right;\n        }\n    }\n    _private__drawCandles(renderingScope, bars, visibleRange) {\n        if (this._private__data === null) {\n            return;\n        }\n        const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = renderingScope;\n        let prevBarColor = \"\";\n        const borderWidth = this._private__calculateBorderWidth(horizontalPixelRatio);\n        for(let i = visibleRange.from; i < visibleRange.to; i++){\n            const bar = bars[i];\n            let top = Math.round(Math.min(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            let bottom = Math.round(Math.max(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            let left = Math.round(bar._internal_x * horizontalPixelRatio) - Math.floor(this._private__barWidth * 0.5);\n            let right = left + this._private__barWidth - 1;\n            if (bar._internal_barColor !== prevBarColor) {\n                const barColor = bar._internal_barColor;\n                ctx.fillStyle = barColor;\n                prevBarColor = barColor;\n            }\n            if (this._private__data._internal_borderVisible) {\n                left += borderWidth;\n                top += borderWidth;\n                right -= borderWidth;\n                bottom -= borderWidth;\n            }\n            if (top > bottom) {\n                continue;\n            }\n            ctx.fillRect(left, top, right - left + 1, bottom - top + 1);\n        }\n    }\n    constructor(){\n        super(...arguments);\n        this._private__data = null;\n        // scaled with pixelRatio\n        this._private__barWidth = 0;\n    }\n}\nclass SeriesCandlesticksPaneView extends BarsPaneViewBase {\n    _internal__createRawItem(time, bar, colorer) {\n        return Object.assign(Object.assign({}, this._internal__createDefaultItem(time, bar, colorer)), colorer._internal_barStyle(time));\n    }\n    _internal__prepareRendererData() {\n        const candlestickStyleProps = this._internal__series._internal_options();\n        this._internal__renderer._internal_setData({\n            _internal_bars: this._internal__items,\n            _internal_barSpacing: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            _internal_wickVisible: candlestickStyleProps.wickVisible,\n            _internal_borderVisible: candlestickStyleProps.borderVisible,\n            _internal_visibleRange: this._internal__itemsVisibleRange\n        });\n    }\n    constructor(){\n        super(...arguments);\n        this._internal__renderer = new PaneRendererCandlesticks();\n    }\n}\nclass CustomSeriesPaneRendererWrapper {\n    _internal_draw(target, isHovered, hitTestData) {\n        this._private__sourceRenderer.draw(target, this._private__priceScale, isHovered, hitTestData);\n    }\n    constructor(sourceRenderer, priceScale){\n        this._private__sourceRenderer = sourceRenderer;\n        this._private__priceScale = priceScale;\n    }\n}\nclass SeriesCustomPaneView extends SeriesPaneViewBase {\n    _internal_priceValueBuilder(plotRow) {\n        return this._private__paneView.priceValueBuilder(plotRow);\n    }\n    _internal_isWhitespace(data) {\n        return this._private__paneView.isWhitespace(data);\n    }\n    _internal__fillRawPoints() {\n        const colorer = this._internal__series._internal_barColorer();\n        this._internal__items = this._internal__series._internal_bars()._internal_rows().map((row)=>{\n            return Object.assign(Object.assign({\n                _internal_time: row._internal_index,\n                _internal_x: NaN\n            }, colorer._internal_barStyle(row._internal_index)), {\n                _internal_originalData: row._internal_data\n            });\n        });\n    }\n    _internal__convertToCoordinates(priceScale, timeScale) {\n        timeScale._internal_indexesToCoordinates(this._internal__items, undefinedIfNull(this._internal__itemsVisibleRange));\n    }\n    _internal__prepareRendererData() {\n        this._private__paneView.update({\n            bars: this._internal__items.map(unwrapItemData),\n            barSpacing: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            visibleRange: this._internal__itemsVisibleRange\n        }, this._internal__series._internal_options());\n    }\n    constructor(series, model, paneView){\n        super(series, model, false);\n        this._private__paneView = paneView;\n        this._internal__renderer = new CustomSeriesPaneRendererWrapper(this._private__paneView.renderer(), (price)=>{\n            const firstValue = series._internal_firstValue();\n            if (firstValue === null) {\n                return null;\n            }\n            return series._internal_priceScale()._internal_priceToCoordinate(price, firstValue._internal_value);\n        });\n    }\n}\nfunction unwrapItemData(item) {\n    return {\n        x: item._internal_x,\n        time: item._internal_time,\n        originalData: item._internal_originalData,\n        barColor: item._internal_barColor\n    };\n}\nconst showSpacingMinimalBarWidth = 1;\nconst alignToMinimalWidthLimit = 4;\nclass PaneRendererHistogram extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n        this._private__precalculatedCache = [];\n    }\n    _internal__drawImpl(param) {\n        let { context: ctx, horizontalPixelRatio, verticalPixelRatio } = param;\n        if (this._private__data === null || this._private__data._internal_items.length === 0 || this._private__data._internal_visibleRange === null) {\n            return;\n        }\n        if (!this._private__precalculatedCache.length) {\n            this._private__fillPrecalculatedCache(horizontalPixelRatio);\n        }\n        const tickWidth = Math.max(1, Math.floor(verticalPixelRatio));\n        const histogramBase = Math.round(this._private__data._internal_histogramBase * verticalPixelRatio);\n        const topHistogramBase = histogramBase - Math.floor(tickWidth / 2);\n        const bottomHistogramBase = topHistogramBase + tickWidth;\n        for(let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++){\n            const item = this._private__data._internal_items[i];\n            const current = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from];\n            const y = Math.round(item._internal_y * verticalPixelRatio);\n            ctx.fillStyle = item._internal_barColor;\n            let top;\n            let bottom;\n            if (y <= topHistogramBase) {\n                top = y;\n                bottom = bottomHistogramBase;\n            } else {\n                top = topHistogramBase;\n                bottom = y - Math.floor(tickWidth / 2) + tickWidth;\n            }\n            ctx.fillRect(current._internal_left, top, current._internal_right - current._internal_left + 1, bottom - top);\n        }\n    }\n    // eslint-disable-next-line complexity\n    _private__fillPrecalculatedCache(pixelRatio) {\n        if (this._private__data === null || this._private__data._internal_items.length === 0 || this._private__data._internal_visibleRange === null) {\n            this._private__precalculatedCache = [];\n            return;\n        }\n        const spacing = Math.ceil(this._private__data._internal_barSpacing * pixelRatio) <= showSpacingMinimalBarWidth ? 0 : Math.max(1, Math.floor(pixelRatio));\n        const columnWidth = Math.round(this._private__data._internal_barSpacing * pixelRatio) - spacing;\n        this._private__precalculatedCache = new Array(this._private__data._internal_visibleRange.to - this._private__data._internal_visibleRange.from);\n        for(let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++){\n            const item = this._private__data._internal_items[i];\n            // force cast to avoid ensureDefined call\n            const x = Math.round(item._internal_x * pixelRatio);\n            let left;\n            let right;\n            if (columnWidth % 2) {\n                const halfWidth = (columnWidth - 1) / 2;\n                left = x - halfWidth;\n                right = x + halfWidth;\n            } else {\n                // shift pixel to left\n                const halfWidth = columnWidth / 2;\n                left = x - halfWidth;\n                right = x + halfWidth - 1;\n            }\n            this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from] = {\n                _internal_left: left,\n                _internal_right: right,\n                _internal_roundedCenter: x,\n                _internal_center: item._internal_x * pixelRatio,\n                _internal_time: item._internal_time\n            };\n        }\n        // correct positions\n        for(let i = this._private__data._internal_visibleRange.from + 1; i < this._private__data._internal_visibleRange.to; i++){\n            const current = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from];\n            const prev = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from - 1];\n            if (current._internal_time !== prev._internal_time + 1) {\n                continue;\n            }\n            if (current._internal_left - prev._internal_right !== spacing + 1) {\n                // have to align\n                if (prev._internal_roundedCenter > prev._internal_center) {\n                    // prev wasshifted to left, so add pixel to right\n                    prev._internal_right = current._internal_left - spacing - 1;\n                } else {\n                    // extend current to left\n                    current._internal_left = prev._internal_right + spacing + 1;\n                }\n            }\n        }\n        let minWidth = Math.ceil(this._private__data._internal_barSpacing * pixelRatio);\n        for(let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++){\n            const current = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from];\n            // this could happen if barspacing < 1\n            if (current._internal_right < current._internal_left) {\n                current._internal_right = current._internal_left;\n            }\n            const width = current._internal_right - current._internal_left + 1;\n            minWidth = Math.min(width, minWidth);\n        }\n        if (spacing > 0 && minWidth < alignToMinimalWidthLimit) {\n            for(let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++){\n                const current = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from];\n                const width = current._internal_right - current._internal_left + 1;\n                if (width > minWidth) {\n                    if (current._internal_roundedCenter > current._internal_center) {\n                        current._internal_right -= 1;\n                    } else {\n                        current._internal_left += 1;\n                    }\n                }\n            }\n        }\n    }\n    constructor(){\n        super(...arguments);\n        this._private__data = null;\n        this._private__precalculatedCache = [];\n    }\n}\nclass SeriesHistogramPaneView extends LinePaneViewBase {\n    _internal__createRawItem(time, price, colorer) {\n        return Object.assign(Object.assign({}, this._internal__createRawItemBase(time, price)), colorer._internal_barStyle(time));\n    }\n    _internal__prepareRendererData() {\n        const data = {\n            _internal_items: this._internal__items,\n            _internal_barSpacing: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_histogramBase: this._internal__series._internal_priceScale()._internal_priceToCoordinate(this._internal__series._internal_options().base, ensureNotNull(this._internal__series._internal_firstValue())._internal_value)\n        };\n        this._internal__renderer._internal_setData(data);\n    }\n    constructor(){\n        super(...arguments);\n        this._internal__renderer = new PaneRendererHistogram();\n    }\n}\nclass SeriesLinePaneView extends LinePaneViewBase {\n    _internal__createRawItem(time, price, colorer) {\n        return Object.assign(Object.assign({}, this._internal__createRawItemBase(time, price)), colorer._internal_barStyle(time));\n    }\n    _internal__prepareRendererData() {\n        const options = this._internal__series._internal_options();\n        const data = {\n            _internal_items: this._internal__items,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineType: options.lineVisible ? options.lineType : undefined,\n            _internal_lineWidth: options.lineWidth,\n            _internal_pointMarkersRadius: options.pointMarkersVisible ? options.pointMarkersRadius || options.lineWidth / 2 + 2 : undefined,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: this._internal__model._internal_timeScale()._internal_barSpacing()\n        };\n        this._internal__renderer._internal_setData(data);\n    }\n    constructor(){\n        super(...arguments);\n        this._internal__renderer = new PaneRendererLine();\n    }\n}\nconst defaultReplacementRe = /[2-9]/g;\nclass TextWidthCache {\n    _internal_reset() {\n        this._private__actualSize = 0;\n        this._private__cache.clear();\n        this._private__usageTick = 1;\n        this._private__oldestTick = 1;\n        this._private__tick2Labels = {};\n    }\n    _internal_measureText(ctx, text, optimizationReplacementRe) {\n        return this._private__getMetrics(ctx, text, optimizationReplacementRe).width;\n    }\n    _internal_yMidCorrection(ctx, text, optimizationReplacementRe) {\n        const metrics = this._private__getMetrics(ctx, text, optimizationReplacementRe);\n        // if actualBoundingBoxAscent/actualBoundingBoxDescent are not supported we use 0 as a fallback\n        return ((metrics.actualBoundingBoxAscent || 0) - (metrics.actualBoundingBoxDescent || 0)) / 2;\n    }\n    _private__getMetrics(ctx, text, optimizationReplacementRe) {\n        const re = optimizationReplacementRe || defaultReplacementRe;\n        const cacheString = String(text).replace(re, \"0\");\n        if (this._private__cache.has(cacheString)) {\n            return ensureDefined(this._private__cache.get(cacheString))._internal_metrics;\n        }\n        if (this._private__actualSize === this._private__maxSize) {\n            const oldestValue = this._private__tick2Labels[this._private__oldestTick];\n            delete this._private__tick2Labels[this._private__oldestTick];\n            this._private__cache.delete(oldestValue);\n            this._private__oldestTick++;\n            this._private__actualSize--;\n        }\n        ctx.save();\n        ctx.textBaseline = \"middle\";\n        const metrics = ctx.measureText(cacheString);\n        ctx.restore();\n        if (metrics.width === 0 && !!text.length) {\n            // measureText can return 0 in FF depending on a canvas size, don't cache it\n            return metrics;\n        }\n        this._private__cache.set(cacheString, {\n            _internal_metrics: metrics,\n            _internal_tick: this._private__usageTick\n        });\n        this._private__tick2Labels[this._private__usageTick] = cacheString;\n        this._private__actualSize++;\n        this._private__usageTick++;\n        return metrics;\n    }\n    constructor(size = 50){\n        this._private__actualSize = 0;\n        this._private__usageTick = 1;\n        this._private__oldestTick = 1;\n        this._private__tick2Labels = {};\n        this._private__cache = new Map();\n        this._private__maxSize = size;\n    }\n}\nclass PanePriceAxisViewRenderer {\n    _internal_setParams(priceAxisViewRenderer, rendererOptions, align) {\n        this._private__priceAxisViewRenderer = priceAxisViewRenderer;\n        this._private__rendererOptions = rendererOptions;\n        this._private__align = align;\n    }\n    _internal_draw(target) {\n        if (this._private__rendererOptions === null || this._private__priceAxisViewRenderer === null) {\n            return;\n        }\n        this._private__priceAxisViewRenderer._internal_draw(target, this._private__rendererOptions, this._private__textWidthCache, this._private__align);\n    }\n    constructor(textWidthCache){\n        this._private__priceAxisViewRenderer = null;\n        this._private__rendererOptions = null;\n        this._private__align = \"right\";\n        this._private__textWidthCache = textWidthCache;\n    }\n}\nclass PanePriceAxisView {\n    _internal_renderer() {\n        const pane = this._private__chartModel._internal_paneForSource(this._private__dataSource);\n        if (pane === null) {\n            return null;\n        }\n        // this price scale will be used to find label placement only (left, right, none)\n        const priceScale = pane._internal_isOverlay(this._private__dataSource) ? pane._internal_defaultVisiblePriceScale() : this._private__dataSource._internal_priceScale();\n        if (priceScale === null) {\n            return null;\n        }\n        const position = pane._internal_priceScalePosition(priceScale);\n        if (position === \"overlay\") {\n            return null;\n        }\n        const options = this._private__chartModel._internal_priceAxisRendererOptions();\n        if (options._internal_fontSize !== this._private__fontSize) {\n            this._private__fontSize = options._internal_fontSize;\n            this._private__textWidthCache._internal_reset();\n        }\n        this._private__renderer._internal_setParams(this._private__priceAxisView._internal_paneRenderer(), options, position);\n        return this._private__renderer;\n    }\n    constructor(priceAxisView, dataSource, chartModel){\n        this._private__priceAxisView = priceAxisView;\n        this._private__textWidthCache = new TextWidthCache(50); // when should we clear cache?\n        this._private__dataSource = dataSource;\n        this._private__chartModel = chartModel;\n        this._private__fontSize = -1;\n        this._private__renderer = new PanePriceAxisViewRenderer(this._private__textWidthCache);\n    }\n}\nclass HorizontalLineRenderer extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal_hitTest(x, y) {\n        var _a;\n        if (!((_a = this._private__data) === null || _a === void 0 ? void 0 : _a._internal_visible)) {\n            return null;\n        }\n        const { _internal_y: itemY, _internal_lineWidth: lineWidth, _internal_externalId: externalId } = this._private__data;\n        // add a fixed area threshold around line (Y + width) for hit test\n        if (y >= itemY - lineWidth - 7 /* Constants.HitTestThreshold */  && y <= itemY + lineWidth + 7 /* Constants.HitTestThreshold */ ) {\n            return {\n                _internal_hitTestData: this._private__data,\n                _internal_externalId: externalId\n            };\n        }\n        return null;\n    }\n    _internal__drawImpl(param) {\n        let { context: ctx, bitmapSize, horizontalPixelRatio, verticalPixelRatio } = param;\n        if (this._private__data === null) {\n            return;\n        }\n        if (this._private__data._internal_visible === false) {\n            return;\n        }\n        const y = Math.round(this._private__data._internal_y * verticalPixelRatio);\n        if (y < 0 || y > bitmapSize.height) {\n            return;\n        }\n        ctx.lineCap = \"butt\";\n        ctx.strokeStyle = this._private__data._internal_color;\n        ctx.lineWidth = Math.floor(this._private__data._internal_lineWidth * horizontalPixelRatio);\n        setLineStyle(ctx, this._private__data._internal_lineStyle);\n        drawHorizontalLine(ctx, y, 0, bitmapSize.width);\n    }\n    constructor(){\n        super(...arguments);\n        this._private__data = null;\n    }\n}\nclass SeriesHorizontalLinePaneView {\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_renderer() {\n        if (!this._internal__series._internal_visible()) {\n            return null;\n        }\n        if (this._private__invalidated) {\n            this._internal__updateImpl();\n            this._private__invalidated = false;\n        }\n        return this._internal__lineRenderer;\n    }\n    constructor(series){\n        this._internal__lineRendererData = {\n            _internal_y: 0,\n            _internal_color: \"rgba(0, 0, 0, 0)\",\n            _internal_lineWidth: 1,\n            _internal_lineStyle: 0 /* LineStyle.Solid */ ,\n            _internal_visible: false\n        };\n        this._internal__lineRenderer = new HorizontalLineRenderer();\n        this._private__invalidated = true;\n        this._internal__series = series;\n        this._internal__model = series._internal_model();\n        this._internal__lineRenderer._internal_setData(this._internal__lineRendererData);\n    }\n}\nclass SeriesHorizontalBaseLinePaneView extends SeriesHorizontalLinePaneView {\n    _internal__updateImpl() {\n        this._internal__lineRendererData._internal_visible = false;\n        const priceScale = this._internal__series._internal_priceScale();\n        const mode = priceScale._internal_mode()._internal_mode;\n        if (mode !== 2 /* PriceScaleMode.Percentage */  && mode !== 3 /* PriceScaleMode.IndexedTo100 */ ) {\n            return;\n        }\n        const seriesOptions = this._internal__series._internal_options();\n        if (!seriesOptions.baseLineVisible || !this._internal__series._internal_visible()) {\n            return;\n        }\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return;\n        }\n        this._internal__lineRendererData._internal_visible = true;\n        this._internal__lineRendererData._internal_y = priceScale._internal_priceToCoordinate(firstValue._internal_value, firstValue._internal_value);\n        this._internal__lineRendererData._internal_color = seriesOptions.baseLineColor;\n        this._internal__lineRendererData._internal_lineWidth = seriesOptions.baseLineWidth;\n        this._internal__lineRendererData._internal_lineStyle = seriesOptions.baseLineStyle;\n    }\n    // eslint-disable-next-line no-useless-constructor\n    constructor(series){\n        super(series);\n    }\n}\nclass SeriesLastPriceAnimationRenderer extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal_data() {\n        return this._private__data;\n    }\n    _internal__drawImpl(param) {\n        let { context: ctx, horizontalPixelRatio, verticalPixelRatio } = param;\n        const data = this._private__data;\n        if (data === null) {\n            return;\n        }\n        const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n        const correction = tickWidth % 2 / 2;\n        const centerX = Math.round(data._internal_center.x * horizontalPixelRatio) + correction; // correct x coordinate only\n        const centerY = data._internal_center.y * verticalPixelRatio;\n        ctx.fillStyle = data._internal_seriesLineColor;\n        ctx.beginPath();\n        // TODO: it is better to have different horizontal and vertical radii\n        const centerPointRadius = Math.max(2, data._internal_seriesLineWidth * 1.5) * horizontalPixelRatio;\n        ctx.arc(centerX, centerY, centerPointRadius, 0, 2 * Math.PI, false);\n        ctx.fill();\n        ctx.fillStyle = data._internal_fillColor;\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, data._internal_radius * horizontalPixelRatio, 0, 2 * Math.PI, false);\n        ctx.fill();\n        ctx.lineWidth = tickWidth;\n        ctx.strokeStyle = data._internal_strokeColor;\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, data._internal_radius * horizontalPixelRatio + tickWidth / 2, 0, 2 * Math.PI, false);\n        ctx.stroke();\n    }\n    constructor(){\n        super(...arguments);\n        this._private__data = null;\n    }\n}\nconst animationStagesData = [\n    {\n        _internal_start: 0,\n        _internal_end: 0.25 /* Constants.Stage1Period */ ,\n        _internal_startRadius: 4 /* Constants.Stage1StartCircleRadius */ ,\n        _internal_endRadius: 10 /* Constants.Stage1EndCircleRadius */ ,\n        _internal_startFillAlpha: 0.25 /* Constants.Stage1StartFillAlpha */ ,\n        _internal_endFillAlpha: 0 /* Constants.Stage1EndFillAlpha */ ,\n        _internal_startStrokeAlpha: 0.4 /* Constants.Stage1StartStrokeAlpha */ ,\n        _internal_endStrokeAlpha: 0.8 /* Constants.Stage1EndStrokeAlpha */ \n    },\n    {\n        _internal_start: 0.25 /* Constants.Stage1Period */ ,\n        _internal_end: 0.25 /* Constants.Stage1Period */  + 0.275 /* Constants.Stage2Period */ ,\n        _internal_startRadius: 10 /* Constants.Stage2StartCircleRadius */ ,\n        _internal_endRadius: 14 /* Constants.Stage2EndCircleRadius */ ,\n        _internal_startFillAlpha: 0 /* Constants.Stage2StartFillAlpha */ ,\n        _internal_endFillAlpha: 0 /* Constants.Stage2EndFillAlpha */ ,\n        _internal_startStrokeAlpha: 0.8 /* Constants.Stage2StartStrokeAlpha */ ,\n        _internal_endStrokeAlpha: 0 /* Constants.Stage2EndStrokeAlpha */ \n    },\n    {\n        _internal_start: 0.25 /* Constants.Stage1Period */  + 0.275 /* Constants.Stage2Period */ ,\n        _internal_end: 0.25 /* Constants.Stage1Period */  + 0.275 /* Constants.Stage2Period */  + 0.475 /* Constants.Stage3Period */ ,\n        _internal_startRadius: 14 /* Constants.Stage3StartCircleRadius */ ,\n        _internal_endRadius: 14 /* Constants.Stage3EndCircleRadius */ ,\n        _internal_startFillAlpha: 0 /* Constants.Stage3StartFillAlpha */ ,\n        _internal_endFillAlpha: 0 /* Constants.Stage3EndFillAlpha */ ,\n        _internal_startStrokeAlpha: 0 /* Constants.Stage3StartStrokeAlpha */ ,\n        _internal_endStrokeAlpha: 0 /* Constants.Stage3EndStrokeAlpha */ \n    }\n];\nfunction color(seriesLineColor, stage, startAlpha, endAlpha) {\n    const alpha = startAlpha + (endAlpha - startAlpha) * stage;\n    return applyAlpha(seriesLineColor, alpha);\n}\nfunction radius(stage, startRadius, endRadius) {\n    return startRadius + (endRadius - startRadius) * stage;\n}\nfunction animationData(durationSinceStart, lineColor) {\n    const globalStage = durationSinceStart % 2600 /* Constants.AnimationPeriod */  / 2600 /* Constants.AnimationPeriod */ ;\n    let currentStageData;\n    for (const stageData of animationStagesData){\n        if (globalStage >= stageData._internal_start && globalStage <= stageData._internal_end) {\n            currentStageData = stageData;\n            break;\n        }\n    }\n    assert(currentStageData !== undefined, \"Last price animation internal logic error\");\n    const subStage = (globalStage - currentStageData._internal_start) / (currentStageData._internal_end - currentStageData._internal_start);\n    return {\n        _internal_fillColor: color(lineColor, subStage, currentStageData._internal_startFillAlpha, currentStageData._internal_endFillAlpha),\n        _internal_strokeColor: color(lineColor, subStage, currentStageData._internal_startStrokeAlpha, currentStageData._internal_endStrokeAlpha),\n        _internal_radius: radius(subStage, currentStageData._internal_startRadius, currentStageData._internal_endRadius)\n    };\n}\nclass SeriesLastPriceAnimationPaneView {\n    _internal_onDataCleared() {\n        this._private__endTime = this._private__startTime - 1;\n        this._internal_update();\n    }\n    _internal_onNewRealtimeDataReceived() {\n        this._internal_update();\n        if (this._private__series._internal_options().lastPriceAnimation === 2 /* LastPriceAnimationMode.OnDataUpdate */ ) {\n            const now = performance.now();\n            const timeToAnimationEnd = this._private__endTime - now;\n            if (timeToAnimationEnd > 0) {\n                if (timeToAnimationEnd < 2600 /* Constants.AnimationPeriod */  / 4) {\n                    this._private__endTime += 2600 /* Constants.AnimationPeriod */ ;\n                }\n                return;\n            }\n            this._private__startTime = now;\n            this._private__endTime = now + 2600 /* Constants.AnimationPeriod */ ;\n        }\n    }\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_invalidateStage() {\n        this._private__stageInvalidated = true;\n    }\n    _internal_visible() {\n        // center point is always visible if lastPriceAnimation is not LastPriceAnimationMode.Disabled\n        return this._private__series._internal_options().lastPriceAnimation !== 0 /* LastPriceAnimationMode.Disabled */ ;\n    }\n    _internal_animationActive() {\n        switch(this._private__series._internal_options().lastPriceAnimation){\n            case 0 /* LastPriceAnimationMode.Disabled */ :\n                return false;\n            case 1 /* LastPriceAnimationMode.Continuous */ :\n                return true;\n            case 2 /* LastPriceAnimationMode.OnDataUpdate */ :\n                return performance.now() <= this._private__endTime;\n        }\n    }\n    _internal_renderer() {\n        if (this._private__invalidated) {\n            this._private__updateImpl();\n            this._private__invalidated = false;\n            this._private__stageInvalidated = false;\n        } else if (this._private__stageInvalidated) {\n            this._private__updateRendererDataStage();\n            this._private__stageInvalidated = false;\n        }\n        return this._private__renderer;\n    }\n    _private__updateImpl() {\n        this._private__renderer._internal_setData(null);\n        const timeScale = this._private__series._internal_model()._internal_timeScale();\n        const visibleRange = timeScale._internal_visibleStrictRange();\n        const firstValue = this._private__series._internal_firstValue();\n        if (visibleRange === null || firstValue === null) {\n            return;\n        }\n        const lastValue = this._private__series._internal_lastValueData(true);\n        if (lastValue._internal_noData || !visibleRange._internal_contains(lastValue._internal_index)) {\n            return;\n        }\n        const lastValuePoint = {\n            x: timeScale._internal_indexToCoordinate(lastValue._internal_index),\n            y: this._private__series._internal_priceScale()._internal_priceToCoordinate(lastValue._internal_price, firstValue._internal_value)\n        };\n        const seriesLineColor = lastValue._internal_color;\n        const seriesLineWidth = this._private__series._internal_options().lineWidth;\n        const data = animationData(this._private__duration(), seriesLineColor);\n        this._private__renderer._internal_setData({\n            _internal_seriesLineColor: seriesLineColor,\n            _internal_seriesLineWidth: seriesLineWidth,\n            _internal_fillColor: data._internal_fillColor,\n            _internal_strokeColor: data._internal_strokeColor,\n            _internal_radius: data._internal_radius,\n            _internal_center: lastValuePoint\n        });\n    }\n    _private__updateRendererDataStage() {\n        const rendererData = this._private__renderer._internal_data();\n        if (rendererData !== null) {\n            const data = animationData(this._private__duration(), rendererData._internal_seriesLineColor);\n            rendererData._internal_fillColor = data._internal_fillColor;\n            rendererData._internal_strokeColor = data._internal_strokeColor;\n            rendererData._internal_radius = data._internal_radius;\n        }\n    }\n    _private__duration() {\n        return this._internal_animationActive() ? performance.now() - this._private__startTime : 2600 /* Constants.AnimationPeriod */  - 1;\n    }\n    constructor(series){\n        this._private__renderer = new SeriesLastPriceAnimationRenderer();\n        this._private__invalidated = true;\n        this._private__stageInvalidated = true;\n        this._private__startTime = performance.now();\n        this._private__endTime = this._private__startTime - 1;\n        this._private__series = series;\n    }\n}\nfunction size(barSpacing, coeff) {\n    const result = Math.min(Math.max(barSpacing, 12 /* Constants.MinShapeSize */ ), 30 /* Constants.MaxShapeSize */ ) * coeff;\n    return ceiledOdd(result);\n}\nfunction shapeSize(shape, originalSize) {\n    switch(shape){\n        case \"arrowDown\":\n        case \"arrowUp\":\n            return size(originalSize, 1);\n        case \"circle\":\n            return size(originalSize, 0.8);\n        case \"square\":\n            return size(originalSize, 0.7);\n    }\n}\nfunction calculateShapeHeight(barSpacing) {\n    return ceiledEven(size(barSpacing, 1));\n}\nfunction shapeMargin(barSpacing) {\n    return Math.max(size(barSpacing, 0.1), 3 /* Constants.MinShapeMargin */ );\n}\nfunction drawSquare(ctx, centerX, centerY, size) {\n    const squareSize = shapeSize(\"square\", size);\n    const halfSize = (squareSize - 1) / 2;\n    const left = centerX - halfSize;\n    const top = centerY - halfSize;\n    ctx.fillRect(left, top, squareSize, squareSize);\n}\nfunction hitTestSquare(centerX, centerY, size, x, y) {\n    const squareSize = shapeSize(\"square\", size);\n    const halfSize = (squareSize - 1) / 2;\n    const left = centerX - halfSize;\n    const top = centerY - halfSize;\n    return x >= left && x <= left + squareSize && y >= top && y <= top + squareSize;\n}\nfunction drawArrow(up, ctx, centerX, centerY, size) {\n    const arrowSize = shapeSize(\"arrowUp\", size);\n    const halfArrowSize = (arrowSize - 1) / 2;\n    const baseSize = ceiledOdd(size / 2);\n    const halfBaseSize = (baseSize - 1) / 2;\n    ctx.beginPath();\n    if (up) {\n        ctx.moveTo(centerX - halfArrowSize, centerY);\n        ctx.lineTo(centerX, centerY - halfArrowSize);\n        ctx.lineTo(centerX + halfArrowSize, centerY);\n        ctx.lineTo(centerX + halfBaseSize, centerY);\n        ctx.lineTo(centerX + halfBaseSize, centerY + halfArrowSize);\n        ctx.lineTo(centerX - halfBaseSize, centerY + halfArrowSize);\n        ctx.lineTo(centerX - halfBaseSize, centerY);\n    } else {\n        ctx.moveTo(centerX - halfArrowSize, centerY);\n        ctx.lineTo(centerX, centerY + halfArrowSize);\n        ctx.lineTo(centerX + halfArrowSize, centerY);\n        ctx.lineTo(centerX + halfBaseSize, centerY);\n        ctx.lineTo(centerX + halfBaseSize, centerY - halfArrowSize);\n        ctx.lineTo(centerX - halfBaseSize, centerY - halfArrowSize);\n        ctx.lineTo(centerX - halfBaseSize, centerY);\n    }\n    ctx.fill();\n}\nfunction hitTestArrow(up, centerX, centerY, size, x, y) {\n    // TODO: implement arrow hit test\n    return hitTestSquare(centerX, centerY, size, x, y);\n}\nfunction drawCircle(ctx, centerX, centerY, size) {\n    const circleSize = shapeSize(\"circle\", size);\n    const halfSize = (circleSize - 1) / 2;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, halfSize, 0, 2 * Math.PI, false);\n    ctx.fill();\n}\nfunction hitTestCircle(centerX, centerY, size, x, y) {\n    const circleSize = shapeSize(\"circle\", size);\n    const tolerance = 2 + circleSize / 2;\n    const xOffset = centerX - x;\n    const yOffset = centerY - y;\n    const dist = Math.sqrt(xOffset * xOffset + yOffset * yOffset);\n    return dist <= tolerance;\n}\nfunction drawText(ctx, text, x, y) {\n    ctx.fillText(text, x, y);\n}\nfunction hitTestText(textX, textY, textWidth, textHeight, x, y) {\n    const halfHeight = textHeight / 2;\n    return x >= textX && x <= textX + textWidth && y >= textY - halfHeight && y <= textY + halfHeight;\n}\nclass SeriesMarkersRenderer extends MediaCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal_setParams(fontSize, fontFamily) {\n        if (this._private__fontSize !== fontSize || this._private__fontFamily !== fontFamily) {\n            this._private__fontSize = fontSize;\n            this._private__fontFamily = fontFamily;\n            this._private__font = makeFont(fontSize, fontFamily);\n            this._private__textWidthCache._internal_reset();\n        }\n    }\n    _internal_hitTest(x, y) {\n        if (this._private__data === null || this._private__data._internal_visibleRange === null) {\n            return null;\n        }\n        for(let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++){\n            const item = this._private__data._internal_items[i];\n            if (hitTestItem(item, x, y)) {\n                return {\n                    _internal_hitTestData: item._internal_internalId,\n                    _internal_externalId: item._internal_externalId\n                };\n            }\n        }\n        return null;\n    }\n    _internal__drawImpl(param, isHovered, hitTestData) {\n        let { context: ctx } = param;\n        if (this._private__data === null || this._private__data._internal_visibleRange === null) {\n            return;\n        }\n        ctx.textBaseline = \"middle\";\n        ctx.font = this._private__font;\n        for(let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++){\n            const item = this._private__data._internal_items[i];\n            if (item._internal_text !== undefined) {\n                item._internal_text._internal_width = this._private__textWidthCache._internal_measureText(ctx, item._internal_text._internal_content);\n                item._internal_text._internal_height = this._private__fontSize;\n                item._internal_text._internal_x = item._internal_x - item._internal_text._internal_width / 2;\n            }\n            drawItem(item, ctx);\n        }\n    }\n    constructor(){\n        super(...arguments);\n        this._private__data = null;\n        this._private__textWidthCache = new TextWidthCache();\n        this._private__fontSize = -1;\n        this._private__fontFamily = \"\";\n        this._private__font = \"\";\n    }\n}\nfunction drawItem(item, ctx) {\n    ctx.fillStyle = item._internal_color;\n    if (item._internal_text !== undefined) {\n        drawText(ctx, item._internal_text._internal_content, item._internal_text._internal_x, item._internal_text._internal_y);\n    }\n    drawShape(item, ctx);\n}\nfunction drawShape(item, ctx) {\n    if (item._internal_size === 0) {\n        return;\n    }\n    switch(item._internal_shape){\n        case \"arrowDown\":\n            drawArrow(false, ctx, item._internal_x, item._internal_y, item._internal_size);\n            return;\n        case \"arrowUp\":\n            drawArrow(true, ctx, item._internal_x, item._internal_y, item._internal_size);\n            return;\n        case \"circle\":\n            drawCircle(ctx, item._internal_x, item._internal_y, item._internal_size);\n            return;\n        case \"square\":\n            drawSquare(ctx, item._internal_x, item._internal_y, item._internal_size);\n            return;\n    }\n    ensureNever(item._internal_shape);\n}\nfunction hitTestItem(item, x, y) {\n    if (item._internal_text !== undefined && hitTestText(item._internal_text._internal_x, item._internal_text._internal_y, item._internal_text._internal_width, item._internal_text._internal_height, x, y)) {\n        return true;\n    }\n    return hitTestShape(item, x, y);\n}\nfunction hitTestShape(item, x, y) {\n    if (item._internal_size === 0) {\n        return false;\n    }\n    switch(item._internal_shape){\n        case \"arrowDown\":\n            return hitTestArrow(true, item._internal_x, item._internal_y, item._internal_size, x, y);\n        case \"arrowUp\":\n            return hitTestArrow(false, item._internal_x, item._internal_y, item._internal_size, x, y);\n        case \"circle\":\n            return hitTestCircle(item._internal_x, item._internal_y, item._internal_size, x, y);\n        case \"square\":\n            return hitTestSquare(item._internal_x, item._internal_y, item._internal_size, x, y);\n    }\n}\n// eslint-disable-next-line max-params\nfunction fillSizeAndY(rendererItem, marker, seriesData, offsets, textHeight, shapeMargin, priceScale, timeScale, firstValue) {\n    const inBarPrice = isNumber(seriesData) ? seriesData : seriesData._internal_close;\n    const highPrice = isNumber(seriesData) ? seriesData : seriesData._internal_high;\n    const lowPrice = isNumber(seriesData) ? seriesData : seriesData._internal_low;\n    const sizeMultiplier = isNumber(marker.size) ? Math.max(marker.size, 0) : 1;\n    const shapeSize = calculateShapeHeight(timeScale._internal_barSpacing()) * sizeMultiplier;\n    const halfSize = shapeSize / 2;\n    rendererItem._internal_size = shapeSize;\n    switch(marker.position){\n        case \"inBar\":\n            {\n                rendererItem._internal_y = priceScale._internal_priceToCoordinate(inBarPrice, firstValue);\n                if (rendererItem._internal_text !== undefined) {\n                    rendererItem._internal_text._internal_y = rendererItem._internal_y + halfSize + shapeMargin + textHeight * (0.5 + 0.1 /* Constants.TextMargin */ );\n                }\n                return;\n            }\n        case \"aboveBar\":\n            {\n                rendererItem._internal_y = priceScale._internal_priceToCoordinate(highPrice, firstValue) - halfSize - offsets._internal_aboveBar;\n                if (rendererItem._internal_text !== undefined) {\n                    rendererItem._internal_text._internal_y = rendererItem._internal_y - halfSize - textHeight * (0.5 + 0.1 /* Constants.TextMargin */ );\n                    offsets._internal_aboveBar += textHeight * (1 + 2 * 0.1 /* Constants.TextMargin */ );\n                }\n                offsets._internal_aboveBar += shapeSize + shapeMargin;\n                return;\n            }\n        case \"belowBar\":\n            {\n                rendererItem._internal_y = priceScale._internal_priceToCoordinate(lowPrice, firstValue) + halfSize + offsets._internal_belowBar;\n                if (rendererItem._internal_text !== undefined) {\n                    rendererItem._internal_text._internal_y = rendererItem._internal_y + halfSize + shapeMargin + textHeight * (0.5 + 0.1 /* Constants.TextMargin */ );\n                    offsets._internal_belowBar += textHeight * (1 + 2 * 0.1 /* Constants.TextMargin */ );\n                }\n                offsets._internal_belowBar += shapeSize + shapeMargin;\n                return;\n            }\n    }\n    ensureNever(marker.position);\n}\nclass SeriesMarkersPaneView {\n    _internal_update(updateType) {\n        this._private__invalidated = true;\n        this._private__autoScaleMarginsInvalidated = true;\n        if (updateType === \"data\") {\n            this._private__dataInvalidated = true;\n        }\n    }\n    _internal_renderer(addAnchors) {\n        if (!this._private__series._internal_visible()) {\n            return null;\n        }\n        if (this._private__invalidated) {\n            this._internal__makeValid();\n        }\n        const layout = this._private__model._internal_options().layout;\n        this._private__renderer._internal_setParams(layout.fontSize, layout.fontFamily);\n        this._private__renderer._internal_setData(this._private__data);\n        return this._private__renderer;\n    }\n    _internal_autoScaleMargins() {\n        if (this._private__autoScaleMarginsInvalidated) {\n            if (this._private__series._internal_indexedMarkers().length > 0) {\n                const barSpacing = this._private__model._internal_timeScale()._internal_barSpacing();\n                const shapeMargin$1 = shapeMargin(barSpacing);\n                const marginsAboveAndBelow = calculateShapeHeight(barSpacing) * 1.5 + shapeMargin$1 * 2;\n                this._private__autoScaleMargins = {\n                    above: marginsAboveAndBelow,\n                    below: marginsAboveAndBelow\n                };\n            } else {\n                this._private__autoScaleMargins = null;\n            }\n            this._private__autoScaleMarginsInvalidated = false;\n        }\n        return this._private__autoScaleMargins;\n    }\n    _internal__makeValid() {\n        const priceScale = this._private__series._internal_priceScale();\n        const timeScale = this._private__model._internal_timeScale();\n        const seriesMarkers = this._private__series._internal_indexedMarkers();\n        if (this._private__dataInvalidated) {\n            this._private__data._internal_items = seriesMarkers.map((marker)=>({\n                    _internal_time: marker.time,\n                    _internal_x: 0,\n                    _internal_y: 0,\n                    _internal_size: 0,\n                    _internal_shape: marker.shape,\n                    _internal_color: marker.color,\n                    _internal_internalId: marker._internal_internalId,\n                    _internal_externalId: marker.id,\n                    _internal_text: undefined\n                }));\n            this._private__dataInvalidated = false;\n        }\n        const layoutOptions = this._private__model._internal_options().layout;\n        this._private__data._internal_visibleRange = null;\n        const visibleBars = timeScale._internal_visibleStrictRange();\n        if (visibleBars === null) {\n            return;\n        }\n        const firstValue = this._private__series._internal_firstValue();\n        if (firstValue === null) {\n            return;\n        }\n        if (this._private__data._internal_items.length === 0) {\n            return;\n        }\n        let prevTimeIndex = NaN;\n        const shapeMargin$1 = shapeMargin(timeScale._internal_barSpacing());\n        const offsets = {\n            _internal_aboveBar: shapeMargin$1,\n            _internal_belowBar: shapeMargin$1\n        };\n        this._private__data._internal_visibleRange = visibleTimedValues(this._private__data._internal_items, visibleBars, true);\n        for(let index = this._private__data._internal_visibleRange.from; index < this._private__data._internal_visibleRange.to; index++){\n            const marker = seriesMarkers[index];\n            if (marker.time !== prevTimeIndex) {\n                // new bar, reset stack counter\n                offsets._internal_aboveBar = shapeMargin$1;\n                offsets._internal_belowBar = shapeMargin$1;\n                prevTimeIndex = marker.time;\n            }\n            const rendererItem = this._private__data._internal_items[index];\n            rendererItem._internal_x = timeScale._internal_indexToCoordinate(marker.time);\n            if (marker.text !== undefined && marker.text.length > 0) {\n                rendererItem._internal_text = {\n                    _internal_content: marker.text,\n                    _internal_x: 0,\n                    _internal_y: 0,\n                    _internal_width: 0,\n                    _internal_height: 0\n                };\n            }\n            const dataAt = this._private__series._internal_dataAt(marker.time);\n            if (dataAt === null) {\n                continue;\n            }\n            fillSizeAndY(rendererItem, marker, dataAt, offsets, layoutOptions.fontSize, shapeMargin$1, priceScale, timeScale, firstValue._internal_value);\n        }\n        this._private__invalidated = false;\n    }\n    constructor(series, model){\n        this._private__invalidated = true;\n        this._private__dataInvalidated = true;\n        this._private__autoScaleMarginsInvalidated = true;\n        this._private__autoScaleMargins = null;\n        this._private__renderer = new SeriesMarkersRenderer();\n        this._private__series = series;\n        this._private__model = model;\n        this._private__data = {\n            _internal_items: [],\n            _internal_visibleRange: null\n        };\n    }\n}\nclass SeriesPriceLinePaneView extends SeriesHorizontalLinePaneView {\n    _internal__updateImpl() {\n        const data = this._internal__lineRendererData;\n        data._internal_visible = false;\n        const seriesOptions = this._internal__series._internal_options();\n        if (!seriesOptions.priceLineVisible || !this._internal__series._internal_visible()) {\n            return;\n        }\n        const lastValueData = this._internal__series._internal_lastValueData(seriesOptions.priceLineSource === 0 /* PriceLineSource.LastBar */ );\n        if (lastValueData._internal_noData) {\n            return;\n        }\n        data._internal_visible = true;\n        data._internal_y = lastValueData._internal_coordinate;\n        data._internal_color = this._internal__series._internal_priceLineColor(lastValueData._internal_color);\n        data._internal_lineWidth = seriesOptions.priceLineWidth;\n        data._internal_lineStyle = seriesOptions.priceLineStyle;\n    }\n    // eslint-disable-next-line no-useless-constructor\n    constructor(series){\n        super(series);\n    }\n}\nclass SeriesPriceAxisView extends PriceAxisView {\n    _internal__updateRendererData(axisRendererData, paneRendererData, commonRendererData) {\n        axisRendererData._internal_visible = false;\n        paneRendererData._internal_visible = false;\n        const source = this._private__source;\n        if (!source._internal_visible()) {\n            return;\n        }\n        const seriesOptions = source._internal_options();\n        const showSeriesLastValue = seriesOptions.lastValueVisible;\n        const showSymbolLabel = source._internal_title() !== \"\";\n        const showPriceAndPercentage = seriesOptions.seriesLastValueMode === 0 /* PriceAxisLastValueMode.LastPriceAndPercentageValue */ ;\n        const lastValueData = source._internal_lastValueData(false);\n        if (lastValueData._internal_noData) {\n            return;\n        }\n        if (showSeriesLastValue) {\n            axisRendererData._internal_text = this._internal__axisText(lastValueData, showSeriesLastValue, showPriceAndPercentage);\n            axisRendererData._internal_visible = axisRendererData._internal_text.length !== 0;\n        }\n        if (showSymbolLabel || showPriceAndPercentage) {\n            paneRendererData._internal_text = this._internal__paneText(lastValueData, showSeriesLastValue, showSymbolLabel, showPriceAndPercentage);\n            paneRendererData._internal_visible = paneRendererData._internal_text.length > 0;\n        }\n        const lastValueColor = source._internal_priceLineColor(lastValueData._internal_color);\n        const colors = generateContrastColors(lastValueColor);\n        commonRendererData._internal_background = colors._internal_background;\n        commonRendererData._internal_coordinate = lastValueData._internal_coordinate;\n        paneRendererData._internal_borderColor = source._internal_model()._internal_backgroundColorAtYPercentFromTop(lastValueData._internal_coordinate / source._internal_priceScale()._internal_height());\n        axisRendererData._internal_borderColor = lastValueColor;\n        axisRendererData._internal_color = colors._internal_foreground;\n        paneRendererData._internal_color = colors._internal_foreground;\n    }\n    _internal__paneText(lastValue, showSeriesLastValue, showSymbolLabel, showPriceAndPercentage) {\n        let result = \"\";\n        const title = this._private__source._internal_title();\n        if (showSymbolLabel && title.length !== 0) {\n            result += \"\".concat(title, \" \");\n        }\n        if (showSeriesLastValue && showPriceAndPercentage) {\n            result += this._private__source._internal_priceScale()._internal_isPercentage() ? lastValue._internal_formattedPriceAbsolute : lastValue._internal_formattedPricePercentage;\n        }\n        return result.trim();\n    }\n    _internal__axisText(lastValueData, showSeriesLastValue, showPriceAndPercentage) {\n        if (!showSeriesLastValue) {\n            return \"\";\n        }\n        if (!showPriceAndPercentage) {\n            return lastValueData._internal_text;\n        }\n        return this._private__source._internal_priceScale()._internal_isPercentage() ? lastValueData._internal_formattedPricePercentage : lastValueData._internal_formattedPriceAbsolute;\n    }\n    constructor(source){\n        super();\n        this._private__source = source;\n    }\n}\nfunction computeFiniteResult(method, valueOne, valueTwo, fallback) {\n    const firstFinite = Number.isFinite(valueOne);\n    const secondFinite = Number.isFinite(valueTwo);\n    if (firstFinite && secondFinite) {\n        return method(valueOne, valueTwo);\n    }\n    return !firstFinite && !secondFinite ? fallback : firstFinite ? valueOne : valueTwo;\n}\nclass PriceRangeImpl {\n    _internal_equals(pr) {\n        if (pr === null) {\n            return false;\n        }\n        return this._private__minValue === pr._private__minValue && this._private__maxValue === pr._private__maxValue;\n    }\n    _internal_clone() {\n        return new PriceRangeImpl(this._private__minValue, this._private__maxValue);\n    }\n    _internal_minValue() {\n        return this._private__minValue;\n    }\n    _internal_maxValue() {\n        return this._private__maxValue;\n    }\n    _internal_length() {\n        return this._private__maxValue - this._private__minValue;\n    }\n    _internal_isEmpty() {\n        return this._private__maxValue === this._private__minValue || Number.isNaN(this._private__maxValue) || Number.isNaN(this._private__minValue);\n    }\n    _internal_merge(anotherRange) {\n        if (anotherRange === null) {\n            return this;\n        }\n        return new PriceRangeImpl(computeFiniteResult(Math.min, this._internal_minValue(), anotherRange._internal_minValue(), -Infinity), computeFiniteResult(Math.max, this._internal_maxValue(), anotherRange._internal_maxValue(), Infinity));\n    }\n    _internal_scaleAroundCenter(coeff) {\n        if (!isNumber(coeff)) {\n            return;\n        }\n        const delta = this._private__maxValue - this._private__minValue;\n        if (delta === 0) {\n            return;\n        }\n        const center = (this._private__maxValue + this._private__minValue) * 0.5;\n        let maxDelta = this._private__maxValue - center;\n        let minDelta = this._private__minValue - center;\n        maxDelta *= coeff;\n        minDelta *= coeff;\n        this._private__maxValue = center + maxDelta;\n        this._private__minValue = center + minDelta;\n    }\n    _internal_shift(delta) {\n        if (!isNumber(delta)) {\n            return;\n        }\n        this._private__maxValue += delta;\n        this._private__minValue += delta;\n    }\n    _internal_toRaw() {\n        return {\n            minValue: this._private__minValue,\n            maxValue: this._private__maxValue\n        };\n    }\n    static _internal_fromRaw(raw) {\n        return raw === null ? null : new PriceRangeImpl(raw.minValue, raw.maxValue);\n    }\n    constructor(minValue, maxValue){\n        this._private__minValue = minValue;\n        this._private__maxValue = maxValue;\n    }\n}\nclass AutoscaleInfoImpl {\n    _internal_priceRange() {\n        return this._private__priceRange;\n    }\n    _internal_margins() {\n        return this._private__margins;\n    }\n    _internal_toRaw() {\n        if (this._private__priceRange === null) {\n            return null;\n        }\n        return {\n            priceRange: this._private__priceRange._internal_toRaw(),\n            margins: this._private__margins || undefined\n        };\n    }\n    static _internal_fromRaw(raw) {\n        return raw === null ? null : new AutoscaleInfoImpl(PriceRangeImpl._internal_fromRaw(raw.priceRange), raw.margins);\n    }\n    constructor(priceRange, margins){\n        this._private__priceRange = priceRange;\n        this._private__margins = margins || null;\n    }\n}\nclass CustomPriceLinePaneView extends SeriesHorizontalLinePaneView {\n    _internal__updateImpl() {\n        const data = this._internal__lineRendererData;\n        data._internal_visible = false;\n        const lineOptions = this._private__priceLine._internal_options();\n        if (!this._internal__series._internal_visible() || !lineOptions.lineVisible) {\n            return;\n        }\n        const y = this._private__priceLine._internal_yCoord();\n        if (y === null) {\n            return;\n        }\n        data._internal_visible = true;\n        data._internal_y = y;\n        data._internal_color = lineOptions.color;\n        data._internal_lineWidth = lineOptions.lineWidth;\n        data._internal_lineStyle = lineOptions.lineStyle;\n        data._internal_externalId = this._private__priceLine._internal_options().id;\n    }\n    constructor(series, priceLine){\n        super(series);\n        this._private__priceLine = priceLine;\n    }\n}\nclass CustomPriceLinePriceAxisView extends PriceAxisView {\n    _internal__updateRendererData(axisRendererData, paneRendererData, commonData) {\n        axisRendererData._internal_visible = false;\n        paneRendererData._internal_visible = false;\n        const options = this._private__priceLine._internal_options();\n        const labelVisible = options.axisLabelVisible;\n        const showPaneLabel = options.title !== \"\";\n        const series = this._private__series;\n        if (!labelVisible || !series._internal_visible()) {\n            return;\n        }\n        const y = this._private__priceLine._internal_yCoord();\n        if (y === null) {\n            return;\n        }\n        if (showPaneLabel) {\n            paneRendererData._internal_text = options.title;\n            paneRendererData._internal_visible = true;\n        }\n        paneRendererData._internal_borderColor = series._internal_model()._internal_backgroundColorAtYPercentFromTop(y / series._internal_priceScale()._internal_height());\n        axisRendererData._internal_text = this._private__formatPrice(options.price);\n        axisRendererData._internal_visible = true;\n        const colors = generateContrastColors(options.axisLabelColor || options.color);\n        commonData._internal_background = colors._internal_background;\n        const textColor = options.axisLabelTextColor || colors._internal_foreground;\n        axisRendererData._internal_color = textColor; // price text\n        paneRendererData._internal_color = textColor; // title text\n        commonData._internal_coordinate = y;\n    }\n    _private__formatPrice(price) {\n        const firstValue = this._private__series._internal_firstValue();\n        if (firstValue === null) {\n            return \"\";\n        }\n        return this._private__series._internal_priceScale()._internal_formatPrice(price, firstValue._internal_value);\n    }\n    constructor(series, priceLine){\n        super();\n        this._private__series = series;\n        this._private__priceLine = priceLine;\n    }\n}\nclass CustomPriceLine {\n    _internal_applyOptions(options) {\n        merge(this._private__options, options);\n        this._internal_update();\n        this._private__series._internal_model()._internal_lightUpdate();\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_paneView() {\n        return this._private__priceLineView;\n    }\n    _internal_labelPaneView() {\n        return this._private__panePriceAxisView;\n    }\n    _internal_priceAxisView() {\n        return this._private__priceAxisView;\n    }\n    _internal_update() {\n        this._private__priceLineView._internal_update();\n        this._private__priceAxisView._internal_update();\n    }\n    _internal_yCoord() {\n        const series = this._private__series;\n        const priceScale = series._internal_priceScale();\n        const timeScale = series._internal_model()._internal_timeScale();\n        if (timeScale._internal_isEmpty() || priceScale._internal_isEmpty()) {\n            return null;\n        }\n        const firstValue = series._internal_firstValue();\n        if (firstValue === null) {\n            return null;\n        }\n        return priceScale._internal_priceToCoordinate(this._private__options.price, firstValue._internal_value);\n    }\n    constructor(series, options){\n        this._private__series = series;\n        this._private__options = options;\n        this._private__priceLineView = new CustomPriceLinePaneView(series, this);\n        this._private__priceAxisView = new CustomPriceLinePriceAxisView(series, this);\n        this._private__panePriceAxisView = new PanePriceAxisView(this._private__priceAxisView, series, series._internal_model());\n    }\n}\nclass PriceDataSource extends DataSource {\n    _internal_model() {\n        return this._private__model;\n    }\n    constructor(model){\n        super();\n        this._private__model = model;\n    }\n}\nconst barStyleFnMap = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Bar: (findBar, barStyle, barIndex, precomputedBars)=>{\n        var _a;\n        const upColor = barStyle.upColor;\n        const downColor = barStyle.downColor;\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        const isUp = ensure(currentBar._internal_value[0 /* PlotRowValueIndex.Open */ ]) <= ensure(currentBar._internal_value[3 /* PlotRowValueIndex.Close */ ]);\n        return {\n            _internal_barColor: (_a = currentBar._internal_color) !== null && _a !== void 0 ? _a : isUp ? upColor : downColor\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Candlestick: (findBar, candlestickStyle, barIndex, precomputedBars)=>{\n        var _a, _b, _c;\n        const upColor = candlestickStyle.upColor;\n        const downColor = candlestickStyle.downColor;\n        const borderUpColor = candlestickStyle.borderUpColor;\n        const borderDownColor = candlestickStyle.borderDownColor;\n        const wickUpColor = candlestickStyle.wickUpColor;\n        const wickDownColor = candlestickStyle.wickDownColor;\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        const isUp = ensure(currentBar._internal_value[0 /* PlotRowValueIndex.Open */ ]) <= ensure(currentBar._internal_value[3 /* PlotRowValueIndex.Close */ ]);\n        return {\n            _internal_barColor: (_a = currentBar._internal_color) !== null && _a !== void 0 ? _a : isUp ? upColor : downColor,\n            _internal_barBorderColor: (_b = currentBar._internal_borderColor) !== null && _b !== void 0 ? _b : isUp ? borderUpColor : borderDownColor,\n            _internal_barWickColor: (_c = currentBar._internal_wickColor) !== null && _c !== void 0 ? _c : isUp ? wickUpColor : wickDownColor\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Custom: (findBar, customStyle, barIndex, precomputedBars)=>{\n        var _a;\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        return {\n            _internal_barColor: (_a = currentBar._internal_color) !== null && _a !== void 0 ? _a : customStyle.color\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Area: (findBar, areaStyle, barIndex, precomputedBars)=>{\n        var _a, _b, _c, _d;\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        return {\n            _internal_barColor: (_a = currentBar._internal_lineColor) !== null && _a !== void 0 ? _a : areaStyle.lineColor,\n            _internal_lineColor: (_b = currentBar._internal_lineColor) !== null && _b !== void 0 ? _b : areaStyle.lineColor,\n            _internal_topColor: (_c = currentBar._internal_topColor) !== null && _c !== void 0 ? _c : areaStyle.topColor,\n            _internal_bottomColor: (_d = currentBar._internal_bottomColor) !== null && _d !== void 0 ? _d : areaStyle.bottomColor\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Baseline: (findBar, baselineStyle, barIndex, precomputedBars)=>{\n        var _a, _b, _c, _d, _e, _f;\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        const isAboveBaseline = currentBar._internal_value[3 /* PlotRowValueIndex.Close */ ] >= baselineStyle.baseValue.price;\n        return {\n            _internal_barColor: isAboveBaseline ? baselineStyle.topLineColor : baselineStyle.bottomLineColor,\n            _internal_topLineColor: (_a = currentBar._internal_topLineColor) !== null && _a !== void 0 ? _a : baselineStyle.topLineColor,\n            _internal_bottomLineColor: (_b = currentBar._internal_bottomLineColor) !== null && _b !== void 0 ? _b : baselineStyle.bottomLineColor,\n            _internal_topFillColor1: (_c = currentBar._internal_topFillColor1) !== null && _c !== void 0 ? _c : baselineStyle.topFillColor1,\n            _internal_topFillColor2: (_d = currentBar._internal_topFillColor2) !== null && _d !== void 0 ? _d : baselineStyle.topFillColor2,\n            _internal_bottomFillColor1: (_e = currentBar._internal_bottomFillColor1) !== null && _e !== void 0 ? _e : baselineStyle.bottomFillColor1,\n            _internal_bottomFillColor2: (_f = currentBar._internal_bottomFillColor2) !== null && _f !== void 0 ? _f : baselineStyle.bottomFillColor2\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Line: (findBar, lineStyle, barIndex, precomputedBars)=>{\n        var _a, _b;\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        return {\n            _internal_barColor: (_a = currentBar._internal_color) !== null && _a !== void 0 ? _a : lineStyle.color,\n            _internal_lineColor: (_b = currentBar._internal_color) !== null && _b !== void 0 ? _b : lineStyle.color\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Histogram: (findBar, histogramStyle, barIndex, precomputedBars)=>{\n        var _a;\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        return {\n            _internal_barColor: (_a = currentBar._internal_color) !== null && _a !== void 0 ? _a : histogramStyle.color\n        };\n    }\n};\nclass SeriesBarColorer {\n    _internal_barStyle(barIndex, precomputedBars) {\n        // precomputedBars: {value: [Array BarValues], previousValue: [Array BarValues] | undefined}\n        // Used to avoid binary search if bars are already known\n        return this._private__styleGetter(this._private__findBar, this._private__series._internal_options(), barIndex, precomputedBars);\n    }\n    constructor(series){\n        this._private__findBar = (barIndex, precomputedBars)=>{\n            if (precomputedBars !== undefined) {\n                return precomputedBars._internal_value;\n            }\n            return this._private__series._internal_bars()._internal_valueAt(barIndex);\n        };\n        this._private__series = series;\n        this._private__styleGetter = barStyleFnMap[series._internal_seriesType()];\n    }\n}\n/**\n * Search direction if no data found at provided index\n */ var MismatchDirection;\n(function(MismatchDirection) {\n    /**\n     * Search the nearest left item\n     */ MismatchDirection[MismatchDirection[\"NearestLeft\"] = -1] = \"NearestLeft\";\n    /**\n     * Do not search\n     */ MismatchDirection[MismatchDirection[\"None\"] = 0] = \"None\";\n    /**\n     * Search the nearest right item\n     */ MismatchDirection[MismatchDirection[\"NearestRight\"] = 1] = \"NearestRight\";\n})(MismatchDirection || (MismatchDirection = {}));\n// TODO: think about changing it dynamically\nconst CHUNK_SIZE = 30;\n/**\n * PlotList is an array of plot rows\n * each plot row consists of key (index in timescale) and plot value map\n */ class PlotList {\n    // @returns Last row\n    _internal_last() {\n        return this._internal_size() > 0 ? this._private__items[this._private__items.length - 1] : null;\n    }\n    _internal_firstIndex() {\n        return this._internal_size() > 0 ? this._private__indexAt(0) : null;\n    }\n    _internal_lastIndex() {\n        return this._internal_size() > 0 ? this._private__indexAt(this._private__items.length - 1) : null;\n    }\n    _internal_size() {\n        return this._private__items.length;\n    }\n    _internal_isEmpty() {\n        return this._internal_size() === 0;\n    }\n    _internal_contains(index) {\n        return this._private__search(index, 0 /* MismatchDirection.None */ ) !== null;\n    }\n    _internal_valueAt(index) {\n        return this._internal_search(index);\n    }\n    _internal_search(index) {\n        let searchMode = arguments.length > 1 && arguments[1] !== void 0 /* MismatchDirection.None */  ? arguments[1] : 0;\n        const pos = this._private__search(index, searchMode);\n        if (pos === null) {\n            return null;\n        }\n        return Object.assign(Object.assign({}, this._private__valueAt(pos)), {\n            _internal_index: this._private__indexAt(pos)\n        });\n    }\n    _internal_rows() {\n        return this._private__items;\n    }\n    _internal_minMaxOnRangeCached(start, end, plots) {\n        // this code works for single series only\n        // could fail after whitespaces implementation\n        if (this._internal_isEmpty()) {\n            return null;\n        }\n        let result = null;\n        for (const plot of plots){\n            const plotMinMax = this._private__minMaxOnRangeCachedImpl(start, end, plot);\n            result = mergeMinMax(result, plotMinMax);\n        }\n        return result;\n    }\n    _internal_setData(plotRows) {\n        this._private__rowSearchCache.clear();\n        this._private__minMaxCache.clear();\n        this._private__items = plotRows;\n    }\n    _private__indexAt(offset) {\n        return this._private__items[offset]._internal_index;\n    }\n    _private__valueAt(offset) {\n        return this._private__items[offset];\n    }\n    _private__search(index, searchMode) {\n        const exactPos = this._private__bsearch(index);\n        if (exactPos === null && searchMode !== 0 /* MismatchDirection.None */ ) {\n            switch(searchMode){\n                case -1 /* MismatchDirection.NearestLeft */ :\n                    return this._private__searchNearestLeft(index);\n                case 1 /* MismatchDirection.NearestRight */ :\n                    return this._private__searchNearestRight(index);\n                default:\n                    throw new TypeError(\"Unknown search mode\");\n            }\n        }\n        return exactPos;\n    }\n    _private__searchNearestLeft(index) {\n        let nearestLeftPos = this._private__lowerbound(index);\n        if (nearestLeftPos > 0) {\n            nearestLeftPos = nearestLeftPos - 1;\n        }\n        return nearestLeftPos !== this._private__items.length && this._private__indexAt(nearestLeftPos) < index ? nearestLeftPos : null;\n    }\n    _private__searchNearestRight(index) {\n        const nearestRightPos = this._private__upperbound(index);\n        return nearestRightPos !== this._private__items.length && index < this._private__indexAt(nearestRightPos) ? nearestRightPos : null;\n    }\n    _private__bsearch(index) {\n        const start = this._private__lowerbound(index);\n        if (start !== this._private__items.length && !(index < this._private__items[start]._internal_index)) {\n            return start;\n        }\n        return null;\n    }\n    _private__lowerbound(index) {\n        return lowerBound(this._private__items, index, (a, b)=>a._internal_index < b);\n    }\n    _private__upperbound(index) {\n        return upperBound(this._private__items, index, (a, b)=>a._internal_index > b);\n    }\n    _private__plotMinMax(startIndex, endIndexExclusive, plotIndex) {\n        let result = null;\n        for(let i = startIndex; i < endIndexExclusive; i++){\n            const values = this._private__items[i]._internal_value;\n            const v = values[plotIndex];\n            if (Number.isNaN(v)) {\n                continue;\n            }\n            if (result === null) {\n                result = {\n                    _internal_min: v,\n                    _internal_max: v\n                };\n            } else {\n                if (v < result._internal_min) {\n                    result._internal_min = v;\n                }\n                if (v > result._internal_max) {\n                    result._internal_max = v;\n                }\n            }\n        }\n        return result;\n    }\n    _private__minMaxOnRangeCachedImpl(start, end, plotIndex) {\n        // this code works for single series only\n        // could fail after whitespaces implementation\n        if (this._internal_isEmpty()) {\n            return null;\n        }\n        let result = null;\n        // assume that bar indexes only increase\n        const firstIndex = ensureNotNull(this._internal_firstIndex());\n        const lastIndex = ensureNotNull(this._internal_lastIndex());\n        const s = Math.max(start, firstIndex);\n        const e = Math.min(end, lastIndex);\n        const cachedLow = Math.ceil(s / CHUNK_SIZE) * CHUNK_SIZE;\n        const cachedHigh = Math.max(cachedLow, Math.floor(e / CHUNK_SIZE) * CHUNK_SIZE);\n        {\n            const startIndex = this._private__lowerbound(s);\n            const endIndex = this._private__upperbound(Math.min(e, cachedLow, end)); // non-inclusive end\n            const plotMinMax = this._private__plotMinMax(startIndex, endIndex, plotIndex);\n            result = mergeMinMax(result, plotMinMax);\n        }\n        let minMaxCache = this._private__minMaxCache.get(plotIndex);\n        if (minMaxCache === undefined) {\n            minMaxCache = new Map();\n            this._private__minMaxCache.set(plotIndex, minMaxCache);\n        }\n        // now go cached\n        for(let c = Math.max(cachedLow + 1, s); c < cachedHigh; c += CHUNK_SIZE){\n            const chunkIndex = Math.floor(c / CHUNK_SIZE);\n            let chunkMinMax = minMaxCache.get(chunkIndex);\n            if (chunkMinMax === undefined) {\n                const chunkStart = this._private__lowerbound(chunkIndex * CHUNK_SIZE);\n                const chunkEnd = this._private__upperbound((chunkIndex + 1) * CHUNK_SIZE - 1);\n                chunkMinMax = this._private__plotMinMax(chunkStart, chunkEnd, plotIndex);\n                minMaxCache.set(chunkIndex, chunkMinMax);\n            }\n            result = mergeMinMax(result, chunkMinMax);\n        }\n        // tail\n        {\n            const startIndex = this._private__lowerbound(cachedHigh);\n            const endIndex = this._private__upperbound(e); // non-inclusive end\n            const plotMinMax = this._private__plotMinMax(startIndex, endIndex, plotIndex);\n            result = mergeMinMax(result, plotMinMax);\n        }\n        return result;\n    }\n    constructor(){\n        this._private__items = [];\n        this._private__minMaxCache = new Map();\n        this._private__rowSearchCache = new Map();\n    }\n}\nfunction mergeMinMax(first, second) {\n    if (first === null) {\n        return second;\n    } else {\n        if (second === null) {\n            return first;\n        } else {\n            // merge MinMax values\n            const min = Math.min(first._internal_min, second._internal_min);\n            const max = Math.max(first._internal_max, second._internal_max);\n            return {\n                _internal_min: min,\n                _internal_max: max\n            };\n        }\n    }\n}\nfunction createSeriesPlotList() {\n    return new PlotList();\n}\nclass SeriesPrimitiveRendererWrapper {\n    _internal_draw(target, isHovered, hitTestData) {\n        this._private__baseRenderer.draw(target);\n    }\n    _internal_drawBackground(target, isHovered, hitTestData) {\n        var _a, _b;\n        (_b = (_a = this._private__baseRenderer).drawBackground) === null || _b === void 0 ? void 0 : _b.call(_a, target);\n    }\n    constructor(baseRenderer){\n        this._private__baseRenderer = baseRenderer;\n    }\n}\nclass SeriesPrimitivePaneViewWrapper {\n    _internal_renderer() {\n        var _a;\n        const baseRenderer = this._private__paneView.renderer();\n        if (baseRenderer === null) {\n            return null;\n        }\n        if (((_a = this._private__cache) === null || _a === void 0 ? void 0 : _a._internal_base) === baseRenderer) {\n            return this._private__cache._internal_wrapper;\n        }\n        const wrapper = new SeriesPrimitiveRendererWrapper(baseRenderer);\n        this._private__cache = {\n            _internal_base: baseRenderer,\n            _internal_wrapper: wrapper\n        };\n        return wrapper;\n    }\n    _internal_zOrder() {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = this._private__paneView).zOrder) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : \"normal\";\n    }\n    constructor(paneView){\n        this._private__cache = null;\n        this._private__paneView = paneView;\n    }\n}\nfunction getAxisViewData(baseView) {\n    var _a, _b, _c, _d, _e;\n    return {\n        _internal_text: baseView.text(),\n        _internal_coordinate: baseView.coordinate(),\n        _internal_fixedCoordinate: (_a = baseView.fixedCoordinate) === null || _a === void 0 ? void 0 : _a.call(baseView),\n        _internal_color: baseView.textColor(),\n        _internal_background: baseView.backColor(),\n        _internal_visible: (_c = (_b = baseView.visible) === null || _b === void 0 ? void 0 : _b.call(baseView)) !== null && _c !== void 0 ? _c : true,\n        _internal_tickVisible: (_e = (_d = baseView.tickVisible) === null || _d === void 0 ? void 0 : _d.call(baseView)) !== null && _e !== void 0 ? _e : true\n    };\n}\nclass SeriesPrimitiveTimeAxisViewWrapper {\n    _internal_renderer() {\n        this._private__renderer._internal_setData(Object.assign({\n            _internal_width: this._private__timeScale._internal_width()\n        }, getAxisViewData(this._private__baseView)));\n        return this._private__renderer;\n    }\n    constructor(baseView, timeScale){\n        this._private__renderer = new TimeAxisViewRenderer();\n        this._private__baseView = baseView;\n        this._private__timeScale = timeScale;\n    }\n}\nclass SeriesPrimitivePriceAxisViewWrapper extends PriceAxisView {\n    _internal__updateRendererData(axisRendererData, paneRendererData, commonRendererData) {\n        const data = getAxisViewData(this._private__baseView);\n        commonRendererData._internal_background = data._internal_background;\n        axisRendererData._internal_color = data._internal_color;\n        const additionalPadding = 2 / 12 * this._private__priceScale._internal_fontSize();\n        commonRendererData._internal_additionalPaddingTop = additionalPadding;\n        commonRendererData._internal_additionalPaddingBottom = additionalPadding;\n        commonRendererData._internal_coordinate = data._internal_coordinate;\n        commonRendererData._internal_fixedCoordinate = data._internal_fixedCoordinate;\n        axisRendererData._internal_text = data._internal_text;\n        axisRendererData._internal_visible = data._internal_visible;\n        axisRendererData._internal_tickVisible = data._internal_tickVisible;\n    }\n    constructor(baseView, priceScale){\n        super();\n        this._private__baseView = baseView;\n        this._private__priceScale = priceScale;\n    }\n}\nclass SeriesPrimitiveWrapper {\n    _internal_primitive() {\n        return this._private__primitive;\n    }\n    _internal_updateAllViews() {\n        var _a, _b;\n        (_b = (_a = this._private__primitive).updateAllViews) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    _internal_paneViews() {\n        var _a, _b, _c, _d;\n        const base = (_c = (_b = (_a = this._private__primitive).paneViews) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : [];\n        if (((_d = this._private__paneViewsCache) === null || _d === void 0 ? void 0 : _d._internal_base) === base) {\n            return this._private__paneViewsCache._internal_wrapper;\n        }\n        const wrapper = base.map((pw)=>new SeriesPrimitivePaneViewWrapper(pw));\n        this._private__paneViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper\n        };\n        return wrapper;\n    }\n    _internal_timeAxisViews() {\n        var _a, _b, _c, _d;\n        const base = (_c = (_b = (_a = this._private__primitive).timeAxisViews) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : [];\n        if (((_d = this._private__timeAxisViewsCache) === null || _d === void 0 ? void 0 : _d._internal_base) === base) {\n            return this._private__timeAxisViewsCache._internal_wrapper;\n        }\n        const timeScale = this._private__series._internal_model()._internal_timeScale();\n        const wrapper = base.map((aw)=>new SeriesPrimitiveTimeAxisViewWrapper(aw, timeScale));\n        this._private__timeAxisViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper\n        };\n        return wrapper;\n    }\n    _internal_priceAxisViews() {\n        var _a, _b, _c, _d;\n        const base = (_c = (_b = (_a = this._private__primitive).priceAxisViews) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : [];\n        if (((_d = this._private__priceAxisViewsCache) === null || _d === void 0 ? void 0 : _d._internal_base) === base) {\n            return this._private__priceAxisViewsCache._internal_wrapper;\n        }\n        const priceScale = this._private__series._internal_priceScale();\n        const wrapper = base.map((aw)=>new SeriesPrimitivePriceAxisViewWrapper(aw, priceScale));\n        this._private__priceAxisViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper\n        };\n        return wrapper;\n    }\n    _internal_priceAxisPaneViews() {\n        var _a, _b, _c, _d;\n        const base = (_c = (_b = (_a = this._private__primitive).priceAxisPaneViews) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : [];\n        if (((_d = this._private__priceAxisPaneViewsCache) === null || _d === void 0 ? void 0 : _d._internal_base) === base) {\n            return this._private__priceAxisPaneViewsCache._internal_wrapper;\n        }\n        const wrapper = base.map((pw)=>new SeriesPrimitivePaneViewWrapper(pw));\n        this._private__priceAxisPaneViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper\n        };\n        return wrapper;\n    }\n    _internal_timeAxisPaneViews() {\n        var _a, _b, _c, _d;\n        const base = (_c = (_b = (_a = this._private__primitive).timeAxisPaneViews) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : [];\n        if (((_d = this._private__timeAxisPaneViewsCache) === null || _d === void 0 ? void 0 : _d._internal_base) === base) {\n            return this._private__timeAxisPaneViewsCache._internal_wrapper;\n        }\n        const wrapper = base.map((pw)=>new SeriesPrimitivePaneViewWrapper(pw));\n        this._private__timeAxisPaneViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper\n        };\n        return wrapper;\n    }\n    _internal_autoscaleInfo(startTimePoint, endTimePoint) {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = this._private__primitive).autoscaleInfo) === null || _b === void 0 ? void 0 : _b.call(_a, startTimePoint, endTimePoint)) !== null && _c !== void 0 ? _c : null;\n    }\n    _internal_hitTest(x, y) {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = this._private__primitive).hitTest) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)) !== null && _c !== void 0 ? _c : null;\n    }\n    constructor(primitive, series){\n        this._private__paneViewsCache = null;\n        this._private__timeAxisViewsCache = null;\n        this._private__priceAxisViewsCache = null;\n        this._private__priceAxisPaneViewsCache = null;\n        this._private__timeAxisPaneViewsCache = null;\n        this._private__primitive = primitive;\n        this._private__series = series;\n    }\n}\nfunction extractPrimitivePaneViews(primitives, extractor, zOrder, destination) {\n    primitives.forEach((wrapper)=>{\n        extractor(wrapper).forEach((paneView)=>{\n            if (paneView._internal_zOrder() !== zOrder) {\n                return;\n            }\n            destination.push(paneView);\n        });\n    });\n}\nfunction primitivePaneViewsExtractor(wrapper) {\n    return wrapper._internal_paneViews();\n}\nfunction primitivePricePaneViewsExtractor(wrapper) {\n    return wrapper._internal_priceAxisPaneViews();\n}\nfunction primitiveTimePaneViewsExtractor(wrapper) {\n    return wrapper._internal_timeAxisPaneViews();\n}\nclass Series extends PriceDataSource {\n    _internal_destroy() {\n        if (this._private__animationTimeoutId !== null) {\n            clearTimeout(this._private__animationTimeoutId);\n        }\n    }\n    _internal_priceLineColor(lastBarColor) {\n        return this._private__options.priceLineColor || lastBarColor;\n    }\n    _internal_lastValueData(globalLast) {\n        const noDataRes = {\n            _internal_noData: true\n        };\n        const priceScale = this._internal_priceScale();\n        if (this._internal_model()._internal_timeScale()._internal_isEmpty() || priceScale._internal_isEmpty() || this._private__data._internal_isEmpty()) {\n            return noDataRes;\n        }\n        const visibleBars = this._internal_model()._internal_timeScale()._internal_visibleStrictRange();\n        const firstValue = this._internal_firstValue();\n        if (visibleBars === null || firstValue === null) {\n            return noDataRes;\n        }\n        // find range of bars inside range\n        // TODO: make it more optimal\n        let bar;\n        let lastIndex;\n        if (globalLast) {\n            const lastBar = this._private__data._internal_last();\n            if (lastBar === null) {\n                return noDataRes;\n            }\n            bar = lastBar;\n            lastIndex = lastBar._internal_index;\n        } else {\n            const endBar = this._private__data._internal_search(visibleBars._internal_right(), -1 /* MismatchDirection.NearestLeft */ );\n            if (endBar === null) {\n                return noDataRes;\n            }\n            bar = this._private__data._internal_valueAt(endBar._internal_index);\n            if (bar === null) {\n                return noDataRes;\n            }\n            lastIndex = endBar._internal_index;\n        }\n        const price = bar._internal_value[3 /* PlotRowValueIndex.Close */ ];\n        const barColorer = this._internal_barColorer();\n        const style = barColorer._internal_barStyle(lastIndex, {\n            _internal_value: bar\n        });\n        const coordinate = priceScale._internal_priceToCoordinate(price, firstValue._internal_value);\n        return {\n            _internal_noData: false,\n            _internal_price: price,\n            _internal_text: priceScale._internal_formatPrice(price, firstValue._internal_value),\n            _internal_formattedPriceAbsolute: priceScale._internal_formatPriceAbsolute(price),\n            _internal_formattedPricePercentage: priceScale._internal_formatPricePercentage(price, firstValue._internal_value),\n            _internal_color: style._internal_barColor,\n            _internal_coordinate: coordinate,\n            _internal_index: lastIndex\n        };\n    }\n    _internal_barColorer() {\n        if (this._private__barColorerCache !== null) {\n            return this._private__barColorerCache;\n        }\n        this._private__barColorerCache = new SeriesBarColorer(this);\n        return this._private__barColorerCache;\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_applyOptions(options) {\n        const targetPriceScaleId = options.priceScaleId;\n        if (targetPriceScaleId !== undefined && targetPriceScaleId !== this._private__options.priceScaleId) {\n            // series cannot do it itself, ask model\n            this._internal_model()._internal_moveSeriesToScale(this, targetPriceScaleId);\n        }\n        merge(this._private__options, options);\n        if (options.priceFormat !== undefined) {\n            this._private__recreateFormatter();\n            // updated formatter might affect rendering  and as a consequence of this the width of price axis might be changed\n            // thus we need to force the chart to do a full update to apply changes correctly\n            // full update is quite heavy operation in terms of performance\n            // but updating formatter looks like quite rare so forcing a full update here shouldn't affect the performance a lot\n            this._internal_model()._internal_fullUpdate();\n        }\n        this._internal_model()._internal_updateSource(this);\n        // a series might affect crosshair by some options (like crosshair markers)\n        // that's why we need to update crosshair as well\n        this._internal_model()._internal_updateCrosshair();\n        this._private__paneView._internal_update(\"options\");\n    }\n    _internal_setData(data, updateInfo) {\n        this._private__data._internal_setData(data);\n        this._private__recalculateMarkers();\n        this._private__paneView._internal_update(\"data\");\n        this._private__markersPaneView._internal_update(\"data\");\n        if (this._private__lastPriceAnimationPaneView !== null) {\n            if (updateInfo && updateInfo._internal_lastBarUpdatedOrNewBarsAddedToTheRight) {\n                this._private__lastPriceAnimationPaneView._internal_onNewRealtimeDataReceived();\n            } else if (data.length === 0) {\n                this._private__lastPriceAnimationPaneView._internal_onDataCleared();\n            }\n        }\n        const sourcePane = this._internal_model()._internal_paneForSource(this);\n        this._internal_model()._internal_recalculatePane(sourcePane);\n        this._internal_model()._internal_updateSource(this);\n        this._internal_model()._internal_updateCrosshair();\n        this._internal_model()._internal_lightUpdate();\n    }\n    _internal_setMarkers(data) {\n        this._private__markers = data;\n        this._private__recalculateMarkers();\n        const sourcePane = this._internal_model()._internal_paneForSource(this);\n        this._private__markersPaneView._internal_update(\"data\");\n        this._internal_model()._internal_recalculatePane(sourcePane);\n        this._internal_model()._internal_updateSource(this);\n        this._internal_model()._internal_updateCrosshair();\n        this._internal_model()._internal_lightUpdate();\n    }\n    _internal_markers() {\n        return this._private__markers;\n    }\n    _internal_indexedMarkers() {\n        return this._private__indexedMarkers;\n    }\n    _internal_createPriceLine(options) {\n        const result = new CustomPriceLine(this, options);\n        this._private__customPriceLines.push(result);\n        this._internal_model()._internal_updateSource(this);\n        return result;\n    }\n    _internal_removePriceLine(line) {\n        const index = this._private__customPriceLines.indexOf(line);\n        if (index !== -1) {\n            this._private__customPriceLines.splice(index, 1);\n        }\n        this._internal_model()._internal_updateSource(this);\n    }\n    _internal_seriesType() {\n        return this._private__seriesType;\n    }\n    _internal_firstValue() {\n        const bar = this._internal_firstBar();\n        if (bar === null) {\n            return null;\n        }\n        return {\n            _internal_value: bar._internal_value[3 /* PlotRowValueIndex.Close */ ],\n            _internal_timePoint: bar._internal_time\n        };\n    }\n    _internal_firstBar() {\n        const visibleBars = this._internal_model()._internal_timeScale()._internal_visibleStrictRange();\n        if (visibleBars === null) {\n            return null;\n        }\n        const startTimePoint = visibleBars._internal_left();\n        return this._private__data._internal_search(startTimePoint, 1 /* MismatchDirection.NearestRight */ );\n    }\n    _internal_bars() {\n        return this._private__data;\n    }\n    _internal_dataAt(time) {\n        const prices = this._private__data._internal_valueAt(time);\n        if (prices === null) {\n            return null;\n        }\n        if (this._private__seriesType === \"Bar\" || this._private__seriesType === \"Candlestick\" || this._private__seriesType === \"Custom\") {\n            return {\n                _internal_open: prices._internal_value[0 /* PlotRowValueIndex.Open */ ],\n                _internal_high: prices._internal_value[1 /* PlotRowValueIndex.High */ ],\n                _internal_low: prices._internal_value[2 /* PlotRowValueIndex.Low */ ],\n                _internal_close: prices._internal_value[3 /* PlotRowValueIndex.Close */ ]\n            };\n        } else {\n            return prices._internal_value[3 /* PlotRowValueIndex.Close */ ];\n        }\n    }\n    _internal_topPaneViews(pane) {\n        const res = [];\n        extractPrimitivePaneViews(this._private__primitives, primitivePaneViewsExtractor, \"top\", res);\n        const animationPaneView = this._private__lastPriceAnimationPaneView;\n        if (animationPaneView === null || !animationPaneView._internal_visible()) {\n            return res;\n        }\n        if (this._private__animationTimeoutId === null && animationPaneView._internal_animationActive()) {\n            this._private__animationTimeoutId = setTimeout(()=>{\n                this._private__animationTimeoutId = null;\n                this._internal_model()._internal_cursorUpdate();\n            }, 0);\n        }\n        animationPaneView._internal_invalidateStage();\n        res.push(animationPaneView);\n        return res;\n    }\n    _internal_paneViews() {\n        const res = [];\n        if (!this._private__isOverlay()) {\n            res.push(this._private__baseHorizontalLineView);\n        }\n        res.push(this._private__paneView, this._private__priceLineView, this._private__markersPaneView);\n        const priceLineViews = this._private__customPriceLines.map((line)=>line._internal_paneView());\n        res.push(...priceLineViews);\n        extractPrimitivePaneViews(this._private__primitives, primitivePaneViewsExtractor, \"normal\", res);\n        return res;\n    }\n    _internal_bottomPaneViews() {\n        return this._private__extractPaneViews(primitivePaneViewsExtractor, \"bottom\");\n    }\n    _internal_pricePaneViews(zOrder) {\n        return this._private__extractPaneViews(primitivePricePaneViewsExtractor, zOrder);\n    }\n    _internal_timePaneViews(zOrder) {\n        return this._private__extractPaneViews(primitiveTimePaneViewsExtractor, zOrder);\n    }\n    _internal_primitiveHitTest(x, y) {\n        return this._private__primitives.map((primitive)=>primitive._internal_hitTest(x, y)).filter((result)=>result !== null);\n    }\n    _internal_labelPaneViews(pane) {\n        return [\n            this._private__panePriceAxisView,\n            ...this._private__customPriceLines.map((line)=>line._internal_labelPaneView())\n        ];\n    }\n    _internal_priceAxisViews(pane, priceScale) {\n        if (priceScale !== this._internal__priceScale && !this._private__isOverlay()) {\n            return [];\n        }\n        const result = [\n            ...this._private__priceAxisViews\n        ];\n        for (const customPriceLine of this._private__customPriceLines){\n            result.push(customPriceLine._internal_priceAxisView());\n        }\n        this._private__primitives.forEach((wrapper)=>{\n            result.push(...wrapper._internal_priceAxisViews());\n        });\n        return result;\n    }\n    _internal_timeAxisViews() {\n        const res = [];\n        this._private__primitives.forEach((wrapper)=>{\n            res.push(...wrapper._internal_timeAxisViews());\n        });\n        return res;\n    }\n    _internal_autoscaleInfo(startTimePoint, endTimePoint) {\n        if (this._private__options.autoscaleInfoProvider !== undefined) {\n            const autoscaleInfo = this._private__options.autoscaleInfoProvider(()=>{\n                const res = this._private__autoscaleInfoImpl(startTimePoint, endTimePoint);\n                return res === null ? null : res._internal_toRaw();\n            });\n            return AutoscaleInfoImpl._internal_fromRaw(autoscaleInfo);\n        }\n        return this._private__autoscaleInfoImpl(startTimePoint, endTimePoint);\n    }\n    _internal_minMove() {\n        return this._private__options.priceFormat.minMove;\n    }\n    _internal_formatter() {\n        return this._private__formatter;\n    }\n    _internal_updateAllViews() {\n        var _a;\n        this._private__paneView._internal_update();\n        this._private__markersPaneView._internal_update();\n        for (const priceAxisView of this._private__priceAxisViews){\n            priceAxisView._internal_update();\n        }\n        for (const customPriceLine of this._private__customPriceLines){\n            customPriceLine._internal_update();\n        }\n        this._private__priceLineView._internal_update();\n        this._private__baseHorizontalLineView._internal_update();\n        (_a = this._private__lastPriceAnimationPaneView) === null || _a === void 0 ? void 0 : _a._internal_update();\n        this._private__primitives.forEach((wrapper)=>wrapper._internal_updateAllViews());\n    }\n    _internal_priceScale() {\n        return ensureNotNull(super._internal_priceScale());\n    }\n    _internal_markerDataAtIndex(index) {\n        const getValue = (this._private__seriesType === \"Line\" || this._private__seriesType === \"Area\" || this._private__seriesType === \"Baseline\") && this._private__options.crosshairMarkerVisible;\n        if (!getValue) {\n            return null;\n        }\n        const bar = this._private__data._internal_valueAt(index);\n        if (bar === null) {\n            return null;\n        }\n        const price = bar._internal_value[3 /* PlotRowValueIndex.Close */ ];\n        const radius = this._private__markerRadius();\n        const borderColor = this._private__markerBorderColor();\n        const borderWidth = this._private__markerBorderWidth();\n        const backgroundColor = this._private__markerBackgroundColor(index);\n        return {\n            _internal_price: price,\n            _internal_radius: radius,\n            _internal_borderColor: borderColor,\n            _internal_borderWidth: borderWidth,\n            _internal_backgroundColor: backgroundColor\n        };\n    }\n    _internal_title() {\n        return this._private__options.title;\n    }\n    _internal_visible() {\n        return this._private__options.visible;\n    }\n    _internal_attachPrimitive(primitive) {\n        this._private__primitives.push(new SeriesPrimitiveWrapper(primitive, this));\n    }\n    _internal_detachPrimitive(source) {\n        this._private__primitives = this._private__primitives.filter((wrapper)=>wrapper._internal_primitive() !== source);\n    }\n    _internal_customSeriesPlotValuesBuilder() {\n        if (this._private__paneView instanceof SeriesCustomPaneView === false) {\n            return undefined;\n        }\n        return (data)=>{\n            return this._private__paneView._internal_priceValueBuilder(data);\n        };\n    }\n    _internal_customSeriesWhitespaceCheck() {\n        if (this._private__paneView instanceof SeriesCustomPaneView === false) {\n            return undefined;\n        }\n        return (data)=>{\n            return this._private__paneView._internal_isWhitespace(data);\n        };\n    }\n    _private__isOverlay() {\n        const priceScale = this._internal_priceScale();\n        return !isDefaultPriceScale(priceScale._internal_id());\n    }\n    _private__autoscaleInfoImpl(startTimePoint, endTimePoint) {\n        if (!isInteger(startTimePoint) || !isInteger(endTimePoint) || this._private__data._internal_isEmpty()) {\n            return null;\n        }\n        // TODO: refactor this\n        // series data is strongly hardcoded to keep bars\n        const plots = this._private__seriesType === \"Line\" || this._private__seriesType === \"Area\" || this._private__seriesType === \"Baseline\" || this._private__seriesType === \"Histogram\" ? [\n            3 /* PlotRowValueIndex.Close */ \n        ] : [\n            2 /* PlotRowValueIndex.Low */ ,\n            1 /* PlotRowValueIndex.High */ \n        ];\n        const barsMinMax = this._private__data._internal_minMaxOnRangeCached(startTimePoint, endTimePoint, plots);\n        let range = barsMinMax !== null ? new PriceRangeImpl(barsMinMax._internal_min, barsMinMax._internal_max) : null;\n        if (this._internal_seriesType() === \"Histogram\") {\n            const base = this._private__options.base;\n            const rangeWithBase = new PriceRangeImpl(base, base);\n            range = range !== null ? range._internal_merge(rangeWithBase) : rangeWithBase;\n        }\n        let margins = this._private__markersPaneView._internal_autoScaleMargins();\n        this._private__primitives.forEach((primitive)=>{\n            const primitiveAutoscale = primitive._internal_autoscaleInfo(startTimePoint, endTimePoint);\n            if (primitiveAutoscale === null || primitiveAutoscale === void 0 ? void 0 : primitiveAutoscale.priceRange) {\n                const primitiveRange = new PriceRangeImpl(primitiveAutoscale.priceRange.minValue, primitiveAutoscale.priceRange.maxValue);\n                range = range !== null ? range._internal_merge(primitiveRange) : primitiveRange;\n            }\n            if (primitiveAutoscale === null || primitiveAutoscale === void 0 ? void 0 : primitiveAutoscale.margins) {\n                margins = mergeMargins(margins, primitiveAutoscale.margins);\n            }\n        });\n        return new AutoscaleInfoImpl(range, margins);\n    }\n    _private__markerRadius() {\n        switch(this._private__seriesType){\n            case \"Line\":\n            case \"Area\":\n            case \"Baseline\":\n                return this._private__options.crosshairMarkerRadius;\n        }\n        return 0;\n    }\n    _private__markerBorderColor() {\n        switch(this._private__seriesType){\n            case \"Line\":\n            case \"Area\":\n            case \"Baseline\":\n                {\n                    const crosshairMarkerBorderColor = this._private__options.crosshairMarkerBorderColor;\n                    if (crosshairMarkerBorderColor.length !== 0) {\n                        return crosshairMarkerBorderColor;\n                    }\n                }\n        }\n        return null;\n    }\n    _private__markerBorderWidth() {\n        switch(this._private__seriesType){\n            case \"Line\":\n            case \"Area\":\n            case \"Baseline\":\n                return this._private__options.crosshairMarkerBorderWidth;\n        }\n        return 0;\n    }\n    _private__markerBackgroundColor(index) {\n        switch(this._private__seriesType){\n            case \"Line\":\n            case \"Area\":\n            case \"Baseline\":\n                {\n                    const crosshairMarkerBackgroundColor = this._private__options.crosshairMarkerBackgroundColor;\n                    if (crosshairMarkerBackgroundColor.length !== 0) {\n                        return crosshairMarkerBackgroundColor;\n                    }\n                }\n        }\n        return this._internal_barColorer()._internal_barStyle(index)._internal_barColor;\n    }\n    _private__recreateFormatter() {\n        switch(this._private__options.priceFormat.type){\n            case \"custom\":\n                {\n                    this._private__formatter = {\n                        format: this._private__options.priceFormat.formatter\n                    };\n                    break;\n                }\n            case \"volume\":\n                {\n                    this._private__formatter = new VolumeFormatter(this._private__options.priceFormat.precision);\n                    break;\n                }\n            case \"percent\":\n                {\n                    this._private__formatter = new PercentageFormatter(this._private__options.priceFormat.precision);\n                    break;\n                }\n            default:\n                {\n                    const priceScale = Math.pow(10, this._private__options.priceFormat.precision);\n                    this._private__formatter = new PriceFormatter(priceScale, this._private__options.priceFormat.minMove * priceScale);\n                }\n        }\n        if (this._internal__priceScale !== null) {\n            this._internal__priceScale._internal_updateFormatter();\n        }\n    }\n    _private__recalculateMarkers() {\n        const timeScale = this._internal_model()._internal_timeScale();\n        if (!timeScale._internal_hasPoints() || this._private__data._internal_isEmpty()) {\n            this._private__indexedMarkers = [];\n            return;\n        }\n        const firstDataIndex = ensureNotNull(this._private__data._internal_firstIndex());\n        this._private__indexedMarkers = this._private__markers.map((marker, index)=>{\n            // the first find index on the time scale (across all series)\n            const timePointIndex = ensureNotNull(timeScale._internal_timeToIndex(marker.time, true));\n            // and then search that index inside the series data\n            const searchMode = timePointIndex < firstDataIndex ? 1 /* MismatchDirection.NearestRight */  : -1 /* MismatchDirection.NearestLeft */ ;\n            const seriesDataIndex = ensureNotNull(this._private__data._internal_search(timePointIndex, searchMode))._internal_index;\n            return {\n                time: seriesDataIndex,\n                position: marker.position,\n                shape: marker.shape,\n                color: marker.color,\n                id: marker.id,\n                _internal_internalId: index,\n                text: marker.text,\n                size: marker.size,\n                originalTime: marker.originalTime\n            };\n        });\n    }\n    _private__recreatePaneViews(customPaneView) {\n        this._private__markersPaneView = new SeriesMarkersPaneView(this, this._internal_model());\n        switch(this._private__seriesType){\n            case \"Bar\":\n                {\n                    this._private__paneView = new SeriesBarsPaneView(this, this._internal_model());\n                    break;\n                }\n            case \"Candlestick\":\n                {\n                    this._private__paneView = new SeriesCandlesticksPaneView(this, this._internal_model());\n                    break;\n                }\n            case \"Line\":\n                {\n                    this._private__paneView = new SeriesLinePaneView(this, this._internal_model());\n                    break;\n                }\n            case \"Custom\":\n                {\n                    this._private__paneView = new SeriesCustomPaneView(this, this._internal_model(), ensureDefined(customPaneView));\n                    break;\n                }\n            case \"Area\":\n                {\n                    this._private__paneView = new SeriesAreaPaneView(this, this._internal_model());\n                    break;\n                }\n            case \"Baseline\":\n                {\n                    this._private__paneView = new SeriesBaselinePaneView(this, this._internal_model());\n                    break;\n                }\n            case \"Histogram\":\n                {\n                    this._private__paneView = new SeriesHistogramPaneView(this, this._internal_model());\n                    break;\n                }\n            default:\n                throw Error(\"Unknown chart style assigned: \" + this._private__seriesType);\n        }\n    }\n    _private__extractPaneViews(extractor, zOrder) {\n        const res = [];\n        extractPrimitivePaneViews(this._private__primitives, extractor, zOrder, res);\n        return res;\n    }\n    constructor(model, options, seriesType, pane, customPaneView){\n        super(model);\n        this._private__data = createSeriesPlotList();\n        this._private__priceLineView = new SeriesPriceLinePaneView(this);\n        this._private__customPriceLines = [];\n        this._private__baseHorizontalLineView = new SeriesHorizontalBaseLinePaneView(this);\n        this._private__lastPriceAnimationPaneView = null;\n        this._private__barColorerCache = null;\n        this._private__markers = [];\n        this._private__indexedMarkers = [];\n        this._private__animationTimeoutId = null;\n        this._private__primitives = [];\n        this._private__options = options;\n        this._private__seriesType = seriesType;\n        const priceAxisView = new SeriesPriceAxisView(this);\n        this._private__priceAxisViews = [\n            priceAxisView\n        ];\n        this._private__panePriceAxisView = new PanePriceAxisView(priceAxisView, this, model);\n        if (seriesType === \"Area\" || seriesType === \"Line\" || seriesType === \"Baseline\") {\n            this._private__lastPriceAnimationPaneView = new SeriesLastPriceAnimationPaneView(this);\n        }\n        this._private__recreateFormatter();\n        this._private__recreatePaneViews(customPaneView);\n    }\n}\nfunction mergeMargins(source, additionalMargin) {\n    var _a, _b;\n    return {\n        above: Math.max((_a = source === null || source === void 0 ? void 0 : source.above) !== null && _a !== void 0 ? _a : 0, additionalMargin.above),\n        below: Math.max((_b = source === null || source === void 0 ? void 0 : source.below) !== null && _b !== void 0 ? _b : 0, additionalMargin.below)\n    };\n}\nclass Magnet {\n    _internal_align(price, index, pane) {\n        let res = price;\n        if (this._private__options.mode === 0 /* CrosshairMode.Normal */ ) {\n            return res;\n        }\n        const defaultPriceScale = pane._internal_defaultPriceScale();\n        const firstValue = defaultPriceScale._internal_firstValue();\n        if (firstValue === null) {\n            return res;\n        }\n        const y = defaultPriceScale._internal_priceToCoordinate(price, firstValue);\n        // get all serieses from the pane\n        const serieses = pane._internal_dataSources().filter((ds)=>ds instanceof Series);\n        const candidates = serieses.reduce((acc, series)=>{\n            if (pane._internal_isOverlay(series) || !series._internal_visible()) {\n                return acc;\n            }\n            const ps = series._internal_priceScale();\n            const bars = series._internal_bars();\n            if (ps._internal_isEmpty() || !bars._internal_contains(index)) {\n                return acc;\n            }\n            const bar = bars._internal_valueAt(index);\n            if (bar === null) {\n                return acc;\n            }\n            // convert bar to pixels\n            const firstPrice = ensure(series._internal_firstValue());\n            return acc.concat([\n                ps._internal_priceToCoordinate(bar._internal_value[3 /* PlotRowValueIndex.Close */ ], firstPrice._internal_value)\n            ]);\n        }, []);\n        if (candidates.length === 0) {\n            return res;\n        }\n        candidates.sort((y1, y2)=>Math.abs(y1 - y) - Math.abs(y2 - y));\n        const nearest = candidates[0];\n        res = defaultPriceScale._internal_coordinateToPrice(nearest, firstValue);\n        return res;\n    }\n    constructor(options){\n        this._private__options = options;\n    }\n}\nclass GridRenderer extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal__drawImpl(param) {\n        let { context: ctx, bitmapSize, horizontalPixelRatio, verticalPixelRatio } = param;\n        if (this._private__data === null) {\n            return;\n        }\n        const lineWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n        ctx.lineWidth = lineWidth;\n        strokeInPixel(ctx, ()=>{\n            const data = ensureNotNull(this._private__data);\n            if (data._internal_vertLinesVisible) {\n                ctx.strokeStyle = data._internal_vertLinesColor;\n                setLineStyle(ctx, data._internal_vertLineStyle);\n                ctx.beginPath();\n                for (const timeMark of data._internal_timeMarks){\n                    const x = Math.round(timeMark._internal_coord * horizontalPixelRatio);\n                    ctx.moveTo(x, -lineWidth);\n                    ctx.lineTo(x, bitmapSize.height + lineWidth);\n                }\n                ctx.stroke();\n            }\n            if (data._internal_horzLinesVisible) {\n                ctx.strokeStyle = data._internal_horzLinesColor;\n                setLineStyle(ctx, data._internal_horzLineStyle);\n                ctx.beginPath();\n                for (const priceMark of data._internal_priceMarks){\n                    const y = Math.round(priceMark._internal_coord * verticalPixelRatio);\n                    ctx.moveTo(-lineWidth, y);\n                    ctx.lineTo(bitmapSize.width + lineWidth, y);\n                }\n                ctx.stroke();\n            }\n        });\n    }\n    constructor(){\n        super(...arguments);\n        this._private__data = null;\n    }\n}\nclass GridPaneView {\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_renderer() {\n        if (this._private__invalidated) {\n            const gridOptions = this._private__pane._internal_model()._internal_options().grid;\n            const data = {\n                _internal_horzLinesVisible: gridOptions.horzLines.visible,\n                _internal_vertLinesVisible: gridOptions.vertLines.visible,\n                _internal_horzLinesColor: gridOptions.horzLines.color,\n                _internal_vertLinesColor: gridOptions.vertLines.color,\n                _internal_horzLineStyle: gridOptions.horzLines.style,\n                _internal_vertLineStyle: gridOptions.vertLines.style,\n                _internal_priceMarks: this._private__pane._internal_defaultPriceScale()._internal_marks(),\n                // need this conversiom because TimeMark is a part of external interface\n                // and fields inside TimeMark are not minified\n                _internal_timeMarks: (this._private__pane._internal_model()._internal_timeScale()._internal_marks() || []).map((tm)=>{\n                    return {\n                        _internal_coord: tm.coord\n                    };\n                })\n            };\n            this._private__renderer._internal_setData(data);\n            this._private__invalidated = false;\n        }\n        return this._private__renderer;\n    }\n    constructor(pane){\n        this._private__renderer = new GridRenderer();\n        this._private__invalidated = true;\n        this._private__pane = pane;\n    }\n}\nclass Grid {\n    _internal_paneView() {\n        return this._private__paneView;\n    }\n    constructor(pane){\n        this._private__paneView = new GridPaneView(pane);\n    }\n}\nconst defLogFormula = {\n    _internal_logicalOffset: 4,\n    _internal_coordOffset: 0.0001\n};\nfunction fromPercent(value, baseValue) {\n    if (baseValue < 0) {\n        value = -value;\n    }\n    return value / 100 * baseValue + baseValue;\n}\nfunction toPercent(value, baseValue) {\n    const result = 100 * (value - baseValue) / baseValue;\n    return baseValue < 0 ? -result : result;\n}\nfunction toPercentRange(priceRange, baseValue) {\n    const minPercent = toPercent(priceRange._internal_minValue(), baseValue);\n    const maxPercent = toPercent(priceRange._internal_maxValue(), baseValue);\n    return new PriceRangeImpl(minPercent, maxPercent);\n}\nfunction fromIndexedTo100(value, baseValue) {\n    value -= 100;\n    if (baseValue < 0) {\n        value = -value;\n    }\n    return value / 100 * baseValue + baseValue;\n}\nfunction toIndexedTo100(value, baseValue) {\n    const result = 100 * (value - baseValue) / baseValue + 100;\n    return baseValue < 0 ? -result : result;\n}\nfunction toIndexedTo100Range(priceRange, baseValue) {\n    const minPercent = toIndexedTo100(priceRange._internal_minValue(), baseValue);\n    const maxPercent = toIndexedTo100(priceRange._internal_maxValue(), baseValue);\n    return new PriceRangeImpl(minPercent, maxPercent);\n}\nfunction toLog(price, logFormula) {\n    const m = Math.abs(price);\n    if (m < 1e-15) {\n        return 0;\n    }\n    const res = Math.log10(m + logFormula._internal_coordOffset) + logFormula._internal_logicalOffset;\n    return price < 0 ? -res : res;\n}\nfunction fromLog(logical, logFormula) {\n    const m = Math.abs(logical);\n    if (m < 1e-15) {\n        return 0;\n    }\n    const res = Math.pow(10, m - logFormula._internal_logicalOffset) - logFormula._internal_coordOffset;\n    return logical < 0 ? -res : res;\n}\nfunction convertPriceRangeToLog(priceRange, logFormula) {\n    if (priceRange === null) {\n        return null;\n    }\n    const min = toLog(priceRange._internal_minValue(), logFormula);\n    const max = toLog(priceRange._internal_maxValue(), logFormula);\n    return new PriceRangeImpl(min, max);\n}\nfunction canConvertPriceRangeFromLog(priceRange, logFormula) {\n    if (priceRange === null) {\n        return false;\n    }\n    const min = fromLog(priceRange._internal_minValue(), logFormula);\n    const max = fromLog(priceRange._internal_maxValue(), logFormula);\n    return isFinite(min) && isFinite(max);\n}\nfunction convertPriceRangeFromLog(priceRange, logFormula) {\n    if (priceRange === null) {\n        return null;\n    }\n    const min = fromLog(priceRange._internal_minValue(), logFormula);\n    const max = fromLog(priceRange._internal_maxValue(), logFormula);\n    return new PriceRangeImpl(min, max);\n}\nfunction logFormulaForPriceRange(range) {\n    if (range === null) {\n        return defLogFormula;\n    }\n    const diff = Math.abs(range._internal_maxValue() - range._internal_minValue());\n    if (diff >= 1 || diff < 1e-15) {\n        return defLogFormula;\n    }\n    const digits = Math.ceil(Math.abs(Math.log10(diff)));\n    const logicalOffset = defLogFormula._internal_logicalOffset + digits;\n    const coordOffset = 1 / Math.pow(10, logicalOffset);\n    return {\n        _internal_logicalOffset: logicalOffset,\n        _internal_coordOffset: coordOffset\n    };\n}\nfunction logFormulasAreSame(f1, f2) {\n    return f1._internal_logicalOffset === f2._internal_logicalOffset && f1._internal_coordOffset === f2._internal_coordOffset;\n}\nclass PriceTickSpanCalculator {\n    _internal_tickSpan(high, low, maxTickSpan) {\n        const minMovement = this._private__base === 0 ? 0 : 1 / this._private__base;\n        let resultTickSpan = Math.pow(10, Math.max(0, Math.ceil(Math.log10(high - low))));\n        let index = 0;\n        let c = this._private__integralDividers[0];\n        // eslint-disable-next-line no-constant-condition\n        while(true){\n            // the second part is actual for small with very small values like 1e-10\n            // greaterOrEqual fails for such values\n            const resultTickSpanLargerMinMovement = greaterOrEqual(resultTickSpan, minMovement, 1e-14 /* Constants.TickSpanEpsilon */ ) && resultTickSpan > minMovement + 1e-14 /* Constants.TickSpanEpsilon */ ;\n            const resultTickSpanLargerMaxTickSpan = greaterOrEqual(resultTickSpan, maxTickSpan * c, 1e-14 /* Constants.TickSpanEpsilon */ );\n            const resultTickSpanLarger1 = greaterOrEqual(resultTickSpan, 1, 1e-14 /* Constants.TickSpanEpsilon */ );\n            const haveToContinue = resultTickSpanLargerMinMovement && resultTickSpanLargerMaxTickSpan && resultTickSpanLarger1;\n            if (!haveToContinue) {\n                break;\n            }\n            resultTickSpan /= c;\n            c = this._private__integralDividers[++index % this._private__integralDividers.length];\n        }\n        if (resultTickSpan <= minMovement + 1e-14 /* Constants.TickSpanEpsilon */ ) {\n            resultTickSpan = minMovement;\n        }\n        resultTickSpan = Math.max(1, resultTickSpan);\n        if (this._private__fractionalDividers.length > 0 && equal(resultTickSpan, 1, 1e-14 /* Constants.TickSpanEpsilon */ )) {\n            index = 0;\n            c = this._private__fractionalDividers[0];\n            while(greaterOrEqual(resultTickSpan, maxTickSpan * c, 1e-14 /* Constants.TickSpanEpsilon */ ) && resultTickSpan > minMovement + 1e-14 /* Constants.TickSpanEpsilon */ ){\n                resultTickSpan /= c;\n                c = this._private__fractionalDividers[++index % this._private__fractionalDividers.length];\n            }\n        }\n        return resultTickSpan;\n    }\n    constructor(base, integralDividers){\n        this._private__base = base;\n        this._private__integralDividers = integralDividers;\n        if (isBaseDecimal(this._private__base)) {\n            this._private__fractionalDividers = [\n                2,\n                2.5,\n                2\n            ];\n        } else {\n            this._private__fractionalDividers = [];\n            for(let baseRest = this._private__base; baseRest !== 1;){\n                if (baseRest % 2 === 0) {\n                    this._private__fractionalDividers.push(2);\n                    baseRest /= 2;\n                } else if (baseRest % 5 === 0) {\n                    this._private__fractionalDividers.push(2, 2.5);\n                    baseRest /= 5;\n                } else {\n                    throw new Error(\"unexpected base\");\n                }\n                if (this._private__fractionalDividers.length > 100) {\n                    throw new Error(\"something wrong with base\");\n                }\n            }\n        }\n    }\n}\nconst TICK_DENSITY = 2.5;\nclass PriceTickMarkBuilder {\n    _internal_tickSpan(high, low) {\n        if (high < low) {\n            throw new Error(\"high < low\");\n        }\n        const scaleHeight = this._private__priceScale._internal_height();\n        const markHeight = this._private__tickMarkHeight();\n        const maxTickSpan = (high - low) * markHeight / scaleHeight;\n        const spanCalculator1 = new PriceTickSpanCalculator(this._private__base, [\n            2,\n            2.5,\n            2\n        ]);\n        const spanCalculator2 = new PriceTickSpanCalculator(this._private__base, [\n            2,\n            2,\n            2.5\n        ]);\n        const spanCalculator3 = new PriceTickSpanCalculator(this._private__base, [\n            2.5,\n            2,\n            2\n        ]);\n        const spans = [];\n        spans.push(spanCalculator1._internal_tickSpan(high, low, maxTickSpan), spanCalculator2._internal_tickSpan(high, low, maxTickSpan), spanCalculator3._internal_tickSpan(high, low, maxTickSpan));\n        return min(spans);\n    }\n    _internal_rebuildTickMarks() {\n        const priceScale = this._private__priceScale;\n        const firstValue = priceScale._internal_firstValue();\n        if (firstValue === null) {\n            this._private__marks = [];\n            return;\n        }\n        const scaleHeight = priceScale._internal_height();\n        const bottom = this._private__coordinateToLogicalFunc(scaleHeight - 1, firstValue);\n        const top = this._private__coordinateToLogicalFunc(0, firstValue);\n        const extraTopBottomMargin = this._private__priceScale._internal_options().entireTextOnly ? this._private__fontHeight() / 2 : 0;\n        const minCoord = extraTopBottomMargin;\n        const maxCoord = scaleHeight - 1 - extraTopBottomMargin;\n        const high = Math.max(bottom, top);\n        const low = Math.min(bottom, top);\n        if (high === low) {\n            this._private__marks = [];\n            return;\n        }\n        let span = this._internal_tickSpan(high, low);\n        let mod = high % span;\n        mod += mod < 0 ? span : 0;\n        const sign = high >= low ? 1 : -1;\n        let prevCoord = null;\n        let targetIndex = 0;\n        for(let logical = high - mod; logical > low; logical -= span){\n            const coord = this._private__logicalToCoordinateFunc(logical, firstValue, true);\n            // check if there is place for it\n            // this is required for log scale\n            if (prevCoord !== null && Math.abs(coord - prevCoord) < this._private__tickMarkHeight()) {\n                continue;\n            }\n            // check if a tick mark is partially visible and skip it if entireTextOnly is true\n            if (coord < minCoord || coord > maxCoord) {\n                continue;\n            }\n            if (targetIndex < this._private__marks.length) {\n                this._private__marks[targetIndex]._internal_coord = coord;\n                this._private__marks[targetIndex]._internal_label = priceScale._internal_formatLogical(logical);\n            } else {\n                this._private__marks.push({\n                    _internal_coord: coord,\n                    _internal_label: priceScale._internal_formatLogical(logical)\n                });\n            }\n            targetIndex++;\n            prevCoord = coord;\n            if (priceScale._internal_isLog()) {\n                // recalc span\n                span = this._internal_tickSpan(logical * sign, low);\n            }\n        }\n        this._private__marks.length = targetIndex;\n    }\n    _internal_marks() {\n        return this._private__marks;\n    }\n    _private__fontHeight() {\n        return this._private__priceScale._internal_fontSize();\n    }\n    _private__tickMarkHeight() {\n        return Math.ceil(this._private__fontHeight() * TICK_DENSITY);\n    }\n    constructor(priceScale, base, coordinateToLogicalFunc, logicalToCoordinateFunc){\n        this._private__marks = [];\n        this._private__priceScale = priceScale;\n        this._private__base = base;\n        this._private__coordinateToLogicalFunc = coordinateToLogicalFunc;\n        this._private__logicalToCoordinateFunc = logicalToCoordinateFunc;\n    }\n}\nfunction sortSources(sources) {\n    return sources.slice().sort((s1, s2)=>{\n        return ensureNotNull(s1._internal_zorder()) - ensureNotNull(s2._internal_zorder());\n    });\n}\n/**\n * Represents the price scale mode.\n */ var PriceScaleMode;\n(function(PriceScaleMode) {\n    /**\n     * Price scale shows prices. Price range changes linearly.\n     */ PriceScaleMode[PriceScaleMode[\"Normal\"] = 0] = \"Normal\";\n    /**\n     * Price scale shows prices. Price range changes logarithmically.\n     */ PriceScaleMode[PriceScaleMode[\"Logarithmic\"] = 1] = \"Logarithmic\";\n    /**\n     * Price scale shows percentage values according the first visible value of the price scale.\n     * The first visible value is 0% in this mode.\n     */ PriceScaleMode[PriceScaleMode[\"Percentage\"] = 2] = \"Percentage\";\n    /**\n     * The same as percentage mode, but the first value is moved to 100.\n     */ PriceScaleMode[PriceScaleMode[\"IndexedTo100\"] = 3] = \"IndexedTo100\";\n})(PriceScaleMode || (PriceScaleMode = {}));\nconst percentageFormatter = new PercentageFormatter();\nconst defaultPriceFormatter = new PriceFormatter(100, 1);\nclass PriceScale {\n    _internal_id() {\n        return this._private__id;\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_applyOptions(options) {\n        merge(this._private__options, options);\n        this._internal_updateFormatter();\n        if (options.mode !== undefined) {\n            this._internal_setMode({\n                _internal_mode: options.mode\n            });\n        }\n        if (options.scaleMargins !== undefined) {\n            const top = ensureDefined(options.scaleMargins.top);\n            const bottom = ensureDefined(options.scaleMargins.bottom);\n            if (top < 0 || top > 1) {\n                throw new Error(\"Invalid top margin - expect value between 0 and 1, given=\".concat(top));\n            }\n            if (bottom < 0 || bottom > 1) {\n                throw new Error(\"Invalid bottom margin - expect value between 0 and 1, given=\".concat(bottom));\n            }\n            if (top + bottom > 1) {\n                throw new Error(\"Invalid margins - sum of margins must be less than 1, given=\".concat(top + bottom));\n            }\n            this._private__invalidateInternalHeightCache();\n            this._private__marksCache = null;\n        }\n    }\n    _internal_isAutoScale() {\n        return this._private__options.autoScale;\n    }\n    _internal_isLog() {\n        return this._private__options.mode === 1 /* PriceScaleMode.Logarithmic */ ;\n    }\n    _internal_isPercentage() {\n        return this._private__options.mode === 2 /* PriceScaleMode.Percentage */ ;\n    }\n    _internal_isIndexedTo100() {\n        return this._private__options.mode === 3 /* PriceScaleMode.IndexedTo100 */ ;\n    }\n    _internal_mode() {\n        return {\n            _internal_autoScale: this._private__options.autoScale,\n            _internal_isInverted: this._private__options.invertScale,\n            _internal_mode: this._private__options.mode\n        };\n    }\n    // eslint-disable-next-line complexity\n    _internal_setMode(newMode) {\n        const oldMode = this._internal_mode();\n        let priceRange = null;\n        if (newMode._internal_autoScale !== undefined) {\n            this._private__options.autoScale = newMode._internal_autoScale;\n        }\n        if (newMode._internal_mode !== undefined) {\n            this._private__options.mode = newMode._internal_mode;\n            if (newMode._internal_mode === 2 /* PriceScaleMode.Percentage */  || newMode._internal_mode === 3 /* PriceScaleMode.IndexedTo100 */ ) {\n                this._private__options.autoScale = true;\n            }\n            // TODO: Remove after making rebuildTickMarks lazy\n            this._private__invalidatedForRange._internal_isValid = false;\n        }\n        // define which scale converted from\n        if (oldMode._internal_mode === 1 /* PriceScaleMode.Logarithmic */  && newMode._internal_mode !== oldMode._internal_mode) {\n            if (canConvertPriceRangeFromLog(this._private__priceRange, this._private__logFormula)) {\n                priceRange = convertPriceRangeFromLog(this._private__priceRange, this._private__logFormula);\n                if (priceRange !== null) {\n                    this._internal_setPriceRange(priceRange);\n                }\n            } else {\n                this._private__options.autoScale = true;\n            }\n        }\n        // define which scale converted to\n        if (newMode._internal_mode === 1 /* PriceScaleMode.Logarithmic */  && newMode._internal_mode !== oldMode._internal_mode) {\n            priceRange = convertPriceRangeToLog(this._private__priceRange, this._private__logFormula);\n            if (priceRange !== null) {\n                this._internal_setPriceRange(priceRange);\n            }\n        }\n        const modeChanged = oldMode._internal_mode !== this._private__options.mode;\n        if (modeChanged && (oldMode._internal_mode === 2 /* PriceScaleMode.Percentage */  || this._internal_isPercentage())) {\n            this._internal_updateFormatter();\n        }\n        if (modeChanged && (oldMode._internal_mode === 3 /* PriceScaleMode.IndexedTo100 */  || this._internal_isIndexedTo100())) {\n            this._internal_updateFormatter();\n        }\n        if (newMode._internal_isInverted !== undefined && oldMode._internal_isInverted !== newMode._internal_isInverted) {\n            this._private__options.invertScale = newMode._internal_isInverted;\n            this._private__onIsInvertedChanged();\n        }\n        this._private__modeChanged._internal_fire(oldMode, this._internal_mode());\n    }\n    _internal_modeChanged() {\n        return this._private__modeChanged;\n    }\n    _internal_fontSize() {\n        return this._private__layoutOptions.fontSize;\n    }\n    _internal_height() {\n        return this._private__height;\n    }\n    _internal_setHeight(value) {\n        if (this._private__height === value) {\n            return;\n        }\n        this._private__height = value;\n        this._private__invalidateInternalHeightCache();\n        this._private__marksCache = null;\n    }\n    _internal_internalHeight() {\n        if (this._private__internalHeightCache) {\n            return this._private__internalHeightCache;\n        }\n        const res = this._internal_height() - this._private__topMarginPx() - this._private__bottomMarginPx();\n        this._private__internalHeightCache = res;\n        return res;\n    }\n    _internal_priceRange() {\n        this._private__makeSureItIsValid();\n        return this._private__priceRange;\n    }\n    _internal_setPriceRange(newPriceRange, isForceSetValue) {\n        const oldPriceRange = this._private__priceRange;\n        if (!isForceSetValue && !(oldPriceRange === null && newPriceRange !== null) && (oldPriceRange === null || oldPriceRange._internal_equals(newPriceRange))) {\n            return;\n        }\n        this._private__marksCache = null;\n        this._private__priceRange = newPriceRange;\n    }\n    _internal_isEmpty() {\n        this._private__makeSureItIsValid();\n        return this._private__height === 0 || !this._private__priceRange || this._private__priceRange._internal_isEmpty();\n    }\n    _internal_invertedCoordinate(coordinate) {\n        return this._internal_isInverted() ? coordinate : this._internal_height() - 1 - coordinate;\n    }\n    _internal_priceToCoordinate(price, baseValue) {\n        if (this._internal_isPercentage()) {\n            price = toPercent(price, baseValue);\n        } else if (this._internal_isIndexedTo100()) {\n            price = toIndexedTo100(price, baseValue);\n        }\n        return this._private__logicalToCoordinate(price, baseValue);\n    }\n    _internal_pointsArrayToCoordinates(points, baseValue, visibleRange) {\n        this._private__makeSureItIsValid();\n        const bh = this._private__bottomMarginPx();\n        const range = ensureNotNull(this._internal_priceRange());\n        const min = range._internal_minValue();\n        const max = range._internal_maxValue();\n        const ih = this._internal_internalHeight() - 1;\n        const isInverted = this._internal_isInverted();\n        const hmm = ih / (max - min);\n        const fromIndex = visibleRange === undefined ? 0 : visibleRange.from;\n        const toIndex = visibleRange === undefined ? points.length : visibleRange.to;\n        const transformFn = this._private__getCoordinateTransformer();\n        for(let i = fromIndex; i < toIndex; i++){\n            const point = points[i];\n            const price = point._internal_price;\n            if (isNaN(price)) {\n                continue;\n            }\n            let logical = price;\n            if (transformFn !== null) {\n                logical = transformFn(point._internal_price, baseValue);\n            }\n            const invCoordinate = bh + hmm * (logical - min);\n            const coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            point._internal_y = coordinate;\n        }\n    }\n    _internal_barPricesToCoordinates(pricesList, baseValue, visibleRange) {\n        this._private__makeSureItIsValid();\n        const bh = this._private__bottomMarginPx();\n        const range = ensureNotNull(this._internal_priceRange());\n        const min = range._internal_minValue();\n        const max = range._internal_maxValue();\n        const ih = this._internal_internalHeight() - 1;\n        const isInverted = this._internal_isInverted();\n        const hmm = ih / (max - min);\n        const fromIndex = visibleRange === undefined ? 0 : visibleRange.from;\n        const toIndex = visibleRange === undefined ? pricesList.length : visibleRange.to;\n        const transformFn = this._private__getCoordinateTransformer();\n        for(let i = fromIndex; i < toIndex; i++){\n            const bar = pricesList[i];\n            let openLogical = bar._internal_open;\n            let highLogical = bar._internal_high;\n            let lowLogical = bar._internal_low;\n            let closeLogical = bar._internal_close;\n            if (transformFn !== null) {\n                openLogical = transformFn(bar._internal_open, baseValue);\n                highLogical = transformFn(bar._internal_high, baseValue);\n                lowLogical = transformFn(bar._internal_low, baseValue);\n                closeLogical = transformFn(bar._internal_close, baseValue);\n            }\n            let invCoordinate = bh + hmm * (openLogical - min);\n            let coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            bar._internal_openY = coordinate;\n            invCoordinate = bh + hmm * (highLogical - min);\n            coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            bar._internal_highY = coordinate;\n            invCoordinate = bh + hmm * (lowLogical - min);\n            coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            bar._internal_lowY = coordinate;\n            invCoordinate = bh + hmm * (closeLogical - min);\n            coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            bar._internal_closeY = coordinate;\n        }\n    }\n    _internal_coordinateToPrice(coordinate, baseValue) {\n        const logical = this._private__coordinateToLogical(coordinate, baseValue);\n        return this._internal_logicalToPrice(logical, baseValue);\n    }\n    _internal_logicalToPrice(logical, baseValue) {\n        let value = logical;\n        if (this._internal_isPercentage()) {\n            value = fromPercent(value, baseValue);\n        } else if (this._internal_isIndexedTo100()) {\n            value = fromIndexedTo100(value, baseValue);\n        }\n        return value;\n    }\n    _internal_dataSources() {\n        return this._private__dataSources;\n    }\n    _internal_orderedSources() {\n        if (this._private__cachedOrderedSources) {\n            return this._private__cachedOrderedSources;\n        }\n        let sources = [];\n        for(let i = 0; i < this._private__dataSources.length; i++){\n            const ds = this._private__dataSources[i];\n            if (ds._internal_zorder() === null) {\n                ds._internal_setZorder(i + 1);\n            }\n            sources.push(ds);\n        }\n        sources = sortSources(sources);\n        this._private__cachedOrderedSources = sources;\n        return this._private__cachedOrderedSources;\n    }\n    _internal_addDataSource(source) {\n        if (this._private__dataSources.indexOf(source) !== -1) {\n            return;\n        }\n        this._private__dataSources.push(source);\n        this._internal_updateFormatter();\n        this._internal_invalidateSourcesCache();\n    }\n    _internal_removeDataSource(source) {\n        const index = this._private__dataSources.indexOf(source);\n        if (index === -1) {\n            throw new Error(\"source is not attached to scale\");\n        }\n        this._private__dataSources.splice(index, 1);\n        if (this._private__dataSources.length === 0) {\n            this._internal_setMode({\n                _internal_autoScale: true\n            });\n            // if no sources on price scale let's clear price range cache as well as enabling auto scale\n            this._internal_setPriceRange(null);\n        }\n        this._internal_updateFormatter();\n        this._internal_invalidateSourcesCache();\n    }\n    _internal_firstValue() {\n        // TODO: cache the result\n        let result = null;\n        for (const source of this._private__dataSources){\n            const firstValue = source._internal_firstValue();\n            if (firstValue === null) {\n                continue;\n            }\n            if (result === null || firstValue._internal_timePoint < result._internal_timePoint) {\n                result = firstValue;\n            }\n        }\n        return result === null ? null : result._internal_value;\n    }\n    _internal_isInverted() {\n        return this._private__options.invertScale;\n    }\n    _internal_marks() {\n        const firstValueIsNull = this._internal_firstValue() === null;\n        // do not recalculate marks if firstValueIsNull is true because in this case we'll always get empty result\n        // this could happen in case when a series had some data and then you set empty data to it (in a simplified case)\n        // we could display an empty price scale, but this is not good from UX\n        // so in this case we need to keep an previous marks to display them on the scale\n        // as one of possible examples for this situation could be the following:\n        // let's say you have a study/indicator attached to a price scale and then you decide to stop it, i.e. remove its data because of its visibility\n        // a user will see the previous marks on the scale until you turn on your study back or remove it from the chart completely\n        if (this._private__marksCache !== null && (firstValueIsNull || this._private__marksCache._internal_firstValueIsNull === firstValueIsNull)) {\n            return this._private__marksCache._internal_marks;\n        }\n        this._private__markBuilder._internal_rebuildTickMarks();\n        const marks = this._private__markBuilder._internal_marks();\n        this._private__marksCache = {\n            _internal_marks: marks,\n            _internal_firstValueIsNull: firstValueIsNull\n        };\n        this._private__onMarksChanged._internal_fire();\n        return marks;\n    }\n    _internal_onMarksChanged() {\n        return this._private__onMarksChanged;\n    }\n    _internal_startScale(x) {\n        if (this._internal_isPercentage() || this._internal_isIndexedTo100()) {\n            return;\n        }\n        if (this._private__scaleStartPoint !== null || this._private__priceRangeSnapshot !== null) {\n            return;\n        }\n        if (this._internal_isEmpty()) {\n            return;\n        }\n        // invert x\n        this._private__scaleStartPoint = this._private__height - x;\n        this._private__priceRangeSnapshot = ensureNotNull(this._internal_priceRange())._internal_clone();\n    }\n    _internal_scaleTo(x) {\n        if (this._internal_isPercentage() || this._internal_isIndexedTo100()) {\n            return;\n        }\n        if (this._private__scaleStartPoint === null) {\n            return;\n        }\n        this._internal_setMode({\n            _internal_autoScale: false\n        });\n        // invert x\n        x = this._private__height - x;\n        if (x < 0) {\n            x = 0;\n        }\n        let scaleCoeff = (this._private__scaleStartPoint + (this._private__height - 1) * 0.2) / (x + (this._private__height - 1) * 0.2);\n        const newPriceRange = ensureNotNull(this._private__priceRangeSnapshot)._internal_clone();\n        scaleCoeff = Math.max(scaleCoeff, 0.1);\n        newPriceRange._internal_scaleAroundCenter(scaleCoeff);\n        this._internal_setPriceRange(newPriceRange);\n    }\n    _internal_endScale() {\n        if (this._internal_isPercentage() || this._internal_isIndexedTo100()) {\n            return;\n        }\n        this._private__scaleStartPoint = null;\n        this._private__priceRangeSnapshot = null;\n    }\n    _internal_startScroll(x) {\n        if (this._internal_isAutoScale()) {\n            return;\n        }\n        if (this._private__scrollStartPoint !== null || this._private__priceRangeSnapshot !== null) {\n            return;\n        }\n        if (this._internal_isEmpty()) {\n            return;\n        }\n        this._private__scrollStartPoint = x;\n        this._private__priceRangeSnapshot = ensureNotNull(this._internal_priceRange())._internal_clone();\n    }\n    _internal_scrollTo(x) {\n        if (this._internal_isAutoScale()) {\n            return;\n        }\n        if (this._private__scrollStartPoint === null) {\n            return;\n        }\n        const priceUnitsPerPixel = ensureNotNull(this._internal_priceRange())._internal_length() / (this._internal_internalHeight() - 1);\n        let pixelDelta = x - this._private__scrollStartPoint;\n        if (this._internal_isInverted()) {\n            pixelDelta *= -1;\n        }\n        const priceDelta = pixelDelta * priceUnitsPerPixel;\n        const newPriceRange = ensureNotNull(this._private__priceRangeSnapshot)._internal_clone();\n        newPriceRange._internal_shift(priceDelta);\n        this._internal_setPriceRange(newPriceRange, true);\n        this._private__marksCache = null;\n    }\n    _internal_endScroll() {\n        if (this._internal_isAutoScale()) {\n            return;\n        }\n        if (this._private__scrollStartPoint === null) {\n            return;\n        }\n        this._private__scrollStartPoint = null;\n        this._private__priceRangeSnapshot = null;\n    }\n    _internal_formatter() {\n        if (!this._private__formatter) {\n            this._internal_updateFormatter();\n        }\n        return this._private__formatter;\n    }\n    _internal_formatPrice(price, firstValue) {\n        switch(this._private__options.mode){\n            case 2 /* PriceScaleMode.Percentage */ :\n                return this._private__formatPercentage(toPercent(price, firstValue));\n            case 3 /* PriceScaleMode.IndexedTo100 */ :\n                return this._internal_formatter().format(toIndexedTo100(price, firstValue));\n            default:\n                return this._private__formatPrice(price);\n        }\n    }\n    _internal_formatLogical(logical) {\n        switch(this._private__options.mode){\n            case 2 /* PriceScaleMode.Percentage */ :\n                return this._private__formatPercentage(logical);\n            case 3 /* PriceScaleMode.IndexedTo100 */ :\n                return this._internal_formatter().format(logical);\n            default:\n                return this._private__formatPrice(logical);\n        }\n    }\n    _internal_formatPriceAbsolute(price) {\n        return this._private__formatPrice(price, ensureNotNull(this._private__formatterSource())._internal_formatter());\n    }\n    _internal_formatPricePercentage(price, baseValue) {\n        price = toPercent(price, baseValue);\n        return this._private__formatPercentage(price, percentageFormatter);\n    }\n    _internal_sourcesForAutoScale() {\n        return this._private__dataSources;\n    }\n    _internal_recalculatePriceRange(visibleBars) {\n        this._private__invalidatedForRange = {\n            _internal_visibleBars: visibleBars,\n            _internal_isValid: false\n        };\n    }\n    _internal_updateAllViews() {\n        this._private__dataSources.forEach((s)=>s._internal_updateAllViews());\n    }\n    _internal_updateFormatter() {\n        this._private__marksCache = null;\n        const formatterSource = this._private__formatterSource();\n        let base = 100;\n        if (formatterSource !== null) {\n            base = Math.round(1 / formatterSource._internal_minMove());\n        }\n        this._private__formatter = defaultPriceFormatter;\n        if (this._internal_isPercentage()) {\n            this._private__formatter = percentageFormatter;\n            base = 100;\n        } else if (this._internal_isIndexedTo100()) {\n            this._private__formatter = new PriceFormatter(100, 1);\n            base = 100;\n        } else {\n            if (formatterSource !== null) {\n                // user\n                this._private__formatter = formatterSource._internal_formatter();\n            }\n        }\n        this._private__markBuilder = new PriceTickMarkBuilder(this, base, this._private__coordinateToLogical.bind(this), this._private__logicalToCoordinate.bind(this));\n        this._private__markBuilder._internal_rebuildTickMarks();\n    }\n    _internal_invalidateSourcesCache() {\n        this._private__cachedOrderedSources = null;\n    }\n    /**\n     * @returns The {@link IPriceDataSource} that will be used as the \"formatter source\" (take minMove for formatter).\n     */ _private__formatterSource() {\n        return this._private__dataSources[0] || null;\n    }\n    _private__topMarginPx() {\n        return this._internal_isInverted() ? this._private__options.scaleMargins.bottom * this._internal_height() + this._private__marginBelow : this._private__options.scaleMargins.top * this._internal_height() + this._private__marginAbove;\n    }\n    _private__bottomMarginPx() {\n        return this._internal_isInverted() ? this._private__options.scaleMargins.top * this._internal_height() + this._private__marginAbove : this._private__options.scaleMargins.bottom * this._internal_height() + this._private__marginBelow;\n    }\n    _private__makeSureItIsValid() {\n        if (!this._private__invalidatedForRange._internal_isValid) {\n            this._private__invalidatedForRange._internal_isValid = true;\n            this._private__recalculatePriceRangeImpl();\n        }\n    }\n    _private__invalidateInternalHeightCache() {\n        this._private__internalHeightCache = null;\n    }\n    _private__logicalToCoordinate(logical, baseValue) {\n        this._private__makeSureItIsValid();\n        if (this._internal_isEmpty()) {\n            return 0;\n        }\n        logical = this._internal_isLog() && logical ? toLog(logical, this._private__logFormula) : logical;\n        const range = ensureNotNull(this._internal_priceRange());\n        const invCoordinate = this._private__bottomMarginPx() + (this._internal_internalHeight() - 1) * (logical - range._internal_minValue()) / range._internal_length();\n        const coordinate = this._internal_invertedCoordinate(invCoordinate);\n        return coordinate;\n    }\n    _private__coordinateToLogical(coordinate, baseValue) {\n        this._private__makeSureItIsValid();\n        if (this._internal_isEmpty()) {\n            return 0;\n        }\n        const invCoordinate = this._internal_invertedCoordinate(coordinate);\n        const range = ensureNotNull(this._internal_priceRange());\n        const logical = range._internal_minValue() + range._internal_length() * ((invCoordinate - this._private__bottomMarginPx()) / (this._internal_internalHeight() - 1));\n        return this._internal_isLog() ? fromLog(logical, this._private__logFormula) : logical;\n    }\n    _private__onIsInvertedChanged() {\n        this._private__marksCache = null;\n        this._private__markBuilder._internal_rebuildTickMarks();\n    }\n    // eslint-disable-next-line complexity\n    _private__recalculatePriceRangeImpl() {\n        const visibleBars = this._private__invalidatedForRange._internal_visibleBars;\n        if (visibleBars === null) {\n            return;\n        }\n        let priceRange = null;\n        const sources = this._internal_sourcesForAutoScale();\n        let marginAbove = 0;\n        let marginBelow = 0;\n        for (const source of sources){\n            if (!source._internal_visible()) {\n                continue;\n            }\n            const firstValue = source._internal_firstValue();\n            if (firstValue === null) {\n                continue;\n            }\n            const autoScaleInfo = source._internal_autoscaleInfo(visibleBars._internal_left(), visibleBars._internal_right());\n            let sourceRange = autoScaleInfo && autoScaleInfo._internal_priceRange();\n            if (sourceRange !== null) {\n                switch(this._private__options.mode){\n                    case 1 /* PriceScaleMode.Logarithmic */ :\n                        sourceRange = convertPriceRangeToLog(sourceRange, this._private__logFormula);\n                        break;\n                    case 2 /* PriceScaleMode.Percentage */ :\n                        sourceRange = toPercentRange(sourceRange, firstValue._internal_value);\n                        break;\n                    case 3 /* PriceScaleMode.IndexedTo100 */ :\n                        sourceRange = toIndexedTo100Range(sourceRange, firstValue._internal_value);\n                        break;\n                }\n                if (priceRange === null) {\n                    priceRange = sourceRange;\n                } else {\n                    priceRange = priceRange._internal_merge(ensureNotNull(sourceRange));\n                }\n                if (autoScaleInfo !== null) {\n                    const margins = autoScaleInfo._internal_margins();\n                    if (margins !== null) {\n                        marginAbove = Math.max(marginAbove, margins.above);\n                        marginBelow = Math.max(marginAbove, margins.below);\n                    }\n                }\n            }\n        }\n        if (marginAbove !== this._private__marginAbove || marginBelow !== this._private__marginBelow) {\n            this._private__marginAbove = marginAbove;\n            this._private__marginBelow = marginBelow;\n            this._private__marksCache = null;\n            this._private__invalidateInternalHeightCache();\n        }\n        if (priceRange !== null) {\n            // keep current range is new is empty\n            if (priceRange._internal_minValue() === priceRange._internal_maxValue()) {\n                const formatterSource = this._private__formatterSource();\n                const minMove = formatterSource === null || this._internal_isPercentage() || this._internal_isIndexedTo100() ? 1 : formatterSource._internal_minMove();\n                // if price range is degenerated to 1 point let's extend it by 10 min move values\n                // to avoid incorrect range and empty (blank) scale (in case of min tick much greater than 1)\n                const extendValue = 5 * minMove;\n                if (this._internal_isLog()) {\n                    priceRange = convertPriceRangeFromLog(priceRange, this._private__logFormula);\n                }\n                priceRange = new PriceRangeImpl(priceRange._internal_minValue() - extendValue, priceRange._internal_maxValue() + extendValue);\n                if (this._internal_isLog()) {\n                    priceRange = convertPriceRangeToLog(priceRange, this._private__logFormula);\n                }\n            }\n            if (this._internal_isLog()) {\n                const rawRange = convertPriceRangeFromLog(priceRange, this._private__logFormula);\n                const newLogFormula = logFormulaForPriceRange(rawRange);\n                if (!logFormulasAreSame(newLogFormula, this._private__logFormula)) {\n                    const rawSnapshot = this._private__priceRangeSnapshot !== null ? convertPriceRangeFromLog(this._private__priceRangeSnapshot, this._private__logFormula) : null;\n                    this._private__logFormula = newLogFormula;\n                    priceRange = convertPriceRangeToLog(rawRange, newLogFormula);\n                    if (rawSnapshot !== null) {\n                        this._private__priceRangeSnapshot = convertPriceRangeToLog(rawSnapshot, newLogFormula);\n                    }\n                }\n            }\n            this._internal_setPriceRange(priceRange);\n        } else {\n            // reset empty to default\n            if (this._private__priceRange === null) {\n                this._internal_setPriceRange(new PriceRangeImpl(-0.5, 0.5));\n                this._private__logFormula = logFormulaForPriceRange(null);\n            }\n        }\n        this._private__invalidatedForRange._internal_isValid = true;\n    }\n    _private__getCoordinateTransformer() {\n        if (this._internal_isPercentage()) {\n            return toPercent;\n        } else if (this._internal_isIndexedTo100()) {\n            return toIndexedTo100;\n        } else if (this._internal_isLog()) {\n            return (price)=>toLog(price, this._private__logFormula);\n        }\n        return null;\n    }\n    _private__formatValue(value, formatter, fallbackFormatter) {\n        if (formatter === undefined) {\n            if (fallbackFormatter === undefined) {\n                fallbackFormatter = this._internal_formatter();\n            }\n            return fallbackFormatter.format(value);\n        }\n        return formatter(value);\n    }\n    _private__formatPrice(price, fallbackFormatter) {\n        return this._private__formatValue(price, this._private__localizationOptions.priceFormatter, fallbackFormatter);\n    }\n    _private__formatPercentage(percentage, fallbackFormatter) {\n        return this._private__formatValue(percentage, this._private__localizationOptions.percentageFormatter, fallbackFormatter);\n    }\n    constructor(id, options, layoutOptions, localizationOptions){\n        this._private__height = 0;\n        this._private__internalHeightCache = null;\n        this._private__priceRange = null;\n        this._private__priceRangeSnapshot = null;\n        this._private__invalidatedForRange = {\n            _internal_isValid: false,\n            _internal_visibleBars: null\n        };\n        this._private__marginAbove = 0;\n        this._private__marginBelow = 0;\n        this._private__onMarksChanged = new Delegate();\n        this._private__modeChanged = new Delegate();\n        this._private__dataSources = [];\n        this._private__cachedOrderedSources = null;\n        this._private__marksCache = null;\n        this._private__scaleStartPoint = null;\n        this._private__scrollStartPoint = null;\n        this._private__formatter = defaultPriceFormatter;\n        this._private__logFormula = logFormulaForPriceRange(null);\n        this._private__id = id;\n        this._private__options = options;\n        this._private__layoutOptions = layoutOptions;\n        this._private__localizationOptions = localizationOptions;\n        this._private__markBuilder = new PriceTickMarkBuilder(this, 100, this._private__coordinateToLogical.bind(this), this._private__logicalToCoordinate.bind(this));\n    }\n}\nconst DEFAULT_STRETCH_FACTOR = 1000;\nclass Pane {\n    _internal_applyScaleOptions(options) {\n        if (options.leftPriceScale) {\n            this._private__leftPriceScale._internal_applyOptions(options.leftPriceScale);\n        }\n        if (options.rightPriceScale) {\n            this._private__rightPriceScale._internal_applyOptions(options.rightPriceScale);\n        }\n        if (options.localization) {\n            this._private__leftPriceScale._internal_updateFormatter();\n            this._private__rightPriceScale._internal_updateFormatter();\n        }\n        if (options.overlayPriceScales) {\n            const sourceArrays = Array.from(this._private__overlaySourcesByScaleId.values());\n            for (const arr of sourceArrays){\n                const priceScale = ensureNotNull(arr[0]._internal_priceScale());\n                priceScale._internal_applyOptions(options.overlayPriceScales);\n                if (options.localization) {\n                    priceScale._internal_updateFormatter();\n                }\n            }\n        }\n    }\n    _internal_priceScaleById(id) {\n        switch(id){\n            case \"left\" /* DefaultPriceScaleId.Left */ :\n                {\n                    return this._private__leftPriceScale;\n                }\n            case \"right\" /* DefaultPriceScaleId.Right */ :\n                {\n                    return this._private__rightPriceScale;\n                }\n        }\n        if (this._private__overlaySourcesByScaleId.has(id)) {\n            return ensureDefined(this._private__overlaySourcesByScaleId.get(id))[0]._internal_priceScale();\n        }\n        return null;\n    }\n    _internal_destroy() {\n        this._internal_model()._internal_priceScalesOptionsChanged()._internal_unsubscribeAll(this);\n        this._private__leftPriceScale._internal_modeChanged()._internal_unsubscribeAll(this);\n        this._private__rightPriceScale._internal_modeChanged()._internal_unsubscribeAll(this);\n        this._private__dataSources.forEach((source)=>{\n            if (source._internal_destroy) {\n                source._internal_destroy();\n            }\n        });\n        this._private__destroyed._internal_fire();\n    }\n    _internal_stretchFactor() {\n        return this._private__stretchFactor;\n    }\n    _internal_setStretchFactor(factor) {\n        this._private__stretchFactor = factor;\n    }\n    _internal_model() {\n        return this._private__model;\n    }\n    _internal_width() {\n        return this._private__width;\n    }\n    _internal_height() {\n        return this._private__height;\n    }\n    _internal_setWidth(width) {\n        this._private__width = width;\n        this._internal_updateAllSources();\n    }\n    _internal_setHeight(height) {\n        this._private__height = height;\n        this._private__leftPriceScale._internal_setHeight(height);\n        this._private__rightPriceScale._internal_setHeight(height);\n        // process overlays\n        this._private__dataSources.forEach((ds)=>{\n            if (this._internal_isOverlay(ds)) {\n                const priceScale = ds._internal_priceScale();\n                if (priceScale !== null) {\n                    priceScale._internal_setHeight(height);\n                }\n            }\n        });\n        this._internal_updateAllSources();\n    }\n    _internal_dataSources() {\n        return this._private__dataSources;\n    }\n    _internal_isOverlay(source) {\n        const priceScale = source._internal_priceScale();\n        if (priceScale === null) {\n            return true;\n        }\n        return this._private__leftPriceScale !== priceScale && this._private__rightPriceScale !== priceScale;\n    }\n    _internal_addDataSource(source, targetScaleId, zOrder) {\n        const targetZOrder = zOrder !== undefined ? zOrder : this._private__getZOrderMinMax()._internal_maxZOrder + 1;\n        this._private__insertDataSource(source, targetScaleId, targetZOrder);\n    }\n    _internal_removeDataSource(source) {\n        const index = this._private__dataSources.indexOf(source);\n        assert(index !== -1, \"removeDataSource: invalid data source\");\n        this._private__dataSources.splice(index, 1);\n        const priceScaleId = ensureNotNull(source._internal_priceScale())._internal_id();\n        if (this._private__overlaySourcesByScaleId.has(priceScaleId)) {\n            const overlaySources = ensureDefined(this._private__overlaySourcesByScaleId.get(priceScaleId));\n            const overlayIndex = overlaySources.indexOf(source);\n            if (overlayIndex !== -1) {\n                overlaySources.splice(overlayIndex, 1);\n                if (overlaySources.length === 0) {\n                    this._private__overlaySourcesByScaleId.delete(priceScaleId);\n                }\n            }\n        }\n        const priceScale = source._internal_priceScale();\n        // if source has owner, it returns owner's price scale\n        // and it does not have source in their list\n        if (priceScale && priceScale._internal_dataSources().indexOf(source) >= 0) {\n            priceScale._internal_removeDataSource(source);\n        }\n        if (priceScale !== null) {\n            priceScale._internal_invalidateSourcesCache();\n            this._internal_recalculatePriceScale(priceScale);\n        }\n        this._private__cachedOrderedSources = null;\n    }\n    _internal_priceScalePosition(priceScale) {\n        if (priceScale === this._private__leftPriceScale) {\n            return \"left\";\n        }\n        if (priceScale === this._private__rightPriceScale) {\n            return \"right\";\n        }\n        return \"overlay\";\n    }\n    _internal_leftPriceScale() {\n        return this._private__leftPriceScale;\n    }\n    _internal_rightPriceScale() {\n        return this._private__rightPriceScale;\n    }\n    _internal_startScalePrice(priceScale, x) {\n        priceScale._internal_startScale(x);\n    }\n    _internal_scalePriceTo(priceScale, x) {\n        priceScale._internal_scaleTo(x);\n        // TODO: be more smart and update only affected views\n        this._internal_updateAllSources();\n    }\n    _internal_endScalePrice(priceScale) {\n        priceScale._internal_endScale();\n    }\n    _internal_startScrollPrice(priceScale, x) {\n        priceScale._internal_startScroll(x);\n    }\n    _internal_scrollPriceTo(priceScale, x) {\n        priceScale._internal_scrollTo(x);\n        this._internal_updateAllSources();\n    }\n    _internal_endScrollPrice(priceScale) {\n        priceScale._internal_endScroll();\n    }\n    _internal_updateAllSources() {\n        this._private__dataSources.forEach((source)=>{\n            source._internal_updateAllViews();\n        });\n    }\n    _internal_defaultPriceScale() {\n        let priceScale = null;\n        if (this._private__model._internal_options().rightPriceScale.visible && this._private__rightPriceScale._internal_dataSources().length !== 0) {\n            priceScale = this._private__rightPriceScale;\n        } else if (this._private__model._internal_options().leftPriceScale.visible && this._private__leftPriceScale._internal_dataSources().length !== 0) {\n            priceScale = this._private__leftPriceScale;\n        } else if (this._private__dataSources.length !== 0) {\n            priceScale = this._private__dataSources[0]._internal_priceScale();\n        }\n        if (priceScale === null) {\n            priceScale = this._private__rightPriceScale;\n        }\n        return priceScale;\n    }\n    _internal_defaultVisiblePriceScale() {\n        let priceScale = null;\n        if (this._private__model._internal_options().rightPriceScale.visible) {\n            priceScale = this._private__rightPriceScale;\n        } else if (this._private__model._internal_options().leftPriceScale.visible) {\n            priceScale = this._private__leftPriceScale;\n        }\n        return priceScale;\n    }\n    _internal_recalculatePriceScale(priceScale) {\n        if (priceScale === null || !priceScale._internal_isAutoScale()) {\n            return;\n        }\n        this._private__recalculatePriceScaleImpl(priceScale);\n    }\n    _internal_resetPriceScale(priceScale) {\n        const visibleBars = this._private__timeScale._internal_visibleStrictRange();\n        priceScale._internal_setMode({\n            _internal_autoScale: true\n        });\n        if (visibleBars !== null) {\n            priceScale._internal_recalculatePriceRange(visibleBars);\n        }\n        this._internal_updateAllSources();\n    }\n    _internal_momentaryAutoScale() {\n        this._private__recalculatePriceScaleImpl(this._private__leftPriceScale);\n        this._private__recalculatePriceScaleImpl(this._private__rightPriceScale);\n    }\n    _internal_recalculate() {\n        this._internal_recalculatePriceScale(this._private__leftPriceScale);\n        this._internal_recalculatePriceScale(this._private__rightPriceScale);\n        this._private__dataSources.forEach((ds)=>{\n            if (this._internal_isOverlay(ds)) {\n                this._internal_recalculatePriceScale(ds._internal_priceScale());\n            }\n        });\n        this._internal_updateAllSources();\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_orderedSources() {\n        if (this._private__cachedOrderedSources === null) {\n            this._private__cachedOrderedSources = sortSources(this._private__dataSources);\n        }\n        return this._private__cachedOrderedSources;\n    }\n    _internal_onDestroyed() {\n        return this._private__destroyed;\n    }\n    _internal_grid() {\n        return this._private__grid;\n    }\n    _private__recalculatePriceScaleImpl(priceScale) {\n        // TODO: can use this checks\n        const sourceForAutoScale = priceScale._internal_sourcesForAutoScale();\n        if (sourceForAutoScale && sourceForAutoScale.length > 0 && !this._private__timeScale._internal_isEmpty()) {\n            const visibleBars = this._private__timeScale._internal_visibleStrictRange();\n            if (visibleBars !== null) {\n                priceScale._internal_recalculatePriceRange(visibleBars);\n            }\n        }\n        priceScale._internal_updateAllViews();\n    }\n    _private__getZOrderMinMax() {\n        const sources = this._internal_orderedSources();\n        if (sources.length === 0) {\n            return {\n                _internal_minZOrder: 0,\n                _internal_maxZOrder: 0\n            };\n        }\n        let minZOrder = 0;\n        let maxZOrder = 0;\n        for(let j = 0; j < sources.length; j++){\n            const ds = sources[j];\n            const zOrder = ds._internal_zorder();\n            if (zOrder !== null) {\n                if (zOrder < minZOrder) {\n                    minZOrder = zOrder;\n                }\n                if (zOrder > maxZOrder) {\n                    maxZOrder = zOrder;\n                }\n            }\n        }\n        return {\n            _internal_minZOrder: minZOrder,\n            _internal_maxZOrder: maxZOrder\n        };\n    }\n    _private__insertDataSource(source, priceScaleId, zOrder) {\n        let priceScale = this._internal_priceScaleById(priceScaleId);\n        if (priceScale === null) {\n            priceScale = this._private__createPriceScale(priceScaleId, this._private__model._internal_options().overlayPriceScales);\n        }\n        this._private__dataSources.push(source);\n        if (!isDefaultPriceScale(priceScaleId)) {\n            const overlaySources = this._private__overlaySourcesByScaleId.get(priceScaleId) || [];\n            overlaySources.push(source);\n            this._private__overlaySourcesByScaleId.set(priceScaleId, overlaySources);\n        }\n        priceScale._internal_addDataSource(source);\n        source._internal_setPriceScale(priceScale);\n        source._internal_setZorder(zOrder);\n        this._internal_recalculatePriceScale(priceScale);\n        this._private__cachedOrderedSources = null;\n    }\n    _private__onPriceScaleModeChanged(priceScale, oldMode, newMode) {\n        if (oldMode._internal_mode === newMode._internal_mode) {\n            return;\n        }\n        // momentary auto scale if we toggle percentage/indexedTo100 mode\n        this._private__recalculatePriceScaleImpl(priceScale);\n    }\n    _private__createPriceScale(id, options) {\n        const actualOptions = Object.assign({\n            visible: true,\n            autoScale: true\n        }, clone(options));\n        const priceScale = new PriceScale(id, actualOptions, this._private__model._internal_options().layout, this._private__model._internal_options().localization);\n        priceScale._internal_setHeight(this._internal_height());\n        return priceScale;\n    }\n    constructor(timeScale, model){\n        this._private__dataSources = [];\n        this._private__overlaySourcesByScaleId = new Map();\n        this._private__height = 0;\n        this._private__width = 0;\n        this._private__stretchFactor = DEFAULT_STRETCH_FACTOR;\n        this._private__cachedOrderedSources = null;\n        this._private__destroyed = new Delegate();\n        this._private__timeScale = timeScale;\n        this._private__model = model;\n        this._private__grid = new Grid(this);\n        const options = model._internal_options();\n        this._private__leftPriceScale = this._private__createPriceScale(\"left\" /* DefaultPriceScaleId.Left */ , options.leftPriceScale);\n        this._private__rightPriceScale = this._private__createPriceScale(\"right\" /* DefaultPriceScaleId.Right */ , options.rightPriceScale);\n        this._private__leftPriceScale._internal_modeChanged()._internal_subscribe(this._private__onPriceScaleModeChanged.bind(this, this._private__leftPriceScale), this);\n        this._private__rightPriceScale._internal_modeChanged()._internal_subscribe(this._private__onPriceScaleModeChanged.bind(this, this._private__rightPriceScale), this);\n        this._internal_applyScaleOptions(options);\n    }\n}\nclass FormattedLabelsCache {\n    _internal_format(tickMark) {\n        const time = tickMark.time;\n        const cacheKey = this._private__horzScaleBehavior.cacheKey(time);\n        const tick = this._private__cache.get(cacheKey);\n        if (tick !== undefined) {\n            return tick._internal_string;\n        }\n        if (this._private__actualSize === this._private__maxSize) {\n            const oldestValue = this._private__tick2Labels.get(this._private__oldestTick);\n            this._private__tick2Labels.delete(this._private__oldestTick);\n            this._private__cache.delete(ensureDefined(oldestValue));\n            this._private__oldestTick++;\n            this._private__actualSize--;\n        }\n        const str = this._private__format(tickMark);\n        this._private__cache.set(cacheKey, {\n            _internal_string: str,\n            _internal_tick: this._private__usageTick\n        });\n        this._private__tick2Labels.set(this._private__usageTick, cacheKey);\n        this._private__actualSize++;\n        this._private__usageTick++;\n        return str;\n    }\n    constructor(format, horzScaleBehavior, size = 50){\n        this._private__actualSize = 0;\n        this._private__usageTick = 1;\n        this._private__oldestTick = 1;\n        this._private__cache = new Map();\n        this._private__tick2Labels = new Map();\n        this._private__format = format;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__maxSize = size;\n    }\n}\nclass RangeImpl {\n    _internal_left() {\n        return this._private__left;\n    }\n    _internal_right() {\n        return this._private__right;\n    }\n    _internal_count() {\n        return this._private__right - this._private__left + 1;\n    }\n    _internal_contains(index) {\n        return this._private__left <= index && index <= this._private__right;\n    }\n    _internal_equals(other) {\n        return this._private__left === other._internal_left() && this._private__right === other._internal_right();\n    }\n    constructor(left, right){\n        assert(left <= right, \"right should be >= left\");\n        this._private__left = left;\n        this._private__right = right;\n    }\n}\nfunction areRangesEqual(first, second) {\n    if (first === null || second === null) {\n        return first === second;\n    }\n    return first._internal_equals(second);\n}\nclass TickMarks {\n    _internal_setUniformDistribution(val) {\n        this._private__uniformDistribution = val;\n        this._private__cache = null;\n    }\n    _internal_setTimeScalePoints(newPoints, firstChangedPointIndex) {\n        this._private__removeMarksSinceIndex(firstChangedPointIndex);\n        this._private__cache = null;\n        for(let index = firstChangedPointIndex; index < newPoints.length; ++index){\n            const point = newPoints[index];\n            let marksForWeight = this._private__marksByWeight.get(point.timeWeight);\n            if (marksForWeight === undefined) {\n                marksForWeight = [];\n                this._private__marksByWeight.set(point.timeWeight, marksForWeight);\n            }\n            marksForWeight.push({\n                index: index,\n                time: point.time,\n                weight: point.timeWeight,\n                originalTime: point.originalTime\n            });\n        }\n    }\n    _internal_build(spacing, maxWidth) {\n        const maxIndexesPerMark = Math.ceil(maxWidth / spacing);\n        if (this._private__cache === null || this._private__cache._internal_maxIndexesPerMark !== maxIndexesPerMark) {\n            this._private__cache = {\n                _internal_marks: this._private__buildMarksImpl(maxIndexesPerMark),\n                _internal_maxIndexesPerMark: maxIndexesPerMark\n            };\n        }\n        return this._private__cache._internal_marks;\n    }\n    _private__removeMarksSinceIndex(sinceIndex) {\n        if (sinceIndex === 0) {\n            this._private__marksByWeight.clear();\n            return;\n        }\n        const weightsToClear = [];\n        this._private__marksByWeight.forEach((marks, timeWeight)=>{\n            if (sinceIndex <= marks[0].index) {\n                weightsToClear.push(timeWeight);\n            } else {\n                marks.splice(lowerBound(marks, sinceIndex, (tm)=>tm.index < sinceIndex), Infinity);\n            }\n        });\n        for (const weight of weightsToClear){\n            this._private__marksByWeight.delete(weight);\n        }\n    }\n    _private__buildMarksImpl(maxIndexesPerMark) {\n        let marks = [];\n        for (const weight of Array.from(this._private__marksByWeight.keys()).sort((a, b)=>b - a)){\n            if (!this._private__marksByWeight.get(weight)) {\n                continue;\n            }\n            // Built tickMarks are now prevMarks, and marks it as new array\n            const prevMarks = marks;\n            marks = [];\n            const prevMarksLength = prevMarks.length;\n            let prevMarksPointer = 0;\n            const currentWeight = ensureDefined(this._private__marksByWeight.get(weight));\n            const currentWeightLength = currentWeight.length;\n            let rightIndex = Infinity;\n            let leftIndex = -Infinity;\n            for(let i = 0; i < currentWeightLength; i++){\n                const mark = currentWeight[i];\n                const currentIndex = mark.index;\n                // Determine indexes with which current index will be compared\n                // All marks to the right is moved to new array\n                while(prevMarksPointer < prevMarksLength){\n                    const lastMark = prevMarks[prevMarksPointer];\n                    const lastIndex = lastMark.index;\n                    if (lastIndex < currentIndex) {\n                        prevMarksPointer++;\n                        marks.push(lastMark);\n                        leftIndex = lastIndex;\n                        rightIndex = Infinity;\n                    } else {\n                        rightIndex = lastIndex;\n                        break;\n                    }\n                }\n                if (rightIndex - currentIndex >= maxIndexesPerMark && currentIndex - leftIndex >= maxIndexesPerMark) {\n                    // TickMark fits. Place it into new array\n                    marks.push(mark);\n                    leftIndex = currentIndex;\n                } else {\n                    if (this._private__uniformDistribution) {\n                        return prevMarks;\n                    }\n                }\n            }\n            // Place all unused tickMarks into new array;\n            for(; prevMarksPointer < prevMarksLength; prevMarksPointer++){\n                marks.push(prevMarks[prevMarksPointer]);\n            }\n        }\n        return marks;\n    }\n    constructor(){\n        this._private__marksByWeight = new Map();\n        this._private__cache = null;\n        this._private__uniformDistribution = false;\n    }\n}\nclass TimeScaleVisibleRange {\n    _internal_strictRange() {\n        if (this._private__logicalRange === null) {\n            return null;\n        }\n        return new RangeImpl(Math.floor(this._private__logicalRange._internal_left()), Math.ceil(this._private__logicalRange._internal_right()));\n    }\n    _internal_logicalRange() {\n        return this._private__logicalRange;\n    }\n    static _internal_invalid() {\n        return new TimeScaleVisibleRange(null);\n    }\n    constructor(logicalRange){\n        this._private__logicalRange = logicalRange;\n    }\n}\nconst defaultTickMarkMaxCharacterLength = 8;\nfunction markWithGreaterWeight(a, b) {\n    return a.weight > b.weight ? a : b;\n}\nclass TimeScale {\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_applyLocalizationOptions(localizationOptions) {\n        merge(this._private__localizationOptions, localizationOptions);\n        this._private__invalidateTickMarks();\n        this._private__updateDateTimeFormatter();\n    }\n    _internal_applyOptions(options, localizationOptions) {\n        var _a;\n        merge(this._private__options, options);\n        if (this._private__options.fixLeftEdge) {\n            this._private__doFixLeftEdge();\n        }\n        if (this._private__options.fixRightEdge) {\n            this._private__doFixRightEdge();\n        }\n        // note that bar spacing should be applied before right offset\n        // because right offset depends on bar spacing\n        if (options.barSpacing !== undefined) {\n            this._private__model._internal_setBarSpacing(options.barSpacing);\n        }\n        if (options.rightOffset !== undefined) {\n            this._private__model._internal_setRightOffset(options.rightOffset);\n        }\n        if (options.minBarSpacing !== undefined) {\n            // yes, if we apply min bar spacing then we need to correct bar spacing\n            // the easiest way is to apply it once again\n            this._private__model._internal_setBarSpacing((_a = options.barSpacing) !== null && _a !== void 0 ? _a : this._private__barSpacing);\n        }\n        this._private__invalidateTickMarks();\n        this._private__updateDateTimeFormatter();\n        this._private__optionsApplied._internal_fire();\n    }\n    _internal_indexToTime(index) {\n        var _a, _b;\n        return (_b = (_a = this._private__points[index]) === null || _a === void 0 ? void 0 : _a.time) !== null && _b !== void 0 ? _b : null;\n    }\n    _internal_indexToTimeScalePoint(index) {\n        var _a;\n        return (_a = this._private__points[index]) !== null && _a !== void 0 ? _a : null;\n    }\n    _internal_timeToIndex(time, findNearest) {\n        if (this._private__points.length < 1) {\n            // no time points available\n            return null;\n        }\n        if (this._private__horzScaleBehavior.key(time) > this._private__horzScaleBehavior.key(this._private__points[this._private__points.length - 1].time)) {\n            // special case\n            return findNearest ? this._private__points.length - 1 : null;\n        }\n        const index = lowerBound(this._private__points, this._private__horzScaleBehavior.key(time), (a, b)=>this._private__horzScaleBehavior.key(a.time) < b);\n        if (this._private__horzScaleBehavior.key(time) < this._private__horzScaleBehavior.key(this._private__points[index].time)) {\n            return findNearest ? index : null;\n        }\n        return index;\n    }\n    _internal_isEmpty() {\n        return this._private__width === 0 || this._private__points.length === 0 || this._private__baseIndexOrNull === null;\n    }\n    _internal_hasPoints() {\n        return this._private__points.length > 0;\n    }\n    // strict range: integer indices of the bars in the visible range rounded in more wide direction\n    _internal_visibleStrictRange() {\n        this._private__updateVisibleRange();\n        return this._private__visibleRange._internal_strictRange();\n    }\n    _internal_visibleLogicalRange() {\n        this._private__updateVisibleRange();\n        return this._private__visibleRange._internal_logicalRange();\n    }\n    _internal_visibleTimeRange() {\n        const visibleBars = this._internal_visibleStrictRange();\n        if (visibleBars === null) {\n            return null;\n        }\n        const range = {\n            from: visibleBars._internal_left(),\n            to: visibleBars._internal_right()\n        };\n        return this._internal_timeRangeForLogicalRange(range);\n    }\n    _internal_timeRangeForLogicalRange(range) {\n        const from = Math.round(range.from);\n        const to = Math.round(range.to);\n        const firstIndex = ensureNotNull(this._private__firstIndex());\n        const lastIndex = ensureNotNull(this._private__lastIndex());\n        return {\n            from: ensureNotNull(this._internal_indexToTimeScalePoint(Math.max(firstIndex, from))),\n            to: ensureNotNull(this._internal_indexToTimeScalePoint(Math.min(lastIndex, to)))\n        };\n    }\n    _internal_logicalRangeForTimeRange(range) {\n        return {\n            from: ensureNotNull(this._internal_timeToIndex(range.from, true)),\n            to: ensureNotNull(this._internal_timeToIndex(range.to, true))\n        };\n    }\n    _internal_width() {\n        return this._private__width;\n    }\n    _internal_setWidth(newWidth) {\n        if (!isFinite(newWidth) || newWidth <= 0) {\n            return;\n        }\n        if (this._private__width === newWidth) {\n            return;\n        }\n        // when we change the width and we need to correct visible range because of fixing left edge\n        // we need to check the previous visible range rather than the new one\n        // because it might be updated by changing width, bar spacing, etc\n        // but we need to try to keep the same range\n        const previousVisibleRange = this._internal_visibleLogicalRange();\n        const oldWidth = this._private__width;\n        this._private__width = newWidth;\n        this._private__visibleRangeInvalidated = true;\n        if (this._private__options.lockVisibleTimeRangeOnResize && oldWidth !== 0) {\n            // recalculate bar spacing\n            const newBarSpacing = this._private__barSpacing * newWidth / oldWidth;\n            this._private__barSpacing = newBarSpacing;\n        }\n        // if time scale is scrolled to the end of data and we have fixed right edge\n        // keep left edge instead of right\n        // we need it to avoid \"shaking\" if the last bar visibility affects time scale width\n        if (this._private__options.fixLeftEdge) {\n            // note that logical left range means not the middle of a bar (it's the left border)\n            if (previousVisibleRange !== null && previousVisibleRange._internal_left() <= 0) {\n                const delta = oldWidth - newWidth;\n                // reduce  _rightOffset means move right\n                // we could move more than required - this will be fixed by _correctOffset()\n                this._private__rightOffset -= Math.round(delta / this._private__barSpacing) + 1;\n                this._private__visibleRangeInvalidated = true;\n            }\n        }\n        // updating bar spacing should be first because right offset depends on it\n        this._private__correctBarSpacing();\n        this._private__correctOffset();\n    }\n    _internal_indexToCoordinate(index) {\n        if (this._internal_isEmpty() || !isInteger(index)) {\n            return 0;\n        }\n        const baseIndex = this._internal_baseIndex();\n        const deltaFromRight = baseIndex + this._private__rightOffset - index;\n        const coordinate = this._private__width - (deltaFromRight + 0.5) * this._private__barSpacing - 1;\n        return coordinate;\n    }\n    _internal_indexesToCoordinates(points, visibleRange) {\n        const baseIndex = this._internal_baseIndex();\n        const indexFrom = visibleRange === undefined ? 0 : visibleRange.from;\n        const indexTo = visibleRange === undefined ? points.length : visibleRange.to;\n        for(let i = indexFrom; i < indexTo; i++){\n            const index = points[i]._internal_time;\n            const deltaFromRight = baseIndex + this._private__rightOffset - index;\n            const coordinate = this._private__width - (deltaFromRight + 0.5) * this._private__barSpacing - 1;\n            points[i]._internal_x = coordinate;\n        }\n    }\n    _internal_coordinateToIndex(x) {\n        return Math.ceil(this._private__coordinateToFloatIndex(x));\n    }\n    _internal_setRightOffset(offset) {\n        this._private__visibleRangeInvalidated = true;\n        this._private__rightOffset = offset;\n        this._private__correctOffset();\n        this._private__model._internal_recalculateAllPanes();\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_barSpacing() {\n        return this._private__barSpacing;\n    }\n    _internal_setBarSpacing(newBarSpacing) {\n        this._private__setBarSpacing(newBarSpacing);\n        // do not allow scroll out of visible bars\n        this._private__correctOffset();\n        this._private__model._internal_recalculateAllPanes();\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_rightOffset() {\n        return this._private__rightOffset;\n    }\n    // eslint-disable-next-line complexity\n    _internal_marks() {\n        if (this._internal_isEmpty()) {\n            return null;\n        }\n        if (this._private__timeMarksCache !== null) {\n            return this._private__timeMarksCache;\n        }\n        const spacing = this._private__barSpacing;\n        const fontSize = this._private__model._internal_options().layout.fontSize;\n        const pixelsPer8Characters = (fontSize + 4) * 5;\n        const pixelsPerCharacter = pixelsPer8Characters / defaultTickMarkMaxCharacterLength;\n        const maxLabelWidth = pixelsPerCharacter * (this._private__options.tickMarkMaxCharacterLength || defaultTickMarkMaxCharacterLength);\n        const indexPerLabel = Math.round(maxLabelWidth / spacing);\n        const visibleBars = ensureNotNull(this._internal_visibleStrictRange());\n        const firstBar = Math.max(visibleBars._internal_left(), visibleBars._internal_left() - indexPerLabel);\n        const lastBar = Math.max(visibleBars._internal_right(), visibleBars._internal_right() - indexPerLabel);\n        const items = this._private__tickMarks._internal_build(spacing, maxLabelWidth);\n        // according to indexPerLabel value this value means \"earliest index which _might be_ used as the second label on time scale\"\n        const earliestIndexOfSecondLabel = this._private__firstIndex() + indexPerLabel;\n        // according to indexPerLabel value this value means \"earliest index which _might be_ used as the second last label on time scale\"\n        const indexOfSecondLastLabel = this._private__lastIndex() - indexPerLabel;\n        const isAllScalingAndScrollingDisabled = this._private__isAllScalingAndScrollingDisabled();\n        const isLeftEdgeFixed = this._private__options.fixLeftEdge || isAllScalingAndScrollingDisabled;\n        const isRightEdgeFixed = this._private__options.fixRightEdge || isAllScalingAndScrollingDisabled;\n        let targetIndex = 0;\n        for (const tm of items){\n            if (!(firstBar <= tm.index && tm.index <= lastBar)) {\n                continue;\n            }\n            let label;\n            if (targetIndex < this._private__labels.length) {\n                label = this._private__labels[targetIndex];\n                label.coord = this._internal_indexToCoordinate(tm.index);\n                label.label = this._private__formatLabel(tm);\n                label.weight = tm.weight;\n            } else {\n                label = {\n                    needAlignCoordinate: false,\n                    coord: this._internal_indexToCoordinate(tm.index),\n                    label: this._private__formatLabel(tm),\n                    weight: tm.weight\n                };\n                this._private__labels.push(label);\n            }\n            if (this._private__barSpacing > maxLabelWidth / 2 && !isAllScalingAndScrollingDisabled) {\n                // if there is enough space then let's show all tick marks as usual\n                label.needAlignCoordinate = false;\n            } else {\n                // if a user is able to scroll after a tick mark then show it as usual, otherwise the coordinate might be aligned\n                // if the index is for the second (last) label or later (earlier) then most likely this label might be displayed without correcting the coordinate\n                label.needAlignCoordinate = isLeftEdgeFixed && tm.index <= earliestIndexOfSecondLabel || isRightEdgeFixed && tm.index >= indexOfSecondLastLabel;\n            }\n            targetIndex++;\n        }\n        this._private__labels.length = targetIndex;\n        this._private__timeMarksCache = this._private__labels;\n        return this._private__labels;\n    }\n    _internal_restoreDefault() {\n        this._private__visibleRangeInvalidated = true;\n        this._internal_setBarSpacing(this._private__options.barSpacing);\n        this._internal_setRightOffset(this._private__options.rightOffset);\n    }\n    _internal_setBaseIndex(baseIndex) {\n        this._private__visibleRangeInvalidated = true;\n        this._private__baseIndexOrNull = baseIndex;\n        this._private__correctOffset();\n        this._private__doFixLeftEdge();\n    }\n    /**\n     * Zoom in/out the scale around a `zoomPoint` on `scale` value.\n     *\n     * @param zoomPoint - X coordinate of the point to apply the zoom.\n     * If `rightBarStaysOnScroll` option is disabled, then will be used to restore right offset.\n     * @param scale - Zoom value (in 1/10 parts of current bar spacing).\n     * Negative value means zoom out, positive - zoom in.\n     */ _internal_zoom(zoomPoint, scale) {\n        const floatIndexAtZoomPoint = this._private__coordinateToFloatIndex(zoomPoint);\n        const barSpacing = this._internal_barSpacing();\n        const newBarSpacing = barSpacing + scale * (barSpacing / 10);\n        // zoom in/out bar spacing\n        this._internal_setBarSpacing(newBarSpacing);\n        if (!this._private__options.rightBarStaysOnScroll) {\n            // and then correct right offset to move index under zoomPoint back to its coordinate\n            this._internal_setRightOffset(this._internal_rightOffset() + (floatIndexAtZoomPoint - this._private__coordinateToFloatIndex(zoomPoint)));\n        }\n    }\n    _internal_startScale(x) {\n        if (this._private__scrollStartPoint) {\n            this._internal_endScroll();\n        }\n        if (this._private__scaleStartPoint !== null || this._private__commonTransitionStartState !== null) {\n            return;\n        }\n        if (this._internal_isEmpty()) {\n            return;\n        }\n        this._private__scaleStartPoint = x;\n        this._private__saveCommonTransitionsStartState();\n    }\n    _internal_scaleTo(x) {\n        if (this._private__commonTransitionStartState === null) {\n            return;\n        }\n        const startLengthFromRight = clamp(this._private__width - x, 0, this._private__width);\n        const currentLengthFromRight = clamp(this._private__width - ensureNotNull(this._private__scaleStartPoint), 0, this._private__width);\n        if (startLengthFromRight === 0 || currentLengthFromRight === 0) {\n            return;\n        }\n        this._internal_setBarSpacing(this._private__commonTransitionStartState._internal_barSpacing * startLengthFromRight / currentLengthFromRight);\n    }\n    _internal_endScale() {\n        if (this._private__scaleStartPoint === null) {\n            return;\n        }\n        this._private__scaleStartPoint = null;\n        this._private__clearCommonTransitionsStartState();\n    }\n    _internal_startScroll(x) {\n        if (this._private__scrollStartPoint !== null || this._private__commonTransitionStartState !== null) {\n            return;\n        }\n        if (this._internal_isEmpty()) {\n            return;\n        }\n        this._private__scrollStartPoint = x;\n        this._private__saveCommonTransitionsStartState();\n    }\n    _internal_scrollTo(x) {\n        if (this._private__scrollStartPoint === null) {\n            return;\n        }\n        const shiftInLogical = (this._private__scrollStartPoint - x) / this._internal_barSpacing();\n        this._private__rightOffset = ensureNotNull(this._private__commonTransitionStartState)._internal_rightOffset + shiftInLogical;\n        this._private__visibleRangeInvalidated = true;\n        // do not allow scroll out of visible bars\n        this._private__correctOffset();\n    }\n    _internal_endScroll() {\n        if (this._private__scrollStartPoint === null) {\n            return;\n        }\n        this._private__scrollStartPoint = null;\n        this._private__clearCommonTransitionsStartState();\n    }\n    _internal_scrollToRealTime() {\n        this._internal_scrollToOffsetAnimated(this._private__options.rightOffset);\n    }\n    _internal_scrollToOffsetAnimated(offset) {\n        let animationDuration = arguments.length > 1 && arguments[1] !== void 0 /* Constants.DefaultAnimationDuration */  ? arguments[1] : 400;\n        if (!isFinite(offset)) {\n            throw new RangeError(\"offset is required and must be finite number\");\n        }\n        if (!isFinite(animationDuration) || animationDuration <= 0) {\n            throw new RangeError(\"animationDuration (optional) must be finite positive number\");\n        }\n        const source = this._private__rightOffset;\n        const animationStart = performance.now();\n        this._private__model._internal_setTimeScaleAnimation({\n            _internal_finished: (time)=>(time - animationStart) / animationDuration >= 1,\n            _internal_getPosition: (time)=>{\n                const animationProgress = (time - animationStart) / animationDuration;\n                const finishAnimation = animationProgress >= 1;\n                return finishAnimation ? offset : source + (offset - source) * animationProgress;\n            }\n        });\n    }\n    _internal_update(newPoints, firstChangedPointIndex) {\n        this._private__visibleRangeInvalidated = true;\n        this._private__points = newPoints;\n        this._private__tickMarks._internal_setTimeScalePoints(newPoints, firstChangedPointIndex);\n        this._private__correctOffset();\n    }\n    _internal_visibleBarsChanged() {\n        return this._private__visibleBarsChanged;\n    }\n    _internal_logicalRangeChanged() {\n        return this._private__logicalRangeChanged;\n    }\n    _internal_optionsApplied() {\n        return this._private__optionsApplied;\n    }\n    _internal_baseIndex() {\n        // null is used to known that baseIndex is not set yet\n        // so in methods which should known whether it is set or not\n        // we should check field `_baseIndexOrNull` instead of getter `baseIndex()`\n        // see minRightOffset for example\n        return this._private__baseIndexOrNull || 0;\n    }\n    _internal_setVisibleRange(range) {\n        const length = range._internal_count();\n        this._private__setBarSpacing(this._private__width / length);\n        this._private__rightOffset = range._internal_right() - this._internal_baseIndex();\n        this._private__correctOffset();\n        this._private__visibleRangeInvalidated = true;\n        this._private__model._internal_recalculateAllPanes();\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_fitContent() {\n        const first = this._private__firstIndex();\n        const last = this._private__lastIndex();\n        if (first === null || last === null) {\n            return;\n        }\n        this._internal_setVisibleRange(new RangeImpl(first, last + this._private__options.rightOffset));\n    }\n    _internal_setLogicalRange(range) {\n        const barRange = new RangeImpl(range.from, range.to);\n        this._internal_setVisibleRange(barRange);\n    }\n    _internal_formatDateTime(timeScalePoint) {\n        if (this._private__localizationOptions.timeFormatter !== undefined) {\n            return this._private__localizationOptions.timeFormatter(timeScalePoint.originalTime);\n        }\n        return this._private__horzScaleBehavior.formatHorzItem(timeScalePoint.time);\n    }\n    _private__isAllScalingAndScrollingDisabled() {\n        const { handleScroll, handleScale } = this._private__model._internal_options();\n        return !handleScroll.horzTouchDrag && !handleScroll.mouseWheel && !handleScroll.pressedMouseMove && !handleScroll.vertTouchDrag && !handleScale.axisDoubleClickReset.time && !handleScale.axisPressedMouseMove.time && !handleScale.mouseWheel && !handleScale.pinch;\n    }\n    _private__firstIndex() {\n        return this._private__points.length === 0 ? null : 0;\n    }\n    _private__lastIndex() {\n        return this._private__points.length === 0 ? null : this._private__points.length - 1;\n    }\n    _private__rightOffsetForCoordinate(x) {\n        return (this._private__width - 1 - x) / this._private__barSpacing;\n    }\n    _private__coordinateToFloatIndex(x) {\n        const deltaFromRight = this._private__rightOffsetForCoordinate(x);\n        const baseIndex = this._internal_baseIndex();\n        const index = baseIndex + this._private__rightOffset - deltaFromRight;\n        // JavaScript uses very strange rounding\n        // we need rounding to avoid problems with calculation errors\n        return Math.round(index * 1000000) / 1000000;\n    }\n    _private__setBarSpacing(newBarSpacing) {\n        const oldBarSpacing = this._private__barSpacing;\n        this._private__barSpacing = newBarSpacing;\n        this._private__correctBarSpacing();\n        // this._barSpacing might be changed in _correctBarSpacing\n        if (oldBarSpacing !== this._private__barSpacing) {\n            this._private__visibleRangeInvalidated = true;\n            this._private__resetTimeMarksCache();\n        }\n    }\n    _private__updateVisibleRange() {\n        if (!this._private__visibleRangeInvalidated) {\n            return;\n        }\n        this._private__visibleRangeInvalidated = false;\n        if (this._internal_isEmpty()) {\n            this._private__setVisibleRange(TimeScaleVisibleRange._internal_invalid());\n            return;\n        }\n        const baseIndex = this._internal_baseIndex();\n        const newBarsLength = this._private__width / this._private__barSpacing;\n        const rightBorder = this._private__rightOffset + baseIndex;\n        const leftBorder = rightBorder - newBarsLength + 1;\n        const logicalRange = new RangeImpl(leftBorder, rightBorder);\n        this._private__setVisibleRange(new TimeScaleVisibleRange(logicalRange));\n    }\n    _private__correctBarSpacing() {\n        const minBarSpacing = this._private__minBarSpacing();\n        if (this._private__barSpacing < minBarSpacing) {\n            this._private__barSpacing = minBarSpacing;\n            this._private__visibleRangeInvalidated = true;\n        }\n        if (this._private__width !== 0) {\n            // make sure that this (1 / Constants.MinVisibleBarsCount) >= coeff in max bar spacing (it's 0.5 here)\n            const maxBarSpacing = this._private__width * 0.5;\n            if (this._private__barSpacing > maxBarSpacing) {\n                this._private__barSpacing = maxBarSpacing;\n                this._private__visibleRangeInvalidated = true;\n            }\n        }\n    }\n    _private__minBarSpacing() {\n        // if both options are enabled then limit bar spacing so that zooming-out is not possible\n        // if it would cause either the first or last points to move too far from an edge\n        if (this._private__options.fixLeftEdge && this._private__options.fixRightEdge && this._private__points.length !== 0) {\n            return this._private__width / this._private__points.length;\n        }\n        return this._private__options.minBarSpacing;\n    }\n    _private__correctOffset() {\n        // block scrolling of to future\n        const maxRightOffset = this._private__maxRightOffset();\n        if (this._private__rightOffset > maxRightOffset) {\n            this._private__rightOffset = maxRightOffset;\n            this._private__visibleRangeInvalidated = true;\n        }\n        // block scrolling of to past\n        const minRightOffset = this._private__minRightOffset();\n        if (minRightOffset !== null && this._private__rightOffset < minRightOffset) {\n            this._private__rightOffset = minRightOffset;\n            this._private__visibleRangeInvalidated = true;\n        }\n    }\n    _private__minRightOffset() {\n        const firstIndex = this._private__firstIndex();\n        const baseIndex = this._private__baseIndexOrNull;\n        if (firstIndex === null || baseIndex === null) {\n            return null;\n        }\n        const barsEstimation = this._private__options.fixLeftEdge ? this._private__width / this._private__barSpacing : Math.min(2 /* Constants.MinVisibleBarsCount */ , this._private__points.length);\n        return firstIndex - baseIndex - 1 + barsEstimation;\n    }\n    _private__maxRightOffset() {\n        return this._private__options.fixRightEdge ? 0 : this._private__width / this._private__barSpacing - Math.min(2 /* Constants.MinVisibleBarsCount */ , this._private__points.length);\n    }\n    _private__saveCommonTransitionsStartState() {\n        this._private__commonTransitionStartState = {\n            _internal_barSpacing: this._internal_barSpacing(),\n            _internal_rightOffset: this._internal_rightOffset()\n        };\n    }\n    _private__clearCommonTransitionsStartState() {\n        this._private__commonTransitionStartState = null;\n    }\n    _private__formatLabel(tickMark) {\n        let formatter = this._private__formattedByWeight.get(tickMark.weight);\n        if (formatter === undefined) {\n            formatter = new FormattedLabelsCache((mark)=>{\n                return this._private__formatLabelImpl(mark);\n            }, this._private__horzScaleBehavior);\n            this._private__formattedByWeight.set(tickMark.weight, formatter);\n        }\n        return formatter._internal_format(tickMark);\n    }\n    _private__formatLabelImpl(tickMark) {\n        return this._private__horzScaleBehavior.formatTickmark(tickMark, this._private__localizationOptions);\n    }\n    _private__setVisibleRange(newVisibleRange) {\n        const oldVisibleRange = this._private__visibleRange;\n        this._private__visibleRange = newVisibleRange;\n        if (!areRangesEqual(oldVisibleRange._internal_strictRange(), this._private__visibleRange._internal_strictRange())) {\n            this._private__visibleBarsChanged._internal_fire();\n        }\n        if (!areRangesEqual(oldVisibleRange._internal_logicalRange(), this._private__visibleRange._internal_logicalRange())) {\n            this._private__logicalRangeChanged._internal_fire();\n        }\n        // TODO: reset only coords in case when this._visibleBars has not been changed\n        this._private__resetTimeMarksCache();\n    }\n    _private__resetTimeMarksCache() {\n        this._private__timeMarksCache = null;\n    }\n    _private__invalidateTickMarks() {\n        this._private__resetTimeMarksCache();\n        this._private__formattedByWeight.clear();\n    }\n    _private__updateDateTimeFormatter() {\n        this._private__horzScaleBehavior.updateFormatter(this._private__localizationOptions);\n    }\n    _private__doFixLeftEdge() {\n        if (!this._private__options.fixLeftEdge) {\n            return;\n        }\n        const firstIndex = this._private__firstIndex();\n        if (firstIndex === null) {\n            return;\n        }\n        const visibleRange = this._internal_visibleStrictRange();\n        if (visibleRange === null) {\n            return;\n        }\n        const delta = visibleRange._internal_left() - firstIndex;\n        if (delta < 0) {\n            const leftEdgeOffset = this._private__rightOffset - delta - 1;\n            this._internal_setRightOffset(leftEdgeOffset);\n        }\n        this._private__correctBarSpacing();\n    }\n    _private__doFixRightEdge() {\n        this._private__correctOffset();\n        this._private__correctBarSpacing();\n    }\n    constructor(model, options, localizationOptions, horzScaleBehavior){\n        this._private__width = 0;\n        this._private__baseIndexOrNull = null;\n        this._private__points = [];\n        this._private__scrollStartPoint = null;\n        this._private__scaleStartPoint = null;\n        this._private__tickMarks = new TickMarks();\n        this._private__formattedByWeight = new Map();\n        this._private__visibleRange = TimeScaleVisibleRange._internal_invalid();\n        this._private__visibleRangeInvalidated = true;\n        this._private__visibleBarsChanged = new Delegate();\n        this._private__logicalRangeChanged = new Delegate();\n        this._private__optionsApplied = new Delegate();\n        this._private__commonTransitionStartState = null;\n        this._private__timeMarksCache = null;\n        this._private__labels = [];\n        this._private__options = options;\n        this._private__localizationOptions = localizationOptions;\n        this._private__rightOffset = options.rightOffset;\n        this._private__barSpacing = options.barSpacing;\n        this._private__model = model;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__updateDateTimeFormatter();\n        this._private__tickMarks._internal_setUniformDistribution(options.uniformDistribution);\n    }\n}\nclass WatermarkRenderer extends MediaCoordinatesPaneRenderer {\n    _internal__drawImpl(renderingScope) {}\n    _internal__drawBackgroundImpl(renderingScope) {\n        if (!this._private__data._internal_visible) {\n            return;\n        }\n        const { context: ctx, mediaSize } = renderingScope;\n        let textHeight = 0;\n        for (const line of this._private__data._internal_lines){\n            if (line._internal_text.length === 0) {\n                continue;\n            }\n            ctx.font = line._internal_font;\n            const textWidth = this._private__metrics(ctx, line._internal_text);\n            if (textWidth > mediaSize.width) {\n                line._internal_zoom = mediaSize.width / textWidth;\n            } else {\n                line._internal_zoom = 1;\n            }\n            textHeight += line._internal_lineHeight * line._internal_zoom;\n        }\n        let vertOffset = 0;\n        switch(this._private__data._internal_vertAlign){\n            case \"top\":\n                vertOffset = 0;\n                break;\n            case \"center\":\n                vertOffset = Math.max((mediaSize.height - textHeight) / 2, 0);\n                break;\n            case \"bottom\":\n                vertOffset = Math.max(mediaSize.height - textHeight, 0);\n                break;\n        }\n        ctx.fillStyle = this._private__data._internal_color;\n        for (const line of this._private__data._internal_lines){\n            ctx.save();\n            let horzOffset = 0;\n            switch(this._private__data._internal_horzAlign){\n                case \"left\":\n                    ctx.textAlign = \"left\";\n                    horzOffset = line._internal_lineHeight / 2;\n                    break;\n                case \"center\":\n                    ctx.textAlign = \"center\";\n                    horzOffset = mediaSize.width / 2;\n                    break;\n                case \"right\":\n                    ctx.textAlign = \"right\";\n                    horzOffset = mediaSize.width - 1 - line._internal_lineHeight / 2;\n                    break;\n            }\n            ctx.translate(horzOffset, vertOffset);\n            ctx.textBaseline = \"top\";\n            ctx.font = line._internal_font;\n            ctx.scale(line._internal_zoom, line._internal_zoom);\n            ctx.fillText(line._internal_text, 0, line._internal_vertOffset);\n            ctx.restore();\n            vertOffset += line._internal_lineHeight * line._internal_zoom;\n        }\n    }\n    _private__metrics(ctx, text) {\n        const fontCache = this._private__fontCache(ctx.font);\n        let result = fontCache.get(text);\n        if (result === undefined) {\n            result = ctx.measureText(text).width;\n            fontCache.set(text, result);\n        }\n        return result;\n    }\n    _private__fontCache(font) {\n        let fontCache = this._private__metricsCache.get(font);\n        if (fontCache === undefined) {\n            fontCache = new Map();\n            this._private__metricsCache.set(font, fontCache);\n        }\n        return fontCache;\n    }\n    constructor(data){\n        super();\n        this._private__metricsCache = new Map();\n        this._private__data = data;\n    }\n}\nclass WatermarkPaneView {\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_renderer() {\n        if (this._private__invalidated) {\n            this._private__updateImpl();\n            this._private__invalidated = false;\n        }\n        return this._private__renderer;\n    }\n    _private__updateImpl() {\n        const options = this._private__source._internal_options();\n        const data = this._private__rendererData;\n        data._internal_visible = options.visible;\n        if (!data._internal_visible) {\n            return;\n        }\n        data._internal_color = options.color;\n        data._internal_horzAlign = options.horzAlign;\n        data._internal_vertAlign = options.vertAlign;\n        data._internal_lines = [\n            {\n                _internal_text: options.text,\n                _internal_font: makeFont(options.fontSize, options.fontFamily, options.fontStyle),\n                _internal_lineHeight: options.fontSize * 1.2,\n                _internal_vertOffset: 0,\n                _internal_zoom: 0\n            }\n        ];\n    }\n    constructor(source){\n        this._private__invalidated = true;\n        this._private__rendererData = {\n            _internal_visible: false,\n            _internal_color: \"\",\n            _internal_lines: [],\n            _internal_vertAlign: \"center\",\n            _internal_horzAlign: \"center\"\n        };\n        this._private__renderer = new WatermarkRenderer(this._private__rendererData);\n        this._private__source = source;\n    }\n}\nclass Watermark extends DataSource {\n    _internal_priceAxisViews() {\n        return [];\n    }\n    _internal_paneViews() {\n        return [\n            this._private__paneView\n        ];\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_updateAllViews() {\n        this._private__paneView._internal_update();\n    }\n    constructor(model, options){\n        super();\n        this._private__options = options;\n        this._private__paneView = new WatermarkPaneView(this);\n    }\n}\n/// <reference types=\"_build-time-constants\" />\n/**\n * Determine how to exit the tracking mode.\n *\n * By default, mobile users will long press to deactivate the scroll and have the ability to check values and dates.\n * Another press is required to activate the scroll, be able to move left/right, zoom, etc.\n */ var TrackingModeExitMode;\n(function(TrackingModeExitMode) {\n    /**\n     * Tracking Mode will be deactivated on touch end event.\n     */ TrackingModeExitMode[TrackingModeExitMode[\"OnTouchEnd\"] = 0] = \"OnTouchEnd\";\n    /**\n     * Tracking Mode will be deactivated on the next tap event.\n     */ TrackingModeExitMode[TrackingModeExitMode[\"OnNextTap\"] = 1] = \"OnNextTap\";\n})(TrackingModeExitMode || (TrackingModeExitMode = {}));\nclass ChartModel {\n    _internal_fullUpdate() {\n        this._private__invalidate(InvalidateMask._internal_full());\n    }\n    _internal_lightUpdate() {\n        this._private__invalidate(InvalidateMask._internal_light());\n    }\n    _internal_cursorUpdate() {\n        this._private__invalidate(new InvalidateMask(1 /* InvalidationLevel.Cursor */ ));\n    }\n    _internal_updateSource(source) {\n        const inv = this._private__invalidationMaskForSource(source);\n        this._private__invalidate(inv);\n    }\n    _internal_hoveredSource() {\n        return this._private__hoveredSource;\n    }\n    _internal_setHoveredSource(source) {\n        const prevSource = this._private__hoveredSource;\n        this._private__hoveredSource = source;\n        if (prevSource !== null) {\n            this._internal_updateSource(prevSource._internal_source);\n        }\n        if (source !== null) {\n            this._internal_updateSource(source._internal_source);\n        }\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_applyOptions(options) {\n        merge(this._private__options, options);\n        this._private__panes.forEach((p)=>p._internal_applyScaleOptions(options));\n        if (options.timeScale !== undefined) {\n            this._private__timeScale._internal_applyOptions(options.timeScale);\n        }\n        if (options.localization !== undefined) {\n            this._private__timeScale._internal_applyLocalizationOptions(options.localization);\n        }\n        if (options.leftPriceScale || options.rightPriceScale) {\n            this._private__priceScalesOptionsChanged._internal_fire();\n        }\n        this._private__backgroundTopColor = this._private__getBackgroundColor(0 /* BackgroundColorSide.Top */ );\n        this._private__backgroundBottomColor = this._private__getBackgroundColor(1 /* BackgroundColorSide.Bottom */ );\n        this._internal_fullUpdate();\n    }\n    _internal_applyPriceScaleOptions(priceScaleId, options) {\n        if (priceScaleId === \"left\" /* DefaultPriceScaleId.Left */ ) {\n            this._internal_applyOptions({\n                leftPriceScale: options\n            });\n            return;\n        } else if (priceScaleId === \"right\" /* DefaultPriceScaleId.Right */ ) {\n            this._internal_applyOptions({\n                rightPriceScale: options\n            });\n            return;\n        }\n        const res = this._internal_findPriceScale(priceScaleId);\n        if (res === null) {\n            {\n                throw new Error(\"Trying to apply price scale options with incorrect ID: \".concat(priceScaleId));\n            }\n        }\n        res._internal_priceScale._internal_applyOptions(options);\n        this._private__priceScalesOptionsChanged._internal_fire();\n    }\n    _internal_findPriceScale(priceScaleId) {\n        for (const pane of this._private__panes){\n            const priceScale = pane._internal_priceScaleById(priceScaleId);\n            if (priceScale !== null) {\n                return {\n                    _internal_pane: pane,\n                    _internal_priceScale: priceScale\n                };\n            }\n        }\n        return null;\n    }\n    _internal_timeScale() {\n        return this._private__timeScale;\n    }\n    _internal_panes() {\n        return this._private__panes;\n    }\n    _internal_watermarkSource() {\n        return this._private__watermark;\n    }\n    _internal_crosshairSource() {\n        return this._private__crosshair;\n    }\n    _internal_crosshairMoved() {\n        return this._private__crosshairMoved;\n    }\n    _internal_setPaneHeight(pane, height) {\n        pane._internal_setHeight(height);\n        this._internal_recalculateAllPanes();\n    }\n    _internal_setWidth(width) {\n        this._private__width = width;\n        this._private__timeScale._internal_setWidth(this._private__width);\n        this._private__panes.forEach((pane)=>pane._internal_setWidth(width));\n        this._internal_recalculateAllPanes();\n    }\n    _internal_createPane(index) {\n        const pane = new Pane(this._private__timeScale, this);\n        if (index !== undefined) {\n            this._private__panes.splice(index, 0, pane);\n        } else {\n            // adding to the end - common case\n            this._private__panes.push(pane);\n        }\n        const actualIndex = index === undefined ? this._private__panes.length - 1 : index;\n        // we always do autoscaling on the creation\n        // if autoscale option is true, it is ok, just recalculate by invalidation mask\n        // if autoscale option is false, autoscale anyway on the first draw\n        // also there is a scenario when autoscale is true in constructor and false later on applyOptions\n        const mask = InvalidateMask._internal_full();\n        mask._internal_invalidatePane(actualIndex, {\n            _internal_level: 0 /* InvalidationLevel.None */ ,\n            _internal_autoScale: true\n        });\n        this._private__invalidate(mask);\n        return pane;\n    }\n    _internal_startScalePrice(pane, priceScale, x) {\n        pane._internal_startScalePrice(priceScale, x);\n    }\n    _internal_scalePriceTo(pane, priceScale, x) {\n        pane._internal_scalePriceTo(priceScale, x);\n        this._internal_updateCrosshair();\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */ ));\n    }\n    _internal_endScalePrice(pane, priceScale) {\n        pane._internal_endScalePrice(priceScale);\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */ ));\n    }\n    _internal_startScrollPrice(pane, priceScale, x) {\n        if (priceScale._internal_isAutoScale()) {\n            return;\n        }\n        pane._internal_startScrollPrice(priceScale, x);\n    }\n    _internal_scrollPriceTo(pane, priceScale, x) {\n        if (priceScale._internal_isAutoScale()) {\n            return;\n        }\n        pane._internal_scrollPriceTo(priceScale, x);\n        this._internal_updateCrosshair();\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */ ));\n    }\n    _internal_endScrollPrice(pane, priceScale) {\n        if (priceScale._internal_isAutoScale()) {\n            return;\n        }\n        pane._internal_endScrollPrice(priceScale);\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */ ));\n    }\n    _internal_resetPriceScale(pane, priceScale) {\n        pane._internal_resetPriceScale(priceScale);\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */ ));\n    }\n    _internal_startScaleTime(position) {\n        this._private__timeScale._internal_startScale(position);\n    }\n    /**\n     * Zoom in/out the chart (depends on scale value).\n     *\n     * @param pointX - X coordinate of the point to apply the zoom (the point which should stay on its place)\n     * @param scale - Zoom value. Negative value means zoom out, positive - zoom in.\n     */ _internal_zoomTime(pointX, scale) {\n        const timeScale = this._internal_timeScale();\n        if (timeScale._internal_isEmpty() || scale === 0) {\n            return;\n        }\n        const timeScaleWidth = timeScale._internal_width();\n        pointX = Math.max(1, Math.min(pointX, timeScaleWidth));\n        timeScale._internal_zoom(pointX, scale);\n        this._internal_recalculateAllPanes();\n    }\n    _internal_scrollChart(x) {\n        this._internal_startScrollTime(0);\n        this._internal_scrollTimeTo(x);\n        this._internal_endScrollTime();\n    }\n    _internal_scaleTimeTo(x) {\n        this._private__timeScale._internal_scaleTo(x);\n        this._internal_recalculateAllPanes();\n    }\n    _internal_endScaleTime() {\n        this._private__timeScale._internal_endScale();\n        this._internal_lightUpdate();\n    }\n    _internal_startScrollTime(x) {\n        this._private__timeScale._internal_startScroll(x);\n    }\n    _internal_scrollTimeTo(x) {\n        this._private__timeScale._internal_scrollTo(x);\n        this._internal_recalculateAllPanes();\n    }\n    _internal_endScrollTime() {\n        this._private__timeScale._internal_endScroll();\n        this._internal_lightUpdate();\n    }\n    _internal_serieses() {\n        return this._private__serieses;\n    }\n    _internal_setAndSaveCurrentPosition(x, y, event, pane, skipEvent) {\n        this._private__crosshair._internal_saveOriginCoord(x, y);\n        let price = NaN;\n        let index = this._private__timeScale._internal_coordinateToIndex(x);\n        const visibleBars = this._private__timeScale._internal_visibleStrictRange();\n        if (visibleBars !== null) {\n            index = Math.min(Math.max(visibleBars._internal_left(), index), visibleBars._internal_right());\n        }\n        const priceScale = pane._internal_defaultPriceScale();\n        const firstValue = priceScale._internal_firstValue();\n        if (firstValue !== null) {\n            price = priceScale._internal_coordinateToPrice(y, firstValue);\n        }\n        price = this._private__magnet._internal_align(price, index, pane);\n        this._private__crosshair._internal_setPosition(index, price, pane);\n        this._internal_cursorUpdate();\n        if (!skipEvent) {\n            this._private__crosshairMoved._internal_fire(this._private__crosshair._internal_appliedIndex(), {\n                x,\n                y\n            }, event);\n        }\n    }\n    // A position provided external (not from an internal event listener)\n    _internal_setAndSaveSyntheticPosition(price, horizontalPosition, pane) {\n        const priceScale = pane._internal_defaultPriceScale();\n        const firstValue = priceScale._internal_firstValue();\n        const y = priceScale._internal_priceToCoordinate(price, ensureNotNull(firstValue));\n        const index = this._private__timeScale._internal_timeToIndex(horizontalPosition, true);\n        const x = this._private__timeScale._internal_indexToCoordinate(ensureNotNull(index));\n        this._internal_setAndSaveCurrentPosition(x, y, null, pane, true);\n    }\n    _internal_clearCurrentPosition(skipEvent) {\n        const crosshair = this._internal_crosshairSource();\n        crosshair._internal_clearPosition();\n        this._internal_cursorUpdate();\n        if (!skipEvent) {\n            this._private__crosshairMoved._internal_fire(null, null, null);\n        }\n    }\n    _internal_updateCrosshair() {\n        // apply magnet\n        const pane = this._private__crosshair._internal_pane();\n        if (pane !== null) {\n            const x = this._private__crosshair._internal_originCoordX();\n            const y = this._private__crosshair._internal_originCoordY();\n            this._internal_setAndSaveCurrentPosition(x, y, null, pane);\n        }\n        this._private__crosshair._internal_updateAllViews();\n    }\n    _internal_updateTimeScale(newBaseIndex, newPoints, firstChangedPointIndex) {\n        const oldFirstTime = this._private__timeScale._internal_indexToTime(0);\n        if (newPoints !== undefined && firstChangedPointIndex !== undefined) {\n            this._private__timeScale._internal_update(newPoints, firstChangedPointIndex);\n        }\n        const newFirstTime = this._private__timeScale._internal_indexToTime(0);\n        const currentBaseIndex = this._private__timeScale._internal_baseIndex();\n        const visibleBars = this._private__timeScale._internal_visibleStrictRange();\n        // if time scale cannot return current visible bars range (e.g. time scale has zero-width)\n        // then we do not need to update right offset to shift visible bars range to have the same right offset as we have before new bar\n        // (and actually we cannot)\n        if (visibleBars !== null && oldFirstTime !== null && newFirstTime !== null) {\n            const isLastSeriesBarVisible = visibleBars._internal_contains(currentBaseIndex);\n            const isLeftBarShiftToLeft = this._private__horzScaleBehavior.key(oldFirstTime) > this._private__horzScaleBehavior.key(newFirstTime);\n            const isSeriesPointsAdded = newBaseIndex !== null && newBaseIndex > currentBaseIndex;\n            const isSeriesPointsAddedToRight = isSeriesPointsAdded && !isLeftBarShiftToLeft;\n            const allowShiftWhenReplacingWhitespace = this._private__timeScale._internal_options().allowShiftVisibleRangeOnWhitespaceReplacement;\n            const replacedExistingWhitespace = firstChangedPointIndex === undefined;\n            const needShiftVisibleRangeOnNewBar = isLastSeriesBarVisible && (!replacedExistingWhitespace || allowShiftWhenReplacingWhitespace) && this._private__timeScale._internal_options().shiftVisibleRangeOnNewBar;\n            if (isSeriesPointsAddedToRight && !needShiftVisibleRangeOnNewBar) {\n                const compensationShift = newBaseIndex - currentBaseIndex;\n                this._private__timeScale._internal_setRightOffset(this._private__timeScale._internal_rightOffset() - compensationShift);\n            }\n        }\n        this._private__timeScale._internal_setBaseIndex(newBaseIndex);\n    }\n    _internal_recalculatePane(pane) {\n        if (pane !== null) {\n            pane._internal_recalculate();\n        }\n    }\n    _internal_paneForSource(source) {\n        const pane = this._private__panes.find((p)=>p._internal_orderedSources().includes(source));\n        return pane === undefined ? null : pane;\n    }\n    _internal_recalculateAllPanes() {\n        this._private__watermark._internal_updateAllViews();\n        this._private__panes.forEach((p)=>p._internal_recalculate());\n        this._internal_updateCrosshair();\n    }\n    _internal_destroy() {\n        this._private__panes.forEach((p)=>p._internal_destroy());\n        this._private__panes.length = 0;\n        // to avoid memleaks\n        this._private__options.localization.priceFormatter = undefined;\n        this._private__options.localization.percentageFormatter = undefined;\n        this._private__options.localization.timeFormatter = undefined;\n    }\n    _internal_rendererOptionsProvider() {\n        return this._private__rendererOptionsProvider;\n    }\n    _internal_priceAxisRendererOptions() {\n        return this._private__rendererOptionsProvider._internal_options();\n    }\n    _internal_priceScalesOptionsChanged() {\n        return this._private__priceScalesOptionsChanged;\n    }\n    _internal_createSeries(seriesType, options, customPaneView) {\n        const pane = this._private__panes[0];\n        const series = this._private__createSeries(options, seriesType, pane, customPaneView);\n        this._private__serieses.push(series);\n        if (this._private__serieses.length === 1) {\n            // call fullUpdate to recalculate chart's parts geometry\n            this._internal_fullUpdate();\n        } else {\n            this._internal_lightUpdate();\n        }\n        return series;\n    }\n    _internal_removeSeries(series) {\n        const pane = this._internal_paneForSource(series);\n        const seriesIndex = this._private__serieses.indexOf(series);\n        assert(seriesIndex !== -1, \"Series not found\");\n        this._private__serieses.splice(seriesIndex, 1);\n        ensureNotNull(pane)._internal_removeDataSource(series);\n        if (series._internal_destroy) {\n            series._internal_destroy();\n        }\n    }\n    _internal_moveSeriesToScale(series, targetScaleId) {\n        const pane = ensureNotNull(this._internal_paneForSource(series));\n        pane._internal_removeDataSource(series);\n        // check if targetScaleId exists\n        const target = this._internal_findPriceScale(targetScaleId);\n        if (target === null) {\n            // new scale on the same pane\n            const zOrder = series._internal_zorder();\n            pane._internal_addDataSource(series, targetScaleId, zOrder);\n        } else {\n            // if move to the new scale of the same pane, keep zorder\n            // if move to new pane\n            const zOrder = target._internal_pane === pane ? series._internal_zorder() : undefined;\n            target._internal_pane._internal_addDataSource(series, targetScaleId, zOrder);\n        }\n    }\n    _internal_fitContent() {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_setFitContent();\n        this._private__invalidate(mask);\n    }\n    _internal_setTargetLogicalRange(range) {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_applyRange(range);\n        this._private__invalidate(mask);\n    }\n    _internal_resetTimeScale() {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_resetTimeScale();\n        this._private__invalidate(mask);\n    }\n    _internal_setBarSpacing(spacing) {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_setBarSpacing(spacing);\n        this._private__invalidate(mask);\n    }\n    _internal_setRightOffset(offset) {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_setRightOffset(offset);\n        this._private__invalidate(mask);\n    }\n    _internal_setTimeScaleAnimation(animation) {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_setTimeScaleAnimation(animation);\n        this._private__invalidate(mask);\n    }\n    _internal_stopTimeScaleAnimation() {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_stopTimeScaleAnimation();\n        this._private__invalidate(mask);\n    }\n    _internal_defaultVisiblePriceScaleId() {\n        return this._private__options.rightPriceScale.visible ? \"right\" /* DefaultPriceScaleId.Right */  : \"left\" /* DefaultPriceScaleId.Left */ ;\n    }\n    _internal_backgroundBottomColor() {\n        return this._private__backgroundBottomColor;\n    }\n    _internal_backgroundTopColor() {\n        return this._private__backgroundTopColor;\n    }\n    _internal_backgroundColorAtYPercentFromTop(percent) {\n        const bottomColor = this._private__backgroundBottomColor;\n        const topColor = this._private__backgroundTopColor;\n        if (bottomColor === topColor) {\n            // solid background\n            return bottomColor;\n        }\n        // gradient background\n        // percent should be from 0 to 100 (we're using only integer values to make cache more efficient)\n        percent = Math.max(0, Math.min(100, Math.round(percent * 100)));\n        if (this._private__gradientColorsCache === null || this._private__gradientColorsCache._internal_topColor !== topColor || this._private__gradientColorsCache._internal_bottomColor !== bottomColor) {\n            this._private__gradientColorsCache = {\n                _internal_topColor: topColor,\n                _internal_bottomColor: bottomColor,\n                _internal_colors: new Map()\n            };\n        } else {\n            const cachedValue = this._private__gradientColorsCache._internal_colors.get(percent);\n            if (cachedValue !== undefined) {\n                return cachedValue;\n            }\n        }\n        const result = gradientColorAtPercent(topColor, bottomColor, percent / 100);\n        this._private__gradientColorsCache._internal_colors.set(percent, result);\n        return result;\n    }\n    _private__paneInvalidationMask(pane, level) {\n        const inv = new InvalidateMask(level);\n        if (pane !== null) {\n            const index = this._private__panes.indexOf(pane);\n            inv._internal_invalidatePane(index, {\n                _internal_level: level\n            });\n        }\n        return inv;\n    }\n    _private__invalidationMaskForSource(source, invalidateType) {\n        if (invalidateType === undefined) {\n            invalidateType = 2 /* InvalidationLevel.Light */ ;\n        }\n        return this._private__paneInvalidationMask(this._internal_paneForSource(source), invalidateType);\n    }\n    _private__invalidate(mask) {\n        if (this._private__invalidateHandler) {\n            this._private__invalidateHandler(mask);\n        }\n        this._private__panes.forEach((pane)=>pane._internal_grid()._internal_paneView()._internal_update());\n    }\n    _private__createSeries(options, seriesType, pane, customPaneView) {\n        const series = new Series(this, options, seriesType, pane, customPaneView);\n        const targetScaleId = options.priceScaleId !== undefined ? options.priceScaleId : this._internal_defaultVisiblePriceScaleId();\n        pane._internal_addDataSource(series, targetScaleId);\n        if (!isDefaultPriceScale(targetScaleId)) {\n            // let's apply that options again to apply margins\n            series._internal_applyOptions(options);\n        }\n        return series;\n    }\n    _private__getBackgroundColor(side) {\n        const layoutOptions = this._private__options.layout;\n        if (layoutOptions.background.type === \"gradient\" /* ColorType.VerticalGradient */ ) {\n            return side === 0 /* BackgroundColorSide.Top */  ? layoutOptions.background.topColor : layoutOptions.background.bottomColor;\n        }\n        return layoutOptions.background.color;\n    }\n    constructor(invalidateHandler, options, horzScaleBehavior){\n        this._private__panes = [];\n        this._private__serieses = [];\n        this._private__width = 0;\n        this._private__hoveredSource = null;\n        this._private__priceScalesOptionsChanged = new Delegate();\n        this._private__crosshairMoved = new Delegate();\n        this._private__gradientColorsCache = null;\n        this._private__invalidateHandler = invalidateHandler;\n        this._private__options = options;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__rendererOptionsProvider = new PriceAxisRendererOptionsProvider(this);\n        this._private__timeScale = new TimeScale(this, options.timeScale, this._private__options.localization, horzScaleBehavior);\n        this._private__crosshair = new Crosshair(this, options.crosshair);\n        this._private__magnet = new Magnet(options.crosshair);\n        this._private__watermark = new Watermark(this, options.watermark);\n        this._internal_createPane();\n        this._private__panes[0]._internal_setStretchFactor(DEFAULT_STRETCH_FACTOR * 2);\n        this._private__backgroundTopColor = this._private__getBackgroundColor(0 /* BackgroundColorSide.Top */ );\n        this._private__backgroundBottomColor = this._private__getBackgroundColor(1 /* BackgroundColorSide.Bottom */ );\n    }\n}\nfunction fillUpDownCandlesticksColors(options) {\n    if (options.borderColor !== undefined) {\n        options.borderUpColor = options.borderColor;\n        options.borderDownColor = options.borderColor;\n    }\n    if (options.wickColor !== undefined) {\n        options.wickUpColor = options.wickColor;\n        options.wickDownColor = options.wickColor;\n    }\n}\n/**\n * Represents the type of the last price animation for series such as area or line.\n */ var LastPriceAnimationMode;\n(function(LastPriceAnimationMode) {\n    /**\n     * Animation is always disabled\n     */ LastPriceAnimationMode[LastPriceAnimationMode[\"Disabled\"] = 0] = \"Disabled\";\n    /**\n     * Animation is always enabled.\n     */ LastPriceAnimationMode[LastPriceAnimationMode[\"Continuous\"] = 1] = \"Continuous\";\n    /**\n     * Animation is active after new data.\n     */ LastPriceAnimationMode[LastPriceAnimationMode[\"OnDataUpdate\"] = 2] = \"OnDataUpdate\";\n})(LastPriceAnimationMode || (LastPriceAnimationMode = {}));\nfunction precisionByMinMove(minMove) {\n    if (minMove >= 1) {\n        return 0;\n    }\n    let i = 0;\n    for(; i < 8; i++){\n        const intPart = Math.round(minMove);\n        const fractPart = Math.abs(intPart - minMove);\n        if (fractPart < 1e-8) {\n            return i;\n        }\n        minMove = minMove * 10;\n    }\n    return i;\n}\n/**\n * Represents the source of data to be used for the horizontal price line.\n */ var PriceLineSource;\n(function(PriceLineSource) {\n    /**\n     * Use the last bar data.\n     */ PriceLineSource[PriceLineSource[\"LastBar\"] = 0] = \"LastBar\";\n    /**\n     * Use the last visible data of the chart viewport.\n     */ PriceLineSource[PriceLineSource[\"LastVisible\"] = 1] = \"LastVisible\";\n})(PriceLineSource || (PriceLineSource = {}));\n/**\n * Represents a type of color.\n */ var ColorType;\n(function(ColorType) {\n    /** Solid color */ ColorType[\"Solid\"] = \"solid\";\n    /** Vertical gradient color */ ColorType[\"VerticalGradient\"] = \"gradient\";\n})(ColorType || (ColorType = {}));\n/**\n * Check if a time value is a business day object.\n *\n * @param time - The time to check.\n * @returns `true` if `time` is a {@link BusinessDay} object, false otherwise.\n */ function isBusinessDay(time) {\n    return !isNumber(time) && !isString(time);\n}\n/**\n * Check if a time value is a UTC timestamp number.\n *\n * @param time - The time to check.\n * @returns `true` if `time` is a {@link UTCTimestamp} number, false otherwise.\n */ function isUTCTimestamp(time) {\n    return isNumber(time);\n}\n/**\n * Represents the type of a tick mark on the time axis.\n */ var TickMarkType;\n(function(TickMarkType) {\n    /**\n     * The start of the year (e.g. it's the first tick mark in a year).\n     */ TickMarkType[TickMarkType[\"Year\"] = 0] = \"Year\";\n    /**\n     * The start of the month (e.g. it's the first tick mark in a month).\n     */ TickMarkType[TickMarkType[\"Month\"] = 1] = \"Month\";\n    /**\n     * A day of the month.\n     */ TickMarkType[TickMarkType[\"DayOfMonth\"] = 2] = \"DayOfMonth\";\n    /**\n     * A time without seconds.\n     */ TickMarkType[TickMarkType[\"Time\"] = 3] = \"Time\";\n    /**\n     * A time with seconds.\n     */ TickMarkType[TickMarkType[\"TimeWithSeconds\"] = 4] = \"TimeWithSeconds\";\n})(TickMarkType || (TickMarkType = {}));\nconst getMonth = (date)=>date.getUTCMonth() + 1;\nconst getDay = (date)=>date.getUTCDate();\nconst getYear = (date)=>date.getUTCFullYear();\nconst dd = (date)=>numberToStringWithLeadingZero(getDay(date), 2);\nconst MMMM = (date, locale)=>new Date(date.getUTCFullYear(), date.getUTCMonth(), 1).toLocaleString(locale, {\n        month: \"long\"\n    });\n_c = MMMM;\nconst MMM = (date, locale)=>new Date(date.getUTCFullYear(), date.getUTCMonth(), 1).toLocaleString(locale, {\n        month: \"short\"\n    });\n_c1 = MMM;\nconst MM = (date)=>numberToStringWithLeadingZero(getMonth(date), 2);\n_c2 = MM;\nconst yy = (date)=>numberToStringWithLeadingZero(getYear(date) % 100, 2);\nconst yyyy = (date)=>numberToStringWithLeadingZero(getYear(date), 4);\nfunction formatDate(date, format, locale) {\n    return format.replace(/yyyy/g, yyyy(date)).replace(/yy/g, yy(date)).replace(/MMMM/g, MMMM(date, locale)).replace(/MMM/g, MMM(date, locale)).replace(/MM/g, MM(date)).replace(/dd/g, dd(date));\n}\nclass DateFormatter {\n    _internal_format(date) {\n        return formatDate(date, this._private__dateFormat, this._private__locale);\n    }\n    constructor(dateFormat = \"yyyy-MM-dd\", locale = \"default\"){\n        this._private__dateFormat = dateFormat;\n        this._private__locale = locale;\n    }\n}\nclass TimeFormatter {\n    _internal_format(date) {\n        return this._private__formatStr.replace(\"%h\", numberToStringWithLeadingZero(date.getUTCHours(), 2)).replace(\"%m\", numberToStringWithLeadingZero(date.getUTCMinutes(), 2)).replace(\"%s\", numberToStringWithLeadingZero(date.getUTCSeconds(), 2));\n    }\n    constructor(format){\n        this._private__formatStr = format || \"%h:%m:%s\";\n    }\n}\nconst defaultParams = {\n    _internal_dateFormat: \"yyyy-MM-dd\",\n    _internal_timeFormat: \"%h:%m:%s\",\n    _internal_dateTimeSeparator: \" \",\n    _internal_locale: \"default\"\n};\nclass DateTimeFormatter {\n    _internal_format(dateTime) {\n        return \"\".concat(this._private__dateFormatter._internal_format(dateTime)).concat(this._private__separator).concat(this._private__timeFormatter._internal_format(dateTime));\n    }\n    constructor(params = {}){\n        const formatterParams = Object.assign(Object.assign({}, defaultParams), params);\n        this._private__dateFormatter = new DateFormatter(formatterParams._internal_dateFormat, formatterParams._internal_locale);\n        this._private__timeFormatter = new TimeFormatter(formatterParams._internal_timeFormat);\n        this._private__separator = formatterParams._internal_dateTimeSeparator;\n    }\n}\nfunction defaultTickMarkFormatter(timePoint, tickMarkType, locale) {\n    const formatOptions = {};\n    switch(tickMarkType){\n        case 0 /* TickMarkType.Year */ :\n            formatOptions.year = \"numeric\";\n            break;\n        case 1 /* TickMarkType.Month */ :\n            formatOptions.month = \"short\";\n            break;\n        case 2 /* TickMarkType.DayOfMonth */ :\n            formatOptions.day = \"numeric\";\n            break;\n        case 3 /* TickMarkType.Time */ :\n            formatOptions.hour12 = false;\n            formatOptions.hour = \"2-digit\";\n            formatOptions.minute = \"2-digit\";\n            break;\n        case 4 /* TickMarkType.TimeWithSeconds */ :\n            formatOptions.hour12 = false;\n            formatOptions.hour = \"2-digit\";\n            formatOptions.minute = \"2-digit\";\n            formatOptions.second = \"2-digit\";\n            break;\n    }\n    const date = timePoint._internal_businessDay === undefined ? new Date(timePoint._internal_timestamp * 1000) : new Date(Date.UTC(timePoint._internal_businessDay.year, timePoint._internal_businessDay.month - 1, timePoint._internal_businessDay.day));\n    // from given date we should use only as UTC date or timestamp\n    // but to format as locale date we can convert UTC date to local date\n    const localDateFromUtc = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());\n    return localDateFromUtc.toLocaleString(locale, formatOptions);\n}\nfunction hours(count) {\n    return count * 60 * 60 * 1000;\n}\nfunction minutes(count) {\n    return count * 60 * 1000;\n}\nfunction seconds(count) {\n    return count * 1000;\n}\nconst intradayWeightDivisors = [\n    {\n        _internal_divisor: seconds(1),\n        _internal_weight: 10 /* TickMarkWeight.Second */ \n    },\n    {\n        _internal_divisor: minutes(1),\n        _internal_weight: 20 /* TickMarkWeight.Minute1 */ \n    },\n    {\n        _internal_divisor: minutes(5),\n        _internal_weight: 21 /* TickMarkWeight.Minute5 */ \n    },\n    {\n        _internal_divisor: minutes(30),\n        _internal_weight: 22 /* TickMarkWeight.Minute30 */ \n    },\n    {\n        _internal_divisor: hours(1),\n        _internal_weight: 30 /* TickMarkWeight.Hour1 */ \n    },\n    {\n        _internal_divisor: hours(3),\n        _internal_weight: 31 /* TickMarkWeight.Hour3 */ \n    },\n    {\n        _internal_divisor: hours(6),\n        _internal_weight: 32 /* TickMarkWeight.Hour6 */ \n    },\n    {\n        _internal_divisor: hours(12),\n        _internal_weight: 33 /* TickMarkWeight.Hour12 */ \n    }\n];\nfunction weightByTime(currentDate, prevDate) {\n    if (currentDate.getUTCFullYear() !== prevDate.getUTCFullYear()) {\n        return 70 /* TickMarkWeight.Year */ ;\n    } else if (currentDate.getUTCMonth() !== prevDate.getUTCMonth()) {\n        return 60 /* TickMarkWeight.Month */ ;\n    } else if (currentDate.getUTCDate() !== prevDate.getUTCDate()) {\n        return 50 /* TickMarkWeight.Day */ ;\n    }\n    for(let i = intradayWeightDivisors.length - 1; i >= 0; --i){\n        if (Math.floor(prevDate.getTime() / intradayWeightDivisors[i]._internal_divisor) !== Math.floor(currentDate.getTime() / intradayWeightDivisors[i]._internal_divisor)) {\n            return intradayWeightDivisors[i]._internal_weight;\n        }\n    }\n    return 0 /* TickMarkWeight.LessThanSecond */ ;\n}\nfunction cast(t) {\n    return t;\n}\nfunction fillWeightsForPoints(sortedTimePoints) {\n    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    if (sortedTimePoints.length === 0) {\n        return;\n    }\n    let prevTime = startIndex === 0 ? null : cast(sortedTimePoints[startIndex - 1].time)._internal_timestamp;\n    let prevDate = prevTime !== null ? new Date(prevTime * 1000) : null;\n    let totalTimeDiff = 0;\n    for(let index = startIndex; index < sortedTimePoints.length; ++index){\n        const currentPoint = sortedTimePoints[index];\n        const currentDate = new Date(cast(currentPoint.time)._internal_timestamp * 1000);\n        if (prevDate !== null) {\n            currentPoint.timeWeight = weightByTime(currentDate, prevDate);\n        }\n        totalTimeDiff += cast(currentPoint.time)._internal_timestamp - (prevTime || cast(currentPoint.time)._internal_timestamp);\n        prevTime = cast(currentPoint.time)._internal_timestamp;\n        prevDate = currentDate;\n    }\n    if (startIndex === 0 && sortedTimePoints.length > 1) {\n        // let's guess a weight for the first point\n        // let's say the previous point was average time back in the history\n        const averageTimeDiff = Math.ceil(totalTimeDiff / (sortedTimePoints.length - 1));\n        const approxPrevDate = new Date((cast(sortedTimePoints[0].time)._internal_timestamp - averageTimeDiff) * 1000);\n        sortedTimePoints[0].timeWeight = weightByTime(new Date(cast(sortedTimePoints[0].time)._internal_timestamp * 1000), approxPrevDate);\n    }\n}\nfunction businessDayConverter(time) {\n    let businessDay = time;\n    if (isString(time)) {\n        businessDay = stringToBusinessDay(time);\n    }\n    if (!isBusinessDay(businessDay)) {\n        throw new Error(\"time must be of type BusinessDay\");\n    }\n    const date = new Date(Date.UTC(businessDay.year, businessDay.month - 1, businessDay.day, 0, 0, 0, 0));\n    return {\n        _internal_timestamp: Math.round(date.getTime() / 1000),\n        _internal_businessDay: businessDay\n    };\n}\nfunction timestampConverter(time) {\n    if (!isUTCTimestamp(time)) {\n        throw new Error(\"time must be of type isUTCTimestamp\");\n    }\n    return {\n        _internal_timestamp: time\n    };\n}\nfunction selectTimeConverter(data) {\n    if (data.length === 0) {\n        return null;\n    }\n    if (isBusinessDay(data[0].time) || isString(data[0].time)) {\n        return businessDayConverter;\n    }\n    return timestampConverter;\n}\nconst validDateRegex = /^\\d\\d\\d\\d-\\d\\d-\\d\\d$/;\nfunction convertTime(time) {\n    if (isUTCTimestamp(time)) {\n        return timestampConverter(time);\n    }\n    if (!isBusinessDay(time)) {\n        return businessDayConverter(stringToBusinessDay(time));\n    }\n    return businessDayConverter(time);\n}\nfunction stringToBusinessDay(value) {\n    {\n        // in some browsers (I look at your Chrome) the Date constructor may accept invalid date string\n        // but parses them in 'implementation specific' way\n        // for example 2019-1-1 isn't the same as 2019-01-01 (for Chrome both are 'valid' date strings)\n        // see https://bugs.chromium.org/p/chromium/issues/detail?id=968939\n        // so, we need to be sure that date has valid format to avoid strange behavior and hours of debugging\n        // but let's do this in development build only because of perf\n        if (!validDateRegex.test(value)) {\n            throw new Error(\"Invalid date string=\".concat(value, \", expected format=yyyy-mm-dd\"));\n        }\n    }\n    const d = new Date(value);\n    if (isNaN(d.getTime())) {\n        throw new Error(\"Invalid date string=\".concat(value, \", expected format=yyyy-mm-dd\"));\n    }\n    return {\n        day: d.getUTCDate(),\n        month: d.getUTCMonth() + 1,\n        year: d.getUTCFullYear()\n    };\n}\nfunction convertStringToBusinessDay(value) {\n    if (isString(value.time)) {\n        value.time = stringToBusinessDay(value.time);\n    }\n}\nfunction convertStringsToBusinessDays(data) {\n    return data.forEach(convertStringToBusinessDay);\n}\n// eslint-disable-next-line complexity\nfunction weightToTickMarkType(weight, timeVisible, secondsVisible) {\n    switch(weight){\n        case 0 /* TickMarkWeight.LessThanSecond */ :\n        case 10 /* TickMarkWeight.Second */ :\n            return timeVisible ? secondsVisible ? 4 /* TickMarkType.TimeWithSeconds */  : 3 /* TickMarkType.Time */  : 2 /* TickMarkType.DayOfMonth */ ;\n        case 20 /* TickMarkWeight.Minute1 */ :\n        case 21 /* TickMarkWeight.Minute5 */ :\n        case 22 /* TickMarkWeight.Minute30 */ :\n        case 30 /* TickMarkWeight.Hour1 */ :\n        case 31 /* TickMarkWeight.Hour3 */ :\n        case 32 /* TickMarkWeight.Hour6 */ :\n        case 33 /* TickMarkWeight.Hour12 */ :\n            return timeVisible ? 3 /* TickMarkType.Time */  : 2 /* TickMarkType.DayOfMonth */ ;\n        case 50 /* TickMarkWeight.Day */ :\n            return 2 /* TickMarkType.DayOfMonth */ ;\n        case 60 /* TickMarkWeight.Month */ :\n            return 1 /* TickMarkType.Month */ ;\n        case 70 /* TickMarkWeight.Year */ :\n            return 0 /* TickMarkType.Year */ ;\n    }\n}\nclass HorzScaleBehaviorTime {\n    options() {\n        return this._private__options;\n    }\n    setOptions(options) {\n        this._private__options = options;\n        this.updateFormatter(options.localization);\n    }\n    preprocessData(data) {\n        if (Array.isArray(data)) {\n            convertStringsToBusinessDays(data);\n        } else {\n            convertStringToBusinessDay(data);\n        }\n    }\n    createConverterToInternalObj(data) {\n        return ensureNotNull(selectTimeConverter(data));\n    }\n    key(item) {\n        // eslint-disable-next-line no-restricted-syntax\n        if (typeof item === \"object\" && \"_internal_timestamp\" in item) {\n            return item._internal_timestamp;\n        } else {\n            return this.key(this.convertHorzItemToInternal(item));\n        }\n    }\n    cacheKey(item) {\n        const time = item;\n        return time._internal_businessDay === undefined ? new Date(time._internal_timestamp * 1000).getTime() : new Date(Date.UTC(time._internal_businessDay.year, time._internal_businessDay.month - 1, time._internal_businessDay.day)).getTime();\n    }\n    convertHorzItemToInternal(item) {\n        return convertTime(item);\n    }\n    updateFormatter(options) {\n        if (!this._private__options) {\n            return;\n        }\n        const dateFormat = options.dateFormat;\n        if (this._private__options.timeScale.timeVisible) {\n            this._private__dateTimeFormatter = new DateTimeFormatter({\n                _internal_dateFormat: dateFormat,\n                _internal_timeFormat: this._private__options.timeScale.secondsVisible ? \"%h:%m:%s\" : \"%h:%m\",\n                _internal_dateTimeSeparator: \"   \",\n                _internal_locale: options.locale\n            });\n        } else {\n            this._private__dateTimeFormatter = new DateFormatter(dateFormat, options.locale);\n        }\n    }\n    formatHorzItem(item) {\n        const tp = item;\n        return this._private__dateTimeFormatter._internal_format(new Date(tp._internal_timestamp * 1000));\n    }\n    formatTickmark(tickMark, localizationOptions) {\n        const tickMarkType = weightToTickMarkType(tickMark.weight, this._private__options.timeScale.timeVisible, this._private__options.timeScale.secondsVisible);\n        const options = this._private__options.timeScale;\n        if (options.tickMarkFormatter !== undefined) {\n            const tickMarkString = options.tickMarkFormatter(tickMark.originalTime, tickMarkType, localizationOptions.locale);\n            if (tickMarkString !== null) {\n                return tickMarkString;\n            }\n        }\n        return defaultTickMarkFormatter(tickMark.time, tickMarkType, localizationOptions.locale);\n    }\n    maxTickMarkWeight(tickMarks) {\n        let maxWeight = tickMarks.reduce(markWithGreaterWeight, tickMarks[0]).weight;\n        // special case: it looks strange if 15:00 is bold but 14:00 is not\n        // so if maxWeight > TickMarkWeight.Hour1 and < TickMarkWeight.Day reduce it to TickMarkWeight.Hour1\n        if (maxWeight > 30 /* TickMarkWeight.Hour1 */  && maxWeight < 50 /* TickMarkWeight.Day */ ) {\n            maxWeight = 30 /* TickMarkWeight.Hour1 */ ;\n        }\n        return maxWeight;\n    }\n    fillWeightsForPoints(sortedTimePoints, startIndex) {\n        fillWeightsForPoints(sortedTimePoints, startIndex);\n    }\n    static _internal_applyDefaults(options) {\n        return merge({\n            localization: {\n                dateFormat: \"dd MMM 'yy\"\n            }\n        }, options !== null && options !== void 0 ? options : {});\n    }\n}\n/**\n * When you're trying to use the library in server-side context (for instance in SSR)\n * you don't have some browser-specific variables like navigator or window\n * and if the library will use them on the top level of the library\n * the import will fail due ReferenceError\n * thus, this allows use the navigator on the top level and being imported in server-side context as well\n * See issue #446\n */ // eslint-disable-next-line @typescript-eslint/tslint/config\nconst isRunningOnClientSide = \"object\" !== \"undefined\";\nfunction isFF() {\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    return window.navigator.userAgent.toLowerCase().indexOf(\"firefox\") > -1;\n}\nfunction isIOS() {\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    return /iPhone|iPad|iPod/.test(window.navigator.platform);\n}\nfunction isChrome() {\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    return window.chrome !== undefined;\n}\n// Determine whether the browser is running on windows.\nfunction isWindows() {\n    var _a;\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    // more accurate if available\n    if ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.platform) {\n        return navigator.userAgentData.platform === \"Windows\";\n    }\n    return navigator.userAgent.toLowerCase().indexOf(\"win\") >= 0;\n}\n// Determine whether the browser is Chromium based.\nfunction isChromiumBased() {\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    if (!navigator.userAgentData) {\n        return false;\n    }\n    return navigator.userAgentData.brands.some((brand)=>{\n        return brand.brand.includes(\"Chromium\");\n    });\n}\n/// <reference types=\"_build-time-constants\" />\nfunction warn(msg) {\n    {\n        // eslint-disable-next-line no-console\n        console.warn(msg);\n    }\n}\n// on Hi-DPI CSS size * Device Pixel Ratio should be integer to avoid smoothing\n// For chart widget we decrease the size because we must be inside container.\n// For time axis this is not important, since it just affects space for pane widgets\nfunction suggestChartSize(originalSize) {\n    const integerWidth = Math.floor(originalSize.width);\n    const integerHeight = Math.floor(originalSize.height);\n    const width = integerWidth - integerWidth % 2;\n    const height = integerHeight - integerHeight % 2;\n    return (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n        width,\n        height\n    });\n}\nfunction suggestTimeScaleHeight(originalHeight) {\n    return originalHeight + originalHeight % 2;\n}\nfunction suggestPriceScaleWidth(originalWidth) {\n    return originalWidth + originalWidth % 2;\n}\nfunction distanceBetweenPoints(pos1, pos2) {\n    return pos1._internal_position - pos2._internal_position;\n}\nfunction speedPxPerMSec(pos1, pos2, maxSpeed) {\n    const speed = (pos1._internal_position - pos2._internal_position) / (pos1._internal_time - pos2._internal_time);\n    return Math.sign(speed) * Math.min(Math.abs(speed), maxSpeed);\n}\nfunction durationMSec(speed, dumpingCoeff) {\n    const lnDumpingCoeff = Math.log(dumpingCoeff);\n    return Math.log(1 /* Constants.EpsilonDistance */  * lnDumpingCoeff / -speed) / lnDumpingCoeff;\n}\nclass KineticAnimation {\n    _internal_addPosition(position, time) {\n        if (this._private__position1 !== null) {\n            if (this._private__position1._internal_time === time) {\n                this._private__position1._internal_position = position;\n                return;\n            }\n            if (Math.abs(this._private__position1._internal_position - position) < this._private__minMove) {\n                return;\n            }\n        }\n        this._private__position4 = this._private__position3;\n        this._private__position3 = this._private__position2;\n        this._private__position2 = this._private__position1;\n        this._private__position1 = {\n            _internal_time: time,\n            _internal_position: position\n        };\n    }\n    _internal_start(position, time) {\n        if (this._private__position1 === null || this._private__position2 === null) {\n            return;\n        }\n        if (time - this._private__position1._internal_time > 50 /* Constants.MaxStartDelay */ ) {\n            return;\n        }\n        // To calculate all the rest parameters we should calculate the speed af first\n        let totalDistance = 0;\n        const speed1 = speedPxPerMSec(this._private__position1, this._private__position2, this._private__maxSpeed);\n        const distance1 = distanceBetweenPoints(this._private__position1, this._private__position2);\n        // We're calculating weighted average speed\n        // Than more distance for a segment, than more its weight\n        const speedItems = [\n            speed1\n        ];\n        const distanceItems = [\n            distance1\n        ];\n        totalDistance += distance1;\n        if (this._private__position3 !== null) {\n            const speed2 = speedPxPerMSec(this._private__position2, this._private__position3, this._private__maxSpeed);\n            // stop at this moment if direction of the segment is opposite\n            if (Math.sign(speed2) === Math.sign(speed1)) {\n                const distance2 = distanceBetweenPoints(this._private__position2, this._private__position3);\n                speedItems.push(speed2);\n                distanceItems.push(distance2);\n                totalDistance += distance2;\n                if (this._private__position4 !== null) {\n                    const speed3 = speedPxPerMSec(this._private__position3, this._private__position4, this._private__maxSpeed);\n                    if (Math.sign(speed3) === Math.sign(speed1)) {\n                        const distance3 = distanceBetweenPoints(this._private__position3, this._private__position4);\n                        speedItems.push(speed3);\n                        distanceItems.push(distance3);\n                        totalDistance += distance3;\n                    }\n                }\n            }\n        }\n        let resultSpeed = 0;\n        for(let i = 0; i < speedItems.length; ++i){\n            resultSpeed += distanceItems[i] / totalDistance * speedItems[i];\n        }\n        if (Math.abs(resultSpeed) < this._private__minSpeed) {\n            return;\n        }\n        this._private__animationStartPosition = {\n            _internal_position: position,\n            _internal_time: time\n        };\n        this._private__speedPxPerMsec = resultSpeed;\n        this._private__durationMsecs = durationMSec(Math.abs(resultSpeed), this._private__dumpingCoeff);\n    }\n    _internal_getPosition(time) {\n        const startPosition = ensureNotNull(this._private__animationStartPosition);\n        const durationMsecs = time - startPosition._internal_time;\n        return startPosition._internal_position + this._private__speedPxPerMsec * (Math.pow(this._private__dumpingCoeff, durationMsecs) - 1) / Math.log(this._private__dumpingCoeff);\n    }\n    _internal_finished(time) {\n        return this._private__animationStartPosition === null || this._private__progressDuration(time) === this._private__durationMsecs;\n    }\n    _private__progressDuration(time) {\n        const startPosition = ensureNotNull(this._private__animationStartPosition);\n        const progress = time - startPosition._internal_time;\n        return Math.min(progress, this._private__durationMsecs);\n    }\n    constructor(minSpeed, maxSpeed, dumpingCoeff, minMove){\n        this._private__position1 = null;\n        this._private__position2 = null;\n        this._private__position3 = null;\n        this._private__position4 = null;\n        this._private__animationStartPosition = null;\n        this._private__durationMsecs = 0;\n        this._private__speedPxPerMsec = 0;\n        this._private__minSpeed = minSpeed;\n        this._private__maxSpeed = maxSpeed;\n        this._private__dumpingCoeff = dumpingCoeff;\n        this._private__minMove = minMove;\n    }\n}\nfunction createBoundCanvas(parentElement, size) {\n    const doc = ensureNotNull(parentElement.ownerDocument);\n    const canvas = doc.createElement(\"canvas\");\n    parentElement.appendChild(canvas);\n    const binding = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.bindCanvasElementBitmapSizeTo)(canvas, {\n        type: \"device-pixel-content-box\",\n        options: {\n            allowResizeObserver: false\n        },\n        transform: (bitmapSize, canvasElementClientSize)=>({\n                width: Math.max(bitmapSize.width, canvasElementClientSize.width),\n                height: Math.max(bitmapSize.height, canvasElementClientSize.height)\n            })\n    });\n    binding.resizeCanvasElement(size);\n    return binding;\n}\nfunction releaseCanvas(canvas) {\n    var _a;\n    // This function fixes the iOS Safari error \"Total canvas memory use exceeds the maximum limit\".\n    // Seems that iOS Safari stores canvas elements for some additional time internally.\n    // So if we create/destroy a lot of canvas elements in a short period of time we can get this error.\n    // We resize the canvas to 1x1 pixels to force it to release memmory resources.\n    canvas.width = 1;\n    canvas.height = 1;\n    (_a = canvas.getContext(\"2d\")) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, 1, 1);\n}\nfunction drawBackground(renderer, target, isHovered, hitTestData) {\n    if (renderer._internal_drawBackground) {\n        renderer._internal_drawBackground(target, isHovered, hitTestData);\n    }\n}\nfunction drawForeground(renderer, target, isHovered, hitTestData) {\n    renderer._internal_draw(target, isHovered, hitTestData);\n}\nfunction drawSourcePaneViews(paneViewsGetter, drawRendererFn, source, pane) {\n    const paneViews = paneViewsGetter(source, pane);\n    for (const paneView of paneViews){\n        const renderer = paneView._internal_renderer();\n        if (renderer !== null) {\n            drawRendererFn(renderer);\n        }\n    }\n}\nfunction preventScrollByWheelClick(el) {\n    if (!isChrome()) {\n        return;\n    }\n    el.addEventListener(\"mousedown\", (e)=>{\n        if (e.button === 1 /* MouseEventButton.Middle */ ) {\n            // prevent incorrect scrolling event\n            e.preventDefault();\n            return false;\n        }\n        return undefined;\n    });\n}\n// TODO: get rid of a lot of boolean flags, probably we should replace it with some enum\nclass MouseEventHandler {\n    _internal_destroy() {\n        if (this._private__unsubscribeOutsideMouseEvents !== null) {\n            this._private__unsubscribeOutsideMouseEvents();\n            this._private__unsubscribeOutsideMouseEvents = null;\n        }\n        if (this._private__unsubscribeOutsideTouchEvents !== null) {\n            this._private__unsubscribeOutsideTouchEvents();\n            this._private__unsubscribeOutsideTouchEvents = null;\n        }\n        if (this._private__unsubscribeMousemove !== null) {\n            this._private__unsubscribeMousemove();\n            this._private__unsubscribeMousemove = null;\n        }\n        if (this._private__unsubscribeRootMouseEvents !== null) {\n            this._private__unsubscribeRootMouseEvents();\n            this._private__unsubscribeRootMouseEvents = null;\n        }\n        if (this._private__unsubscribeRootTouchEvents !== null) {\n            this._private__unsubscribeRootTouchEvents();\n            this._private__unsubscribeRootTouchEvents = null;\n        }\n        if (this._private__unsubscribeMobileSafariEvents !== null) {\n            this._private__unsubscribeMobileSafariEvents();\n            this._private__unsubscribeMobileSafariEvents = null;\n        }\n        this._private__clearLongTapTimeout();\n        this._private__resetClickTimeout();\n    }\n    _private__mouseEnterHandler(enterEvent) {\n        if (this._private__unsubscribeMousemove) {\n            this._private__unsubscribeMousemove();\n        }\n        const boundMouseMoveHandler = this._private__mouseMoveHandler.bind(this);\n        this._private__unsubscribeMousemove = ()=>{\n            this._private__target.removeEventListener(\"mousemove\", boundMouseMoveHandler);\n        };\n        this._private__target.addEventListener(\"mousemove\", boundMouseMoveHandler);\n        if (this._private__firesTouchEvents(enterEvent)) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(enterEvent);\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseEnterEvent);\n        this._private__acceptMouseLeave = true;\n    }\n    _private__resetClickTimeout() {\n        if (this._private__clickTimeoutId !== null) {\n            clearTimeout(this._private__clickTimeoutId);\n        }\n        this._private__clickCount = 0;\n        this._private__clickTimeoutId = null;\n        this._private__clickPosition = {\n            _internal_x: Number.NEGATIVE_INFINITY,\n            _internal_y: Number.POSITIVE_INFINITY\n        };\n    }\n    _private__resetTapTimeout() {\n        if (this._private__tapTimeoutId !== null) {\n            clearTimeout(this._private__tapTimeoutId);\n        }\n        this._private__tapCount = 0;\n        this._private__tapTimeoutId = null;\n        this._private__tapPosition = {\n            _internal_x: Number.NEGATIVE_INFINITY,\n            _internal_y: Number.POSITIVE_INFINITY\n        };\n    }\n    _private__mouseMoveHandler(moveEvent) {\n        if (this._private__mousePressed || this._private__touchMoveStartPosition !== null) {\n            return;\n        }\n        if (this._private__firesTouchEvents(moveEvent)) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(moveEvent);\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseMoveEvent);\n        this._private__acceptMouseLeave = true;\n    }\n    _private__touchMoveHandler(moveEvent) {\n        const touch = touchWithId(moveEvent.changedTouches, ensureNotNull(this._private__activeTouchId));\n        if (touch === null) {\n            return;\n        }\n        this._private__lastTouchEventTimeStamp = eventTimeStamp(moveEvent);\n        if (this._private__startPinchMiddlePoint !== null) {\n            return;\n        }\n        if (this._private__preventTouchDragProcess) {\n            return;\n        }\n        // prevent pinch if move event comes faster than the second touch\n        this._private__pinchPrevented = true;\n        const moveInfo = this._private__touchMouseMoveWithDownInfo(getPosition(touch), ensureNotNull(this._private__touchMoveStartPosition));\n        const { _internal_xOffset: xOffset, _internal_yOffset: yOffset, _internal_manhattanDistance: manhattanDistance } = moveInfo;\n        if (!this._private__touchMoveExceededManhattanDistance && manhattanDistance < 5 /* Constants.CancelTapManhattanDistance */ ) {\n            return;\n        }\n        if (!this._private__touchMoveExceededManhattanDistance) {\n            // first time when current position exceeded manhattan distance\n            // vertical drag is more important than horizontal drag\n            // because we scroll the page vertically often than horizontally\n            const correctedXOffset = xOffset * 0.5;\n            // a drag can be only if touch page scroll isn't allowed\n            const isVertDrag = yOffset >= correctedXOffset && !this._private__options._internal_treatVertTouchDragAsPageScroll();\n            const isHorzDrag = correctedXOffset > yOffset && !this._private__options._internal_treatHorzTouchDragAsPageScroll();\n            // if drag event happened then we should revert preventDefault state to original one\n            // and try to process the drag event\n            // else we shouldn't prevent default of the event and ignore processing the drag event\n            if (!isVertDrag && !isHorzDrag) {\n                this._private__preventTouchDragProcess = true;\n            }\n            this._private__touchMoveExceededManhattanDistance = true;\n            // if manhattan distance is more that 5 - we should cancel tap event\n            this._private__cancelTap = true;\n            this._private__clearLongTapTimeout();\n            this._private__resetTapTimeout();\n        }\n        if (!this._private__preventTouchDragProcess) {\n            const compatEvent = this._private__makeCompatEvent(moveEvent, touch);\n            this._private__processTouchEvent(compatEvent, this._private__handler._internal_touchMoveEvent);\n            // we should prevent default in case of touch only\n            // to prevent scroll of the page\n            preventDefault(moveEvent);\n        }\n    }\n    _private__mouseMoveWithDownHandler(moveEvent) {\n        if (moveEvent.button !== 0 /* MouseEventButton.Left */ ) {\n            return;\n        }\n        const moveInfo = this._private__touchMouseMoveWithDownInfo(getPosition(moveEvent), ensureNotNull(this._private__mouseMoveStartPosition));\n        const { _internal_manhattanDistance: manhattanDistance } = moveInfo;\n        if (manhattanDistance >= 5 /* Constants.CancelClickManhattanDistance */ ) {\n            // if manhattan distance is more that 5 - we should cancel click event\n            this._private__cancelClick = true;\n            this._private__resetClickTimeout();\n        }\n        if (this._private__cancelClick) {\n            // if this._cancelClick is true, that means that minimum manhattan distance is already exceeded\n            const compatEvent = this._private__makeCompatEvent(moveEvent);\n            this._private__processMouseEvent(compatEvent, this._private__handler._internal_pressedMouseMoveEvent);\n        }\n    }\n    _private__touchMouseMoveWithDownInfo(currentPosition, startPosition) {\n        const xOffset = Math.abs(startPosition._internal_x - currentPosition._internal_x);\n        const yOffset = Math.abs(startPosition._internal_y - currentPosition._internal_y);\n        const manhattanDistance = xOffset + yOffset;\n        return {\n            _internal_xOffset: xOffset,\n            _internal_yOffset: yOffset,\n            _internal_manhattanDistance: manhattanDistance\n        };\n    }\n    // eslint-disable-next-line complexity\n    _private__touchEndHandler(touchEndEvent) {\n        let touch = touchWithId(touchEndEvent.changedTouches, ensureNotNull(this._private__activeTouchId));\n        if (touch === null && touchEndEvent.touches.length === 0) {\n            // something went wrong, somehow we missed the required touchend event\n            // probably the browser has not sent this event\n            touch = touchEndEvent.changedTouches[0];\n        }\n        if (touch === null) {\n            return;\n        }\n        this._private__activeTouchId = null;\n        this._private__lastTouchEventTimeStamp = eventTimeStamp(touchEndEvent);\n        this._private__clearLongTapTimeout();\n        this._private__touchMoveStartPosition = null;\n        if (this._private__unsubscribeRootTouchEvents) {\n            this._private__unsubscribeRootTouchEvents();\n            this._private__unsubscribeRootTouchEvents = null;\n        }\n        const compatEvent = this._private__makeCompatEvent(touchEndEvent, touch);\n        this._private__processTouchEvent(compatEvent, this._private__handler._internal_touchEndEvent);\n        ++this._private__tapCount;\n        if (this._private__tapTimeoutId && this._private__tapCount > 1) {\n            // check that both clicks are near enough\n            const { _internal_manhattanDistance: manhattanDistance } = this._private__touchMouseMoveWithDownInfo(getPosition(touch), this._private__tapPosition);\n            if (manhattanDistance < 30 /* Constants.DoubleTapManhattanDistance */  && !this._private__cancelTap) {\n                this._private__processTouchEvent(compatEvent, this._private__handler._internal_doubleTapEvent);\n            }\n            this._private__resetTapTimeout();\n        } else {\n            if (!this._private__cancelTap) {\n                this._private__processTouchEvent(compatEvent, this._private__handler._internal_tapEvent);\n                // do not fire mouse events if tap handler was executed\n                // prevent click event on new dom element (who appeared after tap)\n                if (this._private__handler._internal_tapEvent) {\n                    preventDefault(touchEndEvent);\n                }\n            }\n        }\n        // prevent, for example, safari's dblclick-to-zoom or fast-click after long-tap\n        // we handle mouseDoubleClickEvent here ourselves\n        if (this._private__tapCount === 0) {\n            preventDefault(touchEndEvent);\n        }\n        if (touchEndEvent.touches.length === 0) {\n            if (this._private__longTapActive) {\n                this._private__longTapActive = false;\n                // prevent native click event\n                preventDefault(touchEndEvent);\n            }\n        }\n    }\n    _private__mouseUpHandler(mouseUpEvent) {\n        if (mouseUpEvent.button !== 0 /* MouseEventButton.Left */ ) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(mouseUpEvent);\n        this._private__mouseMoveStartPosition = null;\n        this._private__mousePressed = false;\n        if (this._private__unsubscribeRootMouseEvents) {\n            this._private__unsubscribeRootMouseEvents();\n            this._private__unsubscribeRootMouseEvents = null;\n        }\n        if (isFF()) {\n            const rootElement = this._private__target.ownerDocument.documentElement;\n            rootElement.removeEventListener(\"mouseleave\", this._private__onFirefoxOutsideMouseUp);\n        }\n        if (this._private__firesTouchEvents(mouseUpEvent)) {\n            return;\n        }\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseUpEvent);\n        ++this._private__clickCount;\n        if (this._private__clickTimeoutId && this._private__clickCount > 1) {\n            // check that both clicks are near enough\n            const { _internal_manhattanDistance: manhattanDistance } = this._private__touchMouseMoveWithDownInfo(getPosition(mouseUpEvent), this._private__clickPosition);\n            if (manhattanDistance < 5 /* Constants.DoubleClickManhattanDistance */  && !this._private__cancelClick) {\n                this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseDoubleClickEvent);\n            }\n            this._private__resetClickTimeout();\n        } else {\n            if (!this._private__cancelClick) {\n                this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseClickEvent);\n            }\n        }\n    }\n    _private__clearLongTapTimeout() {\n        if (this._private__longTapTimeoutId === null) {\n            return;\n        }\n        clearTimeout(this._private__longTapTimeoutId);\n        this._private__longTapTimeoutId = null;\n    }\n    _private__touchStartHandler(downEvent) {\n        if (this._private__activeTouchId !== null) {\n            return;\n        }\n        const touch = downEvent.changedTouches[0];\n        this._private__activeTouchId = touch.identifier;\n        this._private__lastTouchEventTimeStamp = eventTimeStamp(downEvent);\n        const rootElement = this._private__target.ownerDocument.documentElement;\n        this._private__cancelTap = false;\n        this._private__touchMoveExceededManhattanDistance = false;\n        this._private__preventTouchDragProcess = false;\n        this._private__touchMoveStartPosition = getPosition(touch);\n        if (this._private__unsubscribeRootTouchEvents) {\n            this._private__unsubscribeRootTouchEvents();\n            this._private__unsubscribeRootTouchEvents = null;\n        }\n        {\n            const boundTouchMoveWithDownHandler = this._private__touchMoveHandler.bind(this);\n            const boundTouchEndHandler = this._private__touchEndHandler.bind(this);\n            this._private__unsubscribeRootTouchEvents = ()=>{\n                rootElement.removeEventListener(\"touchmove\", boundTouchMoveWithDownHandler);\n                rootElement.removeEventListener(\"touchend\", boundTouchEndHandler);\n            };\n            rootElement.addEventListener(\"touchmove\", boundTouchMoveWithDownHandler, {\n                passive: false\n            });\n            rootElement.addEventListener(\"touchend\", boundTouchEndHandler, {\n                passive: false\n            });\n            this._private__clearLongTapTimeout();\n            this._private__longTapTimeoutId = setTimeout(this._private__longTapHandler.bind(this, downEvent), 240 /* Delay.LongTap */ );\n        }\n        const compatEvent = this._private__makeCompatEvent(downEvent, touch);\n        this._private__processTouchEvent(compatEvent, this._private__handler._internal_touchStartEvent);\n        if (!this._private__tapTimeoutId) {\n            this._private__tapCount = 0;\n            this._private__tapTimeoutId = setTimeout(this._private__resetTapTimeout.bind(this), 500 /* Delay.ResetClick */ );\n            this._private__tapPosition = getPosition(touch);\n        }\n    }\n    _private__mouseDownHandler(downEvent) {\n        if (downEvent.button !== 0 /* MouseEventButton.Left */ ) {\n            return;\n        }\n        const rootElement = this._private__target.ownerDocument.documentElement;\n        if (isFF()) {\n            rootElement.addEventListener(\"mouseleave\", this._private__onFirefoxOutsideMouseUp);\n        }\n        this._private__cancelClick = false;\n        this._private__mouseMoveStartPosition = getPosition(downEvent);\n        if (this._private__unsubscribeRootMouseEvents) {\n            this._private__unsubscribeRootMouseEvents();\n            this._private__unsubscribeRootMouseEvents = null;\n        }\n        {\n            const boundMouseMoveWithDownHandler = this._private__mouseMoveWithDownHandler.bind(this);\n            const boundMouseUpHandler = this._private__mouseUpHandler.bind(this);\n            this._private__unsubscribeRootMouseEvents = ()=>{\n                rootElement.removeEventListener(\"mousemove\", boundMouseMoveWithDownHandler);\n                rootElement.removeEventListener(\"mouseup\", boundMouseUpHandler);\n            };\n            rootElement.addEventListener(\"mousemove\", boundMouseMoveWithDownHandler);\n            rootElement.addEventListener(\"mouseup\", boundMouseUpHandler);\n        }\n        this._private__mousePressed = true;\n        if (this._private__firesTouchEvents(downEvent)) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(downEvent);\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseDownEvent);\n        if (!this._private__clickTimeoutId) {\n            this._private__clickCount = 0;\n            this._private__clickTimeoutId = setTimeout(this._private__resetClickTimeout.bind(this), 500 /* Delay.ResetClick */ );\n            this._private__clickPosition = getPosition(downEvent);\n        }\n    }\n    _private__init() {\n        this._private__target.addEventListener(\"mouseenter\", this._private__mouseEnterHandler.bind(this));\n        // Do not show context menu when something went wrong\n        this._private__target.addEventListener(\"touchcancel\", this._private__clearLongTapTimeout.bind(this));\n        {\n            const doc = this._private__target.ownerDocument;\n            const outsideHandler = (event)=>{\n                if (!this._private__handler._internal_mouseDownOutsideEvent) {\n                    return;\n                }\n                if (event.composed && this._private__target.contains(event.composedPath()[0])) {\n                    return;\n                }\n                if (event.target && this._private__target.contains(event.target)) {\n                    return;\n                }\n                this._private__handler._internal_mouseDownOutsideEvent();\n            };\n            this._private__unsubscribeOutsideTouchEvents = ()=>{\n                doc.removeEventListener(\"touchstart\", outsideHandler);\n            };\n            this._private__unsubscribeOutsideMouseEvents = ()=>{\n                doc.removeEventListener(\"mousedown\", outsideHandler);\n            };\n            doc.addEventListener(\"mousedown\", outsideHandler);\n            doc.addEventListener(\"touchstart\", outsideHandler, {\n                passive: true\n            });\n        }\n        if (isIOS()) {\n            this._private__unsubscribeMobileSafariEvents = ()=>{\n                this._private__target.removeEventListener(\"dblclick\", this._private__onMobileSafariDoubleClick);\n            };\n            this._private__target.addEventListener(\"dblclick\", this._private__onMobileSafariDoubleClick);\n        }\n        this._private__target.addEventListener(\"mouseleave\", this._private__mouseLeaveHandler.bind(this));\n        this._private__target.addEventListener(\"touchstart\", this._private__touchStartHandler.bind(this), {\n            passive: true\n        });\n        preventScrollByWheelClick(this._private__target);\n        this._private__target.addEventListener(\"mousedown\", this._private__mouseDownHandler.bind(this));\n        this._private__initPinch();\n        // Hey mobile Safari, what's up?\n        // If mobile Safari doesn't have any touchmove handler with passive=false\n        // it treats a touchstart and the following touchmove events as cancelable=false,\n        // so we can't prevent them (as soon we subscribe on touchmove inside touchstart's handler).\n        // And we'll get scroll of the page along with chart's one instead of only chart's scroll.\n        this._private__target.addEventListener(\"touchmove\", ()=>{}, {\n            passive: false\n        });\n    }\n    _private__initPinch() {\n        if (this._private__handler._internal_pinchStartEvent === undefined && this._private__handler._internal_pinchEvent === undefined && this._private__handler._internal_pinchEndEvent === undefined) {\n            return;\n        }\n        this._private__target.addEventListener(\"touchstart\", (event)=>this._private__checkPinchState(event.touches), {\n            passive: true\n        });\n        this._private__target.addEventListener(\"touchmove\", (event)=>{\n            if (event.touches.length !== 2 || this._private__startPinchMiddlePoint === null) {\n                return;\n            }\n            if (this._private__handler._internal_pinchEvent !== undefined) {\n                const currentDistance = getDistance(event.touches[0], event.touches[1]);\n                const scale = currentDistance / this._private__startPinchDistance;\n                this._private__handler._internal_pinchEvent(this._private__startPinchMiddlePoint, scale);\n                preventDefault(event);\n            }\n        }, {\n            passive: false\n        });\n        this._private__target.addEventListener(\"touchend\", (event)=>{\n            this._private__checkPinchState(event.touches);\n        });\n    }\n    _private__checkPinchState(touches) {\n        if (touches.length === 1) {\n            this._private__pinchPrevented = false;\n        }\n        if (touches.length !== 2 || this._private__pinchPrevented || this._private__longTapActive) {\n            this._private__stopPinch();\n        } else {\n            this._private__startPinch(touches);\n        }\n    }\n    _private__startPinch(touches) {\n        const box = getBoundingClientRect(this._private__target);\n        this._private__startPinchMiddlePoint = {\n            _internal_x: (touches[0].clientX - box.left + (touches[1].clientX - box.left)) / 2,\n            _internal_y: (touches[0].clientY - box.top + (touches[1].clientY - box.top)) / 2\n        };\n        this._private__startPinchDistance = getDistance(touches[0], touches[1]);\n        if (this._private__handler._internal_pinchStartEvent !== undefined) {\n            this._private__handler._internal_pinchStartEvent();\n        }\n        this._private__clearLongTapTimeout();\n    }\n    _private__stopPinch() {\n        if (this._private__startPinchMiddlePoint === null) {\n            return;\n        }\n        this._private__startPinchMiddlePoint = null;\n        if (this._private__handler._internal_pinchEndEvent !== undefined) {\n            this._private__handler._internal_pinchEndEvent();\n        }\n    }\n    _private__mouseLeaveHandler(event) {\n        if (this._private__unsubscribeMousemove) {\n            this._private__unsubscribeMousemove();\n        }\n        if (this._private__firesTouchEvents(event)) {\n            return;\n        }\n        if (!this._private__acceptMouseLeave) {\n            // mobile Safari sometimes emits mouse leave event for no reason, there is no way to handle it in other way\n            // just ignore this event if there was no mouse move or mouse enter events\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(event);\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseLeaveEvent);\n        // accept all mouse leave events if it's not an iOS device\n        this._private__acceptMouseLeave = !isIOS();\n    }\n    _private__longTapHandler(event) {\n        const touch = touchWithId(event.touches, ensureNotNull(this._private__activeTouchId));\n        if (touch === null) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(event, touch);\n        this._private__processTouchEvent(compatEvent, this._private__handler._internal_longTapEvent);\n        this._private__cancelTap = true;\n        // long tap is active until touchend event with 0 touches occurred\n        this._private__longTapActive = true;\n    }\n    _private__firesTouchEvents(e) {\n        if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents !== undefined) {\n            return e.sourceCapabilities.firesTouchEvents;\n        }\n        return eventTimeStamp(e) < this._private__lastTouchEventTimeStamp + 500 /* Delay.PreventFiresTouchEvents */ ;\n    }\n    _private__processTouchEvent(event, callback) {\n        if (callback) {\n            callback.call(this._private__handler, event);\n        }\n    }\n    _private__processMouseEvent(event, callback) {\n        if (!callback) {\n            return;\n        }\n        callback.call(this._private__handler, event);\n    }\n    _private__makeCompatEvent(event, touch) {\n        // TouchEvent has no clientX/Y coordinates:\n        // We have to use the last Touch instead\n        const eventLike = touch || event;\n        const box = this._private__target.getBoundingClientRect() || {\n            left: 0,\n            top: 0\n        };\n        return {\n            clientX: eventLike.clientX,\n            clientY: eventLike.clientY,\n            pageX: eventLike.pageX,\n            pageY: eventLike.pageY,\n            screenX: eventLike.screenX,\n            screenY: eventLike.screenY,\n            localX: eventLike.clientX - box.left,\n            localY: eventLike.clientY - box.top,\n            ctrlKey: event.ctrlKey,\n            altKey: event.altKey,\n            shiftKey: event.shiftKey,\n            metaKey: event.metaKey,\n            _internal_isTouch: !event.type.startsWith(\"mouse\") && event.type !== \"contextmenu\" && event.type !== \"click\",\n            _internal_srcType: event.type,\n            _internal_target: eventLike.target,\n            _internal_view: event.view,\n            _internal_preventDefault: ()=>{\n                if (event.type !== \"touchstart\") {\n                    // touchstart is passive and cannot be prevented\n                    preventDefault(event);\n                }\n            }\n        };\n    }\n    constructor(target, handler, options){\n        this._private__clickCount = 0;\n        this._private__clickTimeoutId = null;\n        this._private__clickPosition = {\n            _internal_x: Number.NEGATIVE_INFINITY,\n            _internal_y: Number.POSITIVE_INFINITY\n        };\n        this._private__tapCount = 0;\n        this._private__tapTimeoutId = null;\n        this._private__tapPosition = {\n            _internal_x: Number.NEGATIVE_INFINITY,\n            _internal_y: Number.POSITIVE_INFINITY\n        };\n        this._private__longTapTimeoutId = null;\n        this._private__longTapActive = false;\n        this._private__mouseMoveStartPosition = null;\n        this._private__touchMoveStartPosition = null;\n        this._private__touchMoveExceededManhattanDistance = false;\n        this._private__cancelClick = false;\n        this._private__cancelTap = false;\n        this._private__unsubscribeOutsideMouseEvents = null;\n        this._private__unsubscribeOutsideTouchEvents = null;\n        this._private__unsubscribeMobileSafariEvents = null;\n        this._private__unsubscribeMousemove = null;\n        this._private__unsubscribeRootMouseEvents = null;\n        this._private__unsubscribeRootTouchEvents = null;\n        this._private__startPinchMiddlePoint = null;\n        this._private__startPinchDistance = 0;\n        this._private__pinchPrevented = false;\n        this._private__preventTouchDragProcess = false;\n        this._private__mousePressed = false;\n        this._private__lastTouchEventTimeStamp = 0;\n        // for touchstart/touchmove/touchend events we handle only first touch\n        // i.e. we don't support several active touches at the same time (except pinch event)\n        this._private__activeTouchId = null;\n        // accept all mouse leave events if it's not an iOS device\n        // see _mouseEnterHandler, _mouseMoveHandler, _mouseLeaveHandler\n        this._private__acceptMouseLeave = !isIOS();\n        /**\n         * In Firefox mouse events dont't fire if the mouse position is outside of the browser's border.\n         * To prevent the mouse from hanging while pressed we're subscribing on the mouseleave event of the document element.\n         * We're subscribing on mouseleave, but this event is actually fired on mouseup outside of the browser's border.\n         */ this._private__onFirefoxOutsideMouseUp = (mouseUpEvent)=>{\n            this._private__mouseUpHandler(mouseUpEvent);\n        };\n        /**\n         * Safari doesn't fire touchstart/mousedown events on double tap since iOS 13.\n         * There are two possible solutions:\n         * 1) Call preventDefault in touchEnd handler. But it also prevents click event from firing.\n         * 2) Add listener on dblclick event that fires with the preceding mousedown/mouseup.\n         * https://developer.apple.com/forums/thread/125073\n         */ this._private__onMobileSafariDoubleClick = (dblClickEvent)=>{\n            if (this._private__firesTouchEvents(dblClickEvent)) {\n                const compatEvent = this._private__makeCompatEvent(dblClickEvent);\n                ++this._private__tapCount;\n                if (this._private__tapTimeoutId && this._private__tapCount > 1) {\n                    const { _internal_manhattanDistance: manhattanDistance } = this._private__touchMouseMoveWithDownInfo(getPosition(dblClickEvent), this._private__tapPosition);\n                    if (manhattanDistance < 30 /* Constants.DoubleTapManhattanDistance */  && !this._private__cancelTap) {\n                        this._private__processTouchEvent(compatEvent, this._private__handler._internal_doubleTapEvent);\n                    }\n                    this._private__resetTapTimeout();\n                }\n            } else {\n                const compatEvent = this._private__makeCompatEvent(dblClickEvent);\n                ++this._private__clickCount;\n                if (this._private__clickTimeoutId && this._private__clickCount > 1) {\n                    const { _internal_manhattanDistance: manhattanDistance } = this._private__touchMouseMoveWithDownInfo(getPosition(dblClickEvent), this._private__clickPosition);\n                    if (manhattanDistance < 5 /* Constants.DoubleClickManhattanDistance */  && !this._private__cancelClick) {\n                        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseDoubleClickEvent);\n                    }\n                    this._private__resetClickTimeout();\n                }\n            }\n        };\n        this._private__target = target;\n        this._private__handler = handler;\n        this._private__options = options;\n        this._private__init();\n    }\n}\nfunction getBoundingClientRect(element) {\n    return element.getBoundingClientRect() || {\n        left: 0,\n        top: 0\n    };\n}\nfunction getDistance(p1, p2) {\n    const xDiff = p1.clientX - p2.clientX;\n    const yDiff = p1.clientY - p2.clientY;\n    return Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n}\nfunction preventDefault(event) {\n    if (event.cancelable) {\n        event.preventDefault();\n    }\n}\nfunction getPosition(eventLike) {\n    return {\n        _internal_x: eventLike.pageX,\n        _internal_y: eventLike.pageY\n    };\n}\nfunction eventTimeStamp(e) {\n    // for some reason e.timestamp is always 0 on iPad with magic mouse, so we use performance.now() as a fallback\n    return e.timeStamp || performance.now();\n}\nfunction touchWithId(touches, id) {\n    for(let i = 0; i < touches.length; ++i){\n        if (touches[i].identifier === id) {\n            return touches[i];\n        }\n    }\n    return null;\n}\n// returns true if item is above reference\nfunction comparePrimitiveZOrder(item, reference) {\n    return !reference || item === \"top\" && reference !== \"top\" || item === \"normal\" && reference === \"bottom\";\n}\nfunction findBestPrimitiveHitTest(sources, x, y) {\n    var _a, _b;\n    let bestPrimitiveHit;\n    let bestHitSource;\n    for (const source of sources){\n        const primitiveHitResults = (_b = (_a = source._internal_primitiveHitTest) === null || _a === void 0 ? void 0 : _a.call(source, x, y)) !== null && _b !== void 0 ? _b : [];\n        for (const hitResult of primitiveHitResults){\n            if (comparePrimitiveZOrder(hitResult.zOrder, bestPrimitiveHit === null || bestPrimitiveHit === void 0 ? void 0 : bestPrimitiveHit.zOrder)) {\n                bestPrimitiveHit = hitResult;\n                bestHitSource = source;\n            }\n        }\n    }\n    if (!bestPrimitiveHit || !bestHitSource) {\n        return null;\n    }\n    return {\n        _internal_hit: bestPrimitiveHit,\n        _internal_source: bestHitSource\n    };\n}\nfunction convertPrimitiveHitResult(primitiveHit) {\n    return {\n        _internal_source: primitiveHit._internal_source,\n        _internal_object: {\n            _internal_externalId: primitiveHit._internal_hit.externalId\n        },\n        _internal_cursorStyle: primitiveHit._internal_hit.cursorStyle\n    };\n}\n/**\n * Performs a hit test on a collection of pane views to determine which view and object\n * is located at a given coordinate (x, y) and returns the matching pane view and\n * hit-tested result object, or null if no match is found.\n */ function hitTestPaneView(paneViews, x, y) {\n    for (const paneView of paneViews){\n        const renderer = paneView._internal_renderer();\n        if (renderer !== null && renderer._internal_hitTest) {\n            const result = renderer._internal_hitTest(x, y);\n            if (result !== null) {\n                return {\n                    _internal_view: paneView,\n                    _internal_object: result\n                };\n            }\n        }\n    }\n    return null;\n}\nfunction hitTestPane(pane, x, y) {\n    const sources = pane._internal_orderedSources();\n    const bestPrimitiveHit = findBestPrimitiveHitTest(sources, x, y);\n    if ((bestPrimitiveHit === null || bestPrimitiveHit === void 0 ? void 0 : bestPrimitiveHit._internal_hit.zOrder) === \"top\") {\n        // a primitive hit on the 'top' layer will always beat the built-in hit tests\n        // (on normal layer) so we can return early here.\n        return convertPrimitiveHitResult(bestPrimitiveHit);\n    }\n    for (const source of sources){\n        if (bestPrimitiveHit && bestPrimitiveHit._internal_source === source && bestPrimitiveHit._internal_hit.zOrder !== \"bottom\" && !bestPrimitiveHit._internal_hit.isBackground) {\n            // a primitive will be drawn above a built-in item like a series marker\n            // therefore it takes precedence here.\n            return convertPrimitiveHitResult(bestPrimitiveHit);\n        }\n        const sourceResult = hitTestPaneView(source._internal_paneViews(pane), x, y);\n        if (sourceResult !== null) {\n            return {\n                _internal_source: source,\n                _internal_view: sourceResult._internal_view,\n                _internal_object: sourceResult._internal_object\n            };\n        }\n        if (bestPrimitiveHit && bestPrimitiveHit._internal_source === source && bestPrimitiveHit._internal_hit.zOrder !== \"bottom\" && bestPrimitiveHit._internal_hit.isBackground) {\n            return convertPrimitiveHitResult(bestPrimitiveHit);\n        }\n    }\n    if (bestPrimitiveHit === null || bestPrimitiveHit === void 0 ? void 0 : bestPrimitiveHit._internal_hit) {\n        // return primitive hits for the 'bottom' layer\n        return convertPrimitiveHitResult(bestPrimitiveHit);\n    }\n    return null;\n}\nfunction buildPriceAxisViewsGetter(zOrder, priceScaleId) {\n    return (source)=>{\n        var _a, _b, _c, _d;\n        const psId = (_b = (_a = source._internal_priceScale()) === null || _a === void 0 ? void 0 : _a._internal_id()) !== null && _b !== void 0 ? _b : \"\";\n        if (psId !== priceScaleId) {\n            // exclude if source is using a different price scale.\n            return [];\n        }\n        return (_d = (_c = source._internal_pricePaneViews) === null || _c === void 0 ? void 0 : _c.call(source, zOrder)) !== null && _d !== void 0 ? _d : [];\n    };\n}\nclass PriceAxisWidget {\n    _internal_destroy() {\n        this._private__mouseEventHandler._internal_destroy();\n        this._private__topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__topCanvasBinding.canvasElement);\n        this._private__topCanvasBinding.dispose();\n        this._private__canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__canvasBinding.canvasElement);\n        this._private__canvasBinding.dispose();\n        if (this._private__priceScale !== null) {\n            this._private__priceScale._internal_onMarksChanged()._internal_unsubscribeAll(this);\n        }\n        this._private__priceScale = null;\n    }\n    _internal_getElement() {\n        return this._private__cell;\n    }\n    _internal_fontSize() {\n        return this._private__layoutOptions.fontSize;\n    }\n    _internal_rendererOptions() {\n        const options = this._private__rendererOptionsProvider._internal_options();\n        const isFontChanged = this._private__font !== options._internal_font;\n        if (isFontChanged) {\n            this._private__widthCache._internal_reset();\n            this._private__font = options._internal_font;\n        }\n        return options;\n    }\n    _internal_optimalWidth() {\n        if (this._private__priceScale === null) {\n            return 0;\n        }\n        let tickMarkMaxWidth = 0;\n        const rendererOptions = this._internal_rendererOptions();\n        const ctx = ensureNotNull(this._private__canvasBinding.canvasElement.getContext(\"2d\"));\n        ctx.save();\n        const tickMarks = this._private__priceScale._internal_marks();\n        ctx.font = this._private__baseFont();\n        if (tickMarks.length > 0) {\n            tickMarkMaxWidth = Math.max(this._private__widthCache._internal_measureText(ctx, tickMarks[0]._internal_label), this._private__widthCache._internal_measureText(ctx, tickMarks[tickMarks.length - 1]._internal_label));\n        }\n        const views = this._private__backLabels();\n        for(let j = views.length; j--;){\n            const width = this._private__widthCache._internal_measureText(ctx, views[j]._internal_text());\n            if (width > tickMarkMaxWidth) {\n                tickMarkMaxWidth = width;\n            }\n        }\n        const firstValue = this._private__priceScale._internal_firstValue();\n        if (firstValue !== null && this._private__size !== null) {\n            const topValue = this._private__priceScale._internal_coordinateToPrice(1, firstValue);\n            const bottomValue = this._private__priceScale._internal_coordinateToPrice(this._private__size.height - 2, firstValue);\n            tickMarkMaxWidth = Math.max(tickMarkMaxWidth, this._private__widthCache._internal_measureText(ctx, this._private__priceScale._internal_formatPrice(Math.floor(Math.min(topValue, bottomValue)) + 0.11111111111111, firstValue)), this._private__widthCache._internal_measureText(ctx, this._private__priceScale._internal_formatPrice(Math.ceil(Math.max(topValue, bottomValue)) - 0.11111111111111, firstValue)));\n        }\n        ctx.restore();\n        const resultTickMarksMaxWidth = tickMarkMaxWidth || 34 /* Constants.DefaultOptimalWidth */ ;\n        const res = Math.ceil(rendererOptions._internal_borderSize + rendererOptions._internal_tickLength + rendererOptions._internal_paddingInner + rendererOptions._internal_paddingOuter + 5 /* Constants.LabelOffset */  + resultTickMarksMaxWidth);\n        // make it even, remove this after migration to perfect fancy canvas\n        return suggestPriceScaleWidth(res);\n    }\n    _internal_setSize(newSize) {\n        if (this._private__size === null || !(0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this._private__size, newSize)) {\n            this._private__size = newSize;\n            this._private__isSettingSize = true;\n            this._private__canvasBinding.resizeCanvasElement(newSize);\n            this._private__topCanvasBinding.resizeCanvasElement(newSize);\n            this._private__isSettingSize = false;\n            this._private__cell.style.width = \"\".concat(newSize.width, \"px\");\n            this._private__cell.style.height = \"\".concat(newSize.height, \"px\");\n        }\n    }\n    _internal_getWidth() {\n        return ensureNotNull(this._private__size).width;\n    }\n    _internal_setPriceScale(priceScale) {\n        if (this._private__priceScale === priceScale) {\n            return;\n        }\n        if (this._private__priceScale !== null) {\n            this._private__priceScale._internal_onMarksChanged()._internal_unsubscribeAll(this);\n        }\n        this._private__priceScale = priceScale;\n        priceScale._internal_onMarksChanged()._internal_subscribe(this._private__onMarksChanged.bind(this), this);\n    }\n    _internal_priceScale() {\n        return this._private__priceScale;\n    }\n    _internal_reset() {\n        const pane = this._private__pane._internal_state();\n        const model = this._private__pane._internal_chart()._internal_model();\n        model._internal_resetPriceScale(pane, ensureNotNull(this._internal_priceScale()));\n    }\n    _internal_paint(type) {\n        if (this._private__size === null) {\n            return;\n        }\n        if (type !== 1 /* InvalidationLevel.Cursor */ ) {\n            this._private__alignLabels();\n            this._private__canvasBinding.applySuggestedBitmapSize();\n            const target = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__canvasBinding);\n            if (target !== null) {\n                target.useBitmapCoordinateSpace((scope)=>{\n                    this._private__drawBackground(scope);\n                    this._private__drawBorder(scope);\n                });\n                this._private__pane._internal_drawAdditionalSources(target, this._private__sourceBottomPaneViews);\n                this._private__drawTickMarks(target);\n                this._private__pane._internal_drawAdditionalSources(target, this._private__sourcePaneViews);\n                this._private__drawBackLabels(target);\n            }\n        }\n        this._private__topCanvasBinding.applySuggestedBitmapSize();\n        const topTarget = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__topCanvasBinding);\n        if (topTarget !== null) {\n            topTarget.useBitmapCoordinateSpace((param)=>{\n                let { context: ctx, bitmapSize } = param;\n                ctx.clearRect(0, 0, bitmapSize.width, bitmapSize.height);\n            });\n            this._private__drawCrosshairLabel(topTarget);\n            this._private__pane._internal_drawAdditionalSources(topTarget, this._private__sourceTopPaneViews);\n        }\n    }\n    _internal_getBitmapSize() {\n        return this._private__canvasBinding.bitmapSize;\n    }\n    _internal_drawBitmap(ctx, x, y) {\n        const bitmapSize = this._internal_getBitmapSize();\n        if (bitmapSize.width > 0 && bitmapSize.height > 0) {\n            ctx.drawImage(this._private__canvasBinding.canvasElement, x, y);\n        }\n    }\n    _internal_update() {\n        var _a;\n        // this call has side-effect - it regenerates marks on the price scale\n        (_a = this._private__priceScale) === null || _a === void 0 ? void 0 : _a._internal_marks();\n    }\n    _private__mouseDownEvent(e) {\n        if (this._private__priceScale === null || this._private__priceScale._internal_isEmpty() || !this._private__options.handleScale.axisPressedMouseMove.price) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const pane = this._private__pane._internal_state();\n        this._private__mousedown = true;\n        model._internal_startScalePrice(pane, this._private__priceScale, e.localY);\n    }\n    _private__pressedMouseMoveEvent(e) {\n        if (this._private__priceScale === null || !this._private__options.handleScale.axisPressedMouseMove.price) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const pane = this._private__pane._internal_state();\n        const priceScale = this._private__priceScale;\n        model._internal_scalePriceTo(pane, priceScale, e.localY);\n    }\n    _private__mouseDownOutsideEvent() {\n        if (this._private__priceScale === null || !this._private__options.handleScale.axisPressedMouseMove.price) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const pane = this._private__pane._internal_state();\n        const priceScale = this._private__priceScale;\n        if (this._private__mousedown) {\n            this._private__mousedown = false;\n            model._internal_endScalePrice(pane, priceScale);\n        }\n    }\n    _private__mouseUpEvent(e) {\n        if (this._private__priceScale === null || !this._private__options.handleScale.axisPressedMouseMove.price) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const pane = this._private__pane._internal_state();\n        this._private__mousedown = false;\n        model._internal_endScalePrice(pane, this._private__priceScale);\n    }\n    _private__mouseDoubleClickEvent(e) {\n        if (this._private__options.handleScale.axisDoubleClickReset.price) {\n            this._internal_reset();\n        }\n    }\n    _private__mouseEnterEvent(e) {\n        if (this._private__priceScale === null) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        if (model._internal_options().handleScale.axisPressedMouseMove.price && !this._private__priceScale._internal_isPercentage() && !this._private__priceScale._internal_isIndexedTo100()) {\n            this._private__setCursor(1 /* CursorType.NsResize */ );\n        }\n    }\n    _private__mouseLeaveEvent(e) {\n        this._private__setCursor(0 /* CursorType.Default */ );\n    }\n    _private__backLabels() {\n        const res = [];\n        const priceScale = this._private__priceScale === null ? undefined : this._private__priceScale;\n        const addViewsForSources = (sources)=>{\n            for(let i = 0; i < sources.length; ++i){\n                const source = sources[i];\n                const views = source._internal_priceAxisViews(this._private__pane._internal_state(), priceScale);\n                for(let j = 0; j < views.length; j++){\n                    res.push(views[j]);\n                }\n            }\n        };\n        // calculate max and min coordinates for views on selection\n        // crosshair individually\n        addViewsForSources(this._private__pane._internal_state()._internal_orderedSources());\n        return res;\n    }\n    _private__drawBackground(param) {\n        let { context: ctx, bitmapSize } = param;\n        const { width, height } = bitmapSize;\n        const model = this._private__pane._internal_state()._internal_model();\n        const topColor = model._internal_backgroundTopColor();\n        const bottomColor = model._internal_backgroundBottomColor();\n        if (topColor === bottomColor) {\n            clearRect(ctx, 0, 0, width, height, topColor);\n        } else {\n            clearRectWithGradient(ctx, 0, 0, width, height, topColor, bottomColor);\n        }\n    }\n    _private__drawBorder(param) {\n        let { context: ctx, bitmapSize, horizontalPixelRatio } = param;\n        if (this._private__size === null || this._private__priceScale === null || !this._private__priceScale._internal_options().borderVisible) {\n            return;\n        }\n        ctx.fillStyle = this._private__priceScale._internal_options().borderColor;\n        const borderSize = Math.max(1, Math.floor(this._internal_rendererOptions()._internal_borderSize * horizontalPixelRatio));\n        let left;\n        if (this._private__isLeft) {\n            left = bitmapSize.width - borderSize;\n        } else {\n            left = 0;\n        }\n        ctx.fillRect(left, 0, borderSize, bitmapSize.height);\n    }\n    _private__drawTickMarks(target) {\n        if (this._private__size === null || this._private__priceScale === null) {\n            return;\n        }\n        const tickMarks = this._private__priceScale._internal_marks();\n        const priceScaleOptions = this._private__priceScale._internal_options();\n        const rendererOptions = this._internal_rendererOptions();\n        const tickMarkLeftX = this._private__isLeft ? this._private__size.width - rendererOptions._internal_tickLength : 0;\n        if (priceScaleOptions.borderVisible && priceScaleOptions.ticksVisible) {\n            target.useBitmapCoordinateSpace((param)=>{\n                let { context: ctx, horizontalPixelRatio, verticalPixelRatio } = param;\n                ctx.fillStyle = priceScaleOptions.borderColor;\n                const tickHeight = Math.max(1, Math.floor(verticalPixelRatio));\n                const tickOffset = Math.floor(verticalPixelRatio * 0.5);\n                const tickLength = Math.round(rendererOptions._internal_tickLength * horizontalPixelRatio);\n                ctx.beginPath();\n                for (const tickMark of tickMarks){\n                    ctx.rect(Math.floor(tickMarkLeftX * horizontalPixelRatio), Math.round(tickMark._internal_coord * verticalPixelRatio) - tickOffset, tickLength, tickHeight);\n                }\n                ctx.fill();\n            });\n        }\n        target.useMediaCoordinateSpace((param)=>{\n            let { context: ctx } = param;\n            var _a;\n            ctx.font = this._private__baseFont();\n            ctx.fillStyle = (_a = priceScaleOptions.textColor) !== null && _a !== void 0 ? _a : this._private__layoutOptions.textColor;\n            ctx.textAlign = this._private__isLeft ? \"right\" : \"left\";\n            ctx.textBaseline = \"middle\";\n            const textLeftX = this._private__isLeft ? Math.round(tickMarkLeftX - rendererOptions._internal_paddingInner) : Math.round(tickMarkLeftX + rendererOptions._internal_tickLength + rendererOptions._internal_paddingInner);\n            const yMidCorrections = tickMarks.map((mark)=>this._private__widthCache._internal_yMidCorrection(ctx, mark._internal_label));\n            for(let i = tickMarks.length; i--;){\n                const tickMark = tickMarks[i];\n                ctx.fillText(tickMark._internal_label, textLeftX, tickMark._internal_coord + yMidCorrections[i]);\n            }\n        });\n    }\n    _private__alignLabels() {\n        if (this._private__size === null || this._private__priceScale === null) {\n            return;\n        }\n        let center = this._private__size.height / 2;\n        const views = [];\n        const orderedSources = this._private__priceScale._internal_orderedSources().slice(); // Copy of array\n        const pane = this._private__pane;\n        const paneState = pane._internal_state();\n        const rendererOptions = this._internal_rendererOptions();\n        // if we are default price scale, append labels from no-scale\n        const isDefault = this._private__priceScale === paneState._internal_defaultVisiblePriceScale();\n        if (isDefault) {\n            this._private__pane._internal_state()._internal_orderedSources().forEach((source)=>{\n                if (paneState._internal_isOverlay(source)) {\n                    orderedSources.push(source);\n                }\n            });\n        }\n        // we can use any, but let's use the first source as \"center\" one\n        const centerSource = this._private__priceScale._internal_dataSources()[0];\n        const priceScale = this._private__priceScale;\n        const updateForSources = (sources)=>{\n            sources.forEach((source)=>{\n                const sourceViews = source._internal_priceAxisViews(paneState, priceScale);\n                // never align selected sources\n                sourceViews.forEach((view)=>{\n                    view._internal_setFixedCoordinate(null);\n                    if (view._internal_isVisible()) {\n                        views.push(view);\n                    }\n                });\n                if (centerSource === source && sourceViews.length > 0) {\n                    center = sourceViews[0]._internal_coordinate();\n                }\n            });\n        };\n        // crosshair individually\n        updateForSources(orderedSources);\n        views.forEach((view)=>view._internal_setFixedCoordinate(view._internal_coordinate()));\n        const options = this._private__priceScale._internal_options();\n        if (!options.alignLabels) {\n            return;\n        }\n        this._private__fixLabelOverlap(views, rendererOptions, center);\n    }\n    _private__fixLabelOverlap(views, rendererOptions, center) {\n        if (this._private__size === null) {\n            return;\n        }\n        // split into two parts\n        const top = views.filter((view)=>view._internal_coordinate() <= center);\n        const bottom = views.filter((view)=>view._internal_coordinate() > center);\n        // sort top from center to top\n        top.sort((l, r)=>r._internal_coordinate() - l._internal_coordinate());\n        // share center label\n        if (top.length && bottom.length) {\n            bottom.push(top[0]);\n        }\n        bottom.sort((l, r)=>l._internal_coordinate() - r._internal_coordinate());\n        for (const view of views){\n            const halfHeight = Math.floor(view._internal_height(rendererOptions) / 2);\n            const coordinate = view._internal_coordinate();\n            if (coordinate > -halfHeight && coordinate < halfHeight) {\n                view._internal_setFixedCoordinate(halfHeight);\n            }\n            if (coordinate > this._private__size.height - halfHeight && coordinate < this._private__size.height + halfHeight) {\n                view._internal_setFixedCoordinate(this._private__size.height - halfHeight);\n            }\n        }\n        for(let i = 1; i < top.length; i++){\n            const view = top[i];\n            const prev = top[i - 1];\n            const height = prev._internal_height(rendererOptions, false);\n            const coordinate = view._internal_coordinate();\n            const prevFixedCoordinate = prev._internal_getFixedCoordinate();\n            if (coordinate > prevFixedCoordinate - height) {\n                view._internal_setFixedCoordinate(prevFixedCoordinate - height);\n            }\n        }\n        for(let j = 1; j < bottom.length; j++){\n            const view = bottom[j];\n            const prev = bottom[j - 1];\n            const height = prev._internal_height(rendererOptions, true);\n            const coordinate = view._internal_coordinate();\n            const prevFixedCoordinate = prev._internal_getFixedCoordinate();\n            if (coordinate < prevFixedCoordinate + height) {\n                view._internal_setFixedCoordinate(prevFixedCoordinate + height);\n            }\n        }\n    }\n    _private__drawBackLabels(target) {\n        if (this._private__size === null) {\n            return;\n        }\n        const views = this._private__backLabels();\n        const rendererOptions = this._internal_rendererOptions();\n        const align = this._private__isLeft ? \"right\" : \"left\";\n        views.forEach((view)=>{\n            if (view._internal_isAxisLabelVisible()) {\n                const renderer = view._internal_renderer(ensureNotNull(this._private__priceScale));\n                renderer._internal_draw(target, rendererOptions, this._private__widthCache, align);\n            }\n        });\n    }\n    _private__drawCrosshairLabel(target) {\n        if (this._private__size === null || this._private__priceScale === null) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const views = []; // array of arrays\n        const pane = this._private__pane._internal_state();\n        const v = model._internal_crosshairSource()._internal_priceAxisViews(pane, this._private__priceScale);\n        if (v.length) {\n            views.push(v);\n        }\n        const ro = this._internal_rendererOptions();\n        const align = this._private__isLeft ? \"right\" : \"left\";\n        views.forEach((arr)=>{\n            arr.forEach((view)=>{\n                view._internal_renderer(ensureNotNull(this._private__priceScale))._internal_draw(target, ro, this._private__widthCache, align);\n            });\n        });\n    }\n    _private__setCursor(type) {\n        this._private__cell.style.cursor = type === 1 /* CursorType.NsResize */  ? \"ns-resize\" : \"default\";\n    }\n    _private__onMarksChanged() {\n        const width = this._internal_optimalWidth();\n        // avoid price scale is shrunk\n        // using < instead !== to avoid infinite changes\n        if (this._private__prevOptimalWidth < width) {\n            this._private__pane._internal_chart()._internal_model()._internal_fullUpdate();\n        }\n        this._private__prevOptimalWidth = width;\n    }\n    _private__baseFont() {\n        return makeFont(this._private__layoutOptions.fontSize, this._private__layoutOptions.fontFamily);\n    }\n    constructor(pane, options, rendererOptionsProvider, side){\n        this._private__priceScale = null;\n        this._private__size = null;\n        this._private__mousedown = false;\n        this._private__widthCache = new TextWidthCache(200);\n        this._private__font = null;\n        this._private__prevOptimalWidth = 0;\n        this._private__isSettingSize = false;\n        this._private__canvasSuggestedBitmapSizeChangedHandler = ()=>{\n            if (this._private__isSettingSize) {\n                return;\n            }\n            this._private__pane._internal_chart()._internal_model()._internal_lightUpdate();\n        };\n        this._private__topCanvasSuggestedBitmapSizeChangedHandler = ()=>{\n            if (this._private__isSettingSize) {\n                return;\n            }\n            this._private__pane._internal_chart()._internal_model()._internal_lightUpdate();\n        };\n        this._private__pane = pane;\n        this._private__options = options;\n        this._private__layoutOptions = options.layout;\n        this._private__rendererOptionsProvider = rendererOptionsProvider;\n        this._private__isLeft = side === \"left\";\n        this._private__sourcePaneViews = buildPriceAxisViewsGetter(\"normal\", side);\n        this._private__sourceTopPaneViews = buildPriceAxisViewsGetter(\"top\", side);\n        this._private__sourceBottomPaneViews = buildPriceAxisViewsGetter(\"bottom\", side);\n        this._private__cell = document.createElement(\"div\");\n        this._private__cell.style.height = \"100%\";\n        this._private__cell.style.overflow = \"hidden\";\n        this._private__cell.style.width = \"25px\";\n        this._private__cell.style.left = \"0\";\n        this._private__cell.style.position = \"relative\";\n        this._private__canvasBinding = createBoundCanvas(this._private__cell, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 16,\n            height: 16\n        }));\n        this._private__canvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        const canvas = this._private__canvasBinding.canvasElement;\n        canvas.style.position = \"absolute\";\n        canvas.style.zIndex = \"1\";\n        canvas.style.left = \"0\";\n        canvas.style.top = \"0\";\n        this._private__topCanvasBinding = createBoundCanvas(this._private__cell, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 16,\n            height: 16\n        }));\n        this._private__topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        const topCanvas = this._private__topCanvasBinding.canvasElement;\n        topCanvas.style.position = \"absolute\";\n        topCanvas.style.zIndex = \"2\";\n        topCanvas.style.left = \"0\";\n        topCanvas.style.top = \"0\";\n        const handler = {\n            _internal_mouseDownEvent: this._private__mouseDownEvent.bind(this),\n            _internal_touchStartEvent: this._private__mouseDownEvent.bind(this),\n            _internal_pressedMouseMoveEvent: this._private__pressedMouseMoveEvent.bind(this),\n            _internal_touchMoveEvent: this._private__pressedMouseMoveEvent.bind(this),\n            _internal_mouseDownOutsideEvent: this._private__mouseDownOutsideEvent.bind(this),\n            _internal_mouseUpEvent: this._private__mouseUpEvent.bind(this),\n            _internal_touchEndEvent: this._private__mouseUpEvent.bind(this),\n            _internal_mouseDoubleClickEvent: this._private__mouseDoubleClickEvent.bind(this),\n            _internal_doubleTapEvent: this._private__mouseDoubleClickEvent.bind(this),\n            _internal_mouseEnterEvent: this._private__mouseEnterEvent.bind(this),\n            _internal_mouseLeaveEvent: this._private__mouseLeaveEvent.bind(this)\n        };\n        this._private__mouseEventHandler = new MouseEventHandler(this._private__topCanvasBinding.canvasElement, handler, {\n            _internal_treatVertTouchDragAsPageScroll: ()=>!this._private__options.handleScroll.vertTouchDrag,\n            _internal_treatHorzTouchDragAsPageScroll: ()=>true\n        });\n    }\n}\nfunction sourceBottomPaneViews$1(source, pane) {\n    var _a, _b;\n    return (_b = (_a = source._internal_bottomPaneViews) === null || _a === void 0 ? void 0 : _a.call(source, pane)) !== null && _b !== void 0 ? _b : [];\n}\nfunction sourcePaneViews$1(source, pane) {\n    var _a, _b;\n    return (_b = (_a = source._internal_paneViews) === null || _a === void 0 ? void 0 : _a.call(source, pane)) !== null && _b !== void 0 ? _b : [];\n}\nfunction sourceLabelPaneViews(source, pane) {\n    var _a, _b;\n    return (_b = (_a = source._internal_labelPaneViews) === null || _a === void 0 ? void 0 : _a.call(source, pane)) !== null && _b !== void 0 ? _b : [];\n}\nfunction sourceTopPaneViews$1(source, pane) {\n    var _a, _b;\n    return (_b = (_a = source._internal_topPaneViews) === null || _a === void 0 ? void 0 : _a.call(source, pane)) !== null && _b !== void 0 ? _b : [];\n}\nclass PaneWidget {\n    _internal_destroy() {\n        if (this._private__leftPriceAxisWidget !== null) {\n            this._private__leftPriceAxisWidget._internal_destroy();\n        }\n        if (this._private__rightPriceAxisWidget !== null) {\n            this._private__rightPriceAxisWidget._internal_destroy();\n        }\n        this._private__topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__topCanvasBinding.canvasElement);\n        this._private__topCanvasBinding.dispose();\n        this._private__canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__canvasBinding.canvasElement);\n        this._private__canvasBinding.dispose();\n        if (this._private__state !== null) {\n            this._private__state._internal_onDestroyed()._internal_unsubscribeAll(this);\n        }\n        this._private__mouseEventHandler._internal_destroy();\n    }\n    _internal_state() {\n        return ensureNotNull(this._private__state);\n    }\n    _internal_setState(pane) {\n        if (this._private__state !== null) {\n            this._private__state._internal_onDestroyed()._internal_unsubscribeAll(this);\n        }\n        this._private__state = pane;\n        if (this._private__state !== null) {\n            this._private__state._internal_onDestroyed()._internal_subscribe(PaneWidget.prototype._private__onStateDestroyed.bind(this), this, true);\n        }\n        this._internal_updatePriceAxisWidgetsStates();\n    }\n    _internal_chart() {\n        return this._private__chart;\n    }\n    _internal_getElement() {\n        return this._private__rowElement;\n    }\n    _internal_updatePriceAxisWidgetsStates() {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__recreatePriceAxisWidgets();\n        if (this._private__model()._internal_serieses().length === 0) {\n            return;\n        }\n        if (this._private__leftPriceAxisWidget !== null) {\n            const leftPriceScale = this._private__state._internal_leftPriceScale();\n            this._private__leftPriceAxisWidget._internal_setPriceScale(ensureNotNull(leftPriceScale));\n        }\n        if (this._private__rightPriceAxisWidget !== null) {\n            const rightPriceScale = this._private__state._internal_rightPriceScale();\n            this._private__rightPriceAxisWidget._internal_setPriceScale(ensureNotNull(rightPriceScale));\n        }\n    }\n    _internal_updatePriceAxisWidgets() {\n        if (this._private__leftPriceAxisWidget !== null) {\n            this._private__leftPriceAxisWidget._internal_update();\n        }\n        if (this._private__rightPriceAxisWidget !== null) {\n            this._private__rightPriceAxisWidget._internal_update();\n        }\n    }\n    _internal_stretchFactor() {\n        return this._private__state !== null ? this._private__state._internal_stretchFactor() : 0;\n    }\n    _internal_setStretchFactor(stretchFactor) {\n        if (this._private__state) {\n            this._private__state._internal_setStretchFactor(stretchFactor);\n        }\n    }\n    _internal_mouseEnterEvent(event) {\n        if (!this._private__state) {\n            return;\n        }\n        this._private__onMouseEvent();\n        const x = event.localX;\n        const y = event.localY;\n        this._private__setCrosshairPosition(x, y, event);\n    }\n    _internal_mouseDownEvent(event) {\n        this._private__onMouseEvent();\n        this._private__mouseTouchDownEvent();\n        this._private__setCrosshairPosition(event.localX, event.localY, event);\n    }\n    _internal_mouseMoveEvent(event) {\n        var _a;\n        if (!this._private__state) {\n            return;\n        }\n        this._private__onMouseEvent();\n        const x = event.localX;\n        const y = event.localY;\n        this._private__setCrosshairPosition(x, y, event);\n        const hitTest = this._internal_hitTest(x, y);\n        this._private__chart._internal_setCursorStyle((_a = hitTest === null || hitTest === void 0 ? void 0 : hitTest._internal_cursorStyle) !== null && _a !== void 0 ? _a : null);\n        this._private__model()._internal_setHoveredSource(hitTest && {\n            _internal_source: hitTest._internal_source,\n            _internal_object: hitTest._internal_object\n        });\n    }\n    _internal_mouseClickEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__onMouseEvent();\n        this._private__fireClickedDelegate(event);\n    }\n    _internal_mouseDoubleClickEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__fireMouseClickDelegate(this._private__dblClicked, event);\n    }\n    _internal_doubleTapEvent(event) {\n        this._internal_mouseDoubleClickEvent(event);\n    }\n    _internal_pressedMouseMoveEvent(event) {\n        this._private__onMouseEvent();\n        this._private__pressedMouseTouchMoveEvent(event);\n        this._private__setCrosshairPosition(event.localX, event.localY, event);\n    }\n    _internal_mouseUpEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__onMouseEvent();\n        this._private__longTap = false;\n        this._private__endScroll(event);\n    }\n    _internal_tapEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__fireClickedDelegate(event);\n    }\n    _internal_longTapEvent(event) {\n        this._private__longTap = true;\n        if (this._private__startTrackPoint === null) {\n            const point = {\n                x: event.localX,\n                y: event.localY\n            };\n            this._private__startTrackingMode(point, point, event);\n        }\n    }\n    _internal_mouseLeaveEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__onMouseEvent();\n        this._private__state._internal_model()._internal_setHoveredSource(null);\n        this._private__clearCrosshairPosition();\n    }\n    _internal_clicked() {\n        return this._private__clicked;\n    }\n    _internal_dblClicked() {\n        return this._private__dblClicked;\n    }\n    _internal_pinchStartEvent() {\n        this._private__prevPinchScale = 1;\n        this._private__model()._internal_stopTimeScaleAnimation();\n    }\n    _internal_pinchEvent(middlePoint, scale) {\n        if (!this._private__chart._internal_options().handleScale.pinch) {\n            return;\n        }\n        const zoomScale = (scale - this._private__prevPinchScale) * 5;\n        this._private__prevPinchScale = scale;\n        this._private__model()._internal_zoomTime(middlePoint._internal_x, zoomScale);\n    }\n    _internal_touchStartEvent(event) {\n        this._private__longTap = false;\n        this._private__exitTrackingModeOnNextTry = this._private__startTrackPoint !== null;\n        this._private__mouseTouchDownEvent();\n        const crosshair = this._private__model()._internal_crosshairSource();\n        if (this._private__startTrackPoint !== null && crosshair._internal_visible()) {\n            this._private__initCrosshairPosition = {\n                x: crosshair._internal_appliedX(),\n                y: crosshair._internal_appliedY()\n            };\n            this._private__startTrackPoint = {\n                x: event.localX,\n                y: event.localY\n            };\n        }\n    }\n    _internal_touchMoveEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        const x = event.localX;\n        const y = event.localY;\n        if (this._private__startTrackPoint !== null) {\n            // tracking mode: move crosshair\n            this._private__exitTrackingModeOnNextTry = false;\n            const origPoint = ensureNotNull(this._private__initCrosshairPosition);\n            const newX = origPoint.x + (x - this._private__startTrackPoint.x);\n            const newY = origPoint.y + (y - this._private__startTrackPoint.y);\n            this._private__setCrosshairPosition(newX, newY, event);\n            return;\n        }\n        this._private__pressedMouseTouchMoveEvent(event);\n    }\n    _internal_touchEndEvent(event) {\n        if (this._internal_chart()._internal_options().trackingMode.exitMode === 0 /* TrackingModeExitMode.OnTouchEnd */ ) {\n            this._private__exitTrackingModeOnNextTry = true;\n        }\n        this._private__tryExitTrackingMode();\n        this._private__endScroll(event);\n    }\n    _internal_hitTest(x, y) {\n        const state = this._private__state;\n        if (state === null) {\n            return null;\n        }\n        return hitTestPane(state, x, y);\n    }\n    _internal_setPriceAxisSize(width, position) {\n        const priceAxisWidget = position === \"left\" ? this._private__leftPriceAxisWidget : this._private__rightPriceAxisWidget;\n        ensureNotNull(priceAxisWidget)._internal_setSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width,\n            height: this._private__size.height\n        }));\n    }\n    _internal_getSize() {\n        return this._private__size;\n    }\n    _internal_setSize(newSize) {\n        if ((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this._private__size, newSize)) {\n            return;\n        }\n        this._private__size = newSize;\n        this._private__isSettingSize = true;\n        this._private__canvasBinding.resizeCanvasElement(newSize);\n        this._private__topCanvasBinding.resizeCanvasElement(newSize);\n        this._private__isSettingSize = false;\n        this._private__paneCell.style.width = newSize.width + \"px\";\n        this._private__paneCell.style.height = newSize.height + \"px\";\n    }\n    _internal_recalculatePriceScales() {\n        const pane = ensureNotNull(this._private__state);\n        pane._internal_recalculatePriceScale(pane._internal_leftPriceScale());\n        pane._internal_recalculatePriceScale(pane._internal_rightPriceScale());\n        for (const source of pane._internal_dataSources()){\n            if (pane._internal_isOverlay(source)) {\n                const priceScale = source._internal_priceScale();\n                if (priceScale !== null) {\n                    pane._internal_recalculatePriceScale(priceScale);\n                }\n                // for overlay drawings price scale is owner's price scale\n                // however owner's price scale could not contain ds\n                source._internal_updateAllViews();\n            }\n        }\n    }\n    _internal_getBitmapSize() {\n        return this._private__canvasBinding.bitmapSize;\n    }\n    _internal_drawBitmap(ctx, x, y) {\n        const bitmapSize = this._internal_getBitmapSize();\n        if (bitmapSize.width > 0 && bitmapSize.height > 0) {\n            ctx.drawImage(this._private__canvasBinding.canvasElement, x, y);\n        }\n    }\n    _internal_paint(type) {\n        if (type === 0 /* InvalidationLevel.None */ ) {\n            return;\n        }\n        if (this._private__state === null) {\n            return;\n        }\n        if (type > 1 /* InvalidationLevel.Cursor */ ) {\n            this._internal_recalculatePriceScales();\n        }\n        if (this._private__leftPriceAxisWidget !== null) {\n            this._private__leftPriceAxisWidget._internal_paint(type);\n        }\n        if (this._private__rightPriceAxisWidget !== null) {\n            this._private__rightPriceAxisWidget._internal_paint(type);\n        }\n        if (type !== 1 /* InvalidationLevel.Cursor */ ) {\n            this._private__canvasBinding.applySuggestedBitmapSize();\n            const target = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__canvasBinding);\n            if (target !== null) {\n                target.useBitmapCoordinateSpace((scope)=>{\n                    this._private__drawBackground(scope);\n                });\n                if (this._private__state) {\n                    this._private__drawSources(target, sourceBottomPaneViews$1);\n                    this._private__drawGrid(target);\n                    this._private__drawWatermark(target);\n                    this._private__drawSources(target, sourcePaneViews$1);\n                    this._private__drawSources(target, sourceLabelPaneViews);\n                }\n            }\n        }\n        this._private__topCanvasBinding.applySuggestedBitmapSize();\n        const topTarget = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__topCanvasBinding);\n        if (topTarget !== null) {\n            topTarget.useBitmapCoordinateSpace((param)=>{\n                let { context: ctx, bitmapSize } = param;\n                ctx.clearRect(0, 0, bitmapSize.width, bitmapSize.height);\n            });\n            this._private__drawCrosshair(topTarget);\n            this._private__drawSources(topTarget, sourceTopPaneViews$1);\n        }\n    }\n    _internal_leftPriceAxisWidget() {\n        return this._private__leftPriceAxisWidget;\n    }\n    _internal_rightPriceAxisWidget() {\n        return this._private__rightPriceAxisWidget;\n    }\n    _internal_drawAdditionalSources(target, paneViewsGetter) {\n        this._private__drawSources(target, paneViewsGetter);\n    }\n    _private__onStateDestroyed() {\n        if (this._private__state !== null) {\n            this._private__state._internal_onDestroyed()._internal_unsubscribeAll(this);\n        }\n        this._private__state = null;\n    }\n    _private__fireClickedDelegate(event) {\n        this._private__fireMouseClickDelegate(this._private__clicked, event);\n    }\n    _private__fireMouseClickDelegate(delegate, event) {\n        const x = event.localX;\n        const y = event.localY;\n        if (delegate._internal_hasListeners()) {\n            delegate._internal_fire(this._private__model()._internal_timeScale()._internal_coordinateToIndex(x), {\n                x,\n                y\n            }, event);\n        }\n    }\n    _private__drawBackground(param) {\n        let { context: ctx, bitmapSize } = param;\n        const { width, height } = bitmapSize;\n        const model = this._private__model();\n        const topColor = model._internal_backgroundTopColor();\n        const bottomColor = model._internal_backgroundBottomColor();\n        if (topColor === bottomColor) {\n            clearRect(ctx, 0, 0, width, height, bottomColor);\n        } else {\n            clearRectWithGradient(ctx, 0, 0, width, height, topColor, bottomColor);\n        }\n    }\n    _private__drawGrid(target) {\n        const state = ensureNotNull(this._private__state);\n        const paneView = state._internal_grid()._internal_paneView();\n        const renderer = paneView._internal_renderer();\n        if (renderer !== null) {\n            renderer._internal_draw(target, false);\n        }\n    }\n    _private__drawWatermark(target) {\n        const source = this._private__model()._internal_watermarkSource();\n        this._private__drawSourceImpl(target, sourcePaneViews$1, drawBackground, source);\n        this._private__drawSourceImpl(target, sourcePaneViews$1, drawForeground, source);\n    }\n    _private__drawCrosshair(target) {\n        this._private__drawSourceImpl(target, sourcePaneViews$1, drawForeground, this._private__model()._internal_crosshairSource());\n    }\n    _private__drawSources(target, paneViewsGetter) {\n        const state = ensureNotNull(this._private__state);\n        const sources = state._internal_orderedSources();\n        for (const source of sources){\n            this._private__drawSourceImpl(target, paneViewsGetter, drawBackground, source);\n        }\n        for (const source of sources){\n            this._private__drawSourceImpl(target, paneViewsGetter, drawForeground, source);\n        }\n    }\n    _private__drawSourceImpl(target, paneViewsGetter, drawFn, source) {\n        const state = ensureNotNull(this._private__state);\n        const hoveredSource = state._internal_model()._internal_hoveredSource();\n        const isHovered = hoveredSource !== null && hoveredSource._internal_source === source;\n        const objecId = hoveredSource !== null && isHovered && hoveredSource._internal_object !== undefined ? hoveredSource._internal_object._internal_hitTestData : undefined;\n        const drawRendererFn = (renderer)=>drawFn(renderer, target, isHovered, objecId);\n        drawSourcePaneViews(paneViewsGetter, drawRendererFn, source, state);\n    }\n    _private__recreatePriceAxisWidgets() {\n        if (this._private__state === null) {\n            return;\n        }\n        const chart = this._private__chart;\n        const leftAxisVisible = this._private__state._internal_leftPriceScale()._internal_options().visible;\n        const rightAxisVisible = this._private__state._internal_rightPriceScale()._internal_options().visible;\n        if (!leftAxisVisible && this._private__leftPriceAxisWidget !== null) {\n            this._private__leftAxisCell.removeChild(this._private__leftPriceAxisWidget._internal_getElement());\n            this._private__leftPriceAxisWidget._internal_destroy();\n            this._private__leftPriceAxisWidget = null;\n        }\n        if (!rightAxisVisible && this._private__rightPriceAxisWidget !== null) {\n            this._private__rightAxisCell.removeChild(this._private__rightPriceAxisWidget._internal_getElement());\n            this._private__rightPriceAxisWidget._internal_destroy();\n            this._private__rightPriceAxisWidget = null;\n        }\n        const rendererOptionsProvider = chart._internal_model()._internal_rendererOptionsProvider();\n        if (leftAxisVisible && this._private__leftPriceAxisWidget === null) {\n            this._private__leftPriceAxisWidget = new PriceAxisWidget(this, chart._internal_options(), rendererOptionsProvider, \"left\");\n            this._private__leftAxisCell.appendChild(this._private__leftPriceAxisWidget._internal_getElement());\n        }\n        if (rightAxisVisible && this._private__rightPriceAxisWidget === null) {\n            this._private__rightPriceAxisWidget = new PriceAxisWidget(this, chart._internal_options(), rendererOptionsProvider, \"right\");\n            this._private__rightAxisCell.appendChild(this._private__rightPriceAxisWidget._internal_getElement());\n        }\n    }\n    _private__preventScroll(event) {\n        return event._internal_isTouch && this._private__longTap || this._private__startTrackPoint !== null;\n    }\n    _private__correctXCoord(x) {\n        return Math.max(0, Math.min(x, this._private__size.width - 1));\n    }\n    _private__correctYCoord(y) {\n        return Math.max(0, Math.min(y, this._private__size.height - 1));\n    }\n    _private__setCrosshairPosition(x, y, event) {\n        this._private__model()._internal_setAndSaveCurrentPosition(this._private__correctXCoord(x), this._private__correctYCoord(y), event, ensureNotNull(this._private__state));\n    }\n    _private__clearCrosshairPosition() {\n        this._private__model()._internal_clearCurrentPosition();\n    }\n    _private__tryExitTrackingMode() {\n        if (this._private__exitTrackingModeOnNextTry) {\n            this._private__startTrackPoint = null;\n            this._private__clearCrosshairPosition();\n        }\n    }\n    _private__startTrackingMode(startTrackPoint, crossHairPosition, event) {\n        this._private__startTrackPoint = startTrackPoint;\n        this._private__exitTrackingModeOnNextTry = false;\n        this._private__setCrosshairPosition(crossHairPosition.x, crossHairPosition.y, event);\n        const crosshair = this._private__model()._internal_crosshairSource();\n        this._private__initCrosshairPosition = {\n            x: crosshair._internal_appliedX(),\n            y: crosshair._internal_appliedY()\n        };\n    }\n    _private__model() {\n        return this._private__chart._internal_model();\n    }\n    _private__endScroll(event) {\n        if (!this._private__isScrolling) {\n            return;\n        }\n        const model = this._private__model();\n        const state = this._internal_state();\n        model._internal_endScrollPrice(state, state._internal_defaultPriceScale());\n        this._private__startScrollingPos = null;\n        this._private__isScrolling = false;\n        model._internal_endScrollTime();\n        if (this._private__scrollXAnimation !== null) {\n            const startAnimationTime = performance.now();\n            const timeScale = model._internal_timeScale();\n            this._private__scrollXAnimation._internal_start(timeScale._internal_rightOffset(), startAnimationTime);\n            if (!this._private__scrollXAnimation._internal_finished(startAnimationTime)) {\n                model._internal_setTimeScaleAnimation(this._private__scrollXAnimation);\n            }\n        }\n    }\n    _private__onMouseEvent() {\n        this._private__startTrackPoint = null;\n    }\n    _private__mouseTouchDownEvent() {\n        if (!this._private__state) {\n            return;\n        }\n        this._private__model()._internal_stopTimeScaleAnimation();\n        if (document.activeElement !== document.body && document.activeElement !== document.documentElement) {\n            // If any focusable element except the page itself is focused, remove the focus\n            ensureNotNull(document.activeElement).blur();\n        } else {\n            // Clear selection\n            const selection = document.getSelection();\n            if (selection !== null) {\n                selection.removeAllRanges();\n            }\n        }\n        const priceScale = this._private__state._internal_defaultPriceScale();\n        if (priceScale._internal_isEmpty() || this._private__model()._internal_timeScale()._internal_isEmpty()) {\n            return;\n        }\n    }\n    // eslint-disable-next-line complexity\n    _private__pressedMouseTouchMoveEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        const model = this._private__model();\n        const timeScale = model._internal_timeScale();\n        if (timeScale._internal_isEmpty()) {\n            return;\n        }\n        const chartOptions = this._private__chart._internal_options();\n        const scrollOptions = chartOptions.handleScroll;\n        const kineticScrollOptions = chartOptions.kineticScroll;\n        if ((!scrollOptions.pressedMouseMove || event._internal_isTouch) && (!scrollOptions.horzTouchDrag && !scrollOptions.vertTouchDrag || !event._internal_isTouch)) {\n            return;\n        }\n        const priceScale = this._private__state._internal_defaultPriceScale();\n        const now = performance.now();\n        if (this._private__startScrollingPos === null && !this._private__preventScroll(event)) {\n            this._private__startScrollingPos = {\n                x: event.clientX,\n                y: event.clientY,\n                _internal_timestamp: now,\n                _internal_localX: event.localX,\n                _internal_localY: event.localY\n            };\n        }\n        if (this._private__startScrollingPos !== null && !this._private__isScrolling && (this._private__startScrollingPos.x !== event.clientX || this._private__startScrollingPos.y !== event.clientY)) {\n            if (event._internal_isTouch && kineticScrollOptions.touch || !event._internal_isTouch && kineticScrollOptions.mouse) {\n                const barSpacing = timeScale._internal_barSpacing();\n                this._private__scrollXAnimation = new KineticAnimation(0.2 /* KineticScrollConstants.MinScrollSpeed */  / barSpacing, 7 /* KineticScrollConstants.MaxScrollSpeed */  / barSpacing, 0.997 /* KineticScrollConstants.DumpingCoeff */ , 15 /* KineticScrollConstants.ScrollMinMove */  / barSpacing);\n                this._private__scrollXAnimation._internal_addPosition(timeScale._internal_rightOffset(), this._private__startScrollingPos._internal_timestamp);\n            } else {\n                this._private__scrollXAnimation = null;\n            }\n            if (!priceScale._internal_isEmpty()) {\n                model._internal_startScrollPrice(this._private__state, priceScale, event.localY);\n            }\n            model._internal_startScrollTime(event.localX);\n            this._private__isScrolling = true;\n        }\n        if (this._private__isScrolling) {\n            // this allows scrolling not default price scales\n            if (!priceScale._internal_isEmpty()) {\n                model._internal_scrollPriceTo(this._private__state, priceScale, event.localY);\n            }\n            model._internal_scrollTimeTo(event.localX);\n            if (this._private__scrollXAnimation !== null) {\n                this._private__scrollXAnimation._internal_addPosition(timeScale._internal_rightOffset(), now);\n            }\n        }\n    }\n    constructor(chart, state){\n        this._private__size = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 0,\n            height: 0\n        });\n        this._private__leftPriceAxisWidget = null;\n        this._private__rightPriceAxisWidget = null;\n        this._private__startScrollingPos = null;\n        this._private__isScrolling = false;\n        this._private__clicked = new Delegate();\n        this._private__dblClicked = new Delegate();\n        this._private__prevPinchScale = 0;\n        this._private__longTap = false;\n        this._private__startTrackPoint = null;\n        this._private__exitTrackingModeOnNextTry = false;\n        this._private__initCrosshairPosition = null;\n        this._private__scrollXAnimation = null;\n        this._private__isSettingSize = false;\n        this._private__canvasSuggestedBitmapSizeChangedHandler = ()=>{\n            if (this._private__isSettingSize || this._private__state === null) {\n                return;\n            }\n            this._private__model()._internal_lightUpdate();\n        };\n        this._private__topCanvasSuggestedBitmapSizeChangedHandler = ()=>{\n            if (this._private__isSettingSize || this._private__state === null) {\n                return;\n            }\n            this._private__model()._internal_lightUpdate();\n        };\n        this._private__chart = chart;\n        this._private__state = state;\n        this._private__state._internal_onDestroyed()._internal_subscribe(this._private__onStateDestroyed.bind(this), this, true);\n        this._private__paneCell = document.createElement(\"td\");\n        this._private__paneCell.style.padding = \"0\";\n        this._private__paneCell.style.position = \"relative\";\n        const paneWrapper = document.createElement(\"div\");\n        paneWrapper.style.width = \"100%\";\n        paneWrapper.style.height = \"100%\";\n        paneWrapper.style.position = \"relative\";\n        paneWrapper.style.overflow = \"hidden\";\n        this._private__leftAxisCell = document.createElement(\"td\");\n        this._private__leftAxisCell.style.padding = \"0\";\n        this._private__rightAxisCell = document.createElement(\"td\");\n        this._private__rightAxisCell.style.padding = \"0\";\n        this._private__paneCell.appendChild(paneWrapper);\n        this._private__canvasBinding = createBoundCanvas(paneWrapper, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 16,\n            height: 16\n        }));\n        this._private__canvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        const canvas = this._private__canvasBinding.canvasElement;\n        canvas.style.position = \"absolute\";\n        canvas.style.zIndex = \"1\";\n        canvas.style.left = \"0\";\n        canvas.style.top = \"0\";\n        this._private__topCanvasBinding = createBoundCanvas(paneWrapper, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 16,\n            height: 16\n        }));\n        this._private__topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        const topCanvas = this._private__topCanvasBinding.canvasElement;\n        topCanvas.style.position = \"absolute\";\n        topCanvas.style.zIndex = \"2\";\n        topCanvas.style.left = \"0\";\n        topCanvas.style.top = \"0\";\n        this._private__rowElement = document.createElement(\"tr\");\n        this._private__rowElement.appendChild(this._private__leftAxisCell);\n        this._private__rowElement.appendChild(this._private__paneCell);\n        this._private__rowElement.appendChild(this._private__rightAxisCell);\n        this._internal_updatePriceAxisWidgetsStates();\n        this._private__mouseEventHandler = new MouseEventHandler(this._private__topCanvasBinding.canvasElement, this, {\n            _internal_treatVertTouchDragAsPageScroll: ()=>this._private__startTrackPoint === null && !this._private__chart._internal_options().handleScroll.vertTouchDrag,\n            _internal_treatHorzTouchDragAsPageScroll: ()=>this._private__startTrackPoint === null && !this._private__chart._internal_options().handleScroll.horzTouchDrag\n        });\n    }\n}\nclass PriceAxisStub {\n    _internal_destroy() {\n        this._private__canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__canvasBinding.canvasElement);\n        this._private__canvasBinding.dispose();\n    }\n    _internal_getElement() {\n        return this._private__cell;\n    }\n    _internal_getSize() {\n        return this._private__size;\n    }\n    _internal_setSize(newSize) {\n        if (!(0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this._private__size, newSize)) {\n            this._private__size = newSize;\n            this._private__canvasBinding.resizeCanvasElement(newSize);\n            this._private__cell.style.width = \"\".concat(newSize.width, \"px\");\n            this._private__cell.style.height = \"\".concat(newSize.height, \"px\");\n            this._private__invalidated = true;\n        }\n    }\n    _internal_paint(type) {\n        if (type < 3 /* InvalidationLevel.Full */  && !this._private__invalidated) {\n            return;\n        }\n        if (this._private__size.width === 0 || this._private__size.height === 0) {\n            return;\n        }\n        this._private__invalidated = false;\n        this._private__canvasBinding.applySuggestedBitmapSize();\n        const target = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__canvasBinding);\n        if (target !== null) {\n            target.useBitmapCoordinateSpace((scope)=>{\n                this._private__drawBackground(scope);\n                this._private__drawBorder(scope);\n            });\n        }\n    }\n    _internal_getBitmapSize() {\n        return this._private__canvasBinding.bitmapSize;\n    }\n    _internal_drawBitmap(ctx, x, y) {\n        const bitmapSize = this._internal_getBitmapSize();\n        if (bitmapSize.width > 0 && bitmapSize.height > 0) {\n            ctx.drawImage(this._private__canvasBinding.canvasElement, x, y);\n        }\n    }\n    _private__drawBorder(param) {\n        let { context: ctx, bitmapSize, horizontalPixelRatio, verticalPixelRatio } = param;\n        if (!this._private__borderVisible()) {\n            return;\n        }\n        ctx.fillStyle = this._private__options.timeScale.borderColor;\n        const horzBorderSize = Math.floor(this._private__rendererOptionsProvider._internal_options()._internal_borderSize * horizontalPixelRatio);\n        const vertBorderSize = Math.floor(this._private__rendererOptionsProvider._internal_options()._internal_borderSize * verticalPixelRatio);\n        const left = this._private__isLeft ? bitmapSize.width - horzBorderSize : 0;\n        ctx.fillRect(left, 0, horzBorderSize, vertBorderSize);\n    }\n    _private__drawBackground(param) {\n        let { context: ctx, bitmapSize } = param;\n        clearRect(ctx, 0, 0, bitmapSize.width, bitmapSize.height, this._private__bottomColor());\n    }\n    constructor(side, options, params, borderVisible, bottomColor){\n        this._private__invalidated = true;\n        this._private__size = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 0,\n            height: 0\n        });\n        this._private__canvasSuggestedBitmapSizeChangedHandler = ()=>this._internal_paint(3 /* InvalidationLevel.Full */ );\n        this._private__isLeft = side === \"left\";\n        this._private__rendererOptionsProvider = params._internal_rendererOptionsProvider;\n        this._private__options = options;\n        this._private__borderVisible = borderVisible;\n        this._private__bottomColor = bottomColor;\n        this._private__cell = document.createElement(\"div\");\n        this._private__cell.style.width = \"25px\";\n        this._private__cell.style.height = \"100%\";\n        this._private__cell.style.overflow = \"hidden\";\n        this._private__canvasBinding = createBoundCanvas(this._private__cell, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 16,\n            height: 16\n        }));\n        this._private__canvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n    }\n}\nfunction buildTimeAxisViewsGetter(zOrder) {\n    return (source)=>{\n        var _a, _b;\n        return (_b = (_a = source._internal_timePaneViews) === null || _a === void 0 ? void 0 : _a.call(source, zOrder)) !== null && _b !== void 0 ? _b : [];\n    };\n}\nconst sourcePaneViews = buildTimeAxisViewsGetter(\"normal\");\nconst sourceTopPaneViews = buildTimeAxisViewsGetter(\"top\");\nconst sourceBottomPaneViews = buildTimeAxisViewsGetter(\"bottom\");\nclass TimeAxisWidget {\n    _internal_destroy() {\n        this._private__mouseEventHandler._internal_destroy();\n        if (this._private__leftStub !== null) {\n            this._private__leftStub._internal_destroy();\n        }\n        if (this._private__rightStub !== null) {\n            this._private__rightStub._internal_destroy();\n        }\n        this._private__topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__topCanvasBinding.canvasElement);\n        this._private__topCanvasBinding.dispose();\n        this._private__canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__canvasBinding.canvasElement);\n        this._private__canvasBinding.dispose();\n    }\n    _internal_getElement() {\n        return this._private__element;\n    }\n    _internal_leftStub() {\n        return this._private__leftStub;\n    }\n    _internal_rightStub() {\n        return this._private__rightStub;\n    }\n    _internal_mouseDownEvent(event) {\n        if (this._private__mouseDown) {\n            return;\n        }\n        this._private__mouseDown = true;\n        const model = this._private__chart._internal_model();\n        if (model._internal_timeScale()._internal_isEmpty() || !this._private__chart._internal_options().handleScale.axisPressedMouseMove.time) {\n            return;\n        }\n        model._internal_startScaleTime(event.localX);\n    }\n    _internal_touchStartEvent(event) {\n        this._internal_mouseDownEvent(event);\n    }\n    _internal_mouseDownOutsideEvent() {\n        const model = this._private__chart._internal_model();\n        if (!model._internal_timeScale()._internal_isEmpty() && this._private__mouseDown) {\n            this._private__mouseDown = false;\n            if (this._private__chart._internal_options().handleScale.axisPressedMouseMove.time) {\n                model._internal_endScaleTime();\n            }\n        }\n    }\n    _internal_pressedMouseMoveEvent(event) {\n        const model = this._private__chart._internal_model();\n        if (model._internal_timeScale()._internal_isEmpty() || !this._private__chart._internal_options().handleScale.axisPressedMouseMove.time) {\n            return;\n        }\n        model._internal_scaleTimeTo(event.localX);\n    }\n    _internal_touchMoveEvent(event) {\n        this._internal_pressedMouseMoveEvent(event);\n    }\n    _internal_mouseUpEvent() {\n        this._private__mouseDown = false;\n        const model = this._private__chart._internal_model();\n        if (model._internal_timeScale()._internal_isEmpty() && !this._private__chart._internal_options().handleScale.axisPressedMouseMove.time) {\n            return;\n        }\n        model._internal_endScaleTime();\n    }\n    _internal_touchEndEvent() {\n        this._internal_mouseUpEvent();\n    }\n    _internal_mouseDoubleClickEvent() {\n        if (this._private__chart._internal_options().handleScale.axisDoubleClickReset.time) {\n            this._private__chart._internal_model()._internal_resetTimeScale();\n        }\n    }\n    _internal_doubleTapEvent() {\n        this._internal_mouseDoubleClickEvent();\n    }\n    _internal_mouseEnterEvent() {\n        if (this._private__chart._internal_model()._internal_options().handleScale.axisPressedMouseMove.time) {\n            this._private__setCursor(1 /* CursorType.EwResize */ );\n        }\n    }\n    _internal_mouseLeaveEvent() {\n        this._private__setCursor(0 /* CursorType.Default */ );\n    }\n    _internal_getSize() {\n        return this._private__size;\n    }\n    _internal_sizeChanged() {\n        return this._private__sizeChanged;\n    }\n    _internal_setSizes(timeAxisSize, leftStubWidth, rightStubWidth) {\n        if (!(0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this._private__size, timeAxisSize)) {\n            this._private__size = timeAxisSize;\n            this._private__isSettingSize = true;\n            this._private__canvasBinding.resizeCanvasElement(timeAxisSize);\n            this._private__topCanvasBinding.resizeCanvasElement(timeAxisSize);\n            this._private__isSettingSize = false;\n            this._private__cell.style.width = \"\".concat(timeAxisSize.width, \"px\");\n            this._private__cell.style.height = \"\".concat(timeAxisSize.height, \"px\");\n            this._private__sizeChanged._internal_fire(timeAxisSize);\n        }\n        if (this._private__leftStub !== null) {\n            this._private__leftStub._internal_setSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n                width: leftStubWidth,\n                height: timeAxisSize.height\n            }));\n        }\n        if (this._private__rightStub !== null) {\n            this._private__rightStub._internal_setSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n                width: rightStubWidth,\n                height: timeAxisSize.height\n            }));\n        }\n    }\n    _internal_optimalHeight() {\n        const rendererOptions = this._private__getRendererOptions();\n        return Math.ceil(// rendererOptions.offsetSize +\n        rendererOptions._internal_borderSize + rendererOptions._internal_tickLength + rendererOptions._internal_fontSize + rendererOptions._internal_paddingTop + rendererOptions._internal_paddingBottom + rendererOptions._internal_labelBottomOffset);\n    }\n    _internal_update() {\n        // this call has side-effect - it regenerates marks on the time scale\n        this._private__chart._internal_model()._internal_timeScale()._internal_marks();\n    }\n    _internal_getBitmapSize() {\n        return this._private__canvasBinding.bitmapSize;\n    }\n    _internal_drawBitmap(ctx, x, y) {\n        const bitmapSize = this._internal_getBitmapSize();\n        if (bitmapSize.width > 0 && bitmapSize.height > 0) {\n            ctx.drawImage(this._private__canvasBinding.canvasElement, x, y);\n        }\n    }\n    _internal_paint(type) {\n        if (type === 0 /* InvalidationLevel.None */ ) {\n            return;\n        }\n        if (type !== 1 /* InvalidationLevel.Cursor */ ) {\n            this._private__canvasBinding.applySuggestedBitmapSize();\n            const target = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__canvasBinding);\n            if (target !== null) {\n                target.useBitmapCoordinateSpace((scope)=>{\n                    this._private__drawBackground(scope);\n                    this._private__drawBorder(scope);\n                    this._private__drawAdditionalSources(target, sourceBottomPaneViews);\n                });\n                this._private__drawTickMarks(target);\n                this._private__drawAdditionalSources(target, sourcePaneViews);\n            // atm we don't have sources to be drawn on time axis except crosshair which is rendered on top level canvas\n            // so let's don't call this code at all for now\n            // this._drawLabels(this._chart.model().dataSources(), target);\n            }\n            if (this._private__leftStub !== null) {\n                this._private__leftStub._internal_paint(type);\n            }\n            if (this._private__rightStub !== null) {\n                this._private__rightStub._internal_paint(type);\n            }\n        }\n        this._private__topCanvasBinding.applySuggestedBitmapSize();\n        const topTarget = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__topCanvasBinding);\n        if (topTarget !== null) {\n            topTarget.useBitmapCoordinateSpace((param)=>{\n                let { context: ctx, bitmapSize } = param;\n                ctx.clearRect(0, 0, bitmapSize.width, bitmapSize.height);\n            });\n            this._private__drawLabels([\n                ...this._private__chart._internal_model()._internal_serieses(),\n                this._private__chart._internal_model()._internal_crosshairSource()\n            ], topTarget);\n            this._private__drawAdditionalSources(topTarget, sourceTopPaneViews);\n        }\n    }\n    _private__drawAdditionalSources(target, axisViewsGetter) {\n        const sources = this._private__chart._internal_model()._internal_serieses();\n        for (const source of sources){\n            drawSourcePaneViews(axisViewsGetter, (renderer)=>drawBackground(renderer, target, false, undefined), source, undefined);\n        }\n        for (const source of sources){\n            drawSourcePaneViews(axisViewsGetter, (renderer)=>drawForeground(renderer, target, false, undefined), source, undefined);\n        }\n    }\n    _private__drawBackground(param) {\n        let { context: ctx, bitmapSize } = param;\n        clearRect(ctx, 0, 0, bitmapSize.width, bitmapSize.height, this._private__chart._internal_model()._internal_backgroundBottomColor());\n    }\n    _private__drawBorder(param) {\n        let { context: ctx, bitmapSize, verticalPixelRatio } = param;\n        if (this._private__chart._internal_options().timeScale.borderVisible) {\n            ctx.fillStyle = this._private__lineColor();\n            const borderSize = Math.max(1, Math.floor(this._private__getRendererOptions()._internal_borderSize * verticalPixelRatio));\n            ctx.fillRect(0, 0, bitmapSize.width, borderSize);\n        }\n    }\n    _private__drawTickMarks(target) {\n        const timeScale = this._private__chart._internal_model()._internal_timeScale();\n        const tickMarks = timeScale._internal_marks();\n        if (!tickMarks || tickMarks.length === 0) {\n            return;\n        }\n        const maxWeight = this._private__horzScaleBehavior.maxTickMarkWeight(tickMarks);\n        const rendererOptions = this._private__getRendererOptions();\n        const options = timeScale._internal_options();\n        if (options.borderVisible && options.ticksVisible) {\n            target.useBitmapCoordinateSpace((param)=>{\n                let { context: ctx, horizontalPixelRatio, verticalPixelRatio } = param;\n                ctx.strokeStyle = this._private__lineColor();\n                ctx.fillStyle = this._private__lineColor();\n                const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n                const tickOffset = Math.floor(horizontalPixelRatio * 0.5);\n                ctx.beginPath();\n                const tickLen = Math.round(rendererOptions._internal_tickLength * verticalPixelRatio);\n                for(let index = tickMarks.length; index--;){\n                    const x = Math.round(tickMarks[index].coord * horizontalPixelRatio);\n                    ctx.rect(x - tickOffset, 0, tickWidth, tickLen);\n                }\n                ctx.fill();\n            });\n        }\n        target.useMediaCoordinateSpace((param)=>{\n            let { context: ctx } = param;\n            const yText = rendererOptions._internal_borderSize + rendererOptions._internal_tickLength + rendererOptions._internal_paddingTop + rendererOptions._internal_fontSize / 2;\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillStyle = this._private__textColor();\n            // draw base marks\n            ctx.font = this._private__baseFont();\n            for (const tickMark of tickMarks){\n                if (tickMark.weight < maxWeight) {\n                    const coordinate = tickMark.needAlignCoordinate ? this._private__alignTickMarkLabelCoordinate(ctx, tickMark.coord, tickMark.label) : tickMark.coord;\n                    ctx.fillText(tickMark.label, coordinate, yText);\n                }\n            }\n            ctx.font = this._private__baseBoldFont();\n            for (const tickMark of tickMarks){\n                if (tickMark.weight >= maxWeight) {\n                    const coordinate = tickMark.needAlignCoordinate ? this._private__alignTickMarkLabelCoordinate(ctx, tickMark.coord, tickMark.label) : tickMark.coord;\n                    ctx.fillText(tickMark.label, coordinate, yText);\n                }\n            }\n        });\n    }\n    _private__alignTickMarkLabelCoordinate(ctx, coordinate, labelText) {\n        const labelWidth = this._private__widthCache._internal_measureText(ctx, labelText);\n        const labelWidthHalf = labelWidth / 2;\n        const leftTextCoordinate = Math.floor(coordinate - labelWidthHalf) + 0.5;\n        if (leftTextCoordinate < 0) {\n            coordinate = coordinate + Math.abs(0 - leftTextCoordinate);\n        } else if (leftTextCoordinate + labelWidth > this._private__size.width) {\n            coordinate = coordinate - Math.abs(this._private__size.width - (leftTextCoordinate + labelWidth));\n        }\n        return coordinate;\n    }\n    _private__drawLabels(sources, target) {\n        const rendererOptions = this._private__getRendererOptions();\n        for (const source of sources){\n            for (const view of source._internal_timeAxisViews()){\n                view._internal_renderer()._internal_draw(target, rendererOptions);\n            }\n        }\n    }\n    _private__lineColor() {\n        return this._private__chart._internal_options().timeScale.borderColor;\n    }\n    _private__textColor() {\n        return this._private__options.textColor;\n    }\n    _private__fontSize() {\n        return this._private__options.fontSize;\n    }\n    _private__baseFont() {\n        return makeFont(this._private__fontSize(), this._private__options.fontFamily);\n    }\n    _private__baseBoldFont() {\n        return makeFont(this._private__fontSize(), this._private__options.fontFamily, \"bold\");\n    }\n    _private__getRendererOptions() {\n        if (this._private__rendererOptions === null) {\n            this._private__rendererOptions = {\n                _internal_borderSize: 1 /* Constants.BorderSize */ ,\n                _internal_baselineOffset: NaN,\n                _internal_paddingTop: NaN,\n                _internal_paddingBottom: NaN,\n                _internal_paddingHorizontal: NaN,\n                _internal_tickLength: 5 /* Constants.TickLength */ ,\n                _internal_fontSize: NaN,\n                _internal_font: \"\",\n                _internal_widthCache: new TextWidthCache(),\n                _internal_labelBottomOffset: 0\n            };\n        }\n        const rendererOptions = this._private__rendererOptions;\n        const newFont = this._private__baseFont();\n        if (rendererOptions._internal_font !== newFont) {\n            const fontSize = this._private__fontSize();\n            rendererOptions._internal_fontSize = fontSize;\n            rendererOptions._internal_font = newFont;\n            rendererOptions._internal_paddingTop = 3 * fontSize / 12;\n            rendererOptions._internal_paddingBottom = 3 * fontSize / 12;\n            rendererOptions._internal_paddingHorizontal = 9 * fontSize / 12;\n            rendererOptions._internal_baselineOffset = 0;\n            rendererOptions._internal_labelBottomOffset = 4 * fontSize / 12;\n            rendererOptions._internal_widthCache._internal_reset();\n        }\n        return this._private__rendererOptions;\n    }\n    _private__setCursor(type) {\n        this._private__cell.style.cursor = type === 1 /* CursorType.EwResize */  ? \"ew-resize\" : \"default\";\n    }\n    _private__recreateStubs() {\n        const model = this._private__chart._internal_model();\n        const options = model._internal_options();\n        if (!options.leftPriceScale.visible && this._private__leftStub !== null) {\n            this._private__leftStubCell.removeChild(this._private__leftStub._internal_getElement());\n            this._private__leftStub._internal_destroy();\n            this._private__leftStub = null;\n        }\n        if (!options.rightPriceScale.visible && this._private__rightStub !== null) {\n            this._private__rightStubCell.removeChild(this._private__rightStub._internal_getElement());\n            this._private__rightStub._internal_destroy();\n            this._private__rightStub = null;\n        }\n        const rendererOptionsProvider = this._private__chart._internal_model()._internal_rendererOptionsProvider();\n        const params = {\n            _internal_rendererOptionsProvider: rendererOptionsProvider\n        };\n        const borderVisibleGetter = ()=>{\n            return options.leftPriceScale.borderVisible && model._internal_timeScale()._internal_options().borderVisible;\n        };\n        const bottomColorGetter = ()=>model._internal_backgroundBottomColor();\n        if (options.leftPriceScale.visible && this._private__leftStub === null) {\n            this._private__leftStub = new PriceAxisStub(\"left\", options, params, borderVisibleGetter, bottomColorGetter);\n            this._private__leftStubCell.appendChild(this._private__leftStub._internal_getElement());\n        }\n        if (options.rightPriceScale.visible && this._private__rightStub === null) {\n            this._private__rightStub = new PriceAxisStub(\"right\", options, params, borderVisibleGetter, bottomColorGetter);\n            this._private__rightStubCell.appendChild(this._private__rightStub._internal_getElement());\n        }\n    }\n    constructor(chartWidget, horzScaleBehavior){\n        this._private__leftStub = null;\n        this._private__rightStub = null;\n        this._private__rendererOptions = null;\n        this._private__mouseDown = false;\n        this._private__size = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 0,\n            height: 0\n        });\n        this._private__sizeChanged = new Delegate();\n        this._private__widthCache = new TextWidthCache(5);\n        this._private__isSettingSize = false;\n        this._private__canvasSuggestedBitmapSizeChangedHandler = ()=>{\n            if (!this._private__isSettingSize) {\n                this._private__chart._internal_model()._internal_lightUpdate();\n            }\n        };\n        this._private__topCanvasSuggestedBitmapSizeChangedHandler = ()=>{\n            if (!this._private__isSettingSize) {\n                this._private__chart._internal_model()._internal_lightUpdate();\n            }\n        };\n        this._private__chart = chartWidget;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__options = chartWidget._internal_options().layout;\n        this._private__element = document.createElement(\"tr\");\n        this._private__leftStubCell = document.createElement(\"td\");\n        this._private__leftStubCell.style.padding = \"0\";\n        this._private__rightStubCell = document.createElement(\"td\");\n        this._private__rightStubCell.style.padding = \"0\";\n        this._private__cell = document.createElement(\"td\");\n        this._private__cell.style.height = \"25px\";\n        this._private__cell.style.padding = \"0\";\n        this._private__dv = document.createElement(\"div\");\n        this._private__dv.style.width = \"100%\";\n        this._private__dv.style.height = \"100%\";\n        this._private__dv.style.position = \"relative\";\n        this._private__dv.style.overflow = \"hidden\";\n        this._private__cell.appendChild(this._private__dv);\n        this._private__canvasBinding = createBoundCanvas(this._private__dv, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 16,\n            height: 16\n        }));\n        this._private__canvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        const canvas = this._private__canvasBinding.canvasElement;\n        canvas.style.position = \"absolute\";\n        canvas.style.zIndex = \"1\";\n        canvas.style.left = \"0\";\n        canvas.style.top = \"0\";\n        this._private__topCanvasBinding = createBoundCanvas(this._private__dv, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 16,\n            height: 16\n        }));\n        this._private__topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        const topCanvas = this._private__topCanvasBinding.canvasElement;\n        topCanvas.style.position = \"absolute\";\n        topCanvas.style.zIndex = \"2\";\n        topCanvas.style.left = \"0\";\n        topCanvas.style.top = \"0\";\n        this._private__element.appendChild(this._private__leftStubCell);\n        this._private__element.appendChild(this._private__cell);\n        this._private__element.appendChild(this._private__rightStubCell);\n        this._private__recreateStubs();\n        this._private__chart._internal_model()._internal_priceScalesOptionsChanged()._internal_subscribe(this._private__recreateStubs.bind(this), this);\n        this._private__mouseEventHandler = new MouseEventHandler(this._private__topCanvasBinding.canvasElement, this, {\n            _internal_treatVertTouchDragAsPageScroll: ()=>true,\n            _internal_treatHorzTouchDragAsPageScroll: ()=>!this._private__chart._internal_options().handleScroll.horzTouchDrag\n        });\n    }\n}\nconst windowsChrome = isChromiumBased() && isWindows();\nclass ChartWidget {\n    _internal_model() {\n        return this._private__model;\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_paneWidgets() {\n        return this._private__paneWidgets;\n    }\n    _internal_timeAxisWidget() {\n        return this._private__timeAxisWidget;\n    }\n    _internal_destroy() {\n        this._private__setMouseWheelEventListener(false);\n        if (this._private__drawRafId !== 0) {\n            window.cancelAnimationFrame(this._private__drawRafId);\n        }\n        this._private__model._internal_crosshairMoved()._internal_unsubscribeAll(this);\n        this._private__model._internal_timeScale()._internal_optionsApplied()._internal_unsubscribeAll(this);\n        this._private__model._internal_priceScalesOptionsChanged()._internal_unsubscribeAll(this);\n        this._private__model._internal_destroy();\n        for (const paneWidget of this._private__paneWidgets){\n            this._private__tableElement.removeChild(paneWidget._internal_getElement());\n            paneWidget._internal_clicked()._internal_unsubscribeAll(this);\n            paneWidget._internal_dblClicked()._internal_unsubscribeAll(this);\n            paneWidget._internal_destroy();\n        }\n        this._private__paneWidgets = [];\n        // for (const paneSeparator of this._paneSeparators) {\n        // \tthis._destroySeparator(paneSeparator);\n        // }\n        // this._paneSeparators = [];\n        ensureNotNull(this._private__timeAxisWidget)._internal_destroy();\n        if (this._private__element.parentElement !== null) {\n            this._private__element.parentElement.removeChild(this._private__element);\n        }\n        this._private__crosshairMoved._internal_destroy();\n        this._private__clicked._internal_destroy();\n        this._private__dblClicked._internal_destroy();\n        this._private__uninstallObserver();\n    }\n    _internal_resize(width, height) {\n        let forceRepaint = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        if (this._private__height === height && this._private__width === width) {\n            return;\n        }\n        const sizeHint = suggestChartSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width,\n            height\n        }));\n        this._private__height = sizeHint.height;\n        this._private__width = sizeHint.width;\n        const heightStr = this._private__height + \"px\";\n        const widthStr = this._private__width + \"px\";\n        ensureNotNull(this._private__element).style.height = heightStr;\n        ensureNotNull(this._private__element).style.width = widthStr;\n        this._private__tableElement.style.height = heightStr;\n        this._private__tableElement.style.width = widthStr;\n        if (forceRepaint) {\n            this._private__drawImpl(InvalidateMask._internal_full(), performance.now());\n        } else {\n            this._private__model._internal_fullUpdate();\n        }\n    }\n    _internal_paint(invalidateMask) {\n        if (invalidateMask === undefined) {\n            invalidateMask = InvalidateMask._internal_full();\n        }\n        for(let i = 0; i < this._private__paneWidgets.length; i++){\n            this._private__paneWidgets[i]._internal_paint(invalidateMask._internal_invalidateForPane(i)._internal_level);\n        }\n        if (this._private__options.timeScale.visible) {\n            this._private__timeAxisWidget._internal_paint(invalidateMask._internal_fullInvalidation());\n        }\n    }\n    _internal_applyOptions(options) {\n        const currentlyHasMouseWheelListener = shouldSubscribeMouseWheel(this._private__options);\n        // we don't need to merge options here because it's done in chart model\n        // and since both model and widget share the same object it will be done automatically for widget as well\n        // not ideal solution for sure, but it work's for now Â¯\\_(ã)_/Â¯\n        this._private__model._internal_applyOptions(options);\n        const shouldHaveMouseWheelListener = shouldSubscribeMouseWheel(this._private__options);\n        if (shouldHaveMouseWheelListener !== currentlyHasMouseWheelListener) {\n            this._private__setMouseWheelEventListener(shouldHaveMouseWheelListener);\n        }\n        this._private__updateTimeAxisVisibility();\n        this._private__applyAutoSizeOptions(options);\n    }\n    _internal_clicked() {\n        return this._private__clicked;\n    }\n    _internal_dblClicked() {\n        return this._private__dblClicked;\n    }\n    _internal_crosshairMoved() {\n        return this._private__crosshairMoved;\n    }\n    _internal_takeScreenshot() {\n        if (this._private__invalidateMask !== null) {\n            this._private__drawImpl(this._private__invalidateMask, performance.now());\n            this._private__invalidateMask = null;\n        }\n        const screeshotBitmapSize = this._private__traverseLayout(null);\n        const screenshotCanvas = document.createElement(\"canvas\");\n        screenshotCanvas.width = screeshotBitmapSize.width;\n        screenshotCanvas.height = screeshotBitmapSize.height;\n        const ctx = ensureNotNull(screenshotCanvas.getContext(\"2d\"));\n        this._private__traverseLayout(ctx);\n        return screenshotCanvas;\n    }\n    _internal_getPriceAxisWidth(position) {\n        if (position === \"left\" && !this._private__isLeftAxisVisible()) {\n            return 0;\n        }\n        if (position === \"right\" && !this._private__isRightAxisVisible()) {\n            return 0;\n        }\n        if (this._private__paneWidgets.length === 0) {\n            return 0;\n        }\n        // we don't need to worry about exactly pane widget here\n        // because all pane widgets have the same width of price axis widget\n        // see _adjustSizeImpl\n        const priceAxisWidget = position === \"left\" ? this._private__paneWidgets[0]._internal_leftPriceAxisWidget() : this._private__paneWidgets[0]._internal_rightPriceAxisWidget();\n        return ensureNotNull(priceAxisWidget)._internal_getWidth();\n    }\n    _internal_autoSizeActive() {\n        return this._private__options.autoSize && this._private__observer !== null;\n    }\n    _internal_element() {\n        return this._private__element;\n    }\n    _internal_setCursorStyle(style) {\n        this._private__cursorStyleOverride = style;\n        if (this._private__cursorStyleOverride) {\n            this._internal_element().style.setProperty(\"cursor\", style);\n        } else {\n            this._internal_element().style.removeProperty(\"cursor\");\n        }\n    }\n    _internal_getCursorOverrideStyle() {\n        return this._private__cursorStyleOverride;\n    }\n    _internal_paneSize() {\n        // we currently only support a single pane.\n        return ensureDefined(this._private__paneWidgets[0])._internal_getSize();\n    }\n    // eslint-disable-next-line complexity\n    _private__applyAutoSizeOptions(options) {\n        if (options.autoSize === undefined && this._private__observer && (options.width !== undefined || options.height !== undefined)) {\n            warn(\"You should turn autoSize off explicitly before specifying sizes; try adding options.autoSize: false to new options\");\n            return;\n        }\n        if (options.autoSize && !this._private__observer) {\n            // installing observer will override resize if successful\n            this._private__installObserver();\n        }\n        if (options.autoSize === false && this._private__observer !== null) {\n            this._private__uninstallObserver();\n        }\n        if (!options.autoSize && (options.width !== undefined || options.height !== undefined)) {\n            this._internal_resize(options.width || this._private__width, options.height || this._private__height);\n        }\n    }\n    /**\n     * Traverses the widget's layout (pane and axis child widgets),\n     * draws the screenshot (if rendering context is passed) and returns the screenshot bitmap size\n     *\n     * @param ctx - if passed, used to draw the screenshot of widget\n     * @returns screenshot bitmap size\n     */ _private__traverseLayout(ctx) {\n        let totalWidth = 0;\n        let totalHeight = 0;\n        const firstPane = this._private__paneWidgets[0];\n        const drawPriceAxises = (position, targetX)=>{\n            let targetY = 0;\n            for(let paneIndex = 0; paneIndex < this._private__paneWidgets.length; paneIndex++){\n                const paneWidget = this._private__paneWidgets[paneIndex];\n                const priceAxisWidget = ensureNotNull(position === \"left\" ? paneWidget._internal_leftPriceAxisWidget() : paneWidget._internal_rightPriceAxisWidget());\n                const bitmapSize = priceAxisWidget._internal_getBitmapSize();\n                if (ctx !== null) {\n                    priceAxisWidget._internal_drawBitmap(ctx, targetX, targetY);\n                }\n                targetY += bitmapSize.height;\n            // if (paneIndex < this._paneWidgets.length - 1) {\n            // \tconst separator = this._paneSeparators[paneIndex];\n            // \tconst separatorBitmapSize = separator.getBitmapSize();\n            // \tif (ctx !== null) {\n            // \t\tseparator.drawBitmap(ctx, targetX, targetY);\n            // \t}\n            // \ttargetY += separatorBitmapSize.height;\n            // }\n            }\n        };\n        // draw left price scale if exists\n        if (this._private__isLeftAxisVisible()) {\n            drawPriceAxises(\"left\", 0);\n            const leftAxisBitmapWidth = ensureNotNull(firstPane._internal_leftPriceAxisWidget())._internal_getBitmapSize().width;\n            totalWidth += leftAxisBitmapWidth;\n        }\n        for(let paneIndex = 0; paneIndex < this._private__paneWidgets.length; paneIndex++){\n            const paneWidget = this._private__paneWidgets[paneIndex];\n            const bitmapSize = paneWidget._internal_getBitmapSize();\n            if (ctx !== null) {\n                paneWidget._internal_drawBitmap(ctx, totalWidth, totalHeight);\n            }\n            totalHeight += bitmapSize.height;\n        // if (paneIndex < this._paneWidgets.length - 1) {\n        // \tconst separator = this._paneSeparators[paneIndex];\n        // \tconst separatorBitmapSize = separator.getBitmapSize();\n        // \tif (ctx !== null) {\n        // \t\tseparator.drawBitmap(ctx, totalWidth, totalHeight);\n        // \t}\n        // \ttotalHeight += separatorBitmapSize.height;\n        // }\n        }\n        const firstPaneBitmapWidth = firstPane._internal_getBitmapSize().width;\n        totalWidth += firstPaneBitmapWidth;\n        // draw right price scale if exists\n        if (this._private__isRightAxisVisible()) {\n            drawPriceAxises(\"right\", totalWidth);\n            const rightAxisBitmapWidth = ensureNotNull(firstPane._internal_rightPriceAxisWidget())._internal_getBitmapSize().width;\n            totalWidth += rightAxisBitmapWidth;\n        }\n        const drawStub = (position, targetX, targetY)=>{\n            const stub = ensureNotNull(position === \"left\" ? this._private__timeAxisWidget._internal_leftStub() : this._private__timeAxisWidget._internal_rightStub());\n            stub._internal_drawBitmap(ensureNotNull(ctx), targetX, targetY);\n        };\n        // draw time scale and stubs\n        if (this._private__options.timeScale.visible) {\n            const timeAxisBitmapSize = this._private__timeAxisWidget._internal_getBitmapSize();\n            if (ctx !== null) {\n                let targetX = 0;\n                if (this._private__isLeftAxisVisible()) {\n                    drawStub(\"left\", targetX, totalHeight);\n                    targetX = ensureNotNull(firstPane._internal_leftPriceAxisWidget())._internal_getBitmapSize().width;\n                }\n                this._private__timeAxisWidget._internal_drawBitmap(ctx, targetX, totalHeight);\n                targetX += timeAxisBitmapSize.width;\n                if (this._private__isRightAxisVisible()) {\n                    drawStub(\"right\", targetX, totalHeight);\n                }\n            }\n            totalHeight += timeAxisBitmapSize.height;\n        }\n        return (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: totalWidth,\n            height: totalHeight\n        });\n    }\n    // eslint-disable-next-line complexity\n    _private__adjustSizeImpl() {\n        let totalStretch = 0;\n        let leftPriceAxisWidth = 0;\n        let rightPriceAxisWidth = 0;\n        for (const paneWidget of this._private__paneWidgets){\n            if (this._private__isLeftAxisVisible()) {\n                leftPriceAxisWidth = Math.max(leftPriceAxisWidth, ensureNotNull(paneWidget._internal_leftPriceAxisWidget())._internal_optimalWidth(), this._private__options.leftPriceScale.minimumWidth);\n            }\n            if (this._private__isRightAxisVisible()) {\n                rightPriceAxisWidth = Math.max(rightPriceAxisWidth, ensureNotNull(paneWidget._internal_rightPriceAxisWidget())._internal_optimalWidth(), this._private__options.rightPriceScale.minimumWidth);\n            }\n            totalStretch += paneWidget._internal_stretchFactor();\n        }\n        leftPriceAxisWidth = suggestPriceScaleWidth(leftPriceAxisWidth);\n        rightPriceAxisWidth = suggestPriceScaleWidth(rightPriceAxisWidth);\n        const width = this._private__width;\n        const height = this._private__height;\n        const paneWidth = Math.max(width - leftPriceAxisWidth - rightPriceAxisWidth, 0);\n        // const separatorCount = this._paneSeparators.length;\n        // const separatorHeight = SEPARATOR_HEIGHT;\n        const separatorsHeight = 0; // separatorHeight * separatorCount;\n        const timeAxisVisible = this._private__options.timeScale.visible;\n        let timeAxisHeight = timeAxisVisible ? Math.max(this._private__timeAxisWidget._internal_optimalHeight(), this._private__options.timeScale.minimumHeight) : 0;\n        timeAxisHeight = suggestTimeScaleHeight(timeAxisHeight);\n        const otherWidgetHeight = separatorsHeight + timeAxisHeight;\n        const totalPaneHeight = height < otherWidgetHeight ? 0 : height - otherWidgetHeight;\n        const stretchPixels = totalPaneHeight / totalStretch;\n        let accumulatedHeight = 0;\n        for(let paneIndex = 0; paneIndex < this._private__paneWidgets.length; ++paneIndex){\n            const paneWidget = this._private__paneWidgets[paneIndex];\n            paneWidget._internal_setState(this._private__model._internal_panes()[paneIndex]);\n            let paneHeight = 0;\n            let calculatePaneHeight = 0;\n            if (paneIndex === this._private__paneWidgets.length - 1) {\n                calculatePaneHeight = totalPaneHeight - accumulatedHeight;\n            } else {\n                calculatePaneHeight = Math.round(paneWidget._internal_stretchFactor() * stretchPixels);\n            }\n            paneHeight = Math.max(calculatePaneHeight, 2);\n            accumulatedHeight += paneHeight;\n            paneWidget._internal_setSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n                width: paneWidth,\n                height: paneHeight\n            }));\n            if (this._private__isLeftAxisVisible()) {\n                paneWidget._internal_setPriceAxisSize(leftPriceAxisWidth, \"left\");\n            }\n            if (this._private__isRightAxisVisible()) {\n                paneWidget._internal_setPriceAxisSize(rightPriceAxisWidth, \"right\");\n            }\n            if (paneWidget._internal_state()) {\n                this._private__model._internal_setPaneHeight(paneWidget._internal_state(), paneHeight);\n            }\n        }\n        this._private__timeAxisWidget._internal_setSizes((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: timeAxisVisible ? paneWidth : 0,\n            height: timeAxisHeight\n        }), timeAxisVisible ? leftPriceAxisWidth : 0, timeAxisVisible ? rightPriceAxisWidth : 0);\n        this._private__model._internal_setWidth(paneWidth);\n        if (this._private__leftPriceAxisWidth !== leftPriceAxisWidth) {\n            this._private__leftPriceAxisWidth = leftPriceAxisWidth;\n        }\n        if (this._private__rightPriceAxisWidth !== rightPriceAxisWidth) {\n            this._private__rightPriceAxisWidth = rightPriceAxisWidth;\n        }\n    }\n    _private__setMouseWheelEventListener(add) {\n        if (add) {\n            this._private__element.addEventListener(\"wheel\", this._private__onWheelBound, {\n                passive: false\n            });\n            return;\n        }\n        this._private__element.removeEventListener(\"wheel\", this._private__onWheelBound);\n    }\n    _private__determineWheelSpeedAdjustment(event) {\n        switch(event.deltaMode){\n            case event.DOM_DELTA_PAGE:\n                // one screen at time scroll mode\n                return 120;\n            case event.DOM_DELTA_LINE:\n                // one line at time scroll mode\n                return 32;\n        }\n        if (!windowsChrome) {\n            return 1;\n        }\n        // Chromium on Windows has a bug where the scroll speed isn't correctly\n        // adjusted for high density displays. We need to correct for this so that\n        // scroll speed is consistent between browsers.\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1001735\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1207308\n        return 1 / window.devicePixelRatio;\n    }\n    _private__onMousewheel(event) {\n        if ((event.deltaX === 0 || !this._private__options.handleScroll.mouseWheel) && (event.deltaY === 0 || !this._private__options.handleScale.mouseWheel)) {\n            return;\n        }\n        const scrollSpeedAdjustment = this._private__determineWheelSpeedAdjustment(event);\n        const deltaX = scrollSpeedAdjustment * event.deltaX / 100;\n        const deltaY = -(scrollSpeedAdjustment * event.deltaY / 100);\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        if (deltaY !== 0 && this._private__options.handleScale.mouseWheel) {\n            const zoomScale = Math.sign(deltaY) * Math.min(1, Math.abs(deltaY));\n            const scrollPosition = event.clientX - this._private__element.getBoundingClientRect().left;\n            this._internal_model()._internal_zoomTime(scrollPosition, zoomScale);\n        }\n        if (deltaX !== 0 && this._private__options.handleScroll.mouseWheel) {\n            this._internal_model()._internal_scrollChart(deltaX * -80); // 80 is a made up coefficient, and minus is for the \"natural\" scroll\n        }\n    }\n    _private__drawImpl(invalidateMask, time) {\n        var _a;\n        const invalidationType = invalidateMask._internal_fullInvalidation();\n        // actions for full invalidation ONLY (not shared with light)\n        if (invalidationType === 3 /* InvalidationLevel.Full */ ) {\n            this._private__updateGui();\n        }\n        // light or full invalidate actions\n        if (invalidationType === 3 /* InvalidationLevel.Full */  || invalidationType === 2 /* InvalidationLevel.Light */ ) {\n            this._private__applyMomentaryAutoScale(invalidateMask);\n            this._private__applyTimeScaleInvalidations(invalidateMask, time);\n            this._private__timeAxisWidget._internal_update();\n            this._private__paneWidgets.forEach((pane)=>{\n                pane._internal_updatePriceAxisWidgets();\n            });\n            // In the case a full invalidation has been postponed during the draw, reapply\n            // the timescale invalidations. A full invalidation would mean there is a change\n            // in the timescale width (caused by price scale changes) that needs to be drawn\n            // right away to avoid flickering.\n            if (((_a = this._private__invalidateMask) === null || _a === void 0 ? void 0 : _a._internal_fullInvalidation()) === 3 /* InvalidationLevel.Full */ ) {\n                this._private__invalidateMask._internal_merge(invalidateMask);\n                this._private__updateGui();\n                this._private__applyMomentaryAutoScale(this._private__invalidateMask);\n                this._private__applyTimeScaleInvalidations(this._private__invalidateMask, time);\n                invalidateMask = this._private__invalidateMask;\n                this._private__invalidateMask = null;\n            }\n        }\n        this._internal_paint(invalidateMask);\n    }\n    _private__applyTimeScaleInvalidations(invalidateMask, time) {\n        for (const tsInvalidation of invalidateMask._internal_timeScaleInvalidations()){\n            this._private__applyTimeScaleInvalidation(tsInvalidation, time);\n        }\n    }\n    _private__applyMomentaryAutoScale(invalidateMask) {\n        const panes = this._private__model._internal_panes();\n        for(let i = 0; i < panes.length; i++){\n            if (invalidateMask._internal_invalidateForPane(i)._internal_autoScale) {\n                panes[i]._internal_momentaryAutoScale();\n            }\n        }\n    }\n    _private__applyTimeScaleInvalidation(invalidation, time) {\n        const timeScale = this._private__model._internal_timeScale();\n        switch(invalidation._internal_type){\n            case 0 /* TimeScaleInvalidationType.FitContent */ :\n                timeScale._internal_fitContent();\n                break;\n            case 1 /* TimeScaleInvalidationType.ApplyRange */ :\n                timeScale._internal_setLogicalRange(invalidation._internal_value);\n                break;\n            case 2 /* TimeScaleInvalidationType.ApplyBarSpacing */ :\n                timeScale._internal_setBarSpacing(invalidation._internal_value);\n                break;\n            case 3 /* TimeScaleInvalidationType.ApplyRightOffset */ :\n                timeScale._internal_setRightOffset(invalidation._internal_value);\n                break;\n            case 4 /* TimeScaleInvalidationType.Reset */ :\n                timeScale._internal_restoreDefault();\n                break;\n            case 5 /* TimeScaleInvalidationType.Animation */ :\n                if (!invalidation._internal_value._internal_finished(time)) {\n                    timeScale._internal_setRightOffset(invalidation._internal_value._internal_getPosition(time));\n                }\n                break;\n        }\n    }\n    _private__invalidateHandler(invalidateMask) {\n        if (this._private__invalidateMask !== null) {\n            this._private__invalidateMask._internal_merge(invalidateMask);\n        } else {\n            this._private__invalidateMask = invalidateMask;\n        }\n        if (!this._private__drawPlanned) {\n            this._private__drawPlanned = true;\n            this._private__drawRafId = window.requestAnimationFrame((time)=>{\n                this._private__drawPlanned = false;\n                this._private__drawRafId = 0;\n                if (this._private__invalidateMask !== null) {\n                    const mask = this._private__invalidateMask;\n                    this._private__invalidateMask = null;\n                    this._private__drawImpl(mask, time);\n                    for (const tsInvalidation of mask._internal_timeScaleInvalidations()){\n                        if (tsInvalidation._internal_type === 5 /* TimeScaleInvalidationType.Animation */  && !tsInvalidation._internal_value._internal_finished(time)) {\n                            this._internal_model()._internal_setTimeScaleAnimation(tsInvalidation._internal_value);\n                            break;\n                        }\n                    }\n                }\n            });\n        }\n    }\n    _private__updateGui() {\n        this._private__syncGuiWithModel();\n    }\n    // private _destroySeparator(separator: PaneSeparator): void {\n    // \tthis._tableElement.removeChild(separator.getElement());\n    // \tseparator.destroy();\n    // }\n    _private__syncGuiWithModel() {\n        const panes = this._private__model._internal_panes();\n        const targetPaneWidgetsCount = panes.length;\n        const actualPaneWidgetsCount = this._private__paneWidgets.length;\n        // Remove (if needed) pane widgets and separators\n        for(let i = targetPaneWidgetsCount; i < actualPaneWidgetsCount; i++){\n            const paneWidget = ensureDefined(this._private__paneWidgets.pop());\n            this._private__tableElement.removeChild(paneWidget._internal_getElement());\n            paneWidget._internal_clicked()._internal_unsubscribeAll(this);\n            paneWidget._internal_dblClicked()._internal_unsubscribeAll(this);\n            paneWidget._internal_destroy();\n        // const paneSeparator = this._paneSeparators.pop();\n        // if (paneSeparator !== undefined) {\n        // \tthis._destroySeparator(paneSeparator);\n        // }\n        }\n        // Create (if needed) new pane widgets and separators\n        for(let i = actualPaneWidgetsCount; i < targetPaneWidgetsCount; i++){\n            const paneWidget = new PaneWidget(this, panes[i]);\n            paneWidget._internal_clicked()._internal_subscribe(this._private__onPaneWidgetClicked.bind(this), this);\n            paneWidget._internal_dblClicked()._internal_subscribe(this._private__onPaneWidgetDblClicked.bind(this), this);\n            this._private__paneWidgets.push(paneWidget);\n            // create and insert separator\n            // if (i > 1) {\n            // \tconst paneSeparator = new PaneSeparator(this, i - 1, i, true);\n            // \tthis._paneSeparators.push(paneSeparator);\n            // \tthis._tableElement.insertBefore(paneSeparator.getElement(), this._timeAxisWidget.getElement());\n            // }\n            // insert paneWidget\n            this._private__tableElement.insertBefore(paneWidget._internal_getElement(), this._private__timeAxisWidget._internal_getElement());\n        }\n        for(let i = 0; i < targetPaneWidgetsCount; i++){\n            const state = panes[i];\n            const paneWidget = this._private__paneWidgets[i];\n            if (paneWidget._internal_state() !== state) {\n                paneWidget._internal_setState(state);\n            } else {\n                paneWidget._internal_updatePriceAxisWidgetsStates();\n            }\n        }\n        this._private__updateTimeAxisVisibility();\n        this._private__adjustSizeImpl();\n    }\n    _private__getMouseEventParamsImpl(index, point, event) {\n        var _a;\n        const seriesData = new Map();\n        if (index !== null) {\n            const serieses = this._private__model._internal_serieses();\n            serieses.forEach((s)=>{\n                // TODO: replace with search left\n                const data = s._internal_bars()._internal_search(index);\n                if (data !== null) {\n                    seriesData.set(s, data);\n                }\n            });\n        }\n        let clientTime;\n        if (index !== null) {\n            const timePoint = (_a = this._private__model._internal_timeScale()._internal_indexToTimeScalePoint(index)) === null || _a === void 0 ? void 0 : _a.originalTime;\n            if (timePoint !== undefined) {\n                clientTime = timePoint;\n            }\n        }\n        const hoveredSource = this._internal_model()._internal_hoveredSource();\n        const hoveredSeries = hoveredSource !== null && hoveredSource._internal_source instanceof Series ? hoveredSource._internal_source : undefined;\n        const hoveredObject = hoveredSource !== null && hoveredSource._internal_object !== undefined ? hoveredSource._internal_object._internal_externalId : undefined;\n        return {\n            _internal_originalTime: clientTime,\n            _internal_index: index !== null && index !== void 0 ? index : undefined,\n            _internal_point: point !== null && point !== void 0 ? point : undefined,\n            _internal_hoveredSeries: hoveredSeries,\n            _internal_seriesData: seriesData,\n            _internal_hoveredObject: hoveredObject,\n            _internal_touchMouseEventData: event !== null && event !== void 0 ? event : undefined\n        };\n    }\n    _private__onPaneWidgetClicked(time, point, event) {\n        this._private__clicked._internal_fire(()=>this._private__getMouseEventParamsImpl(time, point, event));\n    }\n    _private__onPaneWidgetDblClicked(time, point, event) {\n        this._private__dblClicked._internal_fire(()=>this._private__getMouseEventParamsImpl(time, point, event));\n    }\n    _private__onPaneWidgetCrosshairMoved(time, point, event) {\n        this._private__crosshairMoved._internal_fire(()=>this._private__getMouseEventParamsImpl(time, point, event));\n    }\n    _private__updateTimeAxisVisibility() {\n        const display = this._private__options.timeScale.visible ? \"\" : \"none\";\n        this._private__timeAxisWidget._internal_getElement().style.display = display;\n    }\n    _private__isLeftAxisVisible() {\n        return this._private__paneWidgets[0]._internal_state()._internal_leftPriceScale()._internal_options().visible;\n    }\n    _private__isRightAxisVisible() {\n        return this._private__paneWidgets[0]._internal_state()._internal_rightPriceScale()._internal_options().visible;\n    }\n    _private__installObserver() {\n        // eslint-disable-next-line no-restricted-syntax\n        if (!(\"ResizeObserver\" in window)) {\n            warn('Options contains \"autoSize\" flag, but the browser does not support ResizeObserver feature. Please provide polyfill.');\n            return false;\n        } else {\n            this._private__observer = new ResizeObserver((entries)=>{\n                const containerEntry = entries.find((entry)=>entry.target === this._private__container);\n                if (!containerEntry) {\n                    return;\n                }\n                this._internal_resize(containerEntry.contentRect.width, containerEntry.contentRect.height);\n            });\n            this._private__observer.observe(this._private__container, {\n                box: \"border-box\"\n            });\n            return true;\n        }\n    }\n    _private__uninstallObserver() {\n        if (this._private__observer !== null) {\n            this._private__observer.disconnect();\n        }\n        this._private__observer = null;\n    }\n    constructor(container, options, horzScaleBehavior){\n        this._private__paneWidgets = [];\n        this._private__drawRafId = 0;\n        this._private__height = 0;\n        this._private__width = 0;\n        this._private__leftPriceAxisWidth = 0;\n        this._private__rightPriceAxisWidth = 0;\n        this._private__invalidateMask = null;\n        this._private__drawPlanned = false;\n        this._private__clicked = new Delegate();\n        this._private__dblClicked = new Delegate();\n        this._private__crosshairMoved = new Delegate();\n        this._private__observer = null;\n        this._private__cursorStyleOverride = null;\n        this._private__container = container;\n        this._private__options = options;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__element = document.createElement(\"div\");\n        this._private__element.classList.add(\"tv-lightweight-charts\");\n        this._private__element.style.overflow = \"hidden\";\n        this._private__element.style.direction = \"ltr\";\n        this._private__element.style.width = \"100%\";\n        this._private__element.style.height = \"100%\";\n        disableSelection(this._private__element);\n        this._private__tableElement = document.createElement(\"table\");\n        this._private__tableElement.setAttribute(\"cellspacing\", \"0\");\n        this._private__element.appendChild(this._private__tableElement);\n        this._private__onWheelBound = this._private__onMousewheel.bind(this);\n        if (shouldSubscribeMouseWheel(this._private__options)) {\n            this._private__setMouseWheelEventListener(true);\n        }\n        this._private__model = new ChartModel(this._private__invalidateHandler.bind(this), this._private__options, horzScaleBehavior);\n        this._internal_model()._internal_crosshairMoved()._internal_subscribe(this._private__onPaneWidgetCrosshairMoved.bind(this), this);\n        this._private__timeAxisWidget = new TimeAxisWidget(this, this._private__horzScaleBehavior);\n        this._private__tableElement.appendChild(this._private__timeAxisWidget._internal_getElement());\n        const usedObserver = options.autoSize && this._private__installObserver();\n        // observer could not fire event immediately for some cases\n        // so we have to set initial size manually\n        let width = this._private__options.width;\n        let height = this._private__options.height;\n        // ignore width/height options if observer has actually been used\n        // however respect options if installing resize observer failed\n        if (usedObserver || width === 0 || height === 0) {\n            const containerRect = container.getBoundingClientRect();\n            width = width || containerRect.width;\n            height = height || containerRect.height;\n        }\n        // BEWARE: resize must be called BEFORE _syncGuiWithModel (in constructor only)\n        // or after but with adjustSize to properly update time scale\n        this._internal_resize(width, height);\n        this._private__syncGuiWithModel();\n        container.appendChild(this._private__element);\n        this._private__updateTimeAxisVisibility();\n        this._private__model._internal_timeScale()._internal_optionsApplied()._internal_subscribe(this._private__model._internal_fullUpdate.bind(this._private__model), this);\n        this._private__model._internal_priceScalesOptionsChanged()._internal_subscribe(this._private__model._internal_fullUpdate.bind(this._private__model), this);\n    }\n}\nfunction disableSelection(element) {\n    element.style.userSelect = \"none\";\n    // eslint-disable-next-line deprecation/deprecation\n    element.style.webkitUserSelect = \"none\";\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-member-access\n    element.style.msUserSelect = \"none\";\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-member-access\n    element.style.MozUserSelect = \"none\";\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-member-access\n    element.style.webkitTapHighlightColor = \"transparent\";\n}\nfunction shouldSubscribeMouseWheel(options) {\n    return Boolean(options.handleScroll.mouseWheel || options.handleScale.mouseWheel);\n}\nfunction isWhitespaceData(data) {\n    return data.open === undefined && data.value === undefined;\n}\nfunction isFulfilledData(data) {\n    return data.open !== undefined || data.value !== undefined;\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction getColoredLineBasedSeriesPlotRow(time, index, item, originalTime) {\n    const val = item.value;\n    const res = {\n        _internal_index: index,\n        _internal_time: time,\n        _internal_value: [\n            val,\n            val,\n            val,\n            val\n        ],\n        _internal_originalTime: originalTime\n    };\n    if (item.color !== undefined) {\n        res._internal_color = item.color;\n    }\n    return res;\n}\nfunction getAreaSeriesPlotRow(time, index, item, originalTime) {\n    const val = item.value;\n    const res = {\n        _internal_index: index,\n        _internal_time: time,\n        _internal_value: [\n            val,\n            val,\n            val,\n            val\n        ],\n        _internal_originalTime: originalTime\n    };\n    if (item.lineColor !== undefined) {\n        res._internal_lineColor = item.lineColor;\n    }\n    if (item.topColor !== undefined) {\n        res._internal_topColor = item.topColor;\n    }\n    if (item.bottomColor !== undefined) {\n        res._internal_bottomColor = item.bottomColor;\n    }\n    return res;\n}\nfunction getBaselineSeriesPlotRow(time, index, item, originalTime) {\n    const val = item.value;\n    const res = {\n        _internal_index: index,\n        _internal_time: time,\n        _internal_value: [\n            val,\n            val,\n            val,\n            val\n        ],\n        _internal_originalTime: originalTime\n    };\n    if (item.topLineColor !== undefined) {\n        res._internal_topLineColor = item.topLineColor;\n    }\n    if (item.bottomLineColor !== undefined) {\n        res._internal_bottomLineColor = item.bottomLineColor;\n    }\n    if (item.topFillColor1 !== undefined) {\n        res._internal_topFillColor1 = item.topFillColor1;\n    }\n    if (item.topFillColor2 !== undefined) {\n        res._internal_topFillColor2 = item.topFillColor2;\n    }\n    if (item.bottomFillColor1 !== undefined) {\n        res._internal_bottomFillColor1 = item.bottomFillColor1;\n    }\n    if (item.bottomFillColor2 !== undefined) {\n        res._internal_bottomFillColor2 = item.bottomFillColor2;\n    }\n    return res;\n}\nfunction getBarSeriesPlotRow(time, index, item, originalTime) {\n    const res = {\n        _internal_index: index,\n        _internal_time: time,\n        _internal_value: [\n            item.open,\n            item.high,\n            item.low,\n            item.close\n        ],\n        _internal_originalTime: originalTime\n    };\n    if (item.color !== undefined) {\n        res._internal_color = item.color;\n    }\n    return res;\n}\nfunction getCandlestickSeriesPlotRow(time, index, item, originalTime) {\n    const res = {\n        _internal_index: index,\n        _internal_time: time,\n        _internal_value: [\n            item.open,\n            item.high,\n            item.low,\n            item.close\n        ],\n        _internal_originalTime: originalTime\n    };\n    if (item.color !== undefined) {\n        res._internal_color = item.color;\n    }\n    if (item.borderColor !== undefined) {\n        res._internal_borderColor = item.borderColor;\n    }\n    if (item.wickColor !== undefined) {\n        res._internal_wickColor = item.wickColor;\n    }\n    return res;\n}\nfunction getCustomSeriesPlotRow(time, index, item, originalTime, dataToPlotRow) {\n    const values = ensureDefined(dataToPlotRow)(item);\n    const max = Math.max(...values);\n    const min = Math.min(...values);\n    const last = values[values.length - 1];\n    const value = [\n        last,\n        max,\n        min,\n        last\n    ];\n    const _a = item, { time: excludedTime, color } = _a, data = __rest(_a, [\n        \"time\",\n        \"color\"\n    ]);\n    return {\n        _internal_index: index,\n        _internal_time: time,\n        _internal_value: value,\n        _internal_originalTime: originalTime,\n        _internal_data: data,\n        _internal_color: color\n    };\n}\nfunction isSeriesPlotRow(row) {\n    return row._internal_value !== undefined;\n}\nfunction wrapCustomValues(plotRow, bar) {\n    if (bar.customValues !== undefined) {\n        plotRow._internal_customValues = bar.customValues;\n    }\n    return plotRow;\n}\nfunction isWhitespaceDataWithCustomCheck(bar, customIsWhitespace) {\n    if (customIsWhitespace) {\n        return customIsWhitespace(bar);\n    }\n    return isWhitespaceData(bar);\n}\nfunction wrapWhitespaceData(createPlotRowFn) {\n    return (time, index, bar, originalTime, dataToPlotRow, customIsWhitespace)=>{\n        if (isWhitespaceDataWithCustomCheck(bar, customIsWhitespace)) {\n            return wrapCustomValues({\n                _internal_time: time,\n                _internal_index: index,\n                _internal_originalTime: originalTime\n            }, bar);\n        }\n        return wrapCustomValues(createPlotRowFn(time, index, bar, originalTime, dataToPlotRow), bar);\n    };\n}\nfunction getSeriesPlotRowCreator(seriesType) {\n    const seriesPlotRowFnMap = {\n        Candlestick: wrapWhitespaceData(getCandlestickSeriesPlotRow),\n        Bar: wrapWhitespaceData(getBarSeriesPlotRow),\n        Area: wrapWhitespaceData(getAreaSeriesPlotRow),\n        Baseline: wrapWhitespaceData(getBaselineSeriesPlotRow),\n        Histogram: wrapWhitespaceData(getColoredLineBasedSeriesPlotRow),\n        Line: wrapWhitespaceData(getColoredLineBasedSeriesPlotRow),\n        Custom: wrapWhitespaceData(getCustomSeriesPlotRow)\n    };\n    return seriesPlotRowFnMap[seriesType];\n}\n/// <reference types=\"_build-time-constants\" />\nfunction createEmptyTimePointData(timePoint) {\n    return {\n        _internal_index: 0,\n        _internal_mapping: new Map(),\n        _internal_timePoint: timePoint\n    };\n}\nfunction seriesRowsFirstAndLastTime(seriesRows, bh) {\n    if (seriesRows === undefined || seriesRows.length === 0) {\n        return undefined;\n    }\n    return {\n        _internal_firstTime: bh.key(seriesRows[0]._internal_time),\n        _internal_lastTime: bh.key(seriesRows[seriesRows.length - 1]._internal_time)\n    };\n}\nfunction seriesUpdateInfo(seriesRows, prevSeriesRows, bh) {\n    const firstAndLastTime = seriesRowsFirstAndLastTime(seriesRows, bh);\n    const prevFirstAndLastTime = seriesRowsFirstAndLastTime(prevSeriesRows, bh);\n    if (firstAndLastTime !== undefined && prevFirstAndLastTime !== undefined) {\n        return {\n            _internal_lastBarUpdatedOrNewBarsAddedToTheRight: firstAndLastTime._internal_lastTime >= prevFirstAndLastTime._internal_lastTime && firstAndLastTime._internal_firstTime >= prevFirstAndLastTime._internal_firstTime\n        };\n    }\n    return undefined;\n}\nfunction timeScalePointTime(mergedPointData) {\n    let result;\n    mergedPointData.forEach((v)=>{\n        if (result === undefined) {\n            result = v._internal_originalTime;\n        }\n    });\n    return ensureDefined(result);\n}\nfunction saveOriginalTime(data) {\n    if (data._internal_originalTime === undefined) {\n        data._internal_originalTime = data.time;\n    }\n}\nclass DataLayer {\n    _internal_destroy() {\n        this._private__pointDataByTimePoint.clear();\n        this._private__seriesRowsBySeries.clear();\n        this._private__seriesLastTimePoint.clear();\n        this._private__sortedTimePoints = [];\n    }\n    _internal_setSeriesData(series, data) {\n        let needCleanupPoints = this._private__pointDataByTimePoint.size !== 0;\n        let isTimeScaleAffected = false;\n        // save previous series rows data before it's replaced inside this._setRowsToSeries\n        const prevSeriesRows = this._private__seriesRowsBySeries.get(series);\n        if (prevSeriesRows !== undefined) {\n            if (this._private__seriesRowsBySeries.size === 1) {\n                needCleanupPoints = false;\n                isTimeScaleAffected = true;\n                // perf optimization - if there is only 1 series, then we can just clear and fill everything from scratch\n                this._private__pointDataByTimePoint.clear();\n            } else {\n                // perf optimization - actually we have to use this._pointDataByTimePoint for going through here\n                // but as soon as this._sortedTimePoints is just a different form of _pointDataByTimePoint we can use it as well\n                for (const point of this._private__sortedTimePoints){\n                    if (point.pointData._internal_mapping.delete(series)) {\n                        isTimeScaleAffected = true;\n                    }\n                }\n            }\n        }\n        let seriesRows = [];\n        if (data.length !== 0) {\n            const originalTimes = data.map((d)=>d.time);\n            const timeConverter = this._private__horzScaleBehavior.createConverterToInternalObj(data);\n            const createPlotRow = getSeriesPlotRowCreator(series._internal_seriesType());\n            const dataToPlotRow = series._internal_customSeriesPlotValuesBuilder();\n            const customWhitespaceChecker = series._internal_customSeriesWhitespaceCheck();\n            seriesRows = data.map((item, index)=>{\n                const time = timeConverter(item.time);\n                const horzItemKey = this._private__horzScaleBehavior.key(time);\n                let timePointData = this._private__pointDataByTimePoint.get(horzItemKey);\n                if (timePointData === undefined) {\n                    // the indexes will be sync later\n                    timePointData = createEmptyTimePointData(time);\n                    this._private__pointDataByTimePoint.set(horzItemKey, timePointData);\n                    isTimeScaleAffected = true;\n                }\n                const row = createPlotRow(time, timePointData._internal_index, item, originalTimes[index], dataToPlotRow, customWhitespaceChecker);\n                timePointData._internal_mapping.set(series, row);\n                return row;\n            });\n        }\n        if (needCleanupPoints) {\n            // we deleted the old data from mapping and added the new ones\n            // so there might be empty points now, let's remove them first\n            this._private__cleanupPointsData();\n        }\n        this._private__setRowsToSeries(series, seriesRows);\n        let firstChangedPointIndex = -1;\n        if (isTimeScaleAffected) {\n            // then generate the time scale points\n            // timeWeight will be updates in _updateTimeScalePoints later\n            const newTimeScalePoints = [];\n            this._private__pointDataByTimePoint.forEach((pointData)=>{\n                newTimeScalePoints.push({\n                    timeWeight: 0,\n                    time: pointData._internal_timePoint,\n                    pointData,\n                    originalTime: timeScalePointTime(pointData._internal_mapping)\n                });\n            });\n            newTimeScalePoints.sort((t1, t2)=>this._private__horzScaleBehavior.key(t1.time) - this._private__horzScaleBehavior.key(t2.time));\n            firstChangedPointIndex = this._private__replaceTimeScalePoints(newTimeScalePoints);\n        }\n        return this._private__getUpdateResponse(series, firstChangedPointIndex, seriesUpdateInfo(this._private__seriesRowsBySeries.get(series), prevSeriesRows, this._private__horzScaleBehavior));\n    }\n    _internal_removeSeries(series) {\n        return this._internal_setSeriesData(series, []);\n    }\n    _internal_updateSeriesData(series, data) {\n        const extendedData = data;\n        saveOriginalTime(extendedData);\n        // convertStringToBusinessDay(data);\n        this._private__horzScaleBehavior.preprocessData(data);\n        const timeConverter = this._private__horzScaleBehavior.createConverterToInternalObj([\n            data\n        ]);\n        const time = timeConverter(data.time);\n        const lastSeriesTime = this._private__seriesLastTimePoint.get(series);\n        if (lastSeriesTime !== undefined && this._private__horzScaleBehavior.key(time) < this._private__horzScaleBehavior.key(lastSeriesTime)) {\n            throw new Error(\"Cannot update oldest data, last time=\".concat(lastSeriesTime, \", new time=\").concat(time));\n        }\n        let pointDataAtTime = this._private__pointDataByTimePoint.get(this._private__horzScaleBehavior.key(time));\n        // if no point data found for the new data item\n        // that means that we need to update scale\n        const affectsTimeScale = pointDataAtTime === undefined;\n        if (pointDataAtTime === undefined) {\n            // the indexes will be sync later\n            pointDataAtTime = createEmptyTimePointData(time);\n            this._private__pointDataByTimePoint.set(this._private__horzScaleBehavior.key(time), pointDataAtTime);\n        }\n        const createPlotRow = getSeriesPlotRowCreator(series._internal_seriesType());\n        const dataToPlotRow = series._internal_customSeriesPlotValuesBuilder();\n        const customWhitespaceChecker = series._internal_customSeriesWhitespaceCheck();\n        const plotRow = createPlotRow(time, pointDataAtTime._internal_index, data, extendedData._internal_originalTime, dataToPlotRow, customWhitespaceChecker);\n        pointDataAtTime._internal_mapping.set(series, plotRow);\n        this._private__updateLastSeriesRow(series, plotRow);\n        const info = {\n            _internal_lastBarUpdatedOrNewBarsAddedToTheRight: isSeriesPlotRow(plotRow)\n        };\n        // if point already exist on the time scale - we don't need to make a full update and just make an incremental one\n        if (!affectsTimeScale) {\n            return this._private__getUpdateResponse(series, -1, info);\n        }\n        const newPoint = {\n            timeWeight: 0,\n            time: pointDataAtTime._internal_timePoint,\n            pointData: pointDataAtTime,\n            originalTime: timeScalePointTime(pointDataAtTime._internal_mapping)\n        };\n        const insertIndex = lowerBound(this._private__sortedTimePoints, this._private__horzScaleBehavior.key(newPoint.time), (a, b)=>this._private__horzScaleBehavior.key(a.time) < b);\n        // yes, I know that this array is readonly and this change is intended to make it performative\n        // we marked _sortedTimePoints array as readonly to avoid modifying this array anywhere else\n        // but this place is exceptional case due performance reasons, sorry\n        this._private__sortedTimePoints.splice(insertIndex, 0, newPoint);\n        for(let index = insertIndex; index < this._private__sortedTimePoints.length; ++index){\n            assignIndexToPointData(this._private__sortedTimePoints[index].pointData, index);\n        }\n        this._private__horzScaleBehavior.fillWeightsForPoints(this._private__sortedTimePoints, insertIndex);\n        return this._private__getUpdateResponse(series, insertIndex, info);\n    }\n    _private__updateLastSeriesRow(series, plotRow) {\n        let seriesData = this._private__seriesRowsBySeries.get(series);\n        if (seriesData === undefined) {\n            seriesData = [];\n            this._private__seriesRowsBySeries.set(series, seriesData);\n        }\n        const lastSeriesRow = seriesData.length !== 0 ? seriesData[seriesData.length - 1] : null;\n        if (lastSeriesRow === null || this._private__horzScaleBehavior.key(plotRow._internal_time) > this._private__horzScaleBehavior.key(lastSeriesRow._internal_time)) {\n            if (isSeriesPlotRow(plotRow)) {\n                seriesData.push(plotRow);\n            }\n        } else {\n            if (isSeriesPlotRow(plotRow)) {\n                seriesData[seriesData.length - 1] = plotRow;\n            } else {\n                seriesData.splice(-1, 1);\n            }\n        }\n        this._private__seriesLastTimePoint.set(series, plotRow._internal_time);\n    }\n    _private__setRowsToSeries(series, seriesRows) {\n        if (seriesRows.length !== 0) {\n            this._private__seriesRowsBySeries.set(series, seriesRows.filter(isSeriesPlotRow));\n            this._private__seriesLastTimePoint.set(series, seriesRows[seriesRows.length - 1]._internal_time);\n        } else {\n            this._private__seriesRowsBySeries.delete(series);\n            this._private__seriesLastTimePoint.delete(series);\n        }\n    }\n    _private__cleanupPointsData() {\n        // let's treat all current points as \"potentially removed\"\n        // we could create an array with actually potentially removed points\n        // but most likely this array will be similar to _sortedTimePoints so let's avoid using additional memory\n        // note that we can use _sortedTimePoints here since a point might be removed only it was here previously\n        for (const point of this._private__sortedTimePoints){\n            if (point.pointData._internal_mapping.size === 0) {\n                this._private__pointDataByTimePoint.delete(this._private__horzScaleBehavior.key(point.time));\n            }\n        }\n    }\n    /**\n     * Sets new time scale and make indexes valid for all series\n     *\n     * @returns The index of the first changed point or `-1` if there is no change.\n     */ _private__replaceTimeScalePoints(newTimePoints) {\n        let firstChangedPointIndex = -1;\n        // search the first different point and \"syncing\" time weight by the way\n        for(let index = 0; index < this._private__sortedTimePoints.length && index < newTimePoints.length; ++index){\n            const oldPoint = this._private__sortedTimePoints[index];\n            const newPoint = newTimePoints[index];\n            if (this._private__horzScaleBehavior.key(oldPoint.time) !== this._private__horzScaleBehavior.key(newPoint.time)) {\n                firstChangedPointIndex = index;\n                break;\n            }\n            // re-assign point's time weight for points if time is the same (and all prior times was the same)\n            newPoint.timeWeight = oldPoint.timeWeight;\n            assignIndexToPointData(newPoint.pointData, index);\n        }\n        if (firstChangedPointIndex === -1 && this._private__sortedTimePoints.length !== newTimePoints.length) {\n            // the common part of the prev and the new points are the same\n            // so the first changed point is the next after the common part\n            firstChangedPointIndex = Math.min(this._private__sortedTimePoints.length, newTimePoints.length);\n        }\n        if (firstChangedPointIndex === -1) {\n            // if no time scale changed, then do nothing\n            return -1;\n        }\n        // if time scale points are changed that means that we need to make full update to all series (with clearing points)\n        // but first we need to synchronize indexes and re-fill time weights\n        for(let index = firstChangedPointIndex; index < newTimePoints.length; ++index){\n            assignIndexToPointData(newTimePoints[index].pointData, index);\n        }\n        // re-fill time weights for point after the first changed one\n        this._private__horzScaleBehavior.fillWeightsForPoints(newTimePoints, firstChangedPointIndex);\n        this._private__sortedTimePoints = newTimePoints;\n        return firstChangedPointIndex;\n    }\n    _private__getBaseIndex() {\n        if (this._private__seriesRowsBySeries.size === 0) {\n            // if we have no data then 'reset' the base index to null\n            return null;\n        }\n        let baseIndex = 0;\n        this._private__seriesRowsBySeries.forEach((data)=>{\n            if (data.length !== 0) {\n                baseIndex = Math.max(baseIndex, data[data.length - 1]._internal_index);\n            }\n        });\n        return baseIndex;\n    }\n    _private__getUpdateResponse(updatedSeries, firstChangedPointIndex, info) {\n        const dataUpdateResponse = {\n            _internal_series: new Map(),\n            _internal_timeScale: {\n                _internal_baseIndex: this._private__getBaseIndex()\n            }\n        };\n        if (firstChangedPointIndex !== -1) {\n            // TODO: it's possible to make perf improvements by checking what series has data after firstChangedPointIndex\n            // but let's skip for now\n            this._private__seriesRowsBySeries.forEach((data, s)=>{\n                dataUpdateResponse._internal_series.set(s, {\n                    _internal_data: data,\n                    _internal_info: s === updatedSeries ? info : undefined\n                });\n            });\n            // if the series data was set to [] it will have already been removed from _seriesRowBySeries\n            // meaning the forEach above won't add the series to the data update response\n            // so we handle that case here\n            if (!this._private__seriesRowsBySeries.has(updatedSeries)) {\n                dataUpdateResponse._internal_series.set(updatedSeries, {\n                    _internal_data: [],\n                    _internal_info: info\n                });\n            }\n            dataUpdateResponse._internal_timeScale._internal_points = this._private__sortedTimePoints;\n            dataUpdateResponse._internal_timeScale._internal_firstChangedPointIndex = firstChangedPointIndex;\n        } else {\n            const seriesData = this._private__seriesRowsBySeries.get(updatedSeries);\n            // if no seriesData found that means that we just removed the series\n            dataUpdateResponse._internal_series.set(updatedSeries, {\n                _internal_data: seriesData || [],\n                _internal_info: info\n            });\n        }\n        return dataUpdateResponse;\n    }\n    constructor(horzScaleBehavior){\n        // note that _pointDataByTimePoint and _seriesRowsBySeries shares THE SAME objects in their values between each other\n        // it's just different kind of maps to make usages/perf better\n        this._private__pointDataByTimePoint = new Map();\n        this._private__seriesRowsBySeries = new Map();\n        this._private__seriesLastTimePoint = new Map();\n        // this is kind of \"dest\" values (in opposite to \"source\" ones) - we don't need to modify it manually, the only by calling _updateTimeScalePoints or updateSeriesData methods\n        this._private__sortedTimePoints = [];\n        this._private__horzScaleBehavior = horzScaleBehavior;\n    }\n}\nfunction assignIndexToPointData(pointData, index) {\n    // first, nevertheless update index of point data (\"make it valid\")\n    pointData._internal_index = index;\n    // and then we need to sync indexes for all series\n    pointData._internal_mapping.forEach((seriesRow)=>{\n        seriesRow._internal_index = index;\n    });\n}\nfunction singleValueData(plotRow) {\n    const data = {\n        value: plotRow._internal_value[3 /* PlotRowValueIndex.Close */ ],\n        time: plotRow._internal_originalTime\n    };\n    if (plotRow._internal_customValues !== undefined) {\n        data.customValues = plotRow._internal_customValues;\n    }\n    return data;\n}\nfunction lineData(plotRow) {\n    const result = singleValueData(plotRow);\n    if (plotRow._internal_color !== undefined) {\n        result.color = plotRow._internal_color;\n    }\n    return result;\n}\nfunction areaData(plotRow) {\n    const result = singleValueData(plotRow);\n    if (plotRow._internal_lineColor !== undefined) {\n        result.lineColor = plotRow._internal_lineColor;\n    }\n    if (plotRow._internal_topColor !== undefined) {\n        result.topColor = plotRow._internal_topColor;\n    }\n    if (plotRow._internal_bottomColor !== undefined) {\n        result.bottomColor = plotRow._internal_bottomColor;\n    }\n    return result;\n}\nfunction baselineData(plotRow) {\n    const result = singleValueData(plotRow);\n    if (plotRow._internal_topLineColor !== undefined) {\n        result.topLineColor = plotRow._internal_topLineColor;\n    }\n    if (plotRow._internal_bottomLineColor !== undefined) {\n        result.bottomLineColor = plotRow._internal_bottomLineColor;\n    }\n    if (plotRow._internal_topFillColor1 !== undefined) {\n        result.topFillColor1 = plotRow._internal_topFillColor1;\n    }\n    if (plotRow._internal_topFillColor2 !== undefined) {\n        result.topFillColor2 = plotRow._internal_topFillColor2;\n    }\n    if (plotRow._internal_bottomFillColor1 !== undefined) {\n        result.bottomFillColor1 = plotRow._internal_bottomFillColor1;\n    }\n    if (plotRow._internal_bottomFillColor2 !== undefined) {\n        result.bottomFillColor2 = plotRow._internal_bottomFillColor2;\n    }\n    return result;\n}\nfunction ohlcData(plotRow) {\n    const data = {\n        open: plotRow._internal_value[0 /* PlotRowValueIndex.Open */ ],\n        high: plotRow._internal_value[1 /* PlotRowValueIndex.High */ ],\n        low: plotRow._internal_value[2 /* PlotRowValueIndex.Low */ ],\n        close: plotRow._internal_value[3 /* PlotRowValueIndex.Close */ ],\n        time: plotRow._internal_originalTime\n    };\n    if (plotRow._internal_customValues !== undefined) {\n        data.customValues = plotRow._internal_customValues;\n    }\n    return data;\n}\nfunction barData(plotRow) {\n    const result = ohlcData(plotRow);\n    if (plotRow._internal_color !== undefined) {\n        result.color = plotRow._internal_color;\n    }\n    return result;\n}\nfunction candlestickData(plotRow) {\n    const result = ohlcData(plotRow);\n    const { _internal_color: color, _internal_borderColor: borderColor, _internal_wickColor: wickColor } = plotRow;\n    if (color !== undefined) {\n        result.color = color;\n    }\n    if (borderColor !== undefined) {\n        result.borderColor = borderColor;\n    }\n    if (wickColor !== undefined) {\n        result.wickColor = wickColor;\n    }\n    return result;\n}\nfunction getSeriesDataCreator(seriesType) {\n    const seriesPlotRowToDataMap = {\n        Area: areaData,\n        Line: lineData,\n        Baseline: baselineData,\n        Histogram: lineData,\n        Bar: barData,\n        Candlestick: candlestickData,\n        Custom: customData\n    };\n    return seriesPlotRowToDataMap[seriesType];\n}\nfunction customData(plotRow) {\n    const time = plotRow._internal_originalTime;\n    return Object.assign(Object.assign({}, plotRow._internal_data), {\n        time\n    });\n}\nconst crosshairOptionsDefaults = {\n    vertLine: {\n        color: \"#9598A1\",\n        width: 1,\n        style: 3 /* LineStyle.LargeDashed */ ,\n        visible: true,\n        labelVisible: true,\n        labelBackgroundColor: \"#131722\"\n    },\n    horzLine: {\n        color: \"#9598A1\",\n        width: 1,\n        style: 3 /* LineStyle.LargeDashed */ ,\n        visible: true,\n        labelVisible: true,\n        labelBackgroundColor: \"#131722\"\n    },\n    mode: 1 /* CrosshairMode.Magnet */ \n};\nconst gridOptionsDefaults = {\n    vertLines: {\n        color: \"#D6DCDE\",\n        style: 0 /* LineStyle.Solid */ ,\n        visible: true\n    },\n    horzLines: {\n        color: \"#D6DCDE\",\n        style: 0 /* LineStyle.Solid */ ,\n        visible: true\n    }\n};\nconst layoutOptionsDefaults = {\n    background: {\n        type: \"solid\" /* ColorType.Solid */ ,\n        color: \"#FFFFFF\"\n    },\n    textColor: \"#191919\",\n    fontSize: 12,\n    fontFamily: defaultFontFamily\n};\nconst priceScaleOptionsDefaults = {\n    autoScale: true,\n    mode: 0 /* PriceScaleMode.Normal */ ,\n    invertScale: false,\n    alignLabels: true,\n    borderVisible: true,\n    borderColor: \"#2B2B43\",\n    entireTextOnly: false,\n    visible: false,\n    ticksVisible: false,\n    scaleMargins: {\n        bottom: 0.1,\n        top: 0.2\n    },\n    minimumWidth: 0\n};\nconst timeScaleOptionsDefaults = {\n    rightOffset: 0,\n    barSpacing: 6,\n    minBarSpacing: 0.5,\n    fixLeftEdge: false,\n    fixRightEdge: false,\n    lockVisibleTimeRangeOnResize: false,\n    rightBarStaysOnScroll: false,\n    borderVisible: true,\n    borderColor: \"#2B2B43\",\n    visible: true,\n    timeVisible: false,\n    secondsVisible: true,\n    shiftVisibleRangeOnNewBar: true,\n    allowShiftVisibleRangeOnWhitespaceReplacement: false,\n    ticksVisible: false,\n    uniformDistribution: false,\n    minimumHeight: 0\n};\nconst watermarkOptionsDefaults = {\n    color: \"rgba(0, 0, 0, 0)\",\n    visible: false,\n    fontSize: 48,\n    fontFamily: defaultFontFamily,\n    fontStyle: \"\",\n    text: \"\",\n    horzAlign: \"center\",\n    vertAlign: \"center\"\n};\nfunction chartOptionsDefaults() {\n    return {\n        width: 0,\n        height: 0,\n        autoSize: false,\n        layout: layoutOptionsDefaults,\n        crosshair: crosshairOptionsDefaults,\n        grid: gridOptionsDefaults,\n        overlayPriceScales: Object.assign({}, priceScaleOptionsDefaults),\n        leftPriceScale: Object.assign(Object.assign({}, priceScaleOptionsDefaults), {\n            visible: false\n        }),\n        rightPriceScale: Object.assign(Object.assign({}, priceScaleOptionsDefaults), {\n            visible: true\n        }),\n        timeScale: timeScaleOptionsDefaults,\n        watermark: watermarkOptionsDefaults,\n        localization: {\n            locale: isRunningOnClientSide ? navigator.language : \"\",\n            dateFormat: \"dd MMM 'yy\"\n        },\n        handleScroll: {\n            mouseWheel: true,\n            pressedMouseMove: true,\n            horzTouchDrag: true,\n            vertTouchDrag: true\n        },\n        handleScale: {\n            axisPressedMouseMove: {\n                time: true,\n                price: true\n            },\n            axisDoubleClickReset: {\n                time: true,\n                price: true\n            },\n            mouseWheel: true,\n            pinch: true\n        },\n        kineticScroll: {\n            mouse: false,\n            touch: true\n        },\n        trackingMode: {\n            exitMode: 1 /* TrackingModeExitMode.OnNextTap */ \n        }\n    };\n}\nclass PriceScaleApi {\n    applyOptions(options) {\n        this._private__chartWidget._internal_model()._internal_applyPriceScaleOptions(this._private__priceScaleId, options);\n    }\n    options() {\n        return this._private__priceScale()._internal_options();\n    }\n    width() {\n        if (!isDefaultPriceScale(this._private__priceScaleId)) {\n            return 0;\n        }\n        return this._private__chartWidget._internal_getPriceAxisWidth(this._private__priceScaleId);\n    }\n    _private__priceScale() {\n        return ensureNotNull(this._private__chartWidget._internal_model()._internal_findPriceScale(this._private__priceScaleId))._internal_priceScale;\n    }\n    constructor(chartWidget, priceScaleId){\n        this._private__chartWidget = chartWidget;\n        this._private__priceScaleId = priceScaleId;\n    }\n}\n/// <reference types=\"_build-time-constants\" />\nfunction checkPriceLineOptions(options) {\n    // eslint-disable-next-line @typescript-eslint/tslint/config\n    assert(typeof options.price === \"number\", \"the type of 'price' price line's property must be a number, got '\".concat(typeof options.price, \"'\"));\n}\nfunction checkItemsAreOrdered(data, bh) {\n    let allowDuplicates = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    if (data.length === 0) {\n        return;\n    }\n    let prevTime = bh.key(data[0].time);\n    for(let i = 1; i < data.length; ++i){\n        const currentTime = bh.key(data[i].time);\n        const checkResult = allowDuplicates ? prevTime <= currentTime : prevTime < currentTime;\n        assert(checkResult, \"data must be asc ordered by time, index=\".concat(i, \", time=\").concat(currentTime, \", prev time=\").concat(prevTime));\n        prevTime = currentTime;\n    }\n}\nfunction checkSeriesValuesType(type, data) {\n    data.forEach(getChecker(type));\n}\nfunction getChecker(type) {\n    switch(type){\n        case \"Bar\":\n        case \"Candlestick\":\n            return checkBarItem.bind(null, type);\n        case \"Area\":\n        case \"Baseline\":\n        case \"Line\":\n        case \"Histogram\":\n            return checkLineItem.bind(null, type);\n        case \"Custom\":\n            return checkCustomItem.bind(null, type);\n    }\n}\nfunction checkBarItem(type, barItem) {\n    if (!isFulfilledData(barItem)) {\n        return;\n    }\n    assert(// eslint-disable-next-line @typescript-eslint/tslint/config\n    typeof barItem.open === \"number\", \"\".concat(type, \" series item data value of open must be a number, got=\").concat(typeof barItem.open, \", value=\").concat(barItem.open));\n    assert(// eslint-disable-next-line @typescript-eslint/tslint/config\n    typeof barItem.high === \"number\", \"\".concat(type, \" series item data value of high must be a number, got=\").concat(typeof barItem.high, \", value=\").concat(barItem.high));\n    assert(// eslint-disable-next-line @typescript-eslint/tslint/config\n    typeof barItem.low === \"number\", \"\".concat(type, \" series item data value of low must be a number, got=\").concat(typeof barItem.low, \", value=\").concat(barItem.low));\n    assert(// eslint-disable-next-line @typescript-eslint/tslint/config\n    typeof barItem.close === \"number\", \"\".concat(type, \" series item data value of close must be a number, got=\").concat(typeof barItem.close, \", value=\").concat(barItem.close));\n}\nfunction checkLineItem(type, lineItem) {\n    if (!isFulfilledData(lineItem)) {\n        return;\n    }\n    assert(// eslint-disable-next-line @typescript-eslint/tslint/config\n    typeof lineItem.value === \"number\", \"\".concat(type, \" series item data value must be a number, got=\").concat(typeof lineItem.value, \", value=\").concat(lineItem.value));\n}\nfunction checkCustomItem() {\n    // Nothing to check yet...\n    return;\n}\nfunction convertSeriesMarker(sm, newTime, originalTime) {\n    const values = __rest(sm, [\n        \"time\",\n        \"originalTime\"\n    ]);\n    /* eslint-disable @typescript-eslint/consistent-type-assertions */ const res = Object.assign({\n        time: newTime\n    }, values);\n    /* eslint-enable @typescript-eslint/consistent-type-assertions */ if (originalTime !== undefined) {\n        res.originalTime = originalTime;\n    }\n    return res;\n}\nconst priceLineOptionsDefaults = {\n    color: \"#FF0000\",\n    price: 0,\n    lineStyle: 2 /* LineStyle.Dashed */ ,\n    lineWidth: 1,\n    lineVisible: true,\n    axisLabelVisible: true,\n    title: \"\",\n    axisLabelColor: \"\",\n    axisLabelTextColor: \"\"\n};\nclass PriceLine {\n    applyOptions(options) {\n        this._private__priceLine._internal_applyOptions(options);\n    }\n    options() {\n        return this._private__priceLine._internal_options();\n    }\n    _internal_priceLine() {\n        return this._private__priceLine;\n    }\n    constructor(priceLine){\n        this._private__priceLine = priceLine;\n    }\n}\nclass SeriesApi {\n    _internal_destroy() {\n        this._private__dataChangedDelegate._internal_destroy();\n    }\n    priceFormatter() {\n        return this._internal__series._internal_formatter();\n    }\n    priceToCoordinate(price) {\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return null;\n        }\n        return this._internal__series._internal_priceScale()._internal_priceToCoordinate(price, firstValue._internal_value);\n    }\n    coordinateToPrice(coordinate) {\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return null;\n        }\n        return this._internal__series._internal_priceScale()._internal_coordinateToPrice(coordinate, firstValue._internal_value);\n    }\n    barsInLogicalRange(range) {\n        if (range === null) {\n            return null;\n        }\n        // we use TimeScaleVisibleRange here to convert LogicalRange to strict range properly\n        const correctedRange = new TimeScaleVisibleRange(new RangeImpl(range.from, range.to))._internal_strictRange();\n        const bars = this._internal__series._internal_bars();\n        if (bars._internal_isEmpty()) {\n            return null;\n        }\n        const dataFirstBarInRange = bars._internal_search(correctedRange._internal_left(), 1 /* MismatchDirection.NearestRight */ );\n        const dataLastBarInRange = bars._internal_search(correctedRange._internal_right(), -1 /* MismatchDirection.NearestLeft */ );\n        const dataFirstIndex = ensureNotNull(bars._internal_firstIndex());\n        const dataLastIndex = ensureNotNull(bars._internal_lastIndex());\n        // this means that we request data in the data gap\n        // e.g. let's say we have series with data [0..10, 30..60]\n        // and we request bars info in range [15, 25]\n        // thus, dataFirstBarInRange will be with index 30 and dataLastBarInRange with 10\n        if (dataFirstBarInRange !== null && dataLastBarInRange !== null && dataFirstBarInRange._internal_index > dataLastBarInRange._internal_index) {\n            return {\n                barsBefore: range.from - dataFirstIndex,\n                barsAfter: dataLastIndex - range.to\n            };\n        }\n        const barsBefore = dataFirstBarInRange === null || dataFirstBarInRange._internal_index === dataFirstIndex ? range.from - dataFirstIndex : dataFirstBarInRange._internal_index - dataFirstIndex;\n        const barsAfter = dataLastBarInRange === null || dataLastBarInRange._internal_index === dataLastIndex ? dataLastIndex - range.to : dataLastIndex - dataLastBarInRange._internal_index;\n        const result = {\n            barsBefore,\n            barsAfter\n        };\n        // actually they can't exist separately\n        if (dataFirstBarInRange !== null && dataLastBarInRange !== null) {\n            result.from = dataFirstBarInRange._internal_originalTime;\n            result.to = dataLastBarInRange._internal_originalTime;\n        }\n        return result;\n    }\n    setData(data) {\n        checkItemsAreOrdered(data, this._private__horzScaleBehavior);\n        checkSeriesValuesType(this._internal__series._internal_seriesType(), data);\n        this._internal__dataUpdatesConsumer._internal_applyNewData(this._internal__series, data);\n        this._private__onDataChanged(\"full\");\n    }\n    update(bar) {\n        checkSeriesValuesType(this._internal__series._internal_seriesType(), [\n            bar\n        ]);\n        this._internal__dataUpdatesConsumer._internal_updateData(this._internal__series, bar);\n        this._private__onDataChanged(\"update\");\n    }\n    dataByIndex(logicalIndex, mismatchDirection) {\n        const data = this._internal__series._internal_bars()._internal_search(logicalIndex, mismatchDirection);\n        if (data === null) {\n            // actually it can be a whitespace\n            return null;\n        }\n        const creator = getSeriesDataCreator(this.seriesType());\n        return creator(data);\n    }\n    data() {\n        const seriesCreator = getSeriesDataCreator(this.seriesType());\n        const rows = this._internal__series._internal_bars()._internal_rows();\n        return rows.map((row)=>seriesCreator(row));\n    }\n    subscribeDataChanged(handler) {\n        this._private__dataChangedDelegate._internal_subscribe(handler);\n    }\n    unsubscribeDataChanged(handler) {\n        this._private__dataChangedDelegate._internal_unsubscribe(handler);\n    }\n    setMarkers(data) {\n        checkItemsAreOrdered(data, this._private__horzScaleBehavior, true);\n        const convertedMarkers = data.map((marker)=>convertSeriesMarker(marker, this._private__horzScaleBehavior.convertHorzItemToInternal(marker.time), marker.time));\n        this._internal__series._internal_setMarkers(convertedMarkers);\n    }\n    markers() {\n        return this._internal__series._internal_markers().map((internalItem)=>{\n            return convertSeriesMarker(internalItem, internalItem.originalTime, undefined);\n        });\n    }\n    applyOptions(options) {\n        this._internal__series._internal_applyOptions(options);\n    }\n    options() {\n        return clone(this._internal__series._internal_options());\n    }\n    priceScale() {\n        return this._private__priceScaleApiProvider.priceScale(this._internal__series._internal_priceScale()._internal_id());\n    }\n    createPriceLine(options) {\n        checkPriceLineOptions(options);\n        const strictOptions = merge(clone(priceLineOptionsDefaults), options);\n        const priceLine = this._internal__series._internal_createPriceLine(strictOptions);\n        return new PriceLine(priceLine);\n    }\n    removePriceLine(line) {\n        this._internal__series._internal_removePriceLine(line._internal_priceLine());\n    }\n    seriesType() {\n        return this._internal__series._internal_seriesType();\n    }\n    attachPrimitive(primitive) {\n        // at this point we cast the generic to unknown because we\n        // don't want the model to know the types of the API (â_â)\n        this._internal__series._internal_attachPrimitive(primitive);\n        if (primitive.attached) {\n            primitive.attached({\n                chart: this._internal__chartApi,\n                series: this,\n                requestUpdate: ()=>this._internal__series._internal_model()._internal_fullUpdate()\n            });\n        }\n    }\n    detachPrimitive(primitive) {\n        this._internal__series._internal_detachPrimitive(primitive);\n        if (primitive.detached) {\n            primitive.detached();\n        }\n    }\n    _private__onDataChanged(scope) {\n        if (this._private__dataChangedDelegate._internal_hasListeners()) {\n            this._private__dataChangedDelegate._internal_fire(scope);\n        }\n    }\n    constructor(series, dataUpdatesConsumer, priceScaleApiProvider, chartApi, horzScaleBehavior){\n        this._private__dataChangedDelegate = new Delegate();\n        this._internal__series = series;\n        this._internal__dataUpdatesConsumer = dataUpdatesConsumer;\n        this._private__priceScaleApiProvider = priceScaleApiProvider;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._internal__chartApi = chartApi;\n    }\n}\nclass TimeScaleApi {\n    _internal_destroy() {\n        this._private__timeScale._internal_visibleBarsChanged()._internal_unsubscribeAll(this);\n        this._private__timeScale._internal_logicalRangeChanged()._internal_unsubscribeAll(this);\n        this._private__timeAxisWidget._internal_sizeChanged()._internal_unsubscribeAll(this);\n        this._private__timeRangeChanged._internal_destroy();\n        this._private__logicalRangeChanged._internal_destroy();\n        this._private__sizeChanged._internal_destroy();\n    }\n    scrollPosition() {\n        return this._private__timeScale._internal_rightOffset();\n    }\n    scrollToPosition(position, animated) {\n        if (!animated) {\n            this._private__model._internal_setRightOffset(position);\n            return;\n        }\n        this._private__timeScale._internal_scrollToOffsetAnimated(position, 1000 /* Constants.AnimationDurationMs */ );\n    }\n    scrollToRealTime() {\n        this._private__timeScale._internal_scrollToRealTime();\n    }\n    getVisibleRange() {\n        const timeRange = this._private__timeScale._internal_visibleTimeRange();\n        if (timeRange === null) {\n            return null;\n        }\n        return {\n            from: timeRange.from.originalTime,\n            to: timeRange.to.originalTime\n        };\n    }\n    setVisibleRange(range) {\n        const convertedRange = {\n            from: this._private__horzScaleBehavior.convertHorzItemToInternal(range.from),\n            to: this._private__horzScaleBehavior.convertHorzItemToInternal(range.to)\n        };\n        const logicalRange = this._private__timeScale._internal_logicalRangeForTimeRange(convertedRange);\n        this._private__model._internal_setTargetLogicalRange(logicalRange);\n    }\n    getVisibleLogicalRange() {\n        const logicalRange = this._private__timeScale._internal_visibleLogicalRange();\n        if (logicalRange === null) {\n            return null;\n        }\n        return {\n            from: logicalRange._internal_left(),\n            to: logicalRange._internal_right()\n        };\n    }\n    setVisibleLogicalRange(range) {\n        assert(range.from <= range.to, \"The from index cannot be after the to index.\");\n        this._private__model._internal_setTargetLogicalRange(range);\n    }\n    resetTimeScale() {\n        this._private__model._internal_resetTimeScale();\n    }\n    fitContent() {\n        this._private__model._internal_fitContent();\n    }\n    logicalToCoordinate(logical) {\n        const timeScale = this._private__model._internal_timeScale();\n        if (timeScale._internal_isEmpty()) {\n            return null;\n        } else {\n            return timeScale._internal_indexToCoordinate(logical);\n        }\n    }\n    coordinateToLogical(x) {\n        if (this._private__timeScale._internal_isEmpty()) {\n            return null;\n        } else {\n            return this._private__timeScale._internal_coordinateToIndex(x);\n        }\n    }\n    timeToCoordinate(time) {\n        const timePoint = this._private__horzScaleBehavior.convertHorzItemToInternal(time);\n        const timePointIndex = this._private__timeScale._internal_timeToIndex(timePoint, false);\n        if (timePointIndex === null) {\n            return null;\n        }\n        return this._private__timeScale._internal_indexToCoordinate(timePointIndex);\n    }\n    coordinateToTime(x) {\n        const timeScale = this._private__model._internal_timeScale();\n        const timePointIndex = timeScale._internal_coordinateToIndex(x);\n        const timePoint = timeScale._internal_indexToTimeScalePoint(timePointIndex);\n        if (timePoint === null) {\n            return null;\n        }\n        return timePoint.originalTime;\n    }\n    width() {\n        return this._private__timeAxisWidget._internal_getSize().width;\n    }\n    height() {\n        return this._private__timeAxisWidget._internal_getSize().height;\n    }\n    subscribeVisibleTimeRangeChange(handler) {\n        this._private__timeRangeChanged._internal_subscribe(handler);\n    }\n    unsubscribeVisibleTimeRangeChange(handler) {\n        this._private__timeRangeChanged._internal_unsubscribe(handler);\n    }\n    subscribeVisibleLogicalRangeChange(handler) {\n        this._private__logicalRangeChanged._internal_subscribe(handler);\n    }\n    unsubscribeVisibleLogicalRangeChange(handler) {\n        this._private__logicalRangeChanged._internal_unsubscribe(handler);\n    }\n    subscribeSizeChange(handler) {\n        this._private__sizeChanged._internal_subscribe(handler);\n    }\n    unsubscribeSizeChange(handler) {\n        this._private__sizeChanged._internal_unsubscribe(handler);\n    }\n    applyOptions(options) {\n        this._private__timeScale._internal_applyOptions(options);\n    }\n    options() {\n        return Object.assign(Object.assign({}, clone(this._private__timeScale._internal_options())), {\n            barSpacing: this._private__timeScale._internal_barSpacing()\n        });\n    }\n    _private__onVisibleBarsChanged() {\n        if (this._private__timeRangeChanged._internal_hasListeners()) {\n            this._private__timeRangeChanged._internal_fire(this.getVisibleRange());\n        }\n    }\n    _private__onVisibleLogicalRangeChanged() {\n        if (this._private__logicalRangeChanged._internal_hasListeners()) {\n            this._private__logicalRangeChanged._internal_fire(this.getVisibleLogicalRange());\n        }\n    }\n    _private__onSizeChanged(size) {\n        this._private__sizeChanged._internal_fire(size.width, size.height);\n    }\n    constructor(model, timeAxisWidget, horzScaleBehavior){\n        this._private__timeRangeChanged = new Delegate();\n        this._private__logicalRangeChanged = new Delegate();\n        this._private__sizeChanged = new Delegate();\n        this._private__model = model;\n        this._private__timeScale = model._internal_timeScale();\n        this._private__timeAxisWidget = timeAxisWidget;\n        this._private__timeScale._internal_visibleBarsChanged()._internal_subscribe(this._private__onVisibleBarsChanged.bind(this));\n        this._private__timeScale._internal_logicalRangeChanged()._internal_subscribe(this._private__onVisibleLogicalRangeChanged.bind(this));\n        this._private__timeAxisWidget._internal_sizeChanged()._internal_subscribe(this._private__onSizeChanged.bind(this));\n        this._private__horzScaleBehavior = horzScaleBehavior;\n    }\n}\nfunction patchPriceFormat(priceFormat) {\n    if (priceFormat === undefined || priceFormat.type === \"custom\") {\n        return;\n    }\n    const priceFormatBuiltIn = priceFormat;\n    if (priceFormatBuiltIn.minMove !== undefined && priceFormatBuiltIn.precision === undefined) {\n        priceFormatBuiltIn.precision = precisionByMinMove(priceFormatBuiltIn.minMove);\n    }\n}\nfunction migrateHandleScaleScrollOptions(options) {\n    if (isBoolean(options.handleScale)) {\n        const handleScale = options.handleScale;\n        options.handleScale = {\n            axisDoubleClickReset: {\n                time: handleScale,\n                price: handleScale\n            },\n            axisPressedMouseMove: {\n                time: handleScale,\n                price: handleScale\n            },\n            mouseWheel: handleScale,\n            pinch: handleScale\n        };\n    } else if (options.handleScale !== undefined) {\n        const { axisPressedMouseMove, axisDoubleClickReset } = options.handleScale;\n        if (isBoolean(axisPressedMouseMove)) {\n            options.handleScale.axisPressedMouseMove = {\n                time: axisPressedMouseMove,\n                price: axisPressedMouseMove\n            };\n        }\n        if (isBoolean(axisDoubleClickReset)) {\n            options.handleScale.axisDoubleClickReset = {\n                time: axisDoubleClickReset,\n                price: axisDoubleClickReset\n            };\n        }\n    }\n    const handleScroll = options.handleScroll;\n    if (isBoolean(handleScroll)) {\n        options.handleScroll = {\n            horzTouchDrag: handleScroll,\n            vertTouchDrag: handleScroll,\n            mouseWheel: handleScroll,\n            pressedMouseMove: handleScroll\n        };\n    }\n}\nfunction toInternalOptions(options) {\n    migrateHandleScaleScrollOptions(options);\n    return options;\n}\nclass ChartApi {\n    remove() {\n        this._private__chartWidget._internal_clicked()._internal_unsubscribeAll(this);\n        this._private__chartWidget._internal_dblClicked()._internal_unsubscribeAll(this);\n        this._private__chartWidget._internal_crosshairMoved()._internal_unsubscribeAll(this);\n        this._private__timeScaleApi._internal_destroy();\n        this._private__chartWidget._internal_destroy();\n        this._private__seriesMap.clear();\n        this._private__seriesMapReversed.clear();\n        this._private__clickedDelegate._internal_destroy();\n        this._private__dblClickedDelegate._internal_destroy();\n        this._private__crosshairMovedDelegate._internal_destroy();\n        this._private__dataLayer._internal_destroy();\n    }\n    resize(width, height, forceRepaint) {\n        if (this.autoSizeActive()) {\n            // We return early here instead of checking this within the actual _chartWidget.resize method\n            // because this should only apply to external resize requests.\n            warn(\"Height and width values ignored because 'autoSize' option is enabled.\");\n            return;\n        }\n        this._private__chartWidget._internal_resize(width, height, forceRepaint);\n    }\n    addCustomSeries(customPaneView, options) {\n        const paneView = ensure(customPaneView);\n        const defaults = Object.assign(Object.assign({}, customStyleDefaults), paneView.defaultOptions());\n        return this._private__addSeriesImpl(\"Custom\", defaults, options, paneView);\n    }\n    addAreaSeries(options) {\n        return this._private__addSeriesImpl(\"Area\", areaStyleDefaults, options);\n    }\n    addBaselineSeries(options) {\n        return this._private__addSeriesImpl(\"Baseline\", baselineStyleDefaults, options);\n    }\n    addBarSeries(options) {\n        return this._private__addSeriesImpl(\"Bar\", barStyleDefaults, options);\n    }\n    addCandlestickSeries() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        fillUpDownCandlesticksColors(options);\n        return this._private__addSeriesImpl(\"Candlestick\", candlestickStyleDefaults, options);\n    }\n    addHistogramSeries(options) {\n        return this._private__addSeriesImpl(\"Histogram\", histogramStyleDefaults, options);\n    }\n    addLineSeries(options) {\n        return this._private__addSeriesImpl(\"Line\", lineStyleDefaults, options);\n    }\n    removeSeries(seriesApi) {\n        const series = ensureDefined(this._private__seriesMap.get(seriesApi));\n        const update = this._private__dataLayer._internal_removeSeries(series);\n        const model = this._private__chartWidget._internal_model();\n        model._internal_removeSeries(series);\n        this._private__sendUpdateToChart(update);\n        this._private__seriesMap.delete(seriesApi);\n        this._private__seriesMapReversed.delete(series);\n    }\n    _internal_applyNewData(series, data) {\n        this._private__sendUpdateToChart(this._private__dataLayer._internal_setSeriesData(series, data));\n    }\n    _internal_updateData(series, data) {\n        this._private__sendUpdateToChart(this._private__dataLayer._internal_updateSeriesData(series, data));\n    }\n    subscribeClick(handler) {\n        this._private__clickedDelegate._internal_subscribe(handler);\n    }\n    unsubscribeClick(handler) {\n        this._private__clickedDelegate._internal_unsubscribe(handler);\n    }\n    subscribeCrosshairMove(handler) {\n        this._private__crosshairMovedDelegate._internal_subscribe(handler);\n    }\n    unsubscribeCrosshairMove(handler) {\n        this._private__crosshairMovedDelegate._internal_unsubscribe(handler);\n    }\n    subscribeDblClick(handler) {\n        this._private__dblClickedDelegate._internal_subscribe(handler);\n    }\n    unsubscribeDblClick(handler) {\n        this._private__dblClickedDelegate._internal_unsubscribe(handler);\n    }\n    priceScale(priceScaleId) {\n        return new PriceScaleApi(this._private__chartWidget, priceScaleId);\n    }\n    timeScale() {\n        return this._private__timeScaleApi;\n    }\n    applyOptions(options) {\n        this._private__chartWidget._internal_applyOptions(toInternalOptions(options));\n    }\n    options() {\n        return this._private__chartWidget._internal_options();\n    }\n    takeScreenshot() {\n        return this._private__chartWidget._internal_takeScreenshot();\n    }\n    autoSizeActive() {\n        return this._private__chartWidget._internal_autoSizeActive();\n    }\n    chartElement() {\n        return this._private__chartWidget._internal_element();\n    }\n    paneSize() {\n        const size = this._private__chartWidget._internal_paneSize();\n        return {\n            height: size.height,\n            width: size.width\n        };\n    }\n    setCrosshairPosition(price, horizontalPosition, seriesApi) {\n        const series = this._private__seriesMap.get(seriesApi);\n        if (series === undefined) {\n            return;\n        }\n        const pane = this._private__chartWidget._internal_model()._internal_paneForSource(series);\n        if (pane === null) {\n            return;\n        }\n        this._private__chartWidget._internal_model()._internal_setAndSaveSyntheticPosition(price, horizontalPosition, pane);\n    }\n    clearCrosshairPosition() {\n        this._private__chartWidget._internal_model()._internal_clearCurrentPosition(true);\n    }\n    _private__addSeriesImpl(type, styleDefaults) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, customPaneView = arguments.length > 3 ? arguments[3] : void 0;\n        patchPriceFormat(options.priceFormat);\n        const strictOptions = merge(clone(seriesOptionsDefaults), clone(styleDefaults), options);\n        const series = this._private__chartWidget._internal_model()._internal_createSeries(type, strictOptions, customPaneView);\n        const res = new SeriesApi(series, this, this, this, this._private__horzScaleBehavior);\n        this._private__seriesMap.set(res, series);\n        this._private__seriesMapReversed.set(series, res);\n        return res;\n    }\n    _private__sendUpdateToChart(update) {\n        const model = this._private__chartWidget._internal_model();\n        model._internal_updateTimeScale(update._internal_timeScale._internal_baseIndex, update._internal_timeScale._internal_points, update._internal_timeScale._internal_firstChangedPointIndex);\n        update._internal_series.forEach((value, series)=>series._internal_setData(value._internal_data, value._internal_info));\n        model._internal_recalculateAllPanes();\n    }\n    _private__mapSeriesToApi(series) {\n        return ensureDefined(this._private__seriesMapReversed.get(series));\n    }\n    _private__convertMouseParams(param) {\n        const seriesData = new Map();\n        param._internal_seriesData.forEach((plotRow, series)=>{\n            const seriesType = series._internal_seriesType();\n            const data = getSeriesDataCreator(seriesType)(plotRow);\n            if (seriesType !== \"Custom\") {\n                assert(isFulfilledData(data));\n            } else {\n                const customWhitespaceChecker = series._internal_customSeriesWhitespaceCheck();\n                assert(!customWhitespaceChecker || customWhitespaceChecker(data) === false);\n            }\n            seriesData.set(this._private__mapSeriesToApi(series), data);\n        });\n        const hoveredSeries = param._internal_hoveredSeries === undefined ? undefined : this._private__mapSeriesToApi(param._internal_hoveredSeries);\n        return {\n            time: param._internal_originalTime,\n            logical: param._internal_index,\n            point: param._internal_point,\n            hoveredSeries,\n            hoveredObjectId: param._internal_hoveredObject,\n            seriesData,\n            sourceEvent: param._internal_touchMouseEventData\n        };\n    }\n    constructor(container, horzScaleBehavior, options){\n        this._private__seriesMap = new Map();\n        this._private__seriesMapReversed = new Map();\n        this._private__clickedDelegate = new Delegate();\n        this._private__dblClickedDelegate = new Delegate();\n        this._private__crosshairMovedDelegate = new Delegate();\n        this._private__dataLayer = new DataLayer(horzScaleBehavior);\n        const internalOptions = options === undefined ? clone(chartOptionsDefaults()) : merge(clone(chartOptionsDefaults()), toInternalOptions(options));\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__chartWidget = new ChartWidget(container, internalOptions, horzScaleBehavior);\n        this._private__chartWidget._internal_clicked()._internal_subscribe((paramSupplier)=>{\n            if (this._private__clickedDelegate._internal_hasListeners()) {\n                this._private__clickedDelegate._internal_fire(this._private__convertMouseParams(paramSupplier()));\n            }\n        }, this);\n        this._private__chartWidget._internal_dblClicked()._internal_subscribe((paramSupplier)=>{\n            if (this._private__dblClickedDelegate._internal_hasListeners()) {\n                this._private__dblClickedDelegate._internal_fire(this._private__convertMouseParams(paramSupplier()));\n            }\n        }, this);\n        this._private__chartWidget._internal_crosshairMoved()._internal_subscribe((paramSupplier)=>{\n            if (this._private__crosshairMovedDelegate._internal_hasListeners()) {\n                this._private__crosshairMovedDelegate._internal_fire(this._private__convertMouseParams(paramSupplier()));\n            }\n        }, this);\n        const model = this._private__chartWidget._internal_model();\n        this._private__timeScaleApi = new TimeScaleApi(model, this._private__chartWidget._internal_timeAxisWidget(), this._private__horzScaleBehavior);\n    }\n}\n/**\n * This function is the main entry point of the Lightweight Charting Library. If you are using time values\n * for the horizontal scale then it is recommended that you rather use the {@link createChart} function.\n *\n * @template HorzScaleItem - type of points on the horizontal scale\n * @template THorzScaleBehavior - type of horizontal axis strategy that encapsulate all the specific behaviors of the horizontal scale type\n *\n * @param container - ID of HTML element or element itself\n * @param horzScaleBehavior - Horizontal scale behavior\n * @param options - Any subset of options to be applied at start.\n * @returns An interface to the created chart\n */ function createChartEx(container, horzScaleBehavior, options) {\n    let htmlElement;\n    if (isString(container)) {\n        const element = document.getElementById(container);\n        assert(element !== null, \"Cannot find element in DOM with id=\".concat(container));\n        htmlElement = element;\n    } else {\n        htmlElement = container;\n    }\n    const res = new ChartApi(htmlElement, horzScaleBehavior, options);\n    horzScaleBehavior.setOptions(res.options());\n    return res;\n}\n/**\n * This function is the simplified main entry point of the Lightweight Charting Library with time points for the horizontal scale.\n *\n * @param container - ID of HTML element or element itself\n * @param options - Any subset of options to be applied at start.\n * @returns An interface to the created chart\n */ function createChart(container, options) {\n    return createChartEx(container, new HorzScaleBehaviorTime(), HorzScaleBehaviorTime._internal_applyDefaults(options));\n}\n/// <reference types=\"_build-time-constants\" />\nconst customSeriesDefaultOptions = Object.assign(Object.assign({}, seriesOptionsDefaults), customStyleDefaults);\n/**\n * Returns the current version as a string. For example `'3.3.0'`.\n */ function version() {\n    return \"4.1.2\";\n}\n\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"MMMM\");\n$RefreshReg$(_c1, \"MMM\");\n$RefreshReg$(_c2, \"MM\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9saWdodHdlaWdodC1jaGFydHMvZGlzdC9saWdodHdlaWdodC1jaGFydHMuZGV2ZWxvcG1lbnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDMEg7QUFFM0gsTUFBTUssMkJBQTJCO0lBQzdCQyxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsYUFBYTtJQUNiQyxlQUFlO0lBQ2ZDLGFBQWE7SUFDYkMsZUFBZTtJQUNmQyxpQkFBaUI7SUFDakJDLFdBQVc7SUFDWEMsYUFBYTtJQUNiQyxlQUFlO0FBQ25CO0FBQ0EsTUFBTUMsbUJBQW1CO0lBQ3JCVixTQUFTO0lBQ1RDLFdBQVc7SUFDWFUsYUFBYTtJQUNiQyxVQUFVO0FBQ2Q7QUFDQSxNQUFNQyxvQkFBb0I7SUFDdEJDLE9BQU87SUFDUEMsV0FBVyxFQUFFLG1CQUFtQjtJQUNoQ0MsV0FBVztJQUNYQyxVQUFVLEVBQUUsbUJBQW1CO0lBQy9CQyxhQUFhO0lBQ2JDLHdCQUF3QjtJQUN4QkMsdUJBQXVCO0lBQ3ZCQyw0QkFBNEI7SUFDNUJDLDRCQUE0QjtJQUM1QkMsZ0NBQWdDO0lBQ2hDQyxvQkFBb0IsRUFBRSxtQ0FBbUM7SUFDekRDLHFCQUFxQjtBQUN6QjtBQUNBLE1BQU1DLG9CQUFvQjtJQUN0QkMsVUFBVTtJQUNWQyxhQUFhO0lBQ2JDLGtCQUFrQjtJQUNsQkMsV0FBVztJQUNYZixXQUFXLEVBQUUsbUJBQW1CO0lBQ2hDQyxXQUFXO0lBQ1hDLFVBQVUsRUFBRSxtQkFBbUI7SUFDL0JDLGFBQWE7SUFDYkMsd0JBQXdCO0lBQ3hCQyx1QkFBdUI7SUFDdkJDLDRCQUE0QjtJQUM1QkMsNEJBQTRCO0lBQzVCQyxnQ0FBZ0M7SUFDaENDLG9CQUFvQixFQUFFLG1DQUFtQztJQUN6REMscUJBQXFCO0FBQ3pCO0FBQ0EsTUFBTU0sd0JBQXdCO0lBQzFCQyxXQUFXO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztJQUNYO0lB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QUN4RCxJQUFJNnpFO0lBQ0osSUFBSWpsRixTQUFTdTFFLFlBQVk7UUFDckIsTUFBTWpXLFVBQVVvRyxTQUFTd2YsY0FBYyxDQUFDM1A7UUFDeENoa0YsT0FBTyt0RSxZQUFZLE1BQU0sc0NBQWdELE9BQVZpVztRQUMvRDBQLGNBQWMzbEI7SUFDbEIsT0FDSztRQUNEMmxCLGNBQWMxUDtJQUNsQjtJQUNBLE1BQU10dkUsTUFBTSxJQUFJbzhFLFNBQVM0QyxhQUFhaHJDLG1CQUFtQjdvQztJQUN6RDZvQyxrQkFBa0J3VyxVQUFVLENBQUN4cUQsSUFBSW1MLE9BQU87SUFDeEMsT0FBT25MO0FBQ1g7QUFDQTs7Ozs7O0NBTUMsR0FDRCxTQUFTay9FLFlBQVk1UCxTQUFTLEVBQUVua0UsT0FBTztJQUNuQyxPQUFPNHpFLGNBQWN6UCxXQUFXLElBQUkva0IseUJBQXlCQSxzQkFBc0JZLHVCQUF1QixDQUFDaGdEO0FBQy9HO0FBRUEsK0NBQStDO0FBQy9DLE1BQU1nMEUsNkJBQTZCdGhFLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR2wxQix3QkFBd0JEO0FBQzNGOztDQUVDLEdBQ0QsU0FBU3kyRjtJQUNMLE9BQU87QUFDWDtBQUV5USIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGlnaHR3ZWlnaHQtY2hhcnRzL2Rpc3QvbGlnaHR3ZWlnaHQtY2hhcnRzLmRldmVsb3BtZW50Lm1qcz9iNTdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIFRyYWRpbmdWaWV3IExpZ2h0d2VpZ2h0IENoYXJ0c+KEoiB2NC4xLjJcbiAqIENvcHlyaWdodCAoYykgMjAyNCBUcmFkaW5nVmlldywgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgQXBhY2hlIExpY2Vuc2UgMi4wIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuaW1wb3J0IHsgc2l6ZSBhcyBzaXplJDEsIGJpbmRDYW52YXNFbGVtZW50Qml0bWFwU2l6ZVRvLCBlcXVhbFNpemVzLCB0cnlDcmVhdGVDYW52YXNSZW5kZXJpbmdUYXJnZXQyRCB9IGZyb20gJ2ZhbmN5LWNhbnZhcyc7XG5cbmNvbnN0IGNhbmRsZXN0aWNrU3R5bGVEZWZhdWx0cyA9IHtcbiAgICB1cENvbG9yOiAnIzI2YTY5YScsXG4gICAgZG93bkNvbG9yOiAnI2VmNTM1MCcsXG4gICAgd2lja1Zpc2libGU6IHRydWUsXG4gICAgYm9yZGVyVmlzaWJsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogJyMzNzg2NTgnLFxuICAgIGJvcmRlclVwQ29sb3I6ICcjMjZhNjlhJyxcbiAgICBib3JkZXJEb3duQ29sb3I6ICcjZWY1MzUwJyxcbiAgICB3aWNrQ29sb3I6ICcjNzM3Mzc1JyxcbiAgICB3aWNrVXBDb2xvcjogJyMyNmE2OWEnLFxuICAgIHdpY2tEb3duQ29sb3I6ICcjZWY1MzUwJyxcbn07XG5jb25zdCBiYXJTdHlsZURlZmF1bHRzID0ge1xuICAgIHVwQ29sb3I6ICcjMjZhNjlhJyxcbiAgICBkb3duQ29sb3I6ICcjZWY1MzUwJyxcbiAgICBvcGVuVmlzaWJsZTogdHJ1ZSxcbiAgICB0aGluQmFyczogdHJ1ZSxcbn07XG5jb25zdCBsaW5lU3R5bGVEZWZhdWx0cyA9IHtcbiAgICBjb2xvcjogJyMyMTk2ZjMnLFxuICAgIGxpbmVTdHlsZTogMCAvKiBMaW5lU3R5bGUuU29saWQgKi8sXG4gICAgbGluZVdpZHRoOiAzLFxuICAgIGxpbmVUeXBlOiAwIC8qIExpbmVUeXBlLlNpbXBsZSAqLyxcbiAgICBsaW5lVmlzaWJsZTogdHJ1ZSxcbiAgICBjcm9zc2hhaXJNYXJrZXJWaXNpYmxlOiB0cnVlLFxuICAgIGNyb3NzaGFpck1hcmtlclJhZGl1czogNCxcbiAgICBjcm9zc2hhaXJNYXJrZXJCb3JkZXJDb2xvcjogJycsXG4gICAgY3Jvc3NoYWlyTWFya2VyQm9yZGVyV2lkdGg6IDIsXG4gICAgY3Jvc3NoYWlyTWFya2VyQmFja2dyb3VuZENvbG9yOiAnJyxcbiAgICBsYXN0UHJpY2VBbmltYXRpb246IDAgLyogTGFzdFByaWNlQW5pbWF0aW9uTW9kZS5EaXNhYmxlZCAqLyxcbiAgICBwb2ludE1hcmtlcnNWaXNpYmxlOiBmYWxzZSxcbn07XG5jb25zdCBhcmVhU3R5bGVEZWZhdWx0cyA9IHtcbiAgICB0b3BDb2xvcjogJ3JnYmEoIDQ2LCAyMjAsIDEzNSwgMC40KScsXG4gICAgYm90dG9tQ29sb3I6ICdyZ2JhKCA0MCwgMjIxLCAxMDAsIDApJyxcbiAgICBpbnZlcnRGaWxsZWRBcmVhOiBmYWxzZSxcbiAgICBsaW5lQ29sb3I6ICcjMzNENzc4JyxcbiAgICBsaW5lU3R5bGU6IDAgLyogTGluZVN0eWxlLlNvbGlkICovLFxuICAgIGxpbmVXaWR0aDogMyxcbiAgICBsaW5lVHlwZTogMCAvKiBMaW5lVHlwZS5TaW1wbGUgKi8sXG4gICAgbGluZVZpc2libGU6IHRydWUsXG4gICAgY3Jvc3NoYWlyTWFya2VyVmlzaWJsZTogdHJ1ZSxcbiAgICBjcm9zc2hhaXJNYXJrZXJSYWRpdXM6IDQsXG4gICAgY3Jvc3NoYWlyTWFya2VyQm9yZGVyQ29sb3I6ICcnLFxuICAgIGNyb3NzaGFpck1hcmtlckJvcmRlcldpZHRoOiAyLFxuICAgIGNyb3NzaGFpck1hcmtlckJhY2tncm91bmRDb2xvcjogJycsXG4gICAgbGFzdFByaWNlQW5pbWF0aW9uOiAwIC8qIExhc3RQcmljZUFuaW1hdGlvbk1vZGUuRGlzYWJsZWQgKi8sXG4gICAgcG9pbnRNYXJrZXJzVmlzaWJsZTogZmFsc2UsXG59O1xuY29uc3QgYmFzZWxpbmVTdHlsZURlZmF1bHRzID0ge1xuICAgIGJhc2VWYWx1ZToge1xuICAgICAgICB0eXBlOiAncHJpY2UnLFxuICAgICAgICBwcmljZTogMCxcbiAgICB9LFxuICAgIHRvcEZpbGxDb2xvcjE6ICdyZ2JhKDM4LCAxNjYsIDE1NCwgMC4yOCknLFxuICAgIHRvcEZpbGxDb2xvcjI6ICdyZ2JhKDM4LCAxNjYsIDE1NCwgMC4wNSknLFxuICAgIHRvcExpbmVDb2xvcjogJ3JnYmEoMzgsIDE2NiwgMTU0LCAxKScsXG4gICAgYm90dG9tRmlsbENvbG9yMTogJ3JnYmEoMjM5LCA4MywgODAsIDAuMDUpJyxcbiAgICBib3R0b21GaWxsQ29sb3IyOiAncmdiYSgyMzksIDgzLCA4MCwgMC4yOCknLFxuICAgIGJvdHRvbUxpbmVDb2xvcjogJ3JnYmEoMjM5LCA4MywgODAsIDEpJyxcbiAgICBsaW5lV2lkdGg6IDMsXG4gICAgbGluZVN0eWxlOiAwIC8qIExpbmVTdHlsZS5Tb2xpZCAqLyxcbiAgICBsaW5lVHlwZTogMCAvKiBMaW5lVHlwZS5TaW1wbGUgKi8sXG4gICAgbGluZVZpc2libGU6IHRydWUsXG4gICAgY3Jvc3NoYWlyTWFya2VyVmlzaWJsZTogdHJ1ZSxcbiAgICBjcm9zc2hhaXJNYXJrZXJSYWRpdXM6IDQsXG4gICAgY3Jvc3NoYWlyTWFya2VyQm9yZGVyQ29sb3I6ICcnLFxuICAgIGNyb3NzaGFpck1hcmtlckJvcmRlcldpZHRoOiAyLFxuICAgIGNyb3NzaGFpck1hcmtlckJhY2tncm91bmRDb2xvcjogJycsXG4gICAgbGFzdFByaWNlQW5pbWF0aW9uOiAwIC8qIExhc3RQcmljZUFuaW1hdGlvbk1vZGUuRGlzYWJsZWQgKi8sXG4gICAgcG9pbnRNYXJrZXJzVmlzaWJsZTogZmFsc2UsXG59O1xuY29uc3QgaGlzdG9ncmFtU3R5bGVEZWZhdWx0cyA9IHtcbiAgICBjb2xvcjogJyMyNmE2OWEnLFxuICAgIGJhc2U6IDAsXG59O1xuY29uc3QgY3VzdG9tU3R5bGVEZWZhdWx0cyA9IHtcbiAgICBjb2xvcjogJyMyMTk2ZjMnLFxufTtcbmNvbnN0IHNlcmllc09wdGlvbnNEZWZhdWx0cyA9IHtcbiAgICB0aXRsZTogJycsXG4gICAgdmlzaWJsZTogdHJ1ZSxcbiAgICBsYXN0VmFsdWVWaXNpYmxlOiB0cnVlLFxuICAgIHByaWNlTGluZVZpc2libGU6IHRydWUsXG4gICAgcHJpY2VMaW5lU291cmNlOiAwIC8qIFByaWNlTGluZVNvdXJjZS5MYXN0QmFyICovLFxuICAgIHByaWNlTGluZVdpZHRoOiAxLFxuICAgIHByaWNlTGluZUNvbG9yOiAnJyxcbiAgICBwcmljZUxpbmVTdHlsZTogMiAvKiBMaW5lU3R5bGUuRGFzaGVkICovLFxuICAgIGJhc2VMaW5lVmlzaWJsZTogdHJ1ZSxcbiAgICBiYXNlTGluZVdpZHRoOiAxLFxuICAgIGJhc2VMaW5lQ29sb3I6ICcjQjJCNUJFJyxcbiAgICBiYXNlTGluZVN0eWxlOiAwIC8qIExpbmVTdHlsZS5Tb2xpZCAqLyxcbiAgICBwcmljZUZvcm1hdDoge1xuICAgICAgICB0eXBlOiAncHJpY2UnLFxuICAgICAgICBwcmVjaXNpb246IDIsXG4gICAgICAgIG1pbk1vdmU6IDAuMDEsXG4gICAgfSxcbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcG9zc2libGUgbGluZSB0eXBlcy5cbiAqL1xudmFyIExpbmVUeXBlO1xuKGZ1bmN0aW9uIChMaW5lVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEEgbGluZS5cbiAgICAgKi9cbiAgICBMaW5lVHlwZVtMaW5lVHlwZVtcIlNpbXBsZVwiXSA9IDBdID0gXCJTaW1wbGVcIjtcbiAgICAvKipcbiAgICAgKiBBIHN0ZXBwZWQgbGluZS5cbiAgICAgKi9cbiAgICBMaW5lVHlwZVtMaW5lVHlwZVtcIldpdGhTdGVwc1wiXSA9IDFdID0gXCJXaXRoU3RlcHNcIjtcbiAgICAvKipcbiAgICAgKiBBIGN1cnZlZCBsaW5lLlxuICAgICAqL1xuICAgIExpbmVUeXBlW0xpbmVUeXBlW1wiQ3VydmVkXCJdID0gMl0gPSBcIkN1cnZlZFwiO1xufSkoTGluZVR5cGUgfHwgKExpbmVUeXBlID0ge30pKTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcG9zc2libGUgbGluZSBzdHlsZXMuXG4gKi9cbnZhciBMaW5lU3R5bGU7XG4oZnVuY3Rpb24gKExpbmVTdHlsZSkge1xuICAgIC8qKlxuICAgICAqIEEgc29saWQgbGluZS5cbiAgICAgKi9cbiAgICBMaW5lU3R5bGVbTGluZVN0eWxlW1wiU29saWRcIl0gPSAwXSA9IFwiU29saWRcIjtcbiAgICAvKipcbiAgICAgKiBBIGRvdHRlZCBsaW5lLlxuICAgICAqL1xuICAgIExpbmVTdHlsZVtMaW5lU3R5bGVbXCJEb3R0ZWRcIl0gPSAxXSA9IFwiRG90dGVkXCI7XG4gICAgLyoqXG4gICAgICogQSBkYXNoZWQgbGluZS5cbiAgICAgKi9cbiAgICBMaW5lU3R5bGVbTGluZVN0eWxlW1wiRGFzaGVkXCJdID0gMl0gPSBcIkRhc2hlZFwiO1xuICAgIC8qKlxuICAgICAqIEEgZGFzaGVkIGxpbmUgd2l0aCBiaWdnZXIgZGFzaGVzLlxuICAgICAqL1xuICAgIExpbmVTdHlsZVtMaW5lU3R5bGVbXCJMYXJnZURhc2hlZFwiXSA9IDNdID0gXCJMYXJnZURhc2hlZFwiO1xuICAgIC8qKlxuICAgICAqIEEgZG90dGVkIGxpbmUgd2l0aCBtb3JlIHNwYWNlIGJldHdlZW4gZG90cy5cbiAgICAgKi9cbiAgICBMaW5lU3R5bGVbTGluZVN0eWxlW1wiU3BhcnNlRG90dGVkXCJdID0gNF0gPSBcIlNwYXJzZURvdHRlZFwiO1xufSkoTGluZVN0eWxlIHx8IChMaW5lU3R5bGUgPSB7fSkpO1xuZnVuY3Rpb24gc2V0TGluZVN0eWxlKGN0eCwgc3R5bGUpIHtcbiAgICBjb25zdCBkYXNoUGF0dGVybnMgPSB7XG4gICAgICAgIFswIC8qIExpbmVTdHlsZS5Tb2xpZCAqL106IFtdLFxuICAgICAgICBbMSAvKiBMaW5lU3R5bGUuRG90dGVkICovXTogW2N0eC5saW5lV2lkdGgsIGN0eC5saW5lV2lkdGhdLFxuICAgICAgICBbMiAvKiBMaW5lU3R5bGUuRGFzaGVkICovXTogWzIgKiBjdHgubGluZVdpZHRoLCAyICogY3R4LmxpbmVXaWR0aF0sXG4gICAgICAgIFszIC8qIExpbmVTdHlsZS5MYXJnZURhc2hlZCAqL106IFs2ICogY3R4LmxpbmVXaWR0aCwgNiAqIGN0eC5saW5lV2lkdGhdLFxuICAgICAgICBbNCAvKiBMaW5lU3R5bGUuU3BhcnNlRG90dGVkICovXTogW2N0eC5saW5lV2lkdGgsIDQgKiBjdHgubGluZVdpZHRoXSxcbiAgICB9O1xuICAgIGNvbnN0IGRhc2hQYXR0ZXJuID0gZGFzaFBhdHRlcm5zW3N0eWxlXTtcbiAgICBjdHguc2V0TGluZURhc2goZGFzaFBhdHRlcm4pO1xufVxuZnVuY3Rpb24gZHJhd0hvcml6b250YWxMaW5lKGN0eCwgeSwgbGVmdCwgcmlnaHQpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY29uc3QgY29ycmVjdGlvbiA9IChjdHgubGluZVdpZHRoICUgMikgPyAwLjUgOiAwO1xuICAgIGN0eC5tb3ZlVG8obGVmdCwgeSArIGNvcnJlY3Rpb24pO1xuICAgIGN0eC5saW5lVG8ocmlnaHQsIHkgKyBjb3JyZWN0aW9uKTtcbiAgICBjdHguc3Ryb2tlKCk7XG59XG5mdW5jdGlvbiBkcmF3VmVydGljYWxMaW5lKGN0eCwgeCwgdG9wLCBib3R0b20pIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY29uc3QgY29ycmVjdGlvbiA9IChjdHgubGluZVdpZHRoICUgMikgPyAwLjUgOiAwO1xuICAgIGN0eC5tb3ZlVG8oeCArIGNvcnJlY3Rpb24sIHRvcCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgY29ycmVjdGlvbiwgYm90dG9tKTtcbiAgICBjdHguc3Ryb2tlKCk7XG59XG5mdW5jdGlvbiBzdHJva2VJblBpeGVsKGN0eCwgZHJhd0Z1bmN0aW9uKSB7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAoY3R4LmxpbmVXaWR0aCAlIDIpIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLjUsIDAuNSk7XG4gICAgfVxuICAgIGRyYXdGdW5jdGlvbigpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGFuIGFzc2VydGlvbi4gVGhyb3dzIGlmIHRoZSBhc3NlcnRpb24gaXMgZmFpbGVkLlxuICpcbiAqIEBwYXJhbSBjb25kaXRpb24gLSBSZXN1bHQgb2YgdGhlIGFzc2VydGlvbiBldmFsdWF0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRleHQgdG8gaW5jbHVkZSBpbiB0aGUgZXhjZXB0aW9uIG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXNzZXJ0aW9uIGZhaWxlZCcgKyAobWVzc2FnZSA/ICc6ICcgKyBtZXNzYWdlIDogJycpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnN1cmVEZWZpbmVkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBpcyB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZW5zdXJlTm90TnVsbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIGlzIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZW5zdXJlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVuc3VyZU5vdE51bGwoZW5zdXJlRGVmaW5lZCh2YWx1ZSkpO1xufVxuLyoqXG4gKiBDb21waWxlIHRpbWUgY2hlY2sgZm9yIG5ldmVyXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZU5ldmVyKHZhbHVlKSB7IH1cblxuLyoqXG4gKiBOb3RlIHRoaXMgb2JqZWN0IHNob3VsZCBiZSBleHBsaWNpdGx5IG1hcmtlZCBhcyBwdWJsaWMgc28gdGhhdCBkdHMtYnVuZGxlLWdlbmVyYXRvciBkb2VzIG5vdCBtYW5nbGUgdGhlIHByb3BlcnR5IG5hbWVzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlXG4gKi9cbmNvbnN0IG5hbWVkQ29sb3JSZ2JIZXhTdHJpbmdzID0ge1xuICAgIC8vIFRoZSBvcmRlciBvZiBwcm9wZXJ0aWVzIGluIHRoaXMgUmVjb3JkIGlzIG5vdCBpbXBvcnRhbnQgZm9yIHRoZSBpbnRlcm5hbCBsb2dpYy5cbiAgICAvLyBJdCdzIGp1c3QgR1pJUHBlZCBiZXR0ZXIgd2hlbiBwcm9wcyBmb2xsb3dzIHRoaXMgb3JkZXIuXG4gICAgLy8gUGxlYXNlIGFkZCBuZXcgY29sb3JzIHRvIHRoZSBlbmQgb2YgdGhlIHJlY29yZC5cbiAgICBraGFraTogJyNmMGU2OGMnLFxuICAgIGF6dXJlOiAnI2YwZmZmZicsXG4gICAgYWxpY2VibHVlOiAnI2YwZjhmZicsXG4gICAgZ2hvc3R3aGl0ZTogJyNmOGY4ZmYnLFxuICAgIGdvbGQ6ICcjZmZkNzAwJyxcbiAgICBnb2xkZW5yb2Q6ICcjZGFhNTIwJyxcbiAgICBnYWluc2Jvcm86ICcjZGNkY2RjJyxcbiAgICBncmF5OiAnIzgwODA4MCcsXG4gICAgZ3JlZW46ICcjMDA4MDAwJyxcbiAgICBob25leWRldzogJyNmMGZmZjAnLFxuICAgIGZsb3JhbHdoaXRlOiAnI2ZmZmFmMCcsXG4gICAgbGlnaHRibHVlOiAnI2FkZDhlNicsXG4gICAgbGlnaHRjb3JhbDogJyNmMDgwODAnLFxuICAgIGxlbW9uY2hpZmZvbjogJyNmZmZhY2QnLFxuICAgIGhvdHBpbms6ICcjZmY2OWI0JyxcbiAgICBsaWdodHllbGxvdzogJyNmZmZmZTAnLFxuICAgIGdyZWVueWVsbG93OiAnI2FkZmYyZicsXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjZmFmYWQyJyxcbiAgICBsaW1lZ3JlZW46ICcjMzJjZDMyJyxcbiAgICBsaW5lbjogJyNmYWYwZTYnLFxuICAgIGxpZ2h0Y3lhbjogJyNlMGZmZmYnLFxuICAgIG1hZ2VudGE6ICcjZjBmJyxcbiAgICBtYXJvb246ICcjODAwMDAwJyxcbiAgICBvbGl2ZTogJyM4MDgwMDAnLFxuICAgIG9yYW5nZTogJyNmZmE1MDAnLFxuICAgIG9sZGxhY2U6ICcjZmRmNWU2JyxcbiAgICBtZWRpdW1ibHVlOiAnIzAwMDBjZCcsXG4gICAgdHJhbnNwYXJlbnQ6ICcjMDAwMCcsXG4gICAgbGltZTogJyMwZjAnLFxuICAgIGxpZ2h0cGluazogJyNmZmI2YzEnLFxuICAgIG1pc3R5cm9zZTogJyNmZmU0ZTEnLFxuICAgIG1vY2Nhc2luOiAnI2ZmZTRiNScsXG4gICAgbWlkbmlnaHRibHVlOiAnIzE5MTk3MCcsXG4gICAgb3JjaGlkOiAnI2RhNzBkNicsXG4gICAgbWVkaXVtb3JjaGlkOiAnI2JhNTVkMycsXG4gICAgbWVkaXVtdHVycXVvaXNlOiAnIzQ4ZDFjYycsXG4gICAgb3JhbmdlcmVkOiAnI2ZmNDUwMCcsXG4gICAgcm95YWxibHVlOiAnIzQxNjllMScsXG4gICAgcG93ZGVyYmx1ZTogJyNiMGUwZTYnLFxuICAgIHJlZDogJyNmMDAnLFxuICAgIGNvcmFsOiAnI2ZmN2Y1MCcsXG4gICAgdHVycXVvaXNlOiAnIzQwZTBkMCcsXG4gICAgd2hpdGU6ICcjZmZmJyxcbiAgICB3aGl0ZXNtb2tlOiAnI2Y1ZjVmNScsXG4gICAgd2hlYXQ6ICcjZjVkZWIzJyxcbiAgICB0ZWFsOiAnIzAwODA4MCcsXG4gICAgc3RlZWxibHVlOiAnIzQ2ODJiNCcsXG4gICAgYmlzcXVlOiAnI2ZmZTRjNCcsXG4gICAgYXF1YW1hcmluZTogJyM3ZmZmZDQnLFxuICAgIGFxdWE6ICcjMGZmJyxcbiAgICBzaWVubmE6ICcjYTA1MjJkJyxcbiAgICBzaWx2ZXI6ICcjYzBjMGMwJyxcbiAgICBzcHJpbmdncmVlbjogJyMwMGZmN2YnLFxuICAgIGFudGlxdWV3aGl0ZTogJyNmYWViZDcnLFxuICAgIGJ1cmx5d29vZDogJyNkZWI4ODcnLFxuICAgIGJyb3duOiAnI2E1MmEyYScsXG4gICAgYmVpZ2U6ICcjZjVmNWRjJyxcbiAgICBjaG9jb2xhdGU6ICcjZDI2OTFlJyxcbiAgICBjaGFydHJldXNlOiAnIzdmZmYwMCcsXG4gICAgY29ybmZsb3dlcmJsdWU6ICcjNjQ5NWVkJyxcbiAgICBjb3Juc2lsazogJyNmZmY4ZGMnLFxuICAgIGNyaW1zb246ICcjZGMxNDNjJyxcbiAgICBjYWRldGJsdWU6ICcjNWY5ZWEwJyxcbiAgICB0b21hdG86ICcjZmY2MzQ3JyxcbiAgICBmdWNoc2lhOiAnI2YwZicsXG4gICAgYmx1ZTogJyMwMGYnLFxuICAgIHNhbG1vbjogJyNmYTgwNzInLFxuICAgIGJsYW5jaGVkYWxtb25kOiAnI2ZmZWJjZCcsXG4gICAgc2xhdGVibHVlOiAnIzZhNWFjZCcsXG4gICAgc2xhdGVncmF5OiAnIzcwODA5MCcsXG4gICAgdGhpc3RsZTogJyNkOGJmZDgnLFxuICAgIHRhbjogJyNkMmI0OGMnLFxuICAgIGN5YW46ICcjMGZmJyxcbiAgICBkYXJrYmx1ZTogJyMwMDAwOGInLFxuICAgIGRhcmtjeWFuOiAnIzAwOGI4YicsXG4gICAgZGFya2dvbGRlbnJvZDogJyNiODg2MGInLFxuICAgIGRhcmtncmF5OiAnI2E5YTlhOScsXG4gICAgYmx1ZXZpb2xldDogJyM4YTJiZTInLFxuICAgIGJsYWNrOiAnIzAwMCcsXG4gICAgZGFya21hZ2VudGE6ICcjOGIwMDhiJyxcbiAgICBkYXJrc2xhdGVibHVlOiAnIzQ4M2Q4YicsXG4gICAgZGFya2toYWtpOiAnI2JkYjc2YicsXG4gICAgZGFya29yY2hpZDogJyM5OTMyY2MnLFxuICAgIGRhcmtvcmFuZ2U6ICcjZmY4YzAwJyxcbiAgICBkYXJrZ3JlZW46ICcjMDA2NDAwJyxcbiAgICBkYXJrcmVkOiAnIzhiMDAwMCcsXG4gICAgZG9kZ2VyYmx1ZTogJyMxZTkwZmYnLFxuICAgIGRhcmtzbGF0ZWdyYXk6ICcjMmY0ZjRmJyxcbiAgICBkaW1ncmF5OiAnIzY5Njk2OScsXG4gICAgZGVlcHNreWJsdWU6ICcjMDBiZmZmJyxcbiAgICBmaXJlYnJpY2s6ICcjYjIyMjIyJyxcbiAgICBmb3Jlc3RncmVlbjogJyMyMjhiMjInLFxuICAgIGluZGlnbzogJyM0YjAwODInLFxuICAgIGl2b3J5OiAnI2ZmZmZmMCcsXG4gICAgbGF2ZW5kZXJibHVzaDogJyNmZmYwZjUnLFxuICAgIGZlbGRzcGFyOiAnI2QxOTI3NScsXG4gICAgaW5kaWFucmVkOiAnI2NkNWM1YycsXG4gICAgbGlnaHRncmVlbjogJyM5MGVlOTAnLFxuICAgIGxpZ2h0Z3JleTogJyNkM2QzZDMnLFxuICAgIGxpZ2h0c2t5Ymx1ZTogJyM4N2NlZmEnLFxuICAgIGxpZ2h0c2xhdGVncmF5OiAnIzc4OScsXG4gICAgbGlnaHRzbGF0ZWJsdWU6ICcjODQ3MGZmJyxcbiAgICBzbm93OiAnI2ZmZmFmYScsXG4gICAgbGlnaHRzZWFncmVlbjogJyMyMGIyYWEnLFxuICAgIGxpZ2h0c2FsbW9uOiAnI2ZmYTA3YScsXG4gICAgZGFya3NhbG1vbjogJyNlOTk2N2EnLFxuICAgIGRhcmt2aW9sZXQ6ICcjOTQwMGQzJyxcbiAgICBtZWRpdW1wdXJwbGU6ICcjOTM3MGQ4JyxcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiAnIzY2Y2RhYScsXG4gICAgc2t5Ymx1ZTogJyM4N2NlZWInLFxuICAgIGxhdmVuZGVyOiAnI2U2ZTZmYScsXG4gICAgbGlnaHRzdGVlbGJsdWU6ICcjYjBjNGRlJyxcbiAgICBtZWRpdW12aW9sZXRyZWQ6ICcjYzcxNTg1JyxcbiAgICBtaW50Y3JlYW06ICcjZjVmZmZhJyxcbiAgICBuYXZham93aGl0ZTogJyNmZmRlYWQnLFxuICAgIG5hdnk6ICcjMDAwMDgwJyxcbiAgICBvbGl2ZWRyYWI6ICcjNmI4ZTIzJyxcbiAgICBwYWxldmlvbGV0cmVkOiAnI2Q4NzA5MycsXG4gICAgdmlvbGV0cmVkOiAnI2QwMjA5MCcsXG4gICAgeWVsbG93OiAnI2ZmMCcsXG4gICAgeWVsbG93Z3JlZW46ICcjOWFjZDMyJyxcbiAgICBsYXduZ3JlZW46ICcjN2NmYzAwJyxcbiAgICBwaW5rOiAnI2ZmYzBjYicsXG4gICAgcGFsZXR1cnF1b2lzZTogJyNhZmVlZWUnLFxuICAgIHBhbGVnb2xkZW5yb2Q6ICcjZWVlOGFhJyxcbiAgICBkYXJrb2xpdmVncmVlbjogJyM1NTZiMmYnLFxuICAgIGRhcmtzZWFncmVlbjogJyM4ZmJjOGYnLFxuICAgIGRhcmt0dXJxdW9pc2U6ICcjMDBjZWQxJyxcbiAgICBwZWFjaHB1ZmY6ICcjZmZkYWI5JyxcbiAgICBkZWVwcGluazogJyNmZjE0OTMnLFxuICAgIHZpb2xldDogJyNlZTgyZWUnLFxuICAgIHBhbGVncmVlbjogJyM5OGZiOTgnLFxuICAgIG1lZGl1bXNlYWdyZWVuOiAnIzNjYjM3MScsXG4gICAgcGVydTogJyNjZDg1M2YnLFxuICAgIHNhZGRsZWJyb3duOiAnIzhiNDUxMycsXG4gICAgc2FuZHlicm93bjogJyNmNGE0NjAnLFxuICAgIHJvc3licm93bjogJyNiYzhmOGYnLFxuICAgIHB1cnBsZTogJyM4MDAwODAnLFxuICAgIHNlYWdyZWVuOiAnIzJlOGI1NycsXG4gICAgc2Vhc2hlbGw6ICcjZmZmNWVlJyxcbiAgICBwYXBheWF3aGlwOiAnI2ZmZWZkNScsXG4gICAgbWVkaXVtc2xhdGVibHVlOiAnIzdiNjhlZScsXG4gICAgcGx1bTogJyNkZGEwZGQnLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAnIzAwZmE5YScsXG59O1xuZnVuY3Rpb24gbm9ybWFsaXplUmdiQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIGlmIChjb21wb25lbnQgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50ID4gMjU1KSB7XG4gICAgICAgIHJldHVybiAyNTU7XG4gICAgfVxuICAgIC8vIE5hTiB2YWx1ZXMgYXJlIHRyZWF0ZWQgYXMgMFxuICAgIHJldHVybiAoTWF0aC5yb3VuZChjb21wb25lbnQpIHx8IDApO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQWxwaGFDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuICghKGNvbXBvbmVudCA8PSAwKSAmJiAhKGNvbXBvbmVudCA+IDApID8gMCA6XG4gICAgICAgIGNvbXBvbmVudCA8IDAgPyAwIDpcbiAgICAgICAgICAgIGNvbXBvbmVudCA+IDEgPyAxIDpcbiAgICAgICAgICAgICAgICAvLyBsaW1pdCB0aGUgcHJlY2lzaW9uIG9mIGFsbCBudW1iZXJzIHRvIGF0IG1vc3QgNCBkaWdpdHMgaW4gZnJhY3Rpb25hbCBwYXJ0XG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZChjb21wb25lbnQgKiAxMDAwMCkgLyAxMDAwMCk7XG59XG4vKipcbiAqIEBleGFtcGxlXG4gKiAjZmIwXG4gKiBAZXhhbXBsZVxuICogI2YwZlxuICogQGV4YW1wbGVcbiAqICNmMGZhXG4gKi9cbmNvbnN0IHNob3J0SGV4UmUgPSAvXiMoWzAtOWEtZl0pKFswLTlhLWZdKShbMC05YS1mXSkoWzAtOWEtZl0pPyQvaTtcbi8qKlxuICogQGV4YW1wbGVcbiAqICMwMGZmMDBcbiAqIEBleGFtcGxlXG4gKiAjMzM2Njk5XG4gKiBAZXhhbXBsZVxuICogIzMzNjY5OUZBXG4gKi9cbmNvbnN0IGhleFJlID0gL14jKFswLTlhLWZdezJ9KShbMC05YS1mXXsyfSkoWzAtOWEtZl17Mn0pKFswLTlhLWZdezJ9KT8kL2k7XG4vKipcbiAqIEBleGFtcGxlXG4gKiByZ2IoMTIzLCAyMzQsIDQ1KVxuICogQGV4YW1wbGVcbiAqIHJnYigyNTUsMjM0LDI0NSlcbiAqL1xuY29uc3QgcmdiUmUgPSAvXnJnYlxcKFxccyooLT9cXGR7MSwxMH0pXFxzKixcXHMqKC0/XFxkezEsMTB9KVxccyosXFxzKigtP1xcZHsxLDEwfSlcXHMqXFwpJC87XG4vKipcbiAqIEBleGFtcGxlXG4gKiByZ2JhKDEyMywgMjM0LCA0NSwgMSlcbiAqIEBleGFtcGxlXG4gKiByZ2JhKDI1NSwyMzQsMjQ1LDAuMSlcbiAqL1xuY29uc3QgcmdiYVJlID0gL15yZ2JhXFwoXFxzKigtP1xcZHsxLDEwfSlcXHMqLFxccyooLT9cXGR7MSwxMH0pXFxzKixcXHMqKC0/XFxkezEsMTB9KVxccyosXFxzKigtP1tcXGRdezAsMTB9KD86XFwuXFxkKyk/KVxccypcXCkkLztcbmZ1bmN0aW9uIGNvbG9yU3RyaW5nVG9SZ2JhKGNvbG9yU3RyaW5nKSB7XG4gICAgY29sb3JTdHJpbmcgPSBjb2xvclN0cmluZy50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgIGlmIChjb2xvclN0cmluZyBpbiBuYW1lZENvbG9yUmdiSGV4U3RyaW5ncykge1xuICAgICAgICBjb2xvclN0cmluZyA9IG5hbWVkQ29sb3JSZ2JIZXhTdHJpbmdzW2NvbG9yU3RyaW5nXTtcbiAgICB9XG4gICAge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gcmdiYVJlLmV4ZWMoY29sb3JTdHJpbmcpIHx8IHJnYlJlLmV4ZWMoY29sb3JTdHJpbmcpO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVSZ2JDb21wb25lbnQocGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApKSxcbiAgICAgICAgICAgICAgICBub3JtYWxpemVSZ2JDb21wb25lbnQocGFyc2VJbnQobWF0Y2hlc1syXSwgMTApKSxcbiAgICAgICAgICAgICAgICBub3JtYWxpemVSZ2JDb21wb25lbnQocGFyc2VJbnQobWF0Y2hlc1szXSwgMTApKSxcbiAgICAgICAgICAgICAgICBub3JtYWxpemVBbHBoYUNvbXBvbmVudCgobWF0Y2hlcy5sZW5ndGggPCA1ID8gMSA6IHBhcnNlRmxvYXQobWF0Y2hlc1s0XSkpKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gaGV4UmUuZXhlYyhjb2xvclN0cmluZyk7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVJnYkNvbXBvbmVudChwYXJzZUludChtYXRjaGVzWzFdLCAxNikpLFxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVJnYkNvbXBvbmVudChwYXJzZUludChtYXRjaGVzWzJdLCAxNikpLFxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVJnYkNvbXBvbmVudChwYXJzZUludChtYXRjaGVzWzNdLCAxNikpLFxuICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHNob3J0SGV4UmUuZXhlYyhjb2xvclN0cmluZyk7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVJnYkNvbXBvbmVudChwYXJzZUludChtYXRjaGVzWzFdLCAxNikgKiAweDExKSxcbiAgICAgICAgICAgICAgICBub3JtYWxpemVSZ2JDb21wb25lbnQocGFyc2VJbnQobWF0Y2hlc1syXSwgMTYpICogMHgxMSksXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplUmdiQ29tcG9uZW50KHBhcnNlSW50KG1hdGNoZXNbM10sIDE2KSAqIDB4MTEpLFxuICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBhcnNlIGNvbG9yOiAke2NvbG9yU3RyaW5nfWApO1xufVxuZnVuY3Rpb24gcmdiYVRvR3JheXNjYWxlKHJnYlZhbHVlKSB7XG4gICAgLy8gT3JpZ2luYWxseSwgdGhlIE5UU0MgUkdCIHRvIFlVViBmb3JtdWxhXG4gICAgLy8gcGVyZmVjdGVkIGJ5IEBldWdlbmUta29yb2JrbydzIGJsYWNrIG1hZ2ljXG4gICAgY29uc3QgcmVkQ29tcG9uZW50R3JheXNjYWxlV2VpZ2h0ID0gMC4xOTk7XG4gICAgY29uc3QgZ3JlZW5Db21wb25lbnRHcmF5c2NhbGVXZWlnaHQgPSAwLjY4NztcbiAgICBjb25zdCBibHVlQ29tcG9uZW50R3JheXNjYWxlV2VpZ2h0ID0gMC4xMTQ7XG4gICAgcmV0dXJuIChyZWRDb21wb25lbnRHcmF5c2NhbGVXZWlnaHQgKiByZ2JWYWx1ZVswXSArXG4gICAgICAgIGdyZWVuQ29tcG9uZW50R3JheXNjYWxlV2VpZ2h0ICogcmdiVmFsdWVbMV0gK1xuICAgICAgICBibHVlQ29tcG9uZW50R3JheXNjYWxlV2VpZ2h0ICogcmdiVmFsdWVbMl0pO1xufVxuZnVuY3Rpb24gYXBwbHlBbHBoYShjb2xvciwgYWxwaGEpIHtcbiAgICAvLyBzcGVjaWFsIGNhc2Ugb3B0aW1pemF0aW9uXG4gICAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luUmdiYSA9IGNvbG9yU3RyaW5nVG9SZ2JhKGNvbG9yKTtcbiAgICBjb25zdCBvcmlnaW5BbHBoYSA9IG9yaWdpblJnYmFbM107XG4gICAgcmV0dXJuIGByZ2JhKCR7b3JpZ2luUmdiYVswXX0sICR7b3JpZ2luUmdiYVsxXX0sICR7b3JpZ2luUmdiYVsyXX0sICR7YWxwaGEgKiBvcmlnaW5BbHBoYX0pYDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udHJhc3RDb2xvcnMoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgY29uc3QgcmdiID0gY29sb3JTdHJpbmdUb1JnYmEoYmFja2dyb3VuZENvbG9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBfaW50ZXJuYWxfYmFja2dyb3VuZDogYHJnYigke3JnYlswXX0sICR7cmdiWzFdfSwgJHtyZ2JbMl19KWAsXG4gICAgICAgIF9pbnRlcm5hbF9mb3JlZ3JvdW5kOiByZ2JhVG9HcmF5c2NhbGUocmdiKSA+IDE2MCA/ICdibGFjaycgOiAnd2hpdGUnLFxuICAgIH07XG59XG5mdW5jdGlvbiBncmFkaWVudENvbG9yQXRQZXJjZW50KHRvcENvbG9yLCBib3R0b21Db2xvciwgcGVyY2VudCkge1xuICAgIGNvbnN0IFt0b3BSLCB0b3BHLCB0b3BCLCB0b3BBXSA9IGNvbG9yU3RyaW5nVG9SZ2JhKHRvcENvbG9yKTtcbiAgICBjb25zdCBbYm90dG9tUiwgYm90dG9tRywgYm90dG9tQiwgYm90dG9tQV0gPSBjb2xvclN0cmluZ1RvUmdiYShib3R0b21Db2xvcik7XG4gICAgY29uc3QgcmVzdWx0UmdiYSA9IFtcbiAgICAgICAgbm9ybWFsaXplUmdiQ29tcG9uZW50KHRvcFIgKyBwZXJjZW50ICogKGJvdHRvbVIgLSB0b3BSKSksXG4gICAgICAgIG5vcm1hbGl6ZVJnYkNvbXBvbmVudCh0b3BHICsgcGVyY2VudCAqIChib3R0b21HIC0gdG9wRykpLFxuICAgICAgICBub3JtYWxpemVSZ2JDb21wb25lbnQodG9wQiArIHBlcmNlbnQgKiAoYm90dG9tQiAtIHRvcEIpKSxcbiAgICAgICAgbm9ybWFsaXplQWxwaGFDb21wb25lbnQodG9wQSArIHBlcmNlbnQgKiAoYm90dG9tQSAtIHRvcEEpKSxcbiAgICBdO1xuICAgIHJldHVybiBgcmdiYSgke3Jlc3VsdFJnYmFbMF19LCAke3Jlc3VsdFJnYmFbMV19LCAke3Jlc3VsdFJnYmFbMl19LCAke3Jlc3VsdFJnYmFbM119KWA7XG59XG5cbmNsYXNzIERlbGVnYXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdWJzY3JpYmUoY2FsbGJhY2ssIGxpbmtlZE9iamVjdCwgc2luZ2xlc2hvdCkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9jYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGlua2VkT2JqZWN0OiBsaW5rZWRPYmplY3QsXG4gICAgICAgICAgICBfaW50ZXJuYWxfc2luZ2xlc2hvdDogc2luZ2xlc2hvdCA9PT0gdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdW5zdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wcml2YXRlX19saXN0ZW5lcnMuZmluZEluZGV4KChsaXN0ZW5lcikgPT4gY2FsbGJhY2sgPT09IGxpc3RlbmVyLl9pbnRlcm5hbF9jYWxsYmFjayk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwobGlua2VkT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xpc3RlbmVycyA9IHRoaXMuX3ByaXZhdGVfX2xpc3RlbmVycy5maWx0ZXIoKGxpc3RlbmVyKSA9PiBsaXN0ZW5lci5faW50ZXJuYWxfbGlua2VkT2JqZWN0ICE9PSBsaW5rZWRPYmplY3QpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZmlyZShwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyc1NuYXBzaG90ID0gWy4uLnRoaXMuX3ByaXZhdGVfX2xpc3RlbmVyc107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xpc3RlbmVycyA9IHRoaXMuX3ByaXZhdGVfX2xpc3RlbmVycy5maWx0ZXIoKGxpc3RlbmVyKSA9PiAhbGlzdGVuZXIuX2ludGVybmFsX3NpbmdsZXNob3QpO1xuICAgICAgICBsaXN0ZW5lcnNTbmFwc2hvdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIuX2ludGVybmFsX2NhbGxiYWNrKHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2hhc0xpc3RlbmVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2xpc3RlbmVycy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGlzdGVuZXJzID0gW107XG4gICAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gbWVyZ2UoZHN0LCAuLi5zb3VyY2VzKSB7XG4gICAgZm9yIChjb25zdCBzcmMgb2Ygc291cmNlcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgZm9yIChjb25zdCBpIGluIHNyYykge1xuICAgICAgICAgICAgaWYgKHNyY1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ29iamVjdCcgIT09IHR5cGVvZiBzcmNbaV0gfHwgZHN0W2ldID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShzcmNbaV0pKSB7XG4gICAgICAgICAgICAgICAgZHN0W2ldID0gc3JjW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICBtZXJnZShkc3RbaV0sIHNyY1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRzdDtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSAmJiAoaXNGaW5pdGUodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgJiYgKCh2YWx1ZSAlIDEpID09PSAwKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59XG5mdW5jdGlvbiBjbG9uZShvYmplY3QpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IG8gPSBvYmplY3Q7XG4gICAgaWYgKCFvIHx8ICdvYmplY3QnICE9PSB0eXBlb2Ygbykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbGV0IGM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgYyA9IFtdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYyA9IHt9O1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBsZXQgdjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICBmb3IgKHAgaW4gbykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCxuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgIHYgPSBvW3BdO1xuICAgICAgICAgICAgaWYgKHYgJiYgJ29iamVjdCcgPT09IHR5cGVvZiB2KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIGNbcF0gPSBjbG9uZSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICBjW3BdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICByZXR1cm4gYztcbn1cbmZ1bmN0aW9uIG5vdE51bGwodCkge1xuICAgIHJldHVybiB0ICE9PSBudWxsO1xufVxuZnVuY3Rpb24gdW5kZWZpbmVkSWZOdWxsKHQpIHtcbiAgICByZXR1cm4gKHQgPT09IG51bGwpID8gdW5kZWZpbmVkIDogdDtcbn1cblxuLyoqXG4gKiBEZWZhdWx0IGZvbnQgZmFtaWx5LlxuICogTXVzdCBiZSB1c2VkIHRvIGdlbmVyYXRlIGZvbnQgc3RyaW5nIHdoZW4gZm9udCBpcyBub3Qgc3BlY2lmaWVkLlxuICovXG5jb25zdCBkZWZhdWx0Rm9udEZhbWlseSA9IGAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdUcmVidWNoZXQgTVMnLCBSb2JvdG8sIFVidW50dSwgc2Fucy1zZXJpZmA7XG4vKipcbiAqIEdlbmVyYXRlcyBhIGZvbnQgc3RyaW5nLCB3aGljaCBjYW4gYmUgdXNlZCB0byBzZXQgaW4gY2FudmFzJyBmb250IHByb3BlcnR5LlxuICogSWYgbm8gZmFtaWx5IHByb3ZpZGVkLCB7QGxpbmsgZGVmYXVsdEZvbnRGYW1pbHl9IHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gc2l6ZSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuXG4gKiBAcGFyYW0gZmFtaWx5IC0gT3B0aW9uYWwgZm9udCBmYW1pbHkuXG4gKiBAcGFyYW0gc3R5bGUgLSBPcHRpb25hbCBmb250IHN0eWxlLlxuICogQHJldHVybnMgVGhlIGZvbnQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBtYWtlRm9udChzaXplLCBmYW1pbHksIHN0eWxlKSB7XG4gICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3R5bGUgPSBgJHtzdHlsZX0gYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0eWxlID0gJyc7XG4gICAgfVxuICAgIGlmIChmYW1pbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmYW1pbHkgPSBkZWZhdWx0Rm9udEZhbWlseTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3N0eWxlfSR7c2l6ZX1weCAke2ZhbWlseX1gO1xufVxuXG5jbGFzcyBQcmljZUF4aXNSZW5kZXJlck9wdGlvbnNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoY2hhcnRNb2RlbCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYm9yZGVyU2l6ZTogMSAvKiBSZW5kZXJlckNvbnN0YW50cy5Cb3JkZXJTaXplICovLFxuICAgICAgICAgICAgX2ludGVybmFsX3RpY2tMZW5ndGg6IDUgLyogUmVuZGVyZXJDb25zdGFudHMuVGlja0xlbmd0aCAqLyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9mb250U2l6ZTogTmFOLFxuICAgICAgICAgICAgX2ludGVybmFsX2ZvbnQ6ICcnLFxuICAgICAgICAgICAgX2ludGVybmFsX2ZvbnRGYW1pbHk6ICcnLFxuICAgICAgICAgICAgX2ludGVybmFsX2NvbG9yOiAnJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wYW5lQmFja2dyb3VuZENvbG9yOiAnJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wYWRkaW5nQm90dG9tOiAwLFxuICAgICAgICAgICAgX2ludGVybmFsX3BhZGRpbmdJbm5lcjogMCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wYWRkaW5nT3V0ZXI6IDAsXG4gICAgICAgICAgICBfaW50ZXJuYWxfcGFkZGluZ1RvcDogMCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlbGluZU9mZnNldDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbCA9IGNoYXJ0TW9kZWw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcHRpb25zKCkge1xuICAgICAgICBjb25zdCByZW5kZXJlck9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGb250U2l6ZSA9IHRoaXMuX3ByaXZhdGVfX2ZvbnRTaXplKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGb250RmFtaWx5ID0gdGhpcy5fcHJpdmF0ZV9fZm9udEZhbWlseSgpO1xuICAgICAgICBpZiAocmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250U2l6ZSAhPT0gY3VycmVudEZvbnRTaXplIHx8IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udEZhbWlseSAhPT0gY3VycmVudEZvbnRGYW1pbHkpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udFNpemUgPSBjdXJyZW50Rm9udFNpemU7XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2ZvbnRGYW1pbHkgPSBjdXJyZW50Rm9udEZhbWlseTtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udCA9IG1ha2VGb250KGN1cnJlbnRGb250U2l6ZSwgY3VycmVudEZvbnRGYW1pbHkpO1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nVG9wID0gMi41IC8gMTIgKiBjdXJyZW50Rm9udFNpemU7IC8vIDIuNSBweCBmb3IgMTJweCBmb250XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdCb3R0b20gPSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdUb3A7XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdJbm5lciA9IGN1cnJlbnRGb250U2l6ZSAvIDEyICogcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoO1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nT3V0ZXIgPSBjdXJyZW50Rm9udFNpemUgLyAxMiAqIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfdGlja0xlbmd0aDtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfYmFzZWxpbmVPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfY29sb3IgPSB0aGlzLl9wcml2YXRlX190ZXh0Q29sb3IoKTtcbiAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYW5lQmFja2dyb3VuZENvbG9yID0gdGhpcy5fcHJpdmF0ZV9fcGFuZUJhY2tncm91bmRDb2xvcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdGV4dENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpLmxheW91dC50ZXh0Q29sb3I7XG4gICAgfVxuICAgIF9wcml2YXRlX19wYW5lQmFja2dyb3VuZENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbC5faW50ZXJuYWxfYmFja2dyb3VuZFRvcENvbG9yKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19mb250U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NoYXJ0TW9kZWwuX2ludGVybmFsX29wdGlvbnMoKS5sYXlvdXQuZm9udFNpemU7XG4gICAgfVxuICAgIF9wcml2YXRlX19mb250RmFtaWx5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpLmxheW91dC5mb250RmFtaWx5O1xuICAgIH1cbn1cblxuY2xhc3MgQ29tcG9zaXRlUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlcnMgPSBbXTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFJlbmRlcmVycyhyZW5kZXJlcnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJzID0gcmVuZGVyZXJzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZHJhdyh0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJzLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgICAgIHIuX2ludGVybmFsX2RyYXcodGFyZ2V0LCBpc0hvdmVyZWQsIGhpdFRlc3REYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBNZWRpYUNvb3JkaW5hdGVzUGFuZVJlbmRlcmVyIHtcbiAgICBfaW50ZXJuYWxfZHJhdyh0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpIHtcbiAgICAgICAgdGFyZ2V0LnVzZU1lZGlhQ29vcmRpbmF0ZVNwYWNlKChzY29wZSkgPT4gdGhpcy5faW50ZXJuYWxfX2RyYXdJbXBsKHNjb3BlLCBpc0hvdmVyZWQsIGhpdFRlc3REYXRhKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3QmFja2dyb3VuZCh0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpIHtcbiAgICAgICAgdGFyZ2V0LnVzZU1lZGlhQ29vcmRpbmF0ZVNwYWNlKChzY29wZSkgPT4gdGhpcy5faW50ZXJuYWxfX2RyYXdCYWNrZ3JvdW5kSW1wbChzY29wZSwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2RyYXdCYWNrZ3JvdW5kSW1wbChyZW5kZXJpbmdTY29wZSwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSkgeyB9XG59XG5cbmNsYXNzIFBhbmVSZW5kZXJlck1hcmtzIGV4dGVuZHMgTWVkaWFDb29yZGluYXRlc1BhbmVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19kYXRhID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZHJhd0ltcGwoeyBjb250ZXh0OiBjdHggfSkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfX2RhdGEgPT09IG51bGwgfHwgdGhpcy5faW50ZXJuYWxfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpc2libGVSYW5nZSA9IHRoaXMuX2ludGVybmFsX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2U7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9pbnRlcm5hbF9fZGF0YTtcbiAgICAgICAgY29uc3QgZHJhdyA9IChyYWRpdXMpID0+IHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB2aXNpYmxlUmFuZ2UudG8gLSAxOyBpID49IHZpc2libGVSYW5nZS5mcm9tOyAtLWkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IGRhdGEuX2ludGVybmFsX2l0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnQuX2ludGVybmFsX3gsIHBvaW50Ll9pbnRlcm5hbF95KTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHBvaW50Ll9pbnRlcm5hbF94LCBwb2ludC5faW50ZXJuYWxfeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZGF0YS5faW50ZXJuYWxfbGluZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGRhdGEuX2ludGVybmFsX2JhY2tDb2xvcjtcbiAgICAgICAgICAgIGRyYXcoZGF0YS5faW50ZXJuYWxfcmFkaXVzICsgZGF0YS5faW50ZXJuYWxfbGluZVdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZGF0YS5faW50ZXJuYWxfbGluZUNvbG9yO1xuICAgICAgICBkcmF3KGRhdGEuX2ludGVybmFsX3JhZGl1cyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbXB0eU1hcmtlckRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2ludGVybmFsX2l0ZW1zOiBbe1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF94OiAwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF95OiAwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90aW1lOiAwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9wcmljZTogMCxcbiAgICAgICAgICAgIH1dLFxuICAgICAgICBfaW50ZXJuYWxfbGluZUNvbG9yOiAnJyxcbiAgICAgICAgX2ludGVybmFsX2JhY2tDb2xvcjogJycsXG4gICAgICAgIF9pbnRlcm5hbF9yYWRpdXM6IDAsXG4gICAgICAgIF9pbnRlcm5hbF9saW5lV2lkdGg6IDAsXG4gICAgICAgIF9pbnRlcm5hbF92aXNpYmxlUmFuZ2U6IG51bGwsXG4gICAgfTtcbn1cbmNvbnN0IHJhbmdlRm9yU2luZ2xlUG9pbnQgPSB7IGZyb206IDAsIHRvOiAxIH07XG5jbGFzcyBDcm9zc2hhaXJNYXJrc1BhbmVWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihjaGFydE1vZGVsLCBjcm9zc2hhaXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29tcG9zaXRlUmVuZGVyZXIgPSBuZXcgQ29tcG9zaXRlUmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1JlbmRlcmVycyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzRGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0TW9kZWwgPSBjaGFydE1vZGVsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIgPSBjcm9zc2hhaXI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbXBvc2l0ZVJlbmRlcmVyLl9pbnRlcm5hbF9zZXRSZW5kZXJlcnModGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1JlbmRlcmVycyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGUodXBkYXRlVHlwZSkge1xuICAgICAgICBjb25zdCBzZXJpZXNlcyA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0TW9kZWwuX2ludGVybmFsX3Nlcmllc2VzKCk7XG4gICAgICAgIGlmIChzZXJpZXNlcy5sZW5ndGggIT09IHRoaXMuX3ByaXZhdGVfX21hcmtlcnNSZW5kZXJlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzRGF0YSA9IHNlcmllc2VzLm1hcChjcmVhdGVFbXB0eU1hcmtlckRhdGEpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1JlbmRlcmVycyA9IHRoaXMuX3ByaXZhdGVfX21hcmtlcnNEYXRhLm1hcCgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBQYW5lUmVuZGVyZXJNYXJrcygpO1xuICAgICAgICAgICAgICAgIHJlcy5faW50ZXJuYWxfc2V0RGF0YShkYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jb21wb3NpdGVSZW5kZXJlci5faW50ZXJuYWxfc2V0UmVuZGVyZXJzKHRoaXMuX3ByaXZhdGVfX21hcmtlcnNSZW5kZXJlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUltcGwoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NvbXBvc2l0ZVJlbmRlcmVyO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlSW1wbCgpIHtcbiAgICAgICAgY29uc3QgZm9yY2VIaWRkZW4gPSB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIuX2ludGVybmFsX29wdGlvbnMoKS5tb2RlID09PSAyIC8qIENyb3NzaGFpck1vZGUuSGlkZGVuICovO1xuICAgICAgICBjb25zdCBzZXJpZXNlcyA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0TW9kZWwuX2ludGVybmFsX3Nlcmllc2VzKCk7XG4gICAgICAgIGNvbnN0IHRpbWVQb2ludEluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyLl9pbnRlcm5hbF9hcHBsaWVkSW5kZXgoKTtcbiAgICAgICAgY29uc3QgdGltZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIHNlcmllc2VzLmZvckVhY2goKHMsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc0RhdGFbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc2VyaWVzRGF0YSA9IHMuX2ludGVybmFsX21hcmtlckRhdGFBdEluZGV4KHRpbWVQb2ludEluZGV4KTtcbiAgICAgICAgICAgIGlmIChmb3JjZUhpZGRlbiB8fCBzZXJpZXNEYXRhID09PSBudWxsIHx8ICFzLl9pbnRlcm5hbF92aXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBlbnN1cmVOb3ROdWxsKHMuX2ludGVybmFsX2ZpcnN0VmFsdWUoKSk7XG4gICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF9saW5lQ29sb3IgPSBzZXJpZXNEYXRhLl9pbnRlcm5hbF9iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF9yYWRpdXMgPSBzZXJpZXNEYXRhLl9pbnRlcm5hbF9yYWRpdXM7XG4gICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF9saW5lV2lkdGggPSBzZXJpZXNEYXRhLl9pbnRlcm5hbF9ib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGRhdGEuX2ludGVybmFsX2l0ZW1zWzBdLl9pbnRlcm5hbF9wcmljZSA9IHNlcmllc0RhdGEuX2ludGVybmFsX3ByaWNlO1xuICAgICAgICAgICAgZGF0YS5faW50ZXJuYWxfaXRlbXNbMF0uX2ludGVybmFsX3kgPSBzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKHNlcmllc0RhdGEuX2ludGVybmFsX3ByaWNlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF9iYWNrQ29sb3IgPSAoX2EgPSBzZXJpZXNEYXRhLl9pbnRlcm5hbF9ib3JkZXJDb2xvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbC5faW50ZXJuYWxfYmFja2dyb3VuZENvbG9yQXRZUGVyY2VudEZyb21Ub3AoZGF0YS5faW50ZXJuYWxfaXRlbXNbMF0uX2ludGVybmFsX3kgLyBzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX2hlaWdodCgpKTtcbiAgICAgICAgICAgIGRhdGEuX2ludGVybmFsX2l0ZW1zWzBdLl9pbnRlcm5hbF90aW1lID0gdGltZVBvaW50SW5kZXg7XG4gICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF9pdGVtc1swXS5faW50ZXJuYWxfeCA9IHRpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhUb0Nvb3JkaW5hdGUodGltZVBvaW50SW5kZXgpO1xuICAgICAgICAgICAgZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID0gcmFuZ2VGb3JTaW5nbGVQb2ludDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBCaXRtYXBDb29yZGluYXRlc1BhbmVSZW5kZXJlciB7XG4gICAgX2ludGVybmFsX2RyYXcodGFyZ2V0LCBpc0hvdmVyZWQsIGhpdFRlc3REYXRhKSB7XG4gICAgICAgIHRhcmdldC51c2VCaXRtYXBDb29yZGluYXRlU3BhY2UoKHNjb3BlKSA9PiB0aGlzLl9pbnRlcm5hbF9fZHJhd0ltcGwoc2NvcGUsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpKTtcbiAgICB9XG59XG5cbmNsYXNzIENyb3NzaGFpclJlbmRlcmVyIGV4dGVuZHMgQml0bWFwQ29vcmRpbmF0ZXNQYW5lUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZHJhd0ltcGwoeyBjb250ZXh0OiBjdHgsIGJpdG1hcFNpemUsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZlcnRMaW5lc1Zpc2libGUgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92ZXJ0TGluZS5faW50ZXJuYWxfdmlzaWJsZTtcbiAgICAgICAgY29uc3QgaG9yekxpbmVzVmlzaWJsZSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2hvcnpMaW5lLl9pbnRlcm5hbF92aXNpYmxlO1xuICAgICAgICBpZiAoIXZlcnRMaW5lc1Zpc2libGUgJiYgIWhvcnpMaW5lc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gTWF0aC5yb3VuZCh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZCh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF95ICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgICAgIGlmICh2ZXJ0TGluZXNWaXNpYmxlICYmIHggPj0gMCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGguZmxvb3IodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmVydExpbmUuX2ludGVybmFsX2xpbmVXaWR0aCAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3ZlcnRMaW5lLl9pbnRlcm5hbF9jb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92ZXJ0TGluZS5faW50ZXJuYWxfY29sb3I7XG4gICAgICAgICAgICBzZXRMaW5lU3R5bGUoY3R4LCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92ZXJ0TGluZS5faW50ZXJuYWxfbGluZVN0eWxlKTtcbiAgICAgICAgICAgIGRyYXdWZXJ0aWNhbExpbmUoY3R4LCB4LCAwLCBiaXRtYXBTaXplLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvcnpMaW5lc1Zpc2libGUgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5mbG9vcih0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfbGluZVdpZHRoICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2hvcnpMaW5lLl9pbnRlcm5hbF9jb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfY29sb3I7XG4gICAgICAgICAgICBzZXRMaW5lU3R5bGUoY3R4LCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfbGluZVN0eWxlKTtcbiAgICAgICAgICAgIGRyYXdIb3Jpem9udGFsTGluZShjdHgsIHksIDAsIGJpdG1hcFNpemUud2lkdGgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDcm9zc2hhaXJQYW5lVmlldyB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJEYXRhID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX3ZlcnRMaW5lOiB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2xpbmVXaWR0aDogMSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfbGluZVN0eWxlOiAwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9jb2xvcjogJycsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ob3J6TGluZToge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lV2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2xpbmVTdHlsZTogMCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfY29sb3I6ICcnLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW50ZXJuYWxfeDogMCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF95OiAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlciA9IG5ldyBDcm9zc2hhaXJSZW5kZXJlcih0aGlzLl9wcml2YXRlX19yZW5kZXJlckRhdGEpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUltcGwoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlSW1wbCgpIHtcbiAgICAgICAgY29uc3QgdmlzaWJsZSA9IHRoaXMuX3ByaXZhdGVfX3NvdXJjZS5faW50ZXJuYWxfdmlzaWJsZSgpO1xuICAgICAgICBjb25zdCBwYW5lID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19zb3VyY2UuX2ludGVybmFsX3BhbmUoKSk7XG4gICAgICAgIGNvbnN0IGNyb3NzaGFpck9wdGlvbnMgPSBwYW5lLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9vcHRpb25zKCkuY3Jvc3NoYWlyO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJEYXRhO1xuICAgICAgICBpZiAoY3Jvc3NoYWlyT3B0aW9ucy5tb2RlID09PSAyIC8qIENyb3NzaGFpck1vZGUuSGlkZGVuICovKSB7XG4gICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgZGF0YS5faW50ZXJuYWxfdmVydExpbmUuX2ludGVybmFsX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfdmlzaWJsZSA9IHZpc2libGUgJiYgdGhpcy5fcHJpdmF0ZV9fc291cmNlLl9pbnRlcm5hbF9ob3J6TGluZVZpc2libGUocGFuZSk7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3ZlcnRMaW5lLl9pbnRlcm5hbF92aXNpYmxlID0gdmlzaWJsZSAmJiB0aGlzLl9wcml2YXRlX19zb3VyY2UuX2ludGVybmFsX3ZlcnRMaW5lVmlzaWJsZSgpO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfbGluZVdpZHRoID0gY3Jvc3NoYWlyT3B0aW9ucy5ob3J6TGluZS53aWR0aDtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfaG9yekxpbmUuX2ludGVybmFsX2xpbmVTdHlsZSA9IGNyb3NzaGFpck9wdGlvbnMuaG9yekxpbmUuc3R5bGU7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX2hvcnpMaW5lLl9pbnRlcm5hbF9jb2xvciA9IGNyb3NzaGFpck9wdGlvbnMuaG9yekxpbmUuY29sb3I7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3ZlcnRMaW5lLl9pbnRlcm5hbF9saW5lV2lkdGggPSBjcm9zc2hhaXJPcHRpb25zLnZlcnRMaW5lLndpZHRoO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF92ZXJ0TGluZS5faW50ZXJuYWxfbGluZVN0eWxlID0gY3Jvc3NoYWlyT3B0aW9ucy52ZXJ0TGluZS5zdHlsZTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfdmVydExpbmUuX2ludGVybmFsX2NvbG9yID0gY3Jvc3NoYWlyT3B0aW9ucy52ZXJ0TGluZS5jb2xvcjtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfeCA9IHRoaXMuX3ByaXZhdGVfX3NvdXJjZS5faW50ZXJuYWxfYXBwbGllZFgoKTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfeSA9IHRoaXMuX3ByaXZhdGVfX3NvdXJjZS5faW50ZXJuYWxfYXBwbGllZFkoKTtcbiAgICB9XG59XG5cbi8qKlxuICogRmlsbHMgcmVjdGFuZ2xlJ3MgaW5uZXIgYm9yZGVyIChzbywgYWxsIHRoZSBmaWxsZWQgYXJlYSBpcyBsaW1pdGVkIGJ5IHRoZSBbeCwgeCArIHdpZHRoXSpbeSwgeSArIGhlaWdodF0gcmVnaW9uKVxuICogYGBgXG4gKiAoeCwgeSlcbiAqIE8qKioqKioqKioqKioqKioqKioqKioqKnwqKioqKlxuICogfCAgICAgICAgYm9yZGVyICAgICAgICAgfCAgXlxuICogfCAgICoqKioqKioqKioqKioqKioqICAgfCAgfFxuICogfCAgIHwgICAgICAgICAgICAgICB8ICAgfCAgfFxuICogfCBiIHwgICAgICAgICAgICAgICB8IGIgfCAgaFxuICogfCBvIHwgICAgICAgICAgICAgICB8IG8gfCAgZVxuICogfCByIHwgICAgICAgICAgICAgICB8IHIgfCAgaVxuICogfCBkIHwgICAgICAgICAgICAgICB8IGQgfCAgZ1xuICogfCBlIHwgICAgICAgICAgICAgICB8IGUgfCAgaFxuICogfCByIHwgICAgICAgICAgICAgICB8IHIgfCAgdFxuICogfCAgIHwgICAgICAgICAgICAgICB8ICAgfCAgfFxuICogfCAgICoqKioqKioqKioqKioqKioqICAgfCAgfFxuICogfCAgICAgICAgYm9yZGVyICAgICAgICAgfCAgdlxuICogfCoqKioqKioqKioqKioqKioqKioqKioqfCoqKioqXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8PC0tLS0tLS0gd2lkdGggLS0tLS0tLT58XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY3R4IC0gQ29udGV4dCB0byBkcmF3IG9uXG4gKiBAcGFyYW0geCAtIExlZnQgc2lkZSBvZiB0aGUgdGFyZ2V0IHJlY3RhbmdsZVxuICogQHBhcmFtIHkgLSBUb3Agc2lkZSBvZiB0aGUgdGFyZ2V0IHJlY3RhbmdsZVxuICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgdGhlIHRhcmdldCByZWN0YW5nbGVcbiAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHRhcmdldCByZWN0YW5nbGVcbiAqIEBwYXJhbSBib3JkZXJXaWR0aCAtIFdpZHRoIG9mIGJvcmRlciB0byBmaWxsLCBtdXN0IGJlIGxlc3MgdGhhbiB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB0YXJnZXQgcmVjdGFuZ2xlXG4gKi9cbmZ1bmN0aW9uIGZpbGxSZWN0SW5uZXJCb3JkZXIoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBib3JkZXJXaWR0aCkge1xuICAgIC8vIGhvcml6b250YWwgKHRvcCBhbmQgYm90dG9tKSBlZGdlc1xuICAgIGN0eC5maWxsUmVjdCh4ICsgYm9yZGVyV2lkdGgsIHksIHdpZHRoIC0gYm9yZGVyV2lkdGggKiAyLCBib3JkZXJXaWR0aCk7XG4gICAgY3R4LmZpbGxSZWN0KHggKyBib3JkZXJXaWR0aCwgeSArIGhlaWdodCAtIGJvcmRlcldpZHRoLCB3aWR0aCAtIGJvcmRlcldpZHRoICogMiwgYm9yZGVyV2lkdGgpO1xuICAgIC8vIHZlcnRpY2FsIChsZWZ0IGFuZCByaWdodCkgZWRnZXNcbiAgICBjdHguZmlsbFJlY3QoeCwgeSwgYm9yZGVyV2lkdGgsIGhlaWdodCk7XG4gICAgY3R4LmZpbGxSZWN0KHggKyB3aWR0aCAtIGJvcmRlcldpZHRoLCB5LCBib3JkZXJXaWR0aCwgaGVpZ2h0KTtcbn1cbmZ1bmN0aW9uIGNsZWFyUmVjdChjdHgsIHgsIHksIHcsIGgsIGNsZWFyQ29sb3IpIHtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGNsZWFyQ29sb3I7XG4gICAgY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBjaGFuZ2VCb3JkZXJSYWRpdXMoYm9yZGVyUmFkaXVzLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gYm9yZGVyUmFkaXVzLm1hcCgoeCkgPT4geCA9PT0gMCA/IHggOiB4ICsgb2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIGRyYXdSb3VuZFJlY3QoXG4vLyBlc2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LXBhcmFtc1xuY3R4LCB4LCB5LCB3LCBoLCByYWRpaSkge1xuICAgIC8qKlxuICAgICAqIEFzIG9mIE1heSAyMDIzLCBhbGwgb2YgdGhlIG1ham9yIGJyb3dzZXJzIG5vdyBzdXBwb3J0IGN0eC5yb3VuZFJlY3QoKSBzbyB3ZSBzaG91bGRcbiAgICAgKiBiZSBhYmxlIHRvIHN3aXRjaCB0byB0aGUgbmF0aXZlIHZlcnNpb24gc29vbi5cbiAgICAgKi9cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgdyAtIHJhZGlpWzFdLCB5KTtcbiAgICBpZiAocmFkaWlbMV0gIT09IDApIHtcbiAgICAgICAgY3R4LmFyY1RvKHggKyB3LCB5LCB4ICsgdywgeSArIHJhZGlpWzFdLCByYWRpaVsxXSk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHcsIHkgKyBoIC0gcmFkaWlbMl0pO1xuICAgIGlmIChyYWRpaVsyXSAhPT0gMCkge1xuICAgICAgICBjdHguYXJjVG8oeCArIHcsIHkgKyBoLCB4ICsgdyAtIHJhZGlpWzJdLCB5ICsgaCwgcmFkaWlbMl0pO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyByYWRpaVszXSwgeSArIGgpO1xuICAgIGlmIChyYWRpaVszXSAhPT0gMCkge1xuICAgICAgICBjdHguYXJjVG8oeCwgeSArIGgsIHgsIHkgKyBoIC0gcmFkaWlbM10sIHJhZGlpWzNdKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgcmFkaWlbMF0pO1xuICAgIGlmIChyYWRpaVswXSAhPT0gMCkge1xuICAgICAgICBjdHguYXJjVG8oeCwgeSwgeCArIHJhZGlpWzBdLCB5LCByYWRpaVswXSk7XG4gICAgfVxufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbmZ1bmN0aW9uIGRyYXdSb3VuZFJlY3RXaXRoSW5uZXJCb3JkZXIoY3R4LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIGJhY2tncm91bmRDb2xvciwgYm9yZGVyV2lkdGggPSAwLCBib3JkZXJSYWRpdXMgPSBbMCwgMCwgMCwgMF0sIGJvcmRlckNvbG9yID0gJycpIHtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmICghYm9yZGVyV2lkdGggfHwgIWJvcmRlckNvbG9yIHx8IGJvcmRlckNvbG9yID09PSBiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgZHJhd1JvdW5kUmVjdChjdHgsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYWxmQm9yZGVyV2lkdGggPSBib3JkZXJXaWR0aCAvIDI7XG4gICAgLy8gRHJhdyBib2R5XG4gICAgaWYgKGJhY2tncm91bmRDb2xvciAhPT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICBjb25zdCBpbm5lclJhZGlpID0gY2hhbmdlQm9yZGVyUmFkaXVzKGJvcmRlclJhZGl1cywgLWJvcmRlcldpZHRoKTtcbiAgICAgICAgZHJhd1JvdW5kUmVjdChjdHgsIGxlZnQgKyBib3JkZXJXaWR0aCwgdG9wICsgYm9yZGVyV2lkdGgsIHdpZHRoIC0gYm9yZGVyV2lkdGggKiAyLCBoZWlnaHQgLSBib3JkZXJXaWR0aCAqIDIsIGlubmVyUmFkaWkpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICAvLyBEcmF3IGJvcmRlclxuICAgIGlmIChib3JkZXJDb2xvciAhPT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICBjb25zdCBvdXRlclJhZGlpID0gY2hhbmdlQm9yZGVyUmFkaXVzKGJvcmRlclJhZGl1cywgLWhhbGZCb3JkZXJXaWR0aCk7XG4gICAgICAgIGRyYXdSb3VuZFJlY3QoY3R4LCBsZWZ0ICsgaGFsZkJvcmRlcldpZHRoLCB0b3AgKyBoYWxmQm9yZGVyV2lkdGgsIHdpZHRoIC0gYm9yZGVyV2lkdGgsIGhlaWdodCAtIGJvcmRlcldpZHRoLCBvdXRlclJhZGlpKTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuZnVuY3Rpb24gY2xlYXJSZWN0V2l0aEdyYWRpZW50KGN0eCwgeCwgeSwgdywgaCwgdG9wQ29sb3IsIGJvdHRvbUNvbG9yKSB7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgIGNvbnN0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDAsIGgpO1xuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCB0b3BDb2xvcik7XG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIGJvdHRvbUNvbG9yKTtcbiAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG59XG5cbmNsYXNzIFByaWNlQXhpc1ZpZXdSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgY29tbW9uRGF0YSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXREYXRhKGRhdGEsIGNvbW1vbkRhdGEpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0RGF0YShkYXRhLCBjb21tb25EYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb21tb25EYXRhID0gY29tbW9uRGF0YTtcbiAgICB9XG4gICAgX2ludGVybmFsX2hlaWdodChyZW5kZXJlck9wdGlvbnMsIHVzZVNlY29uZExpbmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250U2l6ZSArIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ1RvcCArIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0JvdHRvbTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXcodGFyZ2V0LCByZW5kZXJlck9wdGlvbnMsIHRleHRXaWR0aENhY2hlLCBhbGlnbikge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGUgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0Q29sb3IgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9jb2xvcjtcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gdGhpcy5fcHJpdmF0ZV9fY29tbW9uRGF0YS5faW50ZXJuYWxfYmFja2dyb3VuZDtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSB0YXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKChzY29wZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gc2NvcGUuY29udGV4dDtcbiAgICAgICAgICAgIGN0eC5mb250ID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250O1xuICAgICAgICAgICAgY29uc3QgZ2VvbSA9IHRoaXMuX3ByaXZhdGVfX2NhbGN1bGF0ZUdlb21ldHJ5KHNjb3BlLCByZW5kZXJlck9wdGlvbnMsIHRleHRXaWR0aENhY2hlLCBhbGlnbik7XG4gICAgICAgICAgICBjb25zdCBnYiA9IGdlb20uX2ludGVybmFsX2JpdG1hcDtcbiAgICAgICAgICAgIGNvbnN0IGRyYXdMYWJlbEJvZHkgPSAobGFiZWxCYWNrZ3JvdW5kQ29sb3IsIGxhYmVsQm9yZGVyQ29sb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZ2VvbS5faW50ZXJuYWxfYWxpZ25SaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBkcmF3Um91bmRSZWN0V2l0aElubmVyQm9yZGVyKGN0eCwgZ2IuX2ludGVybmFsX3hPdXRzaWRlLCBnYi5faW50ZXJuYWxfeVRvcCwgZ2IuX2ludGVybmFsX3RvdGFsV2lkdGgsIGdiLl9pbnRlcm5hbF90b3RhbEhlaWdodCwgbGFiZWxCYWNrZ3JvdW5kQ29sb3IsIGdiLl9pbnRlcm5hbF9ob3J6Qm9yZGVyLCBbZ2IuX2ludGVybmFsX3JhZGl1cywgMCwgMCwgZ2IuX2ludGVybmFsX3JhZGl1c10sIGxhYmVsQm9yZGVyQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhd1JvdW5kUmVjdFdpdGhJbm5lckJvcmRlcihjdHgsIGdiLl9pbnRlcm5hbF94SW5zaWRlLCBnYi5faW50ZXJuYWxfeVRvcCwgZ2IuX2ludGVybmFsX3RvdGFsV2lkdGgsIGdiLl9pbnRlcm5hbF90b3RhbEhlaWdodCwgbGFiZWxCYWNrZ3JvdW5kQ29sb3IsIGdiLl9pbnRlcm5hbF9ob3J6Qm9yZGVyLCBbMCwgZ2IuX2ludGVybmFsX3JhZGl1cywgZ2IuX2ludGVybmFsX3JhZGl1cywgMF0sIGxhYmVsQm9yZGVyQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBkcmF3IGJvcmRlclxuICAgICAgICAgICAgLy8gZHJhdyBsYWJlbCBiYWNrZ3JvdW5kXG4gICAgICAgICAgICBkcmF3TGFiZWxCb2R5KGJhY2tncm91bmRDb2xvciwgJ3RyYW5zcGFyZW50Jyk7XG4gICAgICAgICAgICAvLyBkcmF3IHRpY2tcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF90aWNrVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGdiLl9pbnRlcm5hbF94SW5zaWRlLCBnYi5faW50ZXJuYWxfeU1pZCwgZ2IuX2ludGVybmFsX3hUaWNrIC0gZ2IuX2ludGVybmFsX3hJbnNpZGUsIGdiLl9pbnRlcm5hbF90aWNrSGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRyYXcgbGFiZWwgYm9yZGVyIGFib3ZlIHRoZSB0aWNrXG4gICAgICAgICAgICBkcmF3TGFiZWxCb2R5KCd0cmFuc3BhcmVudCcsIGJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICAvLyBkcmF3IHNlcGFyYXRvclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JvcmRlclZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYW5lQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChnZW9tLl9pbnRlcm5hbF9hbGlnblJpZ2h0ID8gZ2IuX2ludGVybmFsX3JpZ2h0IC0gZ2IuX2ludGVybmFsX2hvcnpCb3JkZXIgOiAwLCBnYi5faW50ZXJuYWxfeVRvcCwgZ2IuX2ludGVybmFsX2hvcnpCb3JkZXIsIGdiLl9pbnRlcm5hbF95Qm90dG9tIC0gZ2IuX2ludGVybmFsX3lUb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdlb207XG4gICAgICAgIH0pO1xuICAgICAgICB0YXJnZXQudXNlTWVkaWFDb29yZGluYXRlU3BhY2UoKHsgY29udGV4dDogY3R4IH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdtID0gZ2VvbWV0cnkuX2ludGVybmFsX21lZGlhO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2ZvbnQ7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gZ2VvbWV0cnkuX2ludGVybmFsX2FsaWduUmlnaHQgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF90ZXh0LCBnbS5faW50ZXJuYWxfeFRleHQsIChnbS5faW50ZXJuYWxfeVRvcCArIGdtLl9pbnRlcm5hbF95Qm90dG9tKSAvIDIgKyBnbS5faW50ZXJuYWxfdGV4dE1pZENvcnJlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NhbGN1bGF0ZUdlb21ldHJ5KHNjb3BlLCByZW5kZXJlck9wdGlvbnMsIHRleHRXaWR0aENhY2hlLCBhbGlnbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dDogY3R4LCBiaXRtYXBTaXplLCBtZWRpYVNpemUsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSA9IHNjb3BlO1xuICAgICAgICBjb25zdCB0aWNrU2l6ZSA9ICh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF90aWNrVmlzaWJsZSB8fCAhdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfbW92ZVRleHRUb0ludmlzaWJsZVRpY2spID8gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoIDogMDtcbiAgICAgICAgY29uc3QgaG9yekJvcmRlciA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3NlcGFyYXRvclZpc2libGUgPyByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2JvcmRlclNpemUgOiAwO1xuICAgICAgICBjb25zdCBwYWRkaW5nVG9wID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nVG9wICsgdGhpcy5fcHJpdmF0ZV9fY29tbW9uRGF0YS5faW50ZXJuYWxfYWRkaXRpb25hbFBhZGRpbmdUb3A7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdCb3R0b20gPSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdCb3R0b20gKyB0aGlzLl9wcml2YXRlX19jb21tb25EYXRhLl9pbnRlcm5hbF9hZGRpdGlvbmFsUGFkZGluZ0JvdHRvbTtcbiAgICAgICAgY29uc3QgcGFkZGluZ0lubmVyID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nSW5uZXI7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdPdXRlciA9IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ091dGVyO1xuICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdGV4dDtcbiAgICAgICAgY29uc3QgYWN0dWFsVGV4dEhlaWdodCA9IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udFNpemU7XG4gICAgICAgIGNvbnN0IHRleHRNaWRDb3JyZWN0aW9uID0gdGV4dFdpZHRoQ2FjaGUuX2ludGVybmFsX3lNaWRDb3JyZWN0aW9uKGN0eCwgdGV4dCk7XG4gICAgICAgIGNvbnN0IHRleHRXaWR0aCA9IE1hdGguY2VpbCh0ZXh0V2lkdGhDYWNoZS5faW50ZXJuYWxfbWVhc3VyZVRleHQoY3R4LCB0ZXh0KSk7XG4gICAgICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gYWN0dWFsVGV4dEhlaWdodCArIHBhZGRpbmdUb3AgKyBwYWRkaW5nQm90dG9tO1xuICAgICAgICBjb25zdCB0b3RhbFdpZHRoID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9ib3JkZXJTaXplICsgcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICsgdGV4dFdpZHRoICsgdGlja1NpemU7XG4gICAgICAgIGNvbnN0IHRpY2tIZWlnaHRCaXRtYXAgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHZlcnRpY2FsUGl4ZWxSYXRpbykpO1xuICAgICAgICBsZXQgdG90YWxIZWlnaHRCaXRtYXAgPSBNYXRoLnJvdW5kKHRvdGFsSGVpZ2h0ICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgaWYgKHRvdGFsSGVpZ2h0Qml0bWFwICUgMiAhPT0gdGlja0hlaWdodEJpdG1hcCAlIDIpIHtcbiAgICAgICAgICAgIHRvdGFsSGVpZ2h0Qml0bWFwICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9yekJvcmRlckJpdG1hcCA9IGhvcnpCb3JkZXIgPiAwID8gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihob3J6Qm9yZGVyICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pKSA6IDA7XG4gICAgICAgIGNvbnN0IHRvdGFsV2lkdGhCaXRtYXAgPSBNYXRoLnJvdW5kKHRvdGFsV2lkdGggKiBob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgIC8vIHRpY2sgb3ZlcmxhcHMgc2NhbGUgYm9yZGVyXG4gICAgICAgIGNvbnN0IHRpY2tTaXplQml0bWFwID0gTWF0aC5yb3VuZCh0aWNrU2l6ZSAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgY29uc3QgeU1pZCA9IChfYSA9IHRoaXMuX3ByaXZhdGVfX2NvbW1vbkRhdGEuX2ludGVybmFsX2ZpeGVkQ29vcmRpbmF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5fcHJpdmF0ZV9fY29tbW9uRGF0YS5faW50ZXJuYWxfY29vcmRpbmF0ZTtcbiAgICAgICAgY29uc3QgeU1pZEJpdG1hcCA9IE1hdGgucm91bmQoeU1pZCAqIHZlcnRpY2FsUGl4ZWxSYXRpbykgLSBNYXRoLmZsb29yKHZlcnRpY2FsUGl4ZWxSYXRpbyAqIDAuNSk7XG4gICAgICAgIGNvbnN0IHlUb3BCaXRtYXAgPSBNYXRoLmZsb29yKHlNaWRCaXRtYXAgKyB0aWNrSGVpZ2h0Qml0bWFwIC8gMiAtIHRvdGFsSGVpZ2h0Qml0bWFwIC8gMik7XG4gICAgICAgIGNvbnN0IHlCb3R0b21CaXRtYXAgPSB5VG9wQml0bWFwICsgdG90YWxIZWlnaHRCaXRtYXA7XG4gICAgICAgIGNvbnN0IGFsaWduUmlnaHQgPSBhbGlnbiA9PT0gJ3JpZ2h0JztcbiAgICAgICAgY29uc3QgeEluc2lkZSA9IGFsaWduUmlnaHQgPyBtZWRpYVNpemUud2lkdGggLSBob3J6Qm9yZGVyIDogaG9yekJvcmRlcjtcbiAgICAgICAgY29uc3QgeEluc2lkZUJpdG1hcCA9IGFsaWduUmlnaHQgPyBiaXRtYXBTaXplLndpZHRoIC0gaG9yekJvcmRlckJpdG1hcCA6IGhvcnpCb3JkZXJCaXRtYXA7XG4gICAgICAgIGxldCB4T3V0c2lkZUJpdG1hcDtcbiAgICAgICAgbGV0IHhUaWNrQml0bWFwO1xuICAgICAgICBsZXQgeFRleHQ7XG4gICAgICAgIGlmIChhbGlnblJpZ2h0KSB7XG4gICAgICAgICAgICAvLyAyICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICA2ICA1XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gMyAgICAgICAgICAgICAgIDRcbiAgICAgICAgICAgIHhPdXRzaWRlQml0bWFwID0geEluc2lkZUJpdG1hcCAtIHRvdGFsV2lkdGhCaXRtYXA7XG4gICAgICAgICAgICB4VGlja0JpdG1hcCA9IHhJbnNpZGVCaXRtYXAgLSB0aWNrU2l6ZUJpdG1hcDtcbiAgICAgICAgICAgIHhUZXh0ID0geEluc2lkZSAtIHRpY2tTaXplIC0gcGFkZGluZ0lubmVyIC0gaG9yekJvcmRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIDEgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gNiAgNVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIDQgICAgICAgICAgICAgICAzXG4gICAgICAgICAgICB4T3V0c2lkZUJpdG1hcCA9IHhJbnNpZGVCaXRtYXAgKyB0b3RhbFdpZHRoQml0bWFwO1xuICAgICAgICAgICAgeFRpY2tCaXRtYXAgPSB4SW5zaWRlQml0bWFwICsgdGlja1NpemVCaXRtYXA7XG4gICAgICAgICAgICB4VGV4dCA9IHhJbnNpZGUgKyB0aWNrU2l6ZSArIHBhZGRpbmdJbm5lcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX2FsaWduUmlnaHQ6IGFsaWduUmlnaHQsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYml0bWFwOiB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3lUb3A6IHlUb3BCaXRtYXAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3lNaWQ6IHlNaWRCaXRtYXAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3lCb3R0b206IHlCb3R0b21CaXRtYXAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3RvdGFsV2lkdGg6IHRvdGFsV2lkdGhCaXRtYXAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3RvdGFsSGVpZ2h0OiB0b3RhbEhlaWdodEJpdG1hcCxcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpdCBpcyBiZXR0ZXIgdG8gaGF2ZSBkaWZmZXJlbnQgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgcmFkaWlcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfcmFkaXVzOiAyICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2hvcnpCb3JkZXI6IGhvcnpCb3JkZXJCaXRtYXAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3hPdXRzaWRlOiB4T3V0c2lkZUJpdG1hcCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeEluc2lkZTogeEluc2lkZUJpdG1hcCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeFRpY2s6IHhUaWNrQml0bWFwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90aWNrSGVpZ2h0OiB0aWNrSGVpZ2h0Qml0bWFwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9yaWdodDogYml0bWFwU2l6ZS53aWR0aCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW50ZXJuYWxfbWVkaWE6IHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeVRvcDogeVRvcEJpdG1hcCAvIHZlcnRpY2FsUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeUJvdHRvbTogeUJvdHRvbUJpdG1hcCAvIHZlcnRpY2FsUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeFRleHQ6IHhUZXh0LFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90ZXh0TWlkQ29ycmVjdGlvbjogdGV4dE1pZENvcnJlY3Rpb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuY2xhc3MgUHJpY2VBeGlzVmlldyB7XG4gICAgY29uc3RydWN0b3IoY3Rvcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb21tb25SZW5kZXJlckRhdGEgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfY29vcmRpbmF0ZTogMCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYWNrZ3JvdW5kOiAnIzAwMCcsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYWRkaXRpb25hbFBhZGRpbmdCb3R0b206IDAsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYWRkaXRpb25hbFBhZGRpbmdUb3A6IDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlckRhdGEgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdGV4dDogJycsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdGlja1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbW92ZVRleHRUb0ludmlzaWJsZVRpY2s6IGZhbHNlLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvcmRlckNvbG9yOiAnJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9jb2xvcjogJyNGRkYnLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvcmRlclZpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgX2ludGVybmFsX3NlcGFyYXRvclZpc2libGU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lUmVuZGVyZXJEYXRhID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX3RleHQ6ICcnLFxuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgX2ludGVybmFsX3RpY2tWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9tb3ZlVGV4dFRvSW52aXNpYmxlVGljazogdHJ1ZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3JkZXJDb2xvcjogJycsXG4gICAgICAgICAgICBfaW50ZXJuYWxfY29sb3I6ICcjRkZGJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3JkZXJWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgX2ludGVybmFsX3NlcGFyYXRvclZpc2libGU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyID0gbmV3IChjdG9yIHx8IFByaWNlQXhpc1ZpZXdSZW5kZXJlcikodGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyRGF0YSwgdGhpcy5fcHJpdmF0ZV9fY29tbW9uUmVuZGVyZXJEYXRhKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVJlbmRlcmVyID0gbmV3IChjdG9yIHx8IFByaWNlQXhpc1ZpZXdSZW5kZXJlcikodGhpcy5fcHJpdmF0ZV9fcGFuZVJlbmRlcmVyRGF0YSwgdGhpcy5fcHJpdmF0ZV9fY29tbW9uUmVuZGVyZXJEYXRhKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3RleHQoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZVJlbmRlcmVyRGF0YUlmTmVlZGVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90ZXh0O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY29vcmRpbmF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlUmVuZGVyZXJEYXRhSWZOZWVkZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NvbW1vblJlbmRlcmVyRGF0YS5faW50ZXJuYWxfY29vcmRpbmF0ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaGVpZ2h0KHJlbmRlcmVyT3B0aW9ucywgdXNlU2Vjb25kTGluZSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXIuX2ludGVybmFsX2hlaWdodChyZW5kZXJlck9wdGlvbnMsIHVzZVNlY29uZExpbmUpLCB0aGlzLl9wcml2YXRlX19wYW5lUmVuZGVyZXIuX2ludGVybmFsX2hlaWdodChyZW5kZXJlck9wdGlvbnMsIHVzZVNlY29uZExpbmUpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldEZpeGVkQ29vcmRpbmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NvbW1vblJlbmRlcmVyRGF0YS5faW50ZXJuYWxfZml4ZWRDb29yZGluYXRlIHx8IDA7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRGaXhlZENvb3JkaW5hdGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29tbW9uUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9maXhlZENvb3JkaW5hdGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2lzVmlzaWJsZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlUmVuZGVyZXJEYXRhSWZOZWVkZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgfHwgdGhpcy5fcHJpdmF0ZV9fcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfdmlzaWJsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2lzQXhpc0xhYmVsVmlzaWJsZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlUmVuZGVyZXJEYXRhSWZOZWVkZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlcihwcmljZVNjYWxlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZVJlbmRlcmVyRGF0YUlmTmVlZGVkKCk7XG4gICAgICAgIC8vIGZvcmNlIHVwZGF0ZSB0aWNrVmlzaWJsZSBzdGF0ZSBmcm9tIHByaWNlIHNjYWxlIG9wdGlvbnNcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFuZCB3ZSBjYW4ndCBoYXZlIHByaWNlIGF4aXMgaW4gb3RoZXIgbWV0aG9kc1xuICAgICAgICAvLyAobGlrZSBwYW5lUmVuZGVyZXIgb3IgYW55IG90aGVyIHdobyBjYWxsIF91cGRhdGVSZW5kZXJlckRhdGFJZk5lZWRlZClcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGlja1Zpc2libGUgPSB0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90aWNrVmlzaWJsZSAmJiBwcmljZVNjYWxlLl9pbnRlcm5hbF9vcHRpb25zKCkudGlja3NWaXNpYmxlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90aWNrVmlzaWJsZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3RpY2tWaXNpYmxlICYmIHByaWNlU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKS50aWNrc1Zpc2libGU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YSh0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXJEYXRhLCB0aGlzLl9wcml2YXRlX19jb21tb25SZW5kZXJlckRhdGEpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lUmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEodGhpcy5fcHJpdmF0ZV9fcGFuZVJlbmRlcmVyRGF0YSwgdGhpcy5fcHJpdmF0ZV9fY29tbW9uUmVuZGVyZXJEYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX3BhbmVSZW5kZXJlcigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlUmVuZGVyZXJEYXRhSWZOZWVkZWQoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlckRhdGEsIHRoaXMuX3ByaXZhdGVfX2NvbW1vblJlbmRlcmVyRGF0YSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVSZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YSh0aGlzLl9wcml2YXRlX19wYW5lUmVuZGVyZXJEYXRhLCB0aGlzLl9wcml2YXRlX19jb21tb25SZW5kZXJlckRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZVJlbmRlcmVyO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlUmVuZGVyZXJEYXRhSWZOZWVkZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGlja1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGlja1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX191cGRhdGVSZW5kZXJlckRhdGEodGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyRGF0YSwgdGhpcy5fcHJpdmF0ZV9fcGFuZVJlbmRlcmVyRGF0YSwgdGhpcy5fcHJpdmF0ZV9fY29tbW9uUmVuZGVyZXJEYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ3Jvc3NoYWlyUHJpY2VBeGlzVmlldyBleHRlbmRzIFByaWNlQXhpc1ZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgcHJpY2VTY2FsZSwgdmFsdWVQcm92aWRlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPSBwcmljZVNjYWxlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX192YWx1ZVByb3ZpZGVyID0gdmFsdWVQcm92aWRlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX191cGRhdGVSZW5kZXJlckRhdGEoYXhpc1JlbmRlcmVyRGF0YSwgcGFuZVJlbmRlcmVyRGF0YSwgY29tbW9uUmVuZGVyZXJEYXRhKSB7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3NvdXJjZS5faW50ZXJuYWxfb3B0aW9ucygpLm1vZGUgPT09IDIgLyogQ3Jvc3NoYWlyTW9kZS5IaWRkZW4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fc291cmNlLl9pbnRlcm5hbF9vcHRpb25zKCkuaG9yekxpbmU7XG4gICAgICAgIGlmICghb3B0aW9ucy5sYWJlbFZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3NvdXJjZS5faW50ZXJuYWxfdmlzaWJsZSgpIHx8IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSB8fCAoZmlyc3RWYWx1ZSA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2xvcnMgPSBnZW5lcmF0ZUNvbnRyYXN0Q29sb3JzKG9wdGlvbnMubGFiZWxCYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICBjb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2JhY2tncm91bmQgPSBjb2xvcnMuX2ludGVybmFsX2JhY2tncm91bmQ7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX2NvbG9yID0gY29sb3JzLl9pbnRlcm5hbF9mb3JlZ3JvdW5kO1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsUGFkZGluZyA9IDIgLyAxMiAqIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2ZvbnRTaXplKCk7XG4gICAgICAgIGNvbW1vblJlbmRlcmVyRGF0YS5faW50ZXJuYWxfYWRkaXRpb25hbFBhZGRpbmdUb3AgPSBhZGRpdGlvbmFsUGFkZGluZztcbiAgICAgICAgY29tbW9uUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9hZGRpdGlvbmFsUGFkZGluZ0JvdHRvbSA9IGFkZGl0aW9uYWxQYWRkaW5nO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3ByaXZhdGVfX3ZhbHVlUHJvdmlkZXIodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSk7XG4gICAgICAgIGNvbW1vblJlbmRlcmVyRGF0YS5faW50ZXJuYWxfY29vcmRpbmF0ZSA9IHZhbHVlLl9pbnRlcm5hbF9jb29yZGluYXRlO1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90ZXh0ID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfZm9ybWF0UHJpY2UodmFsdWUuX2ludGVybmFsX3ByaWNlLCBmaXJzdFZhbHVlKTtcbiAgICAgICAgYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IHRydWU7XG4gICAgfVxufVxuXG5jb25zdCBvcHRpbWl6YXRpb25SZXBsYWNlbWVudFJlID0gL1sxLTldL2c7XG5jb25zdCByYWRpdXMkMSA9IDI7XG5jbGFzcyBUaW1lQXhpc1ZpZXdSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZHJhdyh0YXJnZXQsIHJlbmRlcmVyT3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YSA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlID09PSBmYWxzZSB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF90ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHRXaWR0aCA9IHRhcmdldC51c2VNZWRpYUNvb3JkaW5hdGVTcGFjZSgoeyBjb250ZXh0OiBjdHggfSkgPT4ge1xuICAgICAgICAgICAgY3R4LmZvbnQgPSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2ZvbnQ7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChyZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3dpZHRoQ2FjaGUuX2ludGVybmFsX21lYXN1cmVUZXh0KGN0eCwgZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19kYXRhKS5faW50ZXJuYWxfdGV4dCwgb3B0aW1pemF0aW9uUmVwbGFjZW1lbnRSZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRleHRXaWR0aCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9yek1hcmdpbiA9IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0hvcml6b250YWw7XG4gICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0ZXh0V2lkdGggKyAyICogaG9yek1hcmdpbjtcbiAgICAgICAgY29uc3QgbGFiZWxXaWR0aEhhbGYgPSBsYWJlbFdpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgdGltZVNjYWxlV2lkdGggPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF93aWR0aDtcbiAgICAgICAgbGV0IGNvb3JkaW5hdGUgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9jb29yZGluYXRlO1xuICAgICAgICBsZXQgeDEgPSBNYXRoLmZsb29yKGNvb3JkaW5hdGUgLSBsYWJlbFdpZHRoSGFsZikgKyAwLjU7XG4gICAgICAgIGlmICh4MSA8IDApIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlICsgTWF0aC5hYnMoMCAtIHgxKTtcbiAgICAgICAgICAgIHgxID0gTWF0aC5mbG9vcihjb29yZGluYXRlIC0gbGFiZWxXaWR0aEhhbGYpICsgMC41O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHgxICsgbGFiZWxXaWR0aCA+IHRpbWVTY2FsZVdpZHRoKSB7XG4gICAgICAgICAgICBjb29yZGluYXRlID0gY29vcmRpbmF0ZSAtIE1hdGguYWJzKHRpbWVTY2FsZVdpZHRoIC0gKHgxICsgbGFiZWxXaWR0aCkpO1xuICAgICAgICAgICAgeDEgPSBNYXRoLmZsb29yKGNvb3JkaW5hdGUgLSBsYWJlbFdpZHRoSGFsZikgKyAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeDIgPSB4MSArIGxhYmVsV2lkdGg7XG4gICAgICAgIGNvbnN0IHkxID0gMDtcbiAgICAgICAgY29uc3QgeTIgPSBNYXRoLmNlaWwoeTEgK1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9ib3JkZXJTaXplICtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfdGlja0xlbmd0aCArXG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdUb3AgK1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250U2l6ZSArXG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdCb3R0b20pO1xuICAgICAgICB0YXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKCh7IGNvbnRleHQ6IGN0eCwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19kYXRhKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBkYXRhLl9pbnRlcm5hbF9iYWNrZ3JvdW5kO1xuICAgICAgICAgICAgY29uc3QgeDFzY2FsZWQgPSBNYXRoLnJvdW5kKHgxICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgeTFzY2FsZWQgPSBNYXRoLnJvdW5kKHkxICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IHgyc2NhbGVkID0gTWF0aC5yb3VuZCh4MiAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IHkyc2NhbGVkID0gTWF0aC5yb3VuZCh5MiAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCByYWRpdXNTY2FsZWQgPSBNYXRoLnJvdW5kKHJhZGl1cyQxICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MXNjYWxlZCwgeTFzY2FsZWQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4MXNjYWxlZCwgeTJzY2FsZWQgLSByYWRpdXNTY2FsZWQpO1xuICAgICAgICAgICAgY3R4LmFyY1RvKHgxc2NhbGVkLCB5MnNjYWxlZCwgeDFzY2FsZWQgKyByYWRpdXNTY2FsZWQsIHkyc2NhbGVkLCByYWRpdXNTY2FsZWQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4MnNjYWxlZCAtIHJhZGl1c1NjYWxlZCwgeTJzY2FsZWQpO1xuICAgICAgICAgICAgY3R4LmFyY1RvKHgyc2NhbGVkLCB5MnNjYWxlZCwgeDJzY2FsZWQsIHkyc2NhbGVkIC0gcmFkaXVzU2NhbGVkLCByYWRpdXNTY2FsZWQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4MnNjYWxlZCwgeTFzY2FsZWQpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGlmIChkYXRhLl9pbnRlcm5hbF90aWNrVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tYID0gTWF0aC5yb3VuZChkYXRhLl9pbnRlcm5hbF9jb29yZGluYXRlICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tUb3AgPSB5MXNjYWxlZDtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrQm90dG9tID0gTWF0aC5yb3VuZCgodGlja1RvcCArIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfdGlja0xlbmd0aCkgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBkYXRhLl9pbnRlcm5hbF9jb2xvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrV2lkdGggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGhvcml6b250YWxQaXhlbFJhdGlvKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja09mZnNldCA9IE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8gKiAwLjUpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh0aWNrWCAtIHRpY2tPZmZzZXQsIHRpY2tUb3AsIHRpY2tXaWR0aCwgdGlja0JvdHRvbSAtIHRpY2tUb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGFyZ2V0LnVzZU1lZGlhQ29vcmRpbmF0ZVNwYWNlKCh7IGNvbnRleHQ6IGN0eCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19kYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHlUZXh0ID0geTEgK1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfYm9yZGVyU2l6ZSArXG4gICAgICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoICtcbiAgICAgICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdUb3AgK1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udFNpemUgLyAyO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2ZvbnQ7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGRhdGEuX2ludGVybmFsX2NvbG9yO1xuICAgICAgICAgICAgY29uc3QgdGV4dFlDb3JyZWN0aW9uID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF93aWR0aENhY2hlLl9pbnRlcm5hbF95TWlkQ29ycmVjdGlvbihjdHgsICdBcHIwJyk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgxICsgaG9yek1hcmdpbiwgeVRleHQgKyB0ZXh0WUNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGRhdGEuX2ludGVybmFsX3RleHQsIDAsIDApO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIENyb3NzaGFpclRpbWVBeGlzVmlldyB7XG4gICAgY29uc3RydWN0b3IoY3Jvc3NoYWlyLCBtb2RlbCwgdmFsdWVQcm92aWRlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyID0gbmV3IFRpbWVBeGlzVmlld1JlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyRGF0YSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYWNrZ3JvdW5kOiAnIzRjNTI1ZScsXG4gICAgICAgICAgICBfaW50ZXJuYWxfY29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdGV4dDogJycsXG4gICAgICAgICAgICBfaW50ZXJuYWxfd2lkdGg6IDAsXG4gICAgICAgICAgICBfaW50ZXJuYWxfY29vcmRpbmF0ZTogTmFOLFxuICAgICAgICAgICAgX2ludGVybmFsX3RpY2tWaXNpYmxlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIgPSBjcm9zc2hhaXI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ZhbHVlUHJvdmlkZXIgPSB2YWx1ZVByb3ZpZGVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVJbXBsKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyRGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yZW5kZXJlcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3VwZGF0ZUltcGwoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9wcml2YXRlX19yZW5kZXJlckRhdGE7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfb3B0aW9ucygpLm1vZGUgPT09IDIgLyogQ3Jvc3NoYWlyTW9kZS5IaWRkZW4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyLl9pbnRlcm5hbF9vcHRpb25zKCkudmVydExpbmU7XG4gICAgICAgIGlmICghb3B0aW9ucy5sYWJlbFZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lU2NhbGUgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIGlmICh0aW1lU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3dpZHRoID0gdGltZVNjYWxlLl9pbnRlcm5hbF93aWR0aCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3ByaXZhdGVfX3ZhbHVlUHJvdmlkZXIoKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5faW50ZXJuYWxfY29vcmRpbmF0ZSA9IHZhbHVlLl9pbnRlcm5hbF9jb29yZGluYXRlO1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IHRpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhUb1RpbWVTY2FsZVBvaW50KHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfYXBwbGllZEluZGV4KCkpO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF90ZXh0ID0gdGltZVNjYWxlLl9pbnRlcm5hbF9mb3JtYXREYXRlVGltZShlbnN1cmVOb3ROdWxsKGN1cnJlbnRUaW1lKSk7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICBjb25zdCBjb2xvcnMgPSBnZW5lcmF0ZUNvbnRyYXN0Q29sb3JzKG9wdGlvbnMubGFiZWxCYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9iYWNrZ3JvdW5kID0gY29sb3JzLl9pbnRlcm5hbF9iYWNrZ3JvdW5kO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9jb2xvciA9IGNvbG9ycy5faW50ZXJuYWxfZm9yZWdyb3VuZDtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfdGlja1Zpc2libGUgPSB0aW1lU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKS50aWNrc1Zpc2libGU7XG4gICAgfVxufVxuXG5jbGFzcyBEYXRhU291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3ByaWNlU2NhbGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX196b3JkZXIgPSAwO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfem9yZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fem9yZGVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0Wm9yZGVyKHpvcmRlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX196b3JkZXIgPSB6b3JkZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZVNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3ByaWNlU2NhbGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRQcmljZVNjYWxlKHByaWNlU2NhbGUpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3ByaWNlU2NhbGUgPSBwcmljZVNjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbGFiZWxQYW5lVmlld3MocGFuZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aW1lQXhpc1ZpZXdzKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIF9pbnRlcm5hbF92aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY3Jvc3NoYWlyIG1vZGUuXG4gKi9cbnZhciBDcm9zc2hhaXJNb2RlO1xuKGZ1bmN0aW9uIChDcm9zc2hhaXJNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBtb2RlIGFsbG93cyBjcm9zc2hhaXIgdG8gbW92ZSBmcmVlbHkgb24gdGhlIGNoYXJ0LlxuICAgICAqL1xuICAgIENyb3NzaGFpck1vZGVbQ3Jvc3NoYWlyTW9kZVtcIk5vcm1hbFwiXSA9IDBdID0gXCJOb3JtYWxcIjtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZGUgc3RpY2tzIGNyb3NzaGFpcidzIGhvcml6b250YWwgbGluZSB0byB0aGUgcHJpY2UgdmFsdWUgb2YgYSBzaW5nbGUtdmFsdWUgc2VyaWVzIG9yIHRvIHRoZSBjbG9zZSBwcmljZSBvZiBPSExDLWJhc2VkIHNlcmllcy5cbiAgICAgKi9cbiAgICBDcm9zc2hhaXJNb2RlW0Nyb3NzaGFpck1vZGVbXCJNYWduZXRcIl0gPSAxXSA9IFwiTWFnbmV0XCI7XG4gICAgLyoqXG4gICAgICogVGhpcyBtb2RlIGRpc2FibGVzIHJlbmRlcmluZyBvZiB0aGUgY3Jvc3NoYWlyLlxuICAgICAqL1xuICAgIENyb3NzaGFpck1vZGVbQ3Jvc3NoYWlyTW9kZVtcIkhpZGRlblwiXSA9IDJdID0gXCJIaWRkZW5cIjtcbn0pKENyb3NzaGFpck1vZGUgfHwgKENyb3NzaGFpck1vZGUgPSB7fSkpO1xuY2xhc3MgQ3Jvc3NoYWlyIGV4dGVuZHMgRGF0YVNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IobW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlID0gTmFOO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX194ID0gTmFOO1xuICAgICAgICB0aGlzLl9wcml2YXRlX195ID0gTmFOO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcmlnaW5YID0gTmFOO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcmlnaW5ZID0gTmFOO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1BhbmVWaWV3ID0gbmV3IENyb3NzaGFpck1hcmtzUGFuZVZpZXcobW9kZWwsIHRoaXMpO1xuICAgICAgICBjb25zdCB2YWx1ZVByaWNlUHJvdmlkZXIgPSAocmF3UHJpY2VQcm92aWRlciwgcmF3Q29vcmRpbmF0ZVByb3ZpZGVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHByaWNlU2NhbGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb29yZGluYXRlID0gcmF3Q29vcmRpbmF0ZVByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3UHJpY2UgPSByYXdQcmljZVByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHByaWNlU2NhbGUgPT09IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fcGFuZSkuX2ludGVybmFsX2RlZmF1bHRQcmljZVNjYWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJpY2UgbXVzdCBiZSBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IF9pbnRlcm5hbF9wcmljZTogcmF3UHJpY2UsIF9pbnRlcm5hbF9jb29yZGluYXRlOiBjb29yZGluYXRlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbHdheXMgY29udmVydCBmcm9tIGNvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IGVuc3VyZU5vdE51bGwocHJpY2VTY2FsZS5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJpY2UgPSBwcmljZVNjYWxlLl9pbnRlcm5hbF9jb29yZGluYXRlVG9QcmljZShjb29yZGluYXRlLCBmaXJzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgX2ludGVybmFsX3ByaWNlOiBwcmljZSwgX2ludGVybmFsX2Nvb3JkaW5hdGU6IGNvb3JkaW5hdGUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB2YWx1ZVRpbWVQcm92aWRlciA9IChyYXdJbmRleFByb3ZpZGVyLCByYXdDb29yZGluYXRlUHJvdmlkZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZSA9IHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfaW5kZXhUb1RpbWUocmF3SW5kZXhQcm92aWRlcigpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb29yZGluYXRlID0gcmF3Q29vcmRpbmF0ZVByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aW1lIHx8ICFOdW1iZXIuaXNGaW5pdGUoY29vcmRpbmF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90aW1lOiB0aW1lLFxuICAgICAgICAgICAgICAgICAgICBfaW50ZXJuYWxfY29vcmRpbmF0ZTogY29vcmRpbmF0ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZm9yIGN1cnJlbnQgcG9zaXRpb24gYWx3YXlzIHJldHVybiBib3RoIHByaWNlIGFuZCBjb29yZGluYXRlXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2N1cnJlbnRQb3NQcmljZVByb3ZpZGVyID0gdmFsdWVQcmljZVByb3ZpZGVyKCgpID0+IHRoaXMuX3ByaXZhdGVfX3ByaWNlLCAoKSA9PiB0aGlzLl9wcml2YXRlX195KTtcbiAgICAgICAgY29uc3QgY3VycmVudFBvc1RpbWVQcm92aWRlciA9IHZhbHVlVGltZVByb3ZpZGVyKCgpID0+IHRoaXMuX3ByaXZhdGVfX2luZGV4LCAoKSA9PiB0aGlzLl9pbnRlcm5hbF9hcHBsaWVkWCgpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNWaWV3ID0gbmV3IENyb3NzaGFpclRpbWVBeGlzVmlldyh0aGlzLCBtb2RlbCwgY3VycmVudFBvc1RpbWVQcm92aWRlcik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3ID0gbmV3IENyb3NzaGFpclBhbmVWaWV3KHRoaXMpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zYXZlT3JpZ2luQ29vcmQoeCwgeSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcmlnaW5YID0geDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3JpZ2luWSA9IHk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jbGVhck9yaWdpbkNvb3JkKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcmlnaW5YID0gTmFOO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcmlnaW5ZID0gTmFOO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb3JpZ2luQ29vcmRYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3JpZ2luWDtcbiAgICB9XG4gICAgX2ludGVybmFsX29yaWdpbkNvb3JkWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29yaWdpblk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRQb3NpdGlvbihpbmRleCwgcHJpY2UsIHBhbmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdHJ5VG9VcGRhdGVWaWV3cyhpbmRleCwgcHJpY2UsIHBhbmUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbGllZEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faW5kZXg7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBsaWVkWCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3g7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBsaWVkWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3k7XG4gICAgfVxuICAgIF9pbnRlcm5hbF92aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2NsZWFyUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2V0SW5kZXhUb0xhc3RTZXJpZXNCYXJJbmRleCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZSA9IE5hTjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9feCA9IE5hTjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9feSA9IE5hTjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX2NsZWFyT3JpZ2luQ29vcmQoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3BhbmVWaWV3cyhwYW5lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lICE9PSBudWxsID8gW3RoaXMuX3ByaXZhdGVfX3BhbmVWaWV3LCB0aGlzLl9wcml2YXRlX19tYXJrZXJzUGFuZVZpZXddIDogW107XG4gICAgfVxuICAgIF9pbnRlcm5hbF9ob3J6TGluZVZpc2libGUocGFuZSkge1xuICAgICAgICByZXR1cm4gcGFuZSA9PT0gdGhpcy5fcHJpdmF0ZV9fcGFuZSAmJiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmhvcnpMaW5lLnZpc2libGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF92ZXJ0TGluZVZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLnZlcnRMaW5lLnZpc2libGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZUF4aXNWaWV3cyhwYW5lLCBwcmljZVNjYWxlKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZSB8fCB0aGlzLl9wcml2YXRlX19wYW5lICE9PSBwYW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3cy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXdzID0gW107XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wYW5lID09PSBwYW5lKSB7XG4gICAgICAgICAgICB2aWV3cy5wdXNoKHRoaXMuX3ByaXZhdGVfX2NyZWF0ZVByaWNlQXhpc1ZpZXdPbkRlbWFuZCh0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3cywgcHJpY2VTY2FsZSwgdGhpcy5fcHJpdmF0ZV9fY3VycmVudFBvc1ByaWNlUHJvdmlkZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld3M7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aW1lQXhpc1ZpZXdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZSA/IFt0aGlzLl9wcml2YXRlX190aW1lQXhpc1ZpZXddIDogW107XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZUFsbFZpZXdzKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlldy5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdzLmZvckVhY2goKHZhbHVlKSA9PiB2YWx1ZS5faW50ZXJuYWxfdXBkYXRlKCkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1ZpZXcuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzUGFuZVZpZXcuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcHJpY2VTY2FsZUJ5UGFuZShwYW5lKSB7XG4gICAgICAgIGlmIChwYW5lICYmICFwYW5lLl9pbnRlcm5hbF9kZWZhdWx0UHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5lLl9pbnRlcm5hbF9kZWZhdWx0UHJpY2VTY2FsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdHJ5VG9VcGRhdGVWaWV3cyhpbmRleCwgcHJpY2UsIHBhbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3RyeVRvVXBkYXRlRGF0YShpbmRleCwgcHJpY2UsIHBhbmUpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX190cnlUb1VwZGF0ZURhdGEobmV3SW5kZXgsIG5ld1ByaWNlLCBuZXdQYW5lKSB7XG4gICAgICAgIGNvbnN0IG9sZFggPSB0aGlzLl9wcml2YXRlX194O1xuICAgICAgICBjb25zdCBvbGRZID0gdGhpcy5fcHJpdmF0ZV9feTtcbiAgICAgICAgY29uc3Qgb2xkUHJpY2UgPSB0aGlzLl9wcml2YXRlX19wcmljZTtcbiAgICAgICAgY29uc3Qgb2xkSW5kZXggPSB0aGlzLl9wcml2YXRlX19pbmRleDtcbiAgICAgICAgY29uc3Qgb2xkUGFuZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmU7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlQnlQYW5lKG5ld1BhbmUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbmRleCA9IG5ld0luZGV4O1xuICAgICAgICB0aGlzLl9wcml2YXRlX194ID0gaXNOYU4obmV3SW5kZXgpID8gTmFOIDogdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9pbmRleFRvQ29vcmRpbmF0ZShuZXdJbmRleCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUgPSBuZXdQYW5lO1xuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gcHJpY2VTY2FsZSAhPT0gbnVsbCA/IHByaWNlU2NhbGUuX2ludGVybmFsX2ZpcnN0VmFsdWUoKSA6IG51bGw7XG4gICAgICAgIGlmIChwcmljZVNjYWxlICE9PSBudWxsICYmIGZpcnN0VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlID0gbmV3UHJpY2U7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX195ID0gcHJpY2VTY2FsZS5faW50ZXJuYWxfcHJpY2VUb0Nvb3JkaW5hdGUobmV3UHJpY2UsIGZpcnN0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2UgPSBOYU47XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX195ID0gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAob2xkWCAhPT0gdGhpcy5fcHJpdmF0ZV9feCB8fCBvbGRZICE9PSB0aGlzLl9wcml2YXRlX195IHx8IG9sZEluZGV4ICE9PSB0aGlzLl9wcml2YXRlX19pbmRleCB8fFxuICAgICAgICAgICAgb2xkUHJpY2UgIT09IHRoaXMuX3ByaXZhdGVfX3ByaWNlIHx8IG9sZFBhbmUgIT09IHRoaXMuX3ByaXZhdGVfX3BhbmUpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2V0SW5kZXhUb0xhc3RTZXJpZXNCYXJJbmRleCgpIHtcbiAgICAgICAgY29uc3QgbGFzdEluZGV4ZXMgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2VyaWVzZXMoKVxuICAgICAgICAgICAgLm1hcCgocykgPT4gcy5faW50ZXJuYWxfYmFycygpLl9pbnRlcm5hbF9sYXN0SW5kZXgoKSlcbiAgICAgICAgICAgIC5maWx0ZXIobm90TnVsbCk7XG4gICAgICAgIGNvbnN0IGxhc3RCYXJJbmRleCA9IChsYXN0SW5kZXhlcy5sZW5ndGggPT09IDApID8gbnVsbCA6IE1hdGgubWF4KC4uLmxhc3RJbmRleGVzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5kZXggPSBsYXN0QmFySW5kZXggIT09IG51bGwgPyBsYXN0QmFySW5kZXggOiBOYU47XG4gICAgfVxuICAgIF9wcml2YXRlX19jcmVhdGVQcmljZUF4aXNWaWV3T25EZW1hbmQobWFwLCBwcmljZVNjYWxlLCB2YWx1ZVByb3ZpZGVyKSB7XG4gICAgICAgIGxldCB2aWV3ID0gbWFwLmdldChwcmljZVNjYWxlKTtcbiAgICAgICAgaWYgKHZpZXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmlldyA9IG5ldyBDcm9zc2hhaXJQcmljZUF4aXNWaWV3KHRoaXMsIHByaWNlU2NhbGUsIHZhbHVlUHJvdmlkZXIpO1xuICAgICAgICAgICAgbWFwLnNldChwcmljZVNjYWxlLCB2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRGVmYXVsdFByaWNlU2NhbGUocHJpY2VTY2FsZUlkKSB7XG4gICAgcmV0dXJuIHByaWNlU2NhbGVJZCA9PT0gXCJsZWZ0XCIgLyogRGVmYXVsdFByaWNlU2NhbGVJZC5MZWZ0ICovIHx8IHByaWNlU2NhbGVJZCA9PT0gXCJyaWdodFwiIC8qIERlZmF1bHRQcmljZVNjYWxlSWQuUmlnaHQgKi87XG59XG5cbmZ1bmN0aW9uIG1lcmdlUGFuZUludmFsaWRhdGlvbihiZWZvcmVWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAoYmVmb3JlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gTWF0aC5tYXgoYmVmb3JlVmFsdWUuX2ludGVybmFsX2xldmVsLCBuZXdWYWx1ZS5faW50ZXJuYWxfbGV2ZWwpO1xuICAgIGNvbnN0IGF1dG9TY2FsZSA9IGJlZm9yZVZhbHVlLl9pbnRlcm5hbF9hdXRvU2NhbGUgfHwgbmV3VmFsdWUuX2ludGVybmFsX2F1dG9TY2FsZTtcbiAgICByZXR1cm4geyBfaW50ZXJuYWxfbGV2ZWw6IGxldmVsLCBfaW50ZXJuYWxfYXV0b1NjYWxlOiBhdXRvU2NhbGUgfTtcbn1cbmNsYXNzIEludmFsaWRhdGVNYXNrIHtcbiAgICBjb25zdHJ1Y3RvcihnbG9iYWxMZXZlbCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZFBhbmVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2dsb2JhbExldmVsID0gZ2xvYmFsTGV2ZWw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pbnZhbGlkYXRlUGFuZShwYW5lSW5kZXgsIGludmFsaWRhdGlvbikge1xuICAgICAgICBjb25zdCBwcmV2VmFsdWUgPSB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZFBhbmVzLmdldChwYW5lSW5kZXgpO1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG1lcmdlUGFuZUludmFsaWRhdGlvbihwcmV2VmFsdWUsIGludmFsaWRhdGlvbik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkUGFuZXMuc2V0KHBhbmVJbmRleCwgbmV3VmFsdWUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZnVsbEludmFsaWRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2dsb2JhbExldmVsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaW52YWxpZGF0ZUZvclBhbmUocGFuZUluZGV4KSB7XG4gICAgICAgIGNvbnN0IHBhbmVJbnZhbGlkYXRpb24gPSB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZFBhbmVzLmdldChwYW5lSW5kZXgpO1xuICAgICAgICBpZiAocGFuZUludmFsaWRhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9sZXZlbDogdGhpcy5fcHJpdmF0ZV9fZ2xvYmFsTGV2ZWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfbGV2ZWw6IE1hdGgubWF4KHRoaXMuX3ByaXZhdGVfX2dsb2JhbExldmVsLCBwYW5lSW52YWxpZGF0aW9uLl9pbnRlcm5hbF9sZXZlbCksXG4gICAgICAgICAgICBfaW50ZXJuYWxfYXV0b1NjYWxlOiBwYW5lSW52YWxpZGF0aW9uLl9pbnRlcm5hbF9hdXRvU2NhbGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRGaXRDb250ZW50KCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIC8vIG1vZGlmaWVzIGJvdGggYmFyIHNwYWNpbmcgYW5kIHJpZ2h0IG9mZnNldFxuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zID0gW3sgX2ludGVybmFsX3R5cGU6IDAgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5GaXRDb250ZW50ICovIH1dO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlSYW5nZShyYW5nZSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIC8vIG1vZGlmaWVzIGJvdGggYmFyIHNwYWNpbmcgYW5kIHJpZ2h0IG9mZnNldFxuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zID0gW3sgX2ludGVybmFsX3R5cGU6IDEgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BcHBseVJhbmdlICovLCBfaW50ZXJuYWxfdmFsdWU6IHJhbmdlIH1dO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0VGltZVNjYWxlQW5pbWF0aW9uKGFuaW1hdGlvbikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW1vdmVUaW1lU2NhbGVBbmltYXRpb24oKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlSW52YWxpZGF0aW9ucy5wdXNoKHsgX2ludGVybmFsX3R5cGU6IDUgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BbmltYXRpb24gKi8sIF9pbnRlcm5hbF92YWx1ZTogYW5pbWF0aW9uIH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RvcFRpbWVTY2FsZUFuaW1hdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVtb3ZlVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZUludmFsaWRhdGlvbnMucHVzaCh7IF9pbnRlcm5hbF90eXBlOiA2IC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuU3RvcEFuaW1hdGlvbiAqLyB9KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Jlc2V0VGltZVNjYWxlKCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIC8vIG1vZGlmaWVzIGJvdGggYmFyIHNwYWNpbmcgYW5kIHJpZ2h0IG9mZnNldFxuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zID0gW3sgX2ludGVybmFsX3R5cGU6IDQgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5SZXNldCAqLyB9XTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldEJhclNwYWNpbmcoYmFyU3BhY2luZykge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZUludmFsaWRhdGlvbnMucHVzaCh7IF9pbnRlcm5hbF90eXBlOiAyIC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuQXBwbHlCYXJTcGFjaW5nICovLCBfaW50ZXJuYWxfdmFsdWU6IGJhclNwYWNpbmcgfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRSaWdodE9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc3RvcFRpbWVTY2FsZUFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zLnB1c2goeyBfaW50ZXJuYWxfdHlwZTogMyAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLkFwcGx5UmlnaHRPZmZzZXQgKi8sIF9pbnRlcm5hbF92YWx1ZTogb2Zmc2V0IH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGltZVNjYWxlSW52YWxpZGF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZUludmFsaWRhdGlvbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tZXJnZShvdGhlcikge1xuICAgICAgICBmb3IgKGNvbnN0IHRzSW52YWxpZGF0aW9uIG9mIG90aGVyLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hcHBseVRpbWVTY2FsZUludmFsaWRhdGlvbih0c0ludmFsaWRhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZ2xvYmFsTGV2ZWwgPSBNYXRoLm1heCh0aGlzLl9wcml2YXRlX19nbG9iYWxMZXZlbCwgb3RoZXIuX3ByaXZhdGVfX2dsb2JhbExldmVsKTtcbiAgICAgICAgb3RoZXIuX3ByaXZhdGVfX2ludmFsaWRhdGVkUGFuZXMuZm9yRWFjaCgoaW52YWxpZGF0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfaW52YWxpZGF0ZVBhbmUoaW5kZXgsIGludmFsaWRhdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgX2ludGVybmFsX2xpZ2h0KCkge1xuICAgICAgICByZXR1cm4gbmV3IEludmFsaWRhdGVNYXNrKDIgLyogSW52YWxpZGF0aW9uTGV2ZWwuTGlnaHQgKi8pO1xuICAgIH1cbiAgICBzdGF0aWMgX2ludGVybmFsX2Z1bGwoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW52YWxpZGF0ZU1hc2soMyAvKiBJbnZhbGlkYXRpb25MZXZlbC5GdWxsICovKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2FwcGx5VGltZVNjYWxlSW52YWxpZGF0aW9uKGludmFsaWRhdGlvbikge1xuICAgICAgICBzd2l0Y2ggKGludmFsaWRhdGlvbi5faW50ZXJuYWxfdHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuRml0Q29udGVudCAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRGaXRDb250ZW50KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BcHBseVJhbmdlICovOlxuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2FwcGx5UmFuZ2UoaW52YWxpZGF0aW9uLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BcHBseUJhclNwYWNpbmcgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0QmFyU3BhY2luZyhpbnZhbGlkYXRpb24uX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMyAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLkFwcGx5UmlnaHRPZmZzZXQgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0UmlnaHRPZmZzZXQoaW52YWxpZGF0aW9uLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5SZXNldCAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZXNldFRpbWVTY2FsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1IC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuQW5pbWF0aW9uICovOlxuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldFRpbWVTY2FsZUFuaW1hdGlvbihpbnZhbGlkYXRpb24uX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNiAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLlN0b3BBbmltYXRpb24gKi86XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVtb3ZlVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX3JlbW92ZVRpbWVTY2FsZUFuaW1hdGlvbigpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zLmZpbmRJbmRleCgoaW52KSA9PiBpbnYuX2ludGVybmFsX3R5cGUgPT09IDUgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BbmltYXRpb24gKi8pO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IGZvcm1hdHRlck9wdGlvbnMgPSB7XG4gICAgX2ludGVybmFsX2RlY2ltYWxTaWduOiAnLicsXG4gICAgX2ludGVybmFsX2RlY2ltYWxTaWduRnJhY3Rpb25hbDogJ1xcJycsXG59O1xuLyoqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIG9mIGNvbnZlcnQuXG4gKiBAcGFyYW0gbGVuZ3RoIC0gVGhlIGxlbmd0aC4gTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDE2IGluY2x1c2l2ZS5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9TdHJpbmdXaXRoTGVhZGluZ1plcm8odmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnbi9hJztcbiAgICB9XG4gICAgaWYgKCFpc0ludGVnZXIobGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGxlbmd0aCcpO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgMCB8fCBsZW5ndGggPiAxNikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGxlbmd0aCcpO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBjb25zdCBkdW1teVN0cmluZyA9ICcwMDAwMDAwMDAwMDAwMDAwJztcbiAgICByZXR1cm4gKGR1bW15U3RyaW5nICsgdmFsdWUudG9TdHJpbmcoKSkuc2xpY2UoLWxlbmd0aCk7XG59XG5jbGFzcyBQcmljZUZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IocHJpY2VTY2FsZSwgbWluTW92ZSkge1xuICAgICAgICBpZiAoIW1pbk1vdmUpIHtcbiAgICAgICAgICAgIG1pbk1vdmUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOdW1iZXIocHJpY2VTY2FsZSkgfHwgIWlzSW50ZWdlcihwcmljZVNjYWxlKSkge1xuICAgICAgICAgICAgcHJpY2VTY2FsZSA9IDEwMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpY2VTY2FsZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYmFzZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPSBwcmljZVNjYWxlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19taW5Nb3ZlID0gbWluTW92ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FsY3VsYXRlRGVjaW1hbCgpO1xuICAgIH1cbiAgICBmb3JtYXQocHJpY2UpIHtcbiAgICAgICAgLy8gXFx1MjIxMiBpcyB1bmljb2RlJ3MgbWludXMgc2lnbiBodHRwczovL3d3dy5maWxlZm9ybWF0LmluZm8vaW5mby91bmljb2RlL2NoYXIvMjIxMi9pbmRleC5odG1cbiAgICAgICAgLy8gd2Ugc2hvdWxkIHVzZSBpdCBiZWNhdXNlIGl0IGhhcyB0aGUgc2FtZSB3aWR0aCBhcyBwbHVzIHNpZ24gK1xuICAgICAgICBjb25zdCBzaWduID0gcHJpY2UgPCAwID8gJ1xcdTIyMTInIDogJyc7XG4gICAgICAgIHByaWNlID0gTWF0aC5hYnMocHJpY2UpO1xuICAgICAgICByZXR1cm4gc2lnbiArIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdEFzRGVjaW1hbChwcmljZSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19jYWxjdWxhdGVEZWNpbWFsKCkge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGlzLl9iYXNlIGlzIHBvd2VyIG9mIDEwXG4gICAgICAgIC8vIGZvciBkb3VibGUgZnJhY3Rpb25hbCBfZnJhY3Rpb25hbExlbmd0aCBpZiBmb3IgdGhlIG1haW4gZnJhY3Rpb25hbCBvbmx5XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19mcmFjdGlvbmFsTGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPiAwICYmIHRoaXMuX3ByaXZhdGVfX21pbk1vdmUgPiAwKSB7XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGU7XG4gICAgICAgICAgICB3aGlsZSAoYmFzZSA+IDEpIHtcbiAgICAgICAgICAgICAgICBiYXNlIC89IDEwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19mcmFjdGlvbmFsTGVuZ3RoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2Zvcm1hdEFzRGVjaW1hbChwcmljZSkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSAvIHRoaXMuX3ByaXZhdGVfX21pbk1vdmU7XG4gICAgICAgIGxldCBpbnRQYXJ0ID0gTWF0aC5mbG9vcihwcmljZSk7XG4gICAgICAgIGxldCBmcmFjU3RyaW5nID0gJyc7XG4gICAgICAgIGNvbnN0IGZyYWNMZW5ndGggPSB0aGlzLl9pbnRlcm5hbF9fZnJhY3Rpb25hbExlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhpcy5faW50ZXJuYWxfX2ZyYWN0aW9uYWxMZW5ndGggOiBOYU47XG4gICAgICAgIGlmIChiYXNlID4gMSkge1xuICAgICAgICAgICAgbGV0IGZyYWNQYXJ0ID0gKyhNYXRoLnJvdW5kKHByaWNlICogYmFzZSkgLSBpbnRQYXJ0ICogYmFzZSkudG9GaXhlZCh0aGlzLl9pbnRlcm5hbF9fZnJhY3Rpb25hbExlbmd0aCk7XG4gICAgICAgICAgICBpZiAoZnJhY1BhcnQgPj0gYmFzZSkge1xuICAgICAgICAgICAgICAgIGZyYWNQYXJ0IC09IGJhc2U7XG4gICAgICAgICAgICAgICAgaW50UGFydCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhY1N0cmluZyA9IGZvcm1hdHRlck9wdGlvbnMuX2ludGVybmFsX2RlY2ltYWxTaWduICsgbnVtYmVyVG9TdHJpbmdXaXRoTGVhZGluZ1plcm8oK2ZyYWNQYXJ0LnRvRml4ZWQodGhpcy5faW50ZXJuYWxfX2ZyYWN0aW9uYWxMZW5ndGgpICogdGhpcy5fcHJpdmF0ZV9fbWluTW92ZSwgZnJhY0xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgcm91bmQgaW50IHBhcnQgdG8gbWluIG1vdmVcbiAgICAgICAgICAgIGludFBhcnQgPSBNYXRoLnJvdW5kKGludFBhcnQgKiBiYXNlKSAvIGJhc2U7XG4gICAgICAgICAgICAvLyBpZiBtaW4gbW92ZSA+IDEsIGZyYWN0aW9uYWwgcGFydCBpcyBhbHdheXMgPSAwXG4gICAgICAgICAgICBpZiAoZnJhY0xlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmcmFjU3RyaW5nID0gZm9ybWF0dGVyT3B0aW9ucy5faW50ZXJuYWxfZGVjaW1hbFNpZ24gKyBudW1iZXJUb1N0cmluZ1dpdGhMZWFkaW5nWmVybygwLCBmcmFjTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50UGFydC50b0ZpeGVkKDApICsgZnJhY1N0cmluZztcbiAgICB9XG59XG5cbmNsYXNzIFBlcmNlbnRhZ2VGb3JtYXR0ZXIgZXh0ZW5kcyBQcmljZUZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IocHJpY2VTY2FsZSA9IDEwMCkge1xuICAgICAgICBzdXBlcihwcmljZVNjYWxlKTtcbiAgICB9XG4gICAgZm9ybWF0KHByaWNlKSB7XG4gICAgICAgIHJldHVybiBgJHtzdXBlci5mb3JtYXQocHJpY2UpfSVgO1xuICAgIH1cbn1cblxuY2xhc3MgVm9sdW1lRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVjaXNpb24pIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgIH1cbiAgICBmb3JtYXQodm9sKSB7XG4gICAgICAgIGxldCBzaWduID0gJyc7XG4gICAgICAgIGlmICh2b2wgPCAwKSB7XG4gICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgdm9sID0gLXZvbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm9sIDwgOTk1KSB7XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdE51bWJlcih2b2wpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZvbCA8IDk5OTk5NSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB0aGlzLl9wcml2YXRlX19mb3JtYXROdW1iZXIodm9sIC8gMTAwMCkgKyAnSyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodm9sIDwgOTk5OTk5OTk1KSB7XG4gICAgICAgICAgICB2b2wgPSAxMDAwICogTWF0aC5yb3VuZCh2b2wgLyAxMDAwKTtcbiAgICAgICAgICAgIHJldHVybiBzaWduICsgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0TnVtYmVyKHZvbCAvIDEwMDAwMDApICsgJ00nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm9sID0gMTAwMDAwMCAqIE1hdGgucm91bmQodm9sIC8gMTAwMDAwMCk7XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdE51bWJlcih2b2wgLyAxMDAwMDAwMDAwKSArICdCJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZm9ybWF0TnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSBNYXRoLnBvdygxMCwgdGhpcy5fcHJpdmF0ZV9fcHJlY2lzaW9uKTtcbiAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogcHJpY2VTY2FsZSkgLyBwcmljZVNjYWxlO1xuICAgICAgICBpZiAodmFsdWUgPj0gMWUtMTUgJiYgdmFsdWUgPCAxKSB7XG4gICAgICAgICAgICByZXMgPSB2YWx1ZS50b0ZpeGVkKHRoaXMuX3ByaXZhdGVfX3ByZWNpc2lvbikucmVwbGFjZSgvXFwuPzArJC8sICcnKTsgLy8gcmVnZXggcmVtb3ZlcyB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy5yZXBsYWNlKC8oXFwuWzEtOV0qKTArJC8sIChlLCBwMSkgPT4gcDEpO1xuICAgIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXMsIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHdhbGtMaW5lKHJlbmRlcmluZ1Njb3BlLCBpdGVtcywgbGluZVR5cGUsIHZpc2libGVSYW5nZSwgYmFyV2lkdGgsIFxuLy8gdGhlIHZhbHVlcyByZXR1cm5lZCBieSBzdHlsZUdldHRlciBhcmUgY29tcGFyZWQgdXNpbmcgdGhlIG9wZXJhdG9yICE9PSxcbi8vIHNvIGlmIHN0eWxlR2V0dGVyIHJldHVybnMgb2JqZWN0cywgdGhlbiBzdHlsZUdldHRlciBzaG91bGQgcmV0dXJuIHRoZSBzYW1lIG9iamVjdCBmb3IgZXF1YWwgc3R5bGVzXG5zdHlsZUdldHRlciwgZmluaXNoU3R5bGVkQXJlYSkge1xuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDAgfHwgdmlzaWJsZVJhbmdlLmZyb20gPj0gaXRlbXMubGVuZ3RoIHx8IHZpc2libGVSYW5nZS50byA8PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSA9IHJlbmRlcmluZ1Njb3BlO1xuICAgIGNvbnN0IGZpcnN0SXRlbSA9IGl0ZW1zW3Zpc2libGVSYW5nZS5mcm9tXTtcbiAgICBsZXQgY3VycmVudFN0eWxlID0gc3R5bGVHZXR0ZXIocmVuZGVyaW5nU2NvcGUsIGZpcnN0SXRlbSk7XG4gICAgbGV0IGN1cnJlbnRTdHlsZUZpcnN0SXRlbSA9IGZpcnN0SXRlbTtcbiAgICBpZiAodmlzaWJsZVJhbmdlLnRvIC0gdmlzaWJsZVJhbmdlLmZyb20gPCAyKSB7XG4gICAgICAgIGNvbnN0IGhhbGZCYXJXaWR0aCA9IGJhcldpZHRoIC8gMjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb25zdCBpdGVtMSA9IHsgX2ludGVybmFsX3g6IGZpcnN0SXRlbS5faW50ZXJuYWxfeCAtIGhhbGZCYXJXaWR0aCwgX2ludGVybmFsX3k6IGZpcnN0SXRlbS5faW50ZXJuYWxfeSB9O1xuICAgICAgICBjb25zdCBpdGVtMiA9IHsgX2ludGVybmFsX3g6IGZpcnN0SXRlbS5faW50ZXJuYWxfeCArIGhhbGZCYXJXaWR0aCwgX2ludGVybmFsX3k6IGZpcnN0SXRlbS5faW50ZXJuYWxfeSB9O1xuICAgICAgICBjdHgubW92ZVRvKGl0ZW0xLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGl0ZW0xLl9pbnRlcm5hbF95ICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgY3R4LmxpbmVUbyhpdGVtMi5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvLCBpdGVtMi5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgIGZpbmlzaFN0eWxlZEFyZWEocmVuZGVyaW5nU2NvcGUsIGN1cnJlbnRTdHlsZSwgaXRlbTEsIGl0ZW0yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZVN0eWxlID0gKG5ld1N0eWxlLCBjdXJyZW50SXRlbSkgPT4ge1xuICAgICAgICAgICAgZmluaXNoU3R5bGVkQXJlYShyZW5kZXJpbmdTY29wZSwgY3VycmVudFN0eWxlLCBjdXJyZW50U3R5bGVGaXJzdEl0ZW0sIGN1cnJlbnRJdGVtKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN1cnJlbnRTdHlsZSA9IG5ld1N0eWxlO1xuICAgICAgICAgICAgY3VycmVudFN0eWxlRmlyc3RJdGVtID0gY3VycmVudEl0ZW07XG4gICAgICAgIH07XG4gICAgICAgIGxldCBjdXJyZW50SXRlbSA9IGN1cnJlbnRTdHlsZUZpcnN0SXRlbTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGZpcnN0SXRlbS5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvLCBmaXJzdEl0ZW0uX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICBmb3IgKGxldCBpID0gdmlzaWJsZVJhbmdlLmZyb20gKyAxOyBpIDwgdmlzaWJsZVJhbmdlLnRvOyArK2kpIHtcbiAgICAgICAgICAgIGN1cnJlbnRJdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICBjb25zdCBpdGVtU3R5bGUgPSBzdHlsZUdldHRlcihyZW5kZXJpbmdTY29wZSwgY3VycmVudEl0ZW0pO1xuICAgICAgICAgICAgc3dpdGNoIChsaW5lVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBMaW5lVHlwZS5TaW1wbGUgKi86XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY3VycmVudEl0ZW0uX2ludGVybmFsX3ggKiBob3Jpem9udGFsUGl4ZWxSYXRpbywgY3VycmVudEl0ZW0uX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogTGluZVR5cGUuV2l0aFN0ZXBzICovOlxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN1cnJlbnRJdGVtLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGl0ZW1zW2kgLSAxXS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtU3R5bGUgIT09IGN1cnJlbnRTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlU3R5bGUoaXRlbVN0eWxlLCBjdXJyZW50SXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN1cnJlbnRJdGVtLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGl0ZW1zW2kgLSAxXS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjdXJyZW50SXRlbS5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvLCBjdXJyZW50SXRlbS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBMaW5lVHlwZS5DdXJ2ZWQgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2NwMSwgY3AyXSA9IGdldENvbnRyb2xQb2ludHMoaXRlbXMsIGkgLSAxLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3AxLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGNwMS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbywgY3AyLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGNwMi5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbywgY3VycmVudEl0ZW0uX2ludGVybmFsX3ggKiBob3Jpem9udGFsUGl4ZWxSYXRpbywgY3VycmVudEl0ZW0uX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGluZVR5cGUgIT09IDEgLyogTGluZVR5cGUuV2l0aFN0ZXBzICovICYmIGl0ZW1TdHlsZSAhPT0gY3VycmVudFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlU3R5bGUoaXRlbVN0eWxlLCBjdXJyZW50SXRlbSk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjdXJyZW50SXRlbS5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvLCBjdXJyZW50SXRlbS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRTdHlsZUZpcnN0SXRlbSAhPT0gY3VycmVudEl0ZW0gfHwgY3VycmVudFN0eWxlRmlyc3RJdGVtID09PSBjdXJyZW50SXRlbSAmJiBsaW5lVHlwZSA9PT0gMSAvKiBMaW5lVHlwZS5XaXRoU3RlcHMgKi8pIHtcbiAgICAgICAgICAgIGZpbmlzaFN0eWxlZEFyZWEocmVuZGVyaW5nU2NvcGUsIGN1cnJlbnRTdHlsZSwgY3VycmVudFN0eWxlRmlyc3RJdGVtLCBjdXJyZW50SXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBjdXJ2ZVRlbnNpb24gPSA2O1xuZnVuY3Rpb24gc3VidHJhY3QocDEsIHAyKSB7XG4gICAgcmV0dXJuIHsgX2ludGVybmFsX3g6IHAxLl9pbnRlcm5hbF94IC0gcDIuX2ludGVybmFsX3gsIF9pbnRlcm5hbF95OiBwMS5faW50ZXJuYWxfeSAtIHAyLl9pbnRlcm5hbF95IH07XG59XG5mdW5jdGlvbiBhZGQocDEsIHAyKSB7XG4gICAgcmV0dXJuIHsgX2ludGVybmFsX3g6IHAxLl9pbnRlcm5hbF94ICsgcDIuX2ludGVybmFsX3gsIF9pbnRlcm5hbF95OiBwMS5faW50ZXJuYWxfeSArIHAyLl9pbnRlcm5hbF95IH07XG59XG5mdW5jdGlvbiBkaXZpZGUocDEsIG4pIHtcbiAgICByZXR1cm4geyBfaW50ZXJuYWxfeDogcDEuX2ludGVybmFsX3ggLyBuLCBfaW50ZXJuYWxfeTogcDEuX2ludGVybmFsX3kgLyBuIH07XG59XG4vKipcbiAqIEByZXR1cm5zIFR3byBjb250cm9sIHBvaW50cyB0aGF0IGNhbiBiZSB1c2VkIGFzIGFyZ3VtZW50cyB0byB7QGxpbmsgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELmJlemllckN1cnZlVG99IHRvIGRyYXcgYSBjdXJ2ZWQgbGluZSBiZXR3ZWVuIGBwb2ludHNbZnJvbVBvaW50SW5kZXhdYCBhbmQgYHBvaW50c1t0b1BvaW50SW5kZXhdYC5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29udHJvbFBvaW50cyhwb2ludHMsIGZyb21Qb2ludEluZGV4LCB0b1BvaW50SW5kZXgpIHtcbiAgICBjb25zdCBiZWZvcmVGcm9tUG9pbnRJbmRleCA9IE1hdGgubWF4KDAsIGZyb21Qb2ludEluZGV4IC0gMSk7XG4gICAgY29uc3QgYWZ0ZXJUb1BvaW50SW5kZXggPSBNYXRoLm1pbihwb2ludHMubGVuZ3RoIC0gMSwgdG9Qb2ludEluZGV4ICsgMSk7XG4gICAgY29uc3QgY3AxID0gYWRkKHBvaW50c1tmcm9tUG9pbnRJbmRleF0sIGRpdmlkZShzdWJ0cmFjdChwb2ludHNbdG9Qb2ludEluZGV4XSwgcG9pbnRzW2JlZm9yZUZyb21Qb2ludEluZGV4XSksIGN1cnZlVGVuc2lvbikpO1xuICAgIGNvbnN0IGNwMiA9IHN1YnRyYWN0KHBvaW50c1t0b1BvaW50SW5kZXhdLCBkaXZpZGUoc3VidHJhY3QocG9pbnRzW2FmdGVyVG9Qb2ludEluZGV4XSwgcG9pbnRzW2Zyb21Qb2ludEluZGV4XSksIGN1cnZlVGVuc2lvbikpO1xuICAgIHJldHVybiBbY3AxLCBjcDJdO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hTdHlsZWRBcmVhJDEoYmFzZUxldmVsQ29vcmRpbmF0ZSwgc2NvcGUsIHN0eWxlLCBhcmVhRmlyc3RJdGVtLCBuZXdBcmVhRmlyc3RJdGVtKSB7XG4gICAgY29uc3QgeyBjb250ZXh0LCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvIH0gPSBzY29wZTtcbiAgICBjb250ZXh0LmxpbmVUbyhuZXdBcmVhRmlyc3RJdGVtLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGJhc2VMZXZlbENvb3JkaW5hdGUgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQubGluZVRvKGFyZWFGaXJzdEl0ZW0uX2ludGVybmFsX3ggKiBob3Jpem9udGFsUGl4ZWxSYXRpbywgYmFzZUxldmVsQ29vcmRpbmF0ZSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHN0eWxlO1xuICAgIGNvbnRleHQuZmlsbCgpO1xufVxuY2xhc3MgUGFuZVJlbmRlcmVyQXJlYUJhc2UgZXh0ZW5kcyBCaXRtYXBDb29yZGluYXRlc1BhbmVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19kYXRhID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZHJhd0ltcGwocmVuZGVyaW5nU2NvcGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfX2RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IF9pbnRlcm5hbF9pdGVtczogaXRlbXMsIF9pbnRlcm5hbF92aXNpYmxlUmFuZ2U6IHZpc2libGVSYW5nZSwgX2ludGVybmFsX2JhcldpZHRoOiBiYXJXaWR0aCwgX2ludGVybmFsX2xpbmVXaWR0aDogbGluZVdpZHRoLCBfaW50ZXJuYWxfbGluZVN0eWxlOiBsaW5lU3R5bGUsIF9pbnRlcm5hbF9saW5lVHlwZTogbGluZVR5cGUgfSA9IHRoaXMuX2ludGVybmFsX19kYXRhO1xuICAgICAgICBjb25zdCBiYXNlTGV2ZWxDb29yZGluYXRlID0gKF9hID0gdGhpcy5faW50ZXJuYWxfX2RhdGEuX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9pbnRlcm5hbF9fZGF0YS5faW50ZXJuYWxfaW52ZXJ0RmlsbGVkQXJlYSA/IDAgOiByZW5kZXJpbmdTY29wZS5tZWRpYVNpemUuaGVpZ2h0KTtcbiAgICAgICAgaWYgKHZpc2libGVSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN0eCA9IHJlbmRlcmluZ1Njb3BlLmNvbnRleHQ7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gJ2J1dHQnO1xuICAgICAgICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBzZXRMaW5lU3R5bGUoY3R4LCBsaW5lU3R5bGUpO1xuICAgICAgICAvLyB3YWxrIGxpbmVzIHdpdGggd2lkdGg9MSB0byBoYXZlIG1vcmUgYWNjdXJhdGUgZ3JhZGllbnQncyBmaWxsaW5nXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICB3YWxrTGluZShyZW5kZXJpbmdTY29wZSwgaXRlbXMsIGxpbmVUeXBlLCB2aXNpYmxlUmFuZ2UsIGJhcldpZHRoLCB0aGlzLl9pbnRlcm5hbF9fZmlsbFN0eWxlLmJpbmQodGhpcyksIGZpbmlzaFN0eWxlZEFyZWEkMS5iaW5kKG51bGwsIGJhc2VMZXZlbENvb3JkaW5hdGUpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW5WYWwsIG1heFZhbCkge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluVmFsKSwgbWF4VmFsKTtcbn1cbmZ1bmN0aW9uIGlzQmFzZURlY2ltYWwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgY3VycmVudCA9IHZhbHVlOyBjdXJyZW50ID4gMTsgY3VycmVudCAvPSAxMCkge1xuICAgICAgICBpZiAoKGN1cnJlbnQgJSAxMCkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdyZWF0ZXJPckVxdWFsKHgxLCB4MiwgZXBzaWxvbikge1xuICAgIHJldHVybiAoeDIgLSB4MSkgPD0gZXBzaWxvbjtcbn1cbmZ1bmN0aW9uIGVxdWFsKHgxLCB4MiwgZXBzaWxvbikge1xuICAgIHJldHVybiBNYXRoLmFicyh4MSAtIHgyKSA8IGVwc2lsb247XG59XG4vLyBXZSBjYW4ndCB1c2UgTWF0aC5taW4oLi4uYXJyKSBiZWNhdXNlIHRoYXQgd291bGQgb25seSBzdXBwb3J0IGFycmF5cyBzaG9ydGVyIHRoYW4gNjU1MzYgaXRlbXMuXG5mdW5jdGlvbiBtaW4oYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPCAxKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdhcnJheSBpcyBlbXB0eScpO1xuICAgIH1cbiAgICBsZXQgbWluVmFsID0gYXJyWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPCBtaW5WYWwpIHtcbiAgICAgICAgICAgIG1pblZhbCA9IGFycltpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluVmFsO1xufVxuZnVuY3Rpb24gY2VpbGVkRXZlbih4KSB7XG4gICAgY29uc3QgY2VpbGVkID0gTWF0aC5jZWlsKHgpO1xuICAgIHJldHVybiAoY2VpbGVkICUgMiAhPT0gMCkgPyBjZWlsZWQgLSAxIDogY2VpbGVkO1xufVxuZnVuY3Rpb24gY2VpbGVkT2RkKHgpIHtcbiAgICBjb25zdCBjZWlsZWQgPSBNYXRoLmNlaWwoeCk7XG4gICAgcmV0dXJuIChjZWlsZWQgJSAyID09PSAwKSA/IGNlaWxlZCAtIDEgOiBjZWlsZWQ7XG59XG5cbmNsYXNzIEdyYWRpZW50U3R5bGVDYWNoZSB7XG4gICAgX2ludGVybmFsX2dldChzY29wZSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlZFBhcmFtcyA9IHRoaXMuX3ByaXZhdGVfX3BhcmFtcztcbiAgICAgICAgY29uc3QgeyBfaW50ZXJuYWxfdG9wQ29sb3IxOiB0b3BDb2xvcjEsIF9pbnRlcm5hbF90b3BDb2xvcjI6IHRvcENvbG9yMiwgX2ludGVybmFsX2JvdHRvbUNvbG9yMTogYm90dG9tQ29sb3IxLCBfaW50ZXJuYWxfYm90dG9tQ29sb3IyOiBib3R0b21Db2xvcjIsIF9pbnRlcm5hbF9ib3R0b206IGJvdHRvbSwgX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGU6IGJhc2VMZXZlbENvb3JkaW5hdGUgfSA9IHBhcmFtcztcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NhY2hlZFZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGNhY2hlZFBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBjYWNoZWRQYXJhbXMuX2ludGVybmFsX3RvcENvbG9yMSAhPT0gdG9wQ29sb3IxIHx8XG4gICAgICAgICAgICBjYWNoZWRQYXJhbXMuX2ludGVybmFsX3RvcENvbG9yMiAhPT0gdG9wQ29sb3IyIHx8XG4gICAgICAgICAgICBjYWNoZWRQYXJhbXMuX2ludGVybmFsX2JvdHRvbUNvbG9yMSAhPT0gYm90dG9tQ29sb3IxIHx8XG4gICAgICAgICAgICBjYWNoZWRQYXJhbXMuX2ludGVybmFsX2JvdHRvbUNvbG9yMiAhPT0gYm90dG9tQ29sb3IyIHx8XG4gICAgICAgICAgICBjYWNoZWRQYXJhbXMuX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGUgIT09IGJhc2VMZXZlbENvb3JkaW5hdGUgfHxcbiAgICAgICAgICAgIGNhY2hlZFBhcmFtcy5faW50ZXJuYWxfYm90dG9tICE9PSBib3R0b20pIHtcbiAgICAgICAgICAgIGNvbnN0IGdyYWRpZW50ID0gc2NvcGUuY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCBib3R0b20pO1xuICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIHRvcENvbG9yMSk7XG4gICAgICAgICAgICBpZiAoYmFzZUxldmVsQ29vcmRpbmF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZWxpbmVQZXJjZW50ID0gY2xhbXAoYmFzZUxldmVsQ29vcmRpbmF0ZSAqIHNjb3BlLnZlcnRpY2FsUGl4ZWxSYXRpbyAvIGJvdHRvbSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKGJhc2VsaW5lUGVyY2VudCwgdG9wQ29sb3IyKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoYmFzZWxpbmVQZXJjZW50LCBib3R0b21Db2xvcjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIGJvdHRvbUNvbG9yMik7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZWRWYWx1ZSA9IGdyYWRpZW50O1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jYWNoZWRWYWx1ZTtcbiAgICB9XG59XG5cbmNsYXNzIFBhbmVSZW5kZXJlckFyZWEgZXh0ZW5kcyBQYW5lUmVuZGVyZXJBcmVhQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZpbGxDYWNoZSA9IG5ldyBHcmFkaWVudFN0eWxlQ2FjaGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19maWxsU3R5bGUocmVuZGVyaW5nU2NvcGUsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2ZpbGxDYWNoZS5faW50ZXJuYWxfZ2V0KHJlbmRlcmluZ1Njb3BlLCB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29sb3IxOiBpdGVtLl9pbnRlcm5hbF90b3BDb2xvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3BDb2xvcjI6ICcnLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvdHRvbUNvbG9yMTogJycsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tQ29sb3IyOiBpdGVtLl9pbnRlcm5hbF9ib3R0b21Db2xvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3R0b206IHJlbmRlcmluZ1Njb3BlLmJpdG1hcFNpemUuaGVpZ2h0LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdTZXJpZXNQb2ludE1hcmtlcnMocmVuZGVyaW5nU2NvcGUsIGl0ZW1zLCBwb2ludE1hcmtlcnNSYWRpdXMsIHZpc2libGVSYW5nZSwgXG4vLyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHN0eWxlR2V0dGVyIGFyZSBjb21wYXJlZCB1c2luZyB0aGUgb3BlcmF0b3IgIT09LFxuLy8gc28gaWYgc3R5bGVHZXR0ZXIgcmV0dXJucyBvYmplY3RzLCB0aGVuIHN0eWxlR2V0dGVyIHNob3VsZCByZXR1cm4gdGhlIHNhbWUgb2JqZWN0IGZvciBlcXVhbCBzdHlsZXNcbnN0eWxlR2V0dGVyKSB7XG4gICAgY29uc3QgeyBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvLCBjb250ZXh0IH0gPSByZW5kZXJpbmdTY29wZTtcbiAgICBsZXQgcHJldlN0eWxlID0gbnVsbDtcbiAgICBjb25zdCB0aWNrV2lkdGggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGhvcml6b250YWxQaXhlbFJhdGlvKSk7XG4gICAgY29uc3QgY29ycmVjdGlvbiA9ICh0aWNrV2lkdGggJSAyKSAvIDI7XG4gICAgY29uc3QgcmFkaXVzID0gcG9pbnRNYXJrZXJzUmFkaXVzICogdmVydGljYWxQaXhlbFJhdGlvICsgY29ycmVjdGlvbjtcbiAgICBmb3IgKGxldCBpID0gdmlzaWJsZVJhbmdlLnRvIC0gMTsgaSA+PSB2aXNpYmxlUmFuZ2UuZnJvbTsgLS1pKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChwb2ludCkge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBzdHlsZUdldHRlcihyZW5kZXJpbmdTY29wZSwgcG9pbnQpO1xuICAgICAgICAgICAgaWYgKHN0eWxlICE9PSBwcmV2U3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2U3R5bGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc3R5bGU7XG4gICAgICAgICAgICAgICAgcHJldlN0eWxlID0gc3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjZW50ZXJYID0gTWF0aC5yb3VuZChwb2ludC5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvKSArIGNvcnJlY3Rpb247IC8vIGNvcnJlY3QgeCBjb29yZGluYXRlIG9ubHlcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlclkgPSBwb2ludC5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICAgICAgY29udGV4dC5hcmMoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29udGV4dC5maWxsKCk7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaFN0eWxlZEFyZWEoc2NvcGUsIHN0eWxlKSB7XG4gICAgY29uc3QgY3R4ID0gc2NvcGUuY29udGV4dDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZTtcbiAgICBjdHguc3Ryb2tlKCk7XG59XG5jbGFzcyBQYW5lUmVuZGVyZXJMaW5lQmFzZSBleHRlbmRzIEJpdG1hcENvb3JkaW5hdGVzUGFuZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgX2ludGVybmFsX19kcmF3SW1wbChyZW5kZXJpbmdTY29wZSkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfX2RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IF9pbnRlcm5hbF9pdGVtczogaXRlbXMsIF9pbnRlcm5hbF92aXNpYmxlUmFuZ2U6IHZpc2libGVSYW5nZSwgX2ludGVybmFsX2JhcldpZHRoOiBiYXJXaWR0aCwgX2ludGVybmFsX2xpbmVUeXBlOiBsaW5lVHlwZSwgX2ludGVybmFsX2xpbmVXaWR0aDogbGluZVdpZHRoLCBfaW50ZXJuYWxfbGluZVN0eWxlOiBsaW5lU3R5bGUsIF9pbnRlcm5hbF9wb2ludE1hcmtlcnNSYWRpdXM6IHBvaW50TWFya2Vyc1JhZGl1cyB9ID0gdGhpcy5faW50ZXJuYWxfX2RhdGE7XG4gICAgICAgIGlmICh2aXNpYmxlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdHggPSByZW5kZXJpbmdTY29wZS5jb250ZXh0O1xuICAgICAgICBjdHgubGluZUNhcCA9ICdidXR0JztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCAqIHJlbmRlcmluZ1Njb3BlLnZlcnRpY2FsUGl4ZWxSYXRpbztcbiAgICAgICAgc2V0TGluZVN0eWxlKGN0eCwgbGluZVN0eWxlKTtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICAgICAgY29uc3Qgc3R5bGVHZXR0ZXIgPSB0aGlzLl9pbnRlcm5hbF9fc3Ryb2tlU3R5bGUuYmluZCh0aGlzKTtcbiAgICAgICAgaWYgKGxpbmVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdhbGtMaW5lKHJlbmRlcmluZ1Njb3BlLCBpdGVtcywgbGluZVR5cGUsIHZpc2libGVSYW5nZSwgYmFyV2lkdGgsIHN0eWxlR2V0dGVyLCBmaW5pc2hTdHlsZWRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnRNYXJrZXJzUmFkaXVzKSB7XG4gICAgICAgICAgICBkcmF3U2VyaWVzUG9pbnRNYXJrZXJzKHJlbmRlcmluZ1Njb3BlLCBpdGVtcywgcG9pbnRNYXJrZXJzUmFkaXVzLCB2aXNpYmxlUmFuZ2UsIHN0eWxlR2V0dGVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgUGFuZVJlbmRlcmVyTGluZSBleHRlbmRzIFBhbmVSZW5kZXJlckxpbmVCYXNlIHtcbiAgICBfaW50ZXJuYWxfX3N0cm9rZVN0eWxlKHJlbmRlcmluZ1Njb3BlLCBpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLl9pbnRlcm5hbF9saW5lQ29sb3I7XG4gICAgfVxufVxuXG4vKipcbiAqIEJpbmFyeSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdHdvIGFyZ3VtZW50cyAodGhlIGZpcnN0IG9mIHRoZSB0eXBlIG9mIGFycmF5IGVsZW1lbnRzLCBhbmQgdGhlIHNlY29uZCBpcyBhbHdheXMgdmFsKSwgYW5kIHJldHVybnMgYSB2YWx1ZSBjb252ZXJ0aWJsZSB0byBib29sLlxuICogVGhlIHZhbHVlIHJldHVybmVkIGluZGljYXRlcyB3aGV0aGVyIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBjb25zaWRlcmVkIHRvIGdvIGJlZm9yZSB0aGUgc2Vjb25kLlxuICogVGhlIGZ1bmN0aW9uIHNoYWxsIG5vdCBtb2RpZnkgYW55IG9mIGl0cyBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGJvdW5kQ29tcGFyZShsb3dlciwgYXJyLCB2YWx1ZSwgY29tcGFyZSwgc3RhcnQgPSAwLCB0byA9IGFyci5sZW5ndGgpIHtcbiAgICBsZXQgY291bnQgPSB0byAtIHN0YXJ0O1xuICAgIHdoaWxlICgwIDwgY291bnQpIHtcbiAgICAgICAgY29uc3QgY291bnQyID0gKGNvdW50ID4+IDEpO1xuICAgICAgICBjb25zdCBtaWQgPSBzdGFydCArIGNvdW50MjtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW21pZF0sIHZhbHVlKSA9PT0gbG93ZXIpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGNvdW50IC09IGNvdW50MiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3VudCA9IGNvdW50MjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnQ7XG59XG5jb25zdCBsb3dlckJvdW5kID0gYm91bmRDb21wYXJlLmJpbmQobnVsbCwgdHJ1ZSk7XG5jb25zdCB1cHBlckJvdW5kID0gYm91bmRDb21wYXJlLmJpbmQobnVsbCwgZmFsc2UpO1xuXG5mdW5jdGlvbiBsb3dlckJvdW5kSXRlbXNDb21wYXJlKGl0ZW0sIHRpbWUpIHtcbiAgICByZXR1cm4gaXRlbS5faW50ZXJuYWxfdGltZSA8IHRpbWU7XG59XG5mdW5jdGlvbiB1cHBlckJvdW5kSXRlbXNDb21wYXJlKGl0ZW0sIHRpbWUpIHtcbiAgICByZXR1cm4gdGltZSA8IGl0ZW0uX2ludGVybmFsX3RpbWU7XG59XG5mdW5jdGlvbiB2aXNpYmxlVGltZWRWYWx1ZXMoaXRlbXMsIHJhbmdlLCBleHRlbmRlZFJhbmdlKSB7XG4gICAgY29uc3QgZmlyc3RCYXIgPSByYW5nZS5faW50ZXJuYWxfbGVmdCgpO1xuICAgIGNvbnN0IGxhc3RCYXIgPSByYW5nZS5faW50ZXJuYWxfcmlnaHQoKTtcbiAgICBjb25zdCBmcm9tID0gbG93ZXJCb3VuZChpdGVtcywgZmlyc3RCYXIsIGxvd2VyQm91bmRJdGVtc0NvbXBhcmUpO1xuICAgIGNvbnN0IHRvID0gdXBwZXJCb3VuZChpdGVtcywgbGFzdEJhciwgdXBwZXJCb3VuZEl0ZW1zQ29tcGFyZSk7XG4gICAgaWYgKCFleHRlbmRlZFJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvIH07XG4gICAgfVxuICAgIGxldCBleHRlbmRlZEZyb20gPSBmcm9tO1xuICAgIGxldCBleHRlbmRlZFRvID0gdG87XG4gICAgaWYgKGZyb20gPiAwICYmIGZyb20gPCBpdGVtcy5sZW5ndGggJiYgaXRlbXNbZnJvbV0uX2ludGVybmFsX3RpbWUgPj0gZmlyc3RCYXIpIHtcbiAgICAgICAgZXh0ZW5kZWRGcm9tID0gZnJvbSAtIDE7XG4gICAgfVxuICAgIGlmICh0byA+IDAgJiYgdG8gPCBpdGVtcy5sZW5ndGggJiYgaXRlbXNbdG8gLSAxXS5faW50ZXJuYWxfdGltZSA8PSBsYXN0QmFyKSB7XG4gICAgICAgIGV4dGVuZGVkVG8gPSB0byArIDE7XG4gICAgfVxuICAgIHJldHVybiB7IGZyb206IGV4dGVuZGVkRnJvbSwgdG86IGV4dGVuZGVkVG8gfTtcbn1cblxuY2xhc3MgU2VyaWVzUGFuZVZpZXdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMsIG1vZGVsLCBleHRlbmRlZFZpc2libGVSYW5nZSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZGF0YUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX29wdGlvbnNJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzID0gc2VyaWVzO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fbW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZXh0ZW5kZWRWaXNpYmxlUmFuZ2UgPSBleHRlbmRlZFZpc2libGVSYW5nZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSh1cGRhdGVUeXBlKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh1cGRhdGVUeXBlID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19kYXRhSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVUeXBlID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19vcHRpb25zSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF92aXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21ha2VWYWxpZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX2ludGVybmFsX19yZW5kZXJlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX191cGRhdGVPcHRpb25zKCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9faXRlbXMgPSB0aGlzLl9pbnRlcm5hbF9faXRlbXMubWFwKChpdGVtKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYmFyQ29sb3JlcigpLl9pbnRlcm5hbF9iYXJTdHlsZShpdGVtLl9pbnRlcm5hbF90aW1lKSkpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19jbGVhclZpc2libGVSYW5nZSgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlID0gbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21ha2VWYWxpZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX19kYXRhSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19maWxsUmF3UG9pbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZGF0YUludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX19vcHRpb25zSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX191cGRhdGVPcHRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9fb3B0aW9uc0ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX19pbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFrZVZhbGlkSW1wbCgpO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfX2ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX21ha2VWYWxpZEltcGwoKSB7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX2ludGVybmFsX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19jbGVhclZpc2libGVSYW5nZSgpO1xuICAgICAgICBpZiAodGltZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkgfHwgcHJpY2VTY2FsZS5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlzaWJsZUJhcnMgPSB0aW1lU2NhbGUuX2ludGVybmFsX3Zpc2libGVTdHJpY3RSYW5nZSgpO1xuICAgICAgICBpZiAodmlzaWJsZUJhcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYmFycygpLl9pbnRlcm5hbF9zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICBpZiAoZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSA9IHZpc2libGVUaW1lZFZhbHVlcyh0aGlzLl9pbnRlcm5hbF9faXRlbXMsIHZpc2libGVCYXJzLCB0aGlzLl9wcml2YXRlX19leHRlbmRlZFZpc2libGVSYW5nZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19jb252ZXJ0VG9Db29yZGluYXRlcyhwcmljZVNjYWxlLCB0aW1lU2NhbGUsIGZpcnN0VmFsdWUuX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3ByZXBhcmVSZW5kZXJlckRhdGEoKTtcbiAgICB9XG59XG5cbmNsYXNzIExpbmVQYW5lVmlld0Jhc2UgZXh0ZW5kcyBTZXJpZXNQYW5lVmlld0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgbW9kZWwpIHtcbiAgICAgICAgc3VwZXIoc2VyaWVzLCBtb2RlbCwgdHJ1ZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY29udmVydFRvQ29vcmRpbmF0ZXMocHJpY2VTY2FsZSwgdGltZVNjYWxlLCBmaXJzdFZhbHVlKSB7XG4gICAgICAgIHRpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhlc1RvQ29vcmRpbmF0ZXModGhpcy5faW50ZXJuYWxfX2l0ZW1zLCB1bmRlZmluZWRJZk51bGwodGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlKSk7XG4gICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX3BvaW50c0FycmF5VG9Db29yZGluYXRlcyh0aGlzLl9pbnRlcm5hbF9faXRlbXMsIGZpcnN0VmFsdWUsIHVuZGVmaW5lZElmTnVsbCh0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19jcmVhdGVSYXdJdGVtQmFzZSh0aW1lLCBwcmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX3RpbWU6IHRpbWUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfcHJpY2U6IHByaWNlLFxuICAgICAgICAgICAgX2ludGVybmFsX3g6IE5hTixcbiAgICAgICAgICAgIF9pbnRlcm5hbF95OiBOYU4sXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZmlsbFJhd1BvaW50cygpIHtcbiAgICAgICAgY29uc3QgY29sb3JlciA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2JhckNvbG9yZXIoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2l0ZW1zID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYmFycygpLl9pbnRlcm5hbF9yb3dzKCkubWFwKChyb3cpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcm93Ll9pbnRlcm5hbF92YWx1ZVszIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkNsb3NlICovXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbShyb3cuX2ludGVybmFsX2luZGV4LCB2YWx1ZSwgY29sb3Jlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgU2VyaWVzQXJlYVBhbmVWaWV3IGV4dGVuZHMgTGluZVBhbmVWaWV3QmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzLCBtb2RlbCkge1xuICAgICAgICBzdXBlcihzZXJpZXMsIG1vZGVsKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyID0gbmV3IENvbXBvc2l0ZVJlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FyZWFSZW5kZXJlciA9IG5ldyBQYW5lUmVuZGVyZXJBcmVhKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xpbmVSZW5kZXJlciA9IG5ldyBQYW5lUmVuZGVyZXJMaW5lKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19yZW5kZXJlci5faW50ZXJuYWxfc2V0UmVuZGVyZXJzKFt0aGlzLl9wcml2YXRlX19hcmVhUmVuZGVyZXIsIHRoaXMuX3ByaXZhdGVfX2xpbmVSZW5kZXJlcl0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2NyZWF0ZVJhd0l0ZW0odGltZSwgcHJpY2UsIGNvbG9yZXIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5faW50ZXJuYWxfX2NyZWF0ZVJhd0l0ZW1CYXNlKHRpbWUsIHByaWNlKSksIGNvbG9yZXIuX2ludGVybmFsX2JhclN0eWxlKHRpbWUpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19wcmVwYXJlUmVuZGVyZXJEYXRhKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hcmVhUmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEoe1xuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVUeXBlOiBvcHRpb25zLmxpbmVUeXBlLFxuICAgICAgICAgICAgX2ludGVybmFsX2l0ZW1zOiB0aGlzLl9pbnRlcm5hbF9faXRlbXMsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVN0eWxlOiBvcHRpb25zLmxpbmVTdHlsZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lV2lkdGg6IG9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGU6IG51bGwsXG4gICAgICAgICAgICBfaW50ZXJuYWxfaW52ZXJ0RmlsbGVkQXJlYTogb3B0aW9ucy5pbnZlcnRGaWxsZWRBcmVhLFxuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGVSYW5nZTogdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlLFxuICAgICAgICAgICAgX2ludGVybmFsX2JhcldpZHRoOiB0aGlzLl9pbnRlcm5hbF9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9iYXJTcGFjaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19saW5lUmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEoe1xuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVUeXBlOiBvcHRpb25zLmxpbmVWaXNpYmxlID8gb3B0aW9ucy5saW5lVHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pdGVtczogdGhpcy5faW50ZXJuYWxfX2l0ZW1zLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVTdHlsZTogb3B0aW9ucy5saW5lU3R5bGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVdpZHRoOiBvcHRpb25zLmxpbmVXaWR0aCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlUmFuZ2U6IHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJXaWR0aDogdGhpcy5faW50ZXJuYWxfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfYmFyU3BhY2luZygpLFxuICAgICAgICAgICAgX2ludGVybmFsX3BvaW50TWFya2Vyc1JhZGl1czogb3B0aW9ucy5wb2ludE1hcmtlcnNWaXNpYmxlID8gKG9wdGlvbnMucG9pbnRNYXJrZXJzUmFkaXVzIHx8IG9wdGlvbnMubGluZVdpZHRoIC8gMiArIDIpIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9wdGltYWxCYXJXaWR0aChiYXJTcGFjaW5nLCBwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoYmFyU3BhY2luZyAqIDAuMyAqIHBpeGVsUmF0aW8pO1xufVxuZnVuY3Rpb24gb3B0aW1hbENhbmRsZXN0aWNrV2lkdGgoYmFyU3BhY2luZywgcGl4ZWxSYXRpbykge1xuICAgIGNvbnN0IGJhclNwYWNpbmdTcGVjaWFsQ2FzZUZyb20gPSAyLjU7XG4gICAgY29uc3QgYmFyU3BhY2luZ1NwZWNpYWxDYXNlVG8gPSA0O1xuICAgIGNvbnN0IGJhclNwYWNpbmdTcGVjaWFsQ2FzZUNvZWZmID0gMztcbiAgICBpZiAoYmFyU3BhY2luZyA+PSBiYXJTcGFjaW5nU3BlY2lhbENhc2VGcm9tICYmIGJhclNwYWNpbmcgPD0gYmFyU3BhY2luZ1NwZWNpYWxDYXNlVG8pIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoYmFyU3BhY2luZ1NwZWNpYWxDYXNlQ29lZmYgKiBwaXhlbFJhdGlvKTtcbiAgICB9XG4gICAgLy8gY29lZmYgc2hvdWxkIGJlIDEgb24gc21hbGwgYmFyc3BhY2luZyBhbmQgZ28gdG8gMC44IHdoaWxlIGdyb2luZyBiYXIgc3BhY2luZ1xuICAgIGNvbnN0IGJhclNwYWNpbmdSZWR1Y2luZ0NvZWZmID0gMC4yO1xuICAgIGNvbnN0IGNvZWZmID0gMSAtIGJhclNwYWNpbmdSZWR1Y2luZ0NvZWZmICogTWF0aC5hdGFuKE1hdGgubWF4KGJhclNwYWNpbmdTcGVjaWFsQ2FzZVRvLCBiYXJTcGFjaW5nKSAtIGJhclNwYWNpbmdTcGVjaWFsQ2FzZVRvKSAvIChNYXRoLlBJICogMC41KTtcbiAgICBjb25zdCByZXMgPSBNYXRoLmZsb29yKGJhclNwYWNpbmcgKiBjb2VmZiAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnN0IHNjYWxlZEJhclNwYWNpbmcgPSBNYXRoLmZsb29yKGJhclNwYWNpbmcgKiBwaXhlbFJhdGlvKTtcbiAgICBjb25zdCBvcHRpbWFsID0gTWF0aC5taW4ocmVzLCBzY2FsZWRCYXJTcGFjaW5nKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5mbG9vcihwaXhlbFJhdGlvKSwgb3B0aW1hbCk7XG59XG5cbmNsYXNzIFBhbmVSZW5kZXJlckJhcnMgZXh0ZW5kcyBCaXRtYXBDb29yZGluYXRlc1BhbmVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhckxpbmVXaWR0aCA9IDA7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgX2ludGVybmFsX19kcmF3SW1wbCh7IGNvbnRleHQ6IGN0eCwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JhcnMubGVuZ3RoID09PSAwIHx8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoID0gdGhpcy5fcHJpdmF0ZV9fY2FsY0JhcldpZHRoKGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgLy8gZ3JpZCBhbmQgY3Jvc3NoYWlyIGhhdmUgbGluZSB3aWR0aCA9IE1hdGguZmxvb3IocGl4ZWxSYXRpbylcbiAgICAgICAgLy8gaWYgdGhpcyB2YWx1ZSBpcyBvZGQsIHdlIGhhdmUgdG8gbWFrZSBiYXJzJyB3aWR0aCBvZGRcbiAgICAgICAgLy8gaWYgdGhpcyB2YWx1ZSBpcyBldmVuLCB3ZSBoYXZlIHRvIG1ha2UgYmFycycgd2lkdGggZXZlblxuICAgICAgICAvLyBpbiBvcmRlciBvZiBrZWVwaW5nIGNyb3NzaGFpci1vdmVyLWJhciBkcmF3aW5nIHN5bW1ldHJpY1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggPj0gMikge1xuICAgICAgICAgICAgY29uc3QgbGluZVdpZHRoID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihob3Jpem9udGFsUGl4ZWxSYXRpbykpO1xuICAgICAgICAgICAgaWYgKChsaW5lV2lkdGggJSAyKSAhPT0gKHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoICUgMikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJXaWR0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHNjYWxlIGlzIGNvbXByZXNzZWQsIGJhciBjb3VsZCBiZWNvbWUgbGVzcyB0aGFuIDEgQ1NTIHBpeGVsXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhckxpbmVXaWR0aCA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3RoaW5CYXJzID8gTWF0aC5taW4odGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGgsIE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8pKSA6IHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoO1xuICAgICAgICBsZXQgcHJldkNvbG9yID0gbnVsbDtcbiAgICAgICAgY29uc3QgZHJhd09wZW5DbG9zZSA9IHRoaXMuX3ByaXZhdGVfX2JhckxpbmVXaWR0aCA8PSB0aGlzLl9wcml2YXRlX19iYXJXaWR0aCAmJiB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9iYXJTcGFjaW5nID49IE1hdGguZmxvb3IoMS41ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb207IGkgPCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG87ICsraSkge1xuICAgICAgICAgICAgY29uc3QgYmFyID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfYmFyc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmV2Q29sb3IgIT09IGJhci5faW50ZXJuYWxfYmFyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFyLl9pbnRlcm5hbF9iYXJDb2xvcjtcbiAgICAgICAgICAgICAgICBwcmV2Q29sb3IgPSBiYXIuX2ludGVybmFsX2JhckNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYm9keVdpZHRoSGFsZiA9IE1hdGguZmxvb3IodGhpcy5fcHJpdmF0ZV9fYmFyTGluZVdpZHRoICogMC41KTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHlDZW50ZXIgPSBNYXRoLnJvdW5kKGJhci5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHlMZWZ0ID0gYm9keUNlbnRlciAtIGJvZHlXaWR0aEhhbGY7XG4gICAgICAgICAgICBjb25zdCBib2R5V2lkdGggPSB0aGlzLl9wcml2YXRlX19iYXJMaW5lV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBib2R5UmlnaHQgPSBib2R5TGVmdCArIGJvZHlXaWR0aCAtIDE7XG4gICAgICAgICAgICBjb25zdCBoaWdoID0gTWF0aC5taW4oYmFyLl9pbnRlcm5hbF9oaWdoWSwgYmFyLl9pbnRlcm5hbF9sb3dZKTtcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IE1hdGgubWF4KGJhci5faW50ZXJuYWxfaGlnaFksIGJhci5faW50ZXJuYWxfbG93WSk7XG4gICAgICAgICAgICBjb25zdCBib2R5VG9wID0gTWF0aC5yb3VuZChoaWdoICogdmVydGljYWxQaXhlbFJhdGlvKSAtIGJvZHlXaWR0aEhhbGY7XG4gICAgICAgICAgICBjb25zdCBib2R5Qm90dG9tID0gTWF0aC5yb3VuZChsb3cgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pICsgYm9keVdpZHRoSGFsZjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHlIZWlnaHQgPSBNYXRoLm1heCgoYm9keUJvdHRvbSAtIGJvZHlUb3ApLCB0aGlzLl9wcml2YXRlX19iYXJMaW5lV2lkdGgpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGJvZHlMZWZ0LCBib2R5VG9wLCBib2R5V2lkdGgsIGJvZHlIZWlnaHQpO1xuICAgICAgICAgICAgY29uc3Qgc2lkZVdpZHRoID0gTWF0aC5jZWlsKHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoICogMS41KTtcbiAgICAgICAgICAgIGlmIChkcmF3T3BlbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX29wZW5WaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZW5MZWZ0ID0gYm9keUNlbnRlciAtIHNpZGVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9wZW5Ub3AgPSBNYXRoLm1heChib2R5VG9wLCBNYXRoLnJvdW5kKGJhci5faW50ZXJuYWxfb3BlblkgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pIC0gYm9keVdpZHRoSGFsZik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvcGVuQm90dG9tID0gb3BlblRvcCArIGJvZHlXaWR0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuQm90dG9tID4gYm9keVRvcCArIGJvZHlIZWlnaHQgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuQm90dG9tID0gYm9keVRvcCArIGJvZHlIZWlnaHQgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlblRvcCA9IG9wZW5Cb3R0b20gLSBib2R5V2lkdGggKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChvcGVuTGVmdCwgb3BlblRvcCwgYm9keUxlZnQgLSBvcGVuTGVmdCwgb3BlbkJvdHRvbSAtIG9wZW5Ub3AgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VSaWdodCA9IGJvZHlDZW50ZXIgKyBzaWRlV2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IGNsb3NlVG9wID0gTWF0aC5tYXgoYm9keVRvcCwgTWF0aC5yb3VuZChiYXIuX2ludGVybmFsX2Nsb3NlWSAqIHZlcnRpY2FsUGl4ZWxSYXRpbykgLSBib2R5V2lkdGhIYWxmKTtcbiAgICAgICAgICAgICAgICBsZXQgY2xvc2VCb3R0b20gPSBjbG9zZVRvcCArIGJvZHlXaWR0aCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlQm90dG9tID4gYm9keVRvcCArIGJvZHlIZWlnaHQgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQm90dG9tID0gYm9keVRvcCArIGJvZHlIZWlnaHQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZVRvcCA9IGNsb3NlQm90dG9tIC0gYm9keVdpZHRoICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGJvZHlSaWdodCArIDEsIGNsb3NlVG9wLCBjbG9zZVJpZ2h0IC0gYm9keVJpZ2h0LCBjbG9zZUJvdHRvbSAtIGNsb3NlVG9wICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2NhbGNCYXJXaWR0aChwaXhlbFJhdGlvKSB7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5mbG9vcihwaXhlbFJhdGlvKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGxpbWl0LCBNYXRoLmZsb29yKG9wdGltYWxCYXJXaWR0aChlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2RhdGEpLl9pbnRlcm5hbF9iYXJTcGFjaW5nLCBwaXhlbFJhdGlvKSkpO1xuICAgIH1cbn1cblxuY2xhc3MgQmFyc1BhbmVWaWV3QmFzZSBleHRlbmRzIFNlcmllc1BhbmVWaWV3QmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzLCBtb2RlbCkge1xuICAgICAgICBzdXBlcihzZXJpZXMsIG1vZGVsLCBmYWxzZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY29udmVydFRvQ29vcmRpbmF0ZXMocHJpY2VTY2FsZSwgdGltZVNjYWxlLCBmaXJzdFZhbHVlKSB7XG4gICAgICAgIHRpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhlc1RvQ29vcmRpbmF0ZXModGhpcy5faW50ZXJuYWxfX2l0ZW1zLCB1bmRlZmluZWRJZk51bGwodGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlKSk7XG4gICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX2JhclByaWNlc1RvQ29vcmRpbmF0ZXModGhpcy5faW50ZXJuYWxfX2l0ZW1zLCBmaXJzdFZhbHVlLCB1bmRlZmluZWRJZk51bGwodGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY3JlYXRlRGVmYXVsdEl0ZW0odGltZSwgYmFyLCBjb2xvcmVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdGltZTogdGltZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9vcGVuOiBiYXIuX2ludGVybmFsX3ZhbHVlWzAgLyogUGxvdFJvd1ZhbHVlSW5kZXguT3BlbiAqL10sXG4gICAgICAgICAgICBfaW50ZXJuYWxfaGlnaDogYmFyLl9pbnRlcm5hbF92YWx1ZVsxIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkhpZ2ggKi9dLFxuICAgICAgICAgICAgX2ludGVybmFsX2xvdzogYmFyLl9pbnRlcm5hbF92YWx1ZVsyIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkxvdyAqL10sXG4gICAgICAgICAgICBfaW50ZXJuYWxfY2xvc2U6IGJhci5faW50ZXJuYWxfdmFsdWVbMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqL10sXG4gICAgICAgICAgICBfaW50ZXJuYWxfeDogTmFOLFxuICAgICAgICAgICAgX2ludGVybmFsX29wZW5ZOiBOYU4sXG4gICAgICAgICAgICBfaW50ZXJuYWxfaGlnaFk6IE5hTixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9sb3dZOiBOYU4sXG4gICAgICAgICAgICBfaW50ZXJuYWxfY2xvc2VZOiBOYU4sXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZmlsbFJhd1BvaW50cygpIHtcbiAgICAgICAgY29uc3QgY29sb3JlciA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2JhckNvbG9yZXIoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2l0ZW1zID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYmFycygpLl9pbnRlcm5hbF9yb3dzKCkubWFwKChyb3cpID0+IHRoaXMuX2ludGVybmFsX19jcmVhdGVSYXdJdGVtKHJvdy5faW50ZXJuYWxfaW5kZXgsIHJvdywgY29sb3JlcikpO1xuICAgIH1cbn1cblxuY2xhc3MgU2VyaWVzQmFyc1BhbmVWaWV3IGV4dGVuZHMgQmFyc1BhbmVWaWV3QmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19yZW5kZXJlciA9IG5ldyBQYW5lUmVuZGVyZXJCYXJzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbSh0aW1lLCBiYXIsIGNvbG9yZXIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5faW50ZXJuYWxfX2NyZWF0ZURlZmF1bHRJdGVtKHRpbWUsIGJhciwgY29sb3JlcikpLCBjb2xvcmVyLl9pbnRlcm5hbF9iYXJTdHlsZSh0aW1lKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fcHJlcGFyZVJlbmRlcmVyRGF0YSgpIHtcbiAgICAgICAgY29uc3QgYmFyU3R5bGVQcm9wcyA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJzOiB0aGlzLl9pbnRlcm5hbF9faXRlbXMsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyU3BhY2luZzogdGhpcy5faW50ZXJuYWxfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfYmFyU3BhY2luZygpLFxuICAgICAgICAgICAgX2ludGVybmFsX29wZW5WaXNpYmxlOiBiYXJTdHlsZVByb3BzLm9wZW5WaXNpYmxlLFxuICAgICAgICAgICAgX2ludGVybmFsX3RoaW5CYXJzOiBiYXJTdHlsZVByb3BzLnRoaW5CYXJzLFxuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGVSYW5nZTogdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIFBhbmVSZW5kZXJlckJhc2VsaW5lQXJlYSBleHRlbmRzIFBhbmVSZW5kZXJlckFyZWFCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZmlsbENhY2hlID0gbmV3IEdyYWRpZW50U3R5bGVDYWNoZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2ZpbGxTdHlsZShyZW5kZXJpbmdTY29wZSwgaXRlbSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5faW50ZXJuYWxfX2RhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19maWxsQ2FjaGUuX2ludGVybmFsX2dldChyZW5kZXJpbmdTY29wZSwge1xuICAgICAgICAgICAgX2ludGVybmFsX3RvcENvbG9yMTogaXRlbS5faW50ZXJuYWxfdG9wRmlsbENvbG9yMSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3BDb2xvcjI6IGl0ZW0uX2ludGVybmFsX3RvcEZpbGxDb2xvcjIsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tQ29sb3IxOiBpdGVtLl9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IxLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvdHRvbUNvbG9yMjogaXRlbS5faW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3R0b206IHJlbmRlcmluZ1Njb3BlLmJpdG1hcFNpemUuaGVpZ2h0LFxuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGU6IGRhdGEuX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgUGFuZVJlbmRlcmVyQmFzZWxpbmVMaW5lIGV4dGVuZHMgUGFuZVJlbmRlcmVyTGluZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdHJva2VDYWNoZSA9IG5ldyBHcmFkaWVudFN0eWxlQ2FjaGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19zdHJva2VTdHlsZShyZW5kZXJpbmdTY29wZSwgaXRlbSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5faW50ZXJuYWxfX2RhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zdHJva2VDYWNoZS5faW50ZXJuYWxfZ2V0KHJlbmRlcmluZ1Njb3BlLCB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29sb3IxOiBpdGVtLl9pbnRlcm5hbF90b3BMaW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29sb3IyOiBpdGVtLl9pbnRlcm5hbF90b3BMaW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tQ29sb3IxOiBpdGVtLl9pbnRlcm5hbF9ib3R0b21MaW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tQ29sb3IyOiBpdGVtLl9pbnRlcm5hbF9ib3R0b21MaW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tOiByZW5kZXJpbmdTY29wZS5iaXRtYXBTaXplLmhlaWdodCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlTGV2ZWxDb29yZGluYXRlOiBkYXRhLl9pbnRlcm5hbF9iYXNlTGV2ZWxDb29yZGluYXRlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIFNlcmllc0Jhc2VsaW5lUGFuZVZpZXcgZXh0ZW5kcyBMaW5lUGFuZVZpZXdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMsIG1vZGVsKSB7XG4gICAgICAgIHN1cGVyKHNlcmllcywgbW9kZWwpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fcmVuZGVyZXIgPSBuZXcgQ29tcG9zaXRlUmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFzZWxpbmVBcmVhUmVuZGVyZXIgPSBuZXcgUGFuZVJlbmRlcmVyQmFzZWxpbmVBcmVhKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VsaW5lTGluZVJlbmRlcmVyID0gbmV3IFBhbmVSZW5kZXJlckJhc2VsaW5lTGluZSgpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fcmVuZGVyZXIuX2ludGVybmFsX3NldFJlbmRlcmVycyhbdGhpcy5fcHJpdmF0ZV9fYmFzZWxpbmVBcmVhUmVuZGVyZXIsIHRoaXMuX3ByaXZhdGVfX2Jhc2VsaW5lTGluZVJlbmRlcmVyXSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbSh0aW1lLCBwcmljZSwgY29sb3Jlcikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbUJhc2UodGltZSwgcHJpY2UpKSwgY29sb3Jlci5faW50ZXJuYWxfYmFyU3R5bGUodGltZSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3ByZXBhcmVSZW5kZXJlckRhdGEoKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgYmFzZUxldmVsQ29vcmRpbmF0ZSA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX3ByaWNlU2NhbGUoKS5faW50ZXJuYWxfcHJpY2VUb0Nvb3JkaW5hdGUob3B0aW9ucy5iYXNlVmFsdWUucHJpY2UsIGZpcnN0VmFsdWUuX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgY29uc3QgYmFyV2lkdGggPSB0aGlzLl9pbnRlcm5hbF9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9iYXJTcGFjaW5nKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VsaW5lQXJlYVJlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pdGVtczogdGhpcy5faW50ZXJuYWxfX2l0ZW1zLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVXaWR0aDogb3B0aW9ucy5saW5lV2lkdGgsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVN0eWxlOiBvcHRpb25zLmxpbmVTdHlsZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lVHlwZTogb3B0aW9ucy5saW5lVHlwZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlTGV2ZWxDb29yZGluYXRlOiBiYXNlTGV2ZWxDb29yZGluYXRlLFxuICAgICAgICAgICAgX2ludGVybmFsX2ludmVydEZpbGxlZEFyZWE6IGZhbHNlLFxuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGVSYW5nZTogdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlLFxuICAgICAgICAgICAgX2ludGVybmFsX2JhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VsaW5lTGluZVJlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pdGVtczogdGhpcy5faW50ZXJuYWxfX2l0ZW1zLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVXaWR0aDogb3B0aW9ucy5saW5lV2lkdGgsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVN0eWxlOiBvcHRpb25zLmxpbmVTdHlsZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lVHlwZTogb3B0aW9ucy5saW5lVmlzaWJsZSA/IG9wdGlvbnMubGluZVR5cGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfaW50ZXJuYWxfcG9pbnRNYXJrZXJzUmFkaXVzOiBvcHRpb25zLnBvaW50TWFya2Vyc1Zpc2libGUgPyAob3B0aW9ucy5wb2ludE1hcmtlcnNSYWRpdXMgfHwgb3B0aW9ucy5saW5lV2lkdGggLyAyICsgMikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFzZUxldmVsQ29vcmRpbmF0ZTogYmFzZUxldmVsQ29vcmRpbmF0ZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlUmFuZ2U6IHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgUGFuZVJlbmRlcmVyQ2FuZGxlc3RpY2tzIGV4dGVuZHMgQml0bWFwQ29vcmRpbmF0ZXNQYW5lUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gbnVsbDtcbiAgICAgICAgLy8gc2NhbGVkIHdpdGggcGl4ZWxSYXRpb1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJXaWR0aCA9IDA7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZHJhd0ltcGwocmVuZGVyaW5nU2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEgPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfYmFycy5sZW5ndGggPT09IDAgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBob3Jpem9udGFsUGl4ZWxSYXRpbyB9ID0gcmVuZGVyaW5nU2NvcGU7XG4gICAgICAgIC8vIG5vdyB3ZSBrbm93IHBpeGVsUmF0aW8gYW5kIHdlIGNvdWxkIGNhbGN1bGF0ZSBiYXJXaWR0aCBlZmZlY3RpdmVseVxuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJXaWR0aCA9IG9wdGltYWxDYW5kbGVzdGlja1dpZHRoKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JhclNwYWNpbmcsIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgLy8gZ3JpZCBhbmQgY3Jvc3NoYWlyIGhhdmUgbGluZSB3aWR0aCA9IE1hdGguZmxvb3IocGl4ZWxSYXRpbylcbiAgICAgICAgLy8gaWYgdGhpcyB2YWx1ZSBpcyBvZGQsIHdlIGhhdmUgdG8gbWFrZSBjYW5kbGVzdGlja3MnIHdpZHRoIG9kZFxuICAgICAgICAvLyBpZiB0aGlzIHZhbHVlIGlzIGV2ZW4sIHdlIGhhdmUgdG8gbWFrZSBjYW5kbGVzdGlja3MnIHdpZHRoIGV2ZW5cbiAgICAgICAgLy8gaW4gb3JkZXIgb2Yga2VlcGluZyBjcm9zc2hhaXItb3Zlci1jYW5kbGVzdGlja3MgZHJhd2luZyBzeW1tZXRyaWNcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoID49IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpY2tXaWR0aCA9IE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgaWYgKCh3aWNrV2lkdGggJSAyKSAhPT0gKHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoICUgMikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJXaWR0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhcnMgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9iYXJzO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfd2lja1Zpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdXaWNrcyhyZW5kZXJpbmdTY29wZSwgYmFycywgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfYm9yZGVyVmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0JvcmRlcihyZW5kZXJpbmdTY29wZSwgYmFycywgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IHRoaXMuX3ByaXZhdGVfX2NhbGN1bGF0ZUJvcmRlcldpZHRoKGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9ib3JkZXJWaXNpYmxlIHx8IHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoID4gYm9yZGVyV2lkdGggKiAyKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3Q2FuZGxlcyhyZW5kZXJpbmdTY29wZSwgYmFycywgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd1dpY2tzKHJlbmRlcmluZ1Njb3BlLCBiYXJzLCB2aXNpYmxlUmFuZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNvbnRleHQ6IGN0eCwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9ID0gcmVuZGVyaW5nU2NvcGU7XG4gICAgICAgIGxldCBwcmV2V2lja0NvbG9yID0gJyc7XG4gICAgICAgIGxldCB3aWNrV2lkdGggPSBNYXRoLm1pbihNYXRoLmZsb29yKGhvcml6b250YWxQaXhlbFJhdGlvKSwgTWF0aC5mbG9vcih0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9iYXJTcGFjaW5nICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pKTtcbiAgICAgICAgd2lja1dpZHRoID0gTWF0aC5tYXgoTWF0aC5mbG9vcihob3Jpem9udGFsUGl4ZWxSYXRpbyksIE1hdGgubWluKHdpY2tXaWR0aCwgdGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGgpKTtcbiAgICAgICAgY29uc3Qgd2lja09mZnNldCA9IE1hdGguZmxvb3Iod2lja1dpZHRoICogMC41KTtcbiAgICAgICAgbGV0IHByZXZFZGdlID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHZpc2libGVSYW5nZS5mcm9tOyBpIDwgdmlzaWJsZVJhbmdlLnRvOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJhciA9IGJhcnNbaV07XG4gICAgICAgICAgICBpZiAoYmFyLl9pbnRlcm5hbF9iYXJXaWNrQ29sb3IgIT09IHByZXZXaWNrQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFyLl9pbnRlcm5hbF9iYXJXaWNrQ29sb3I7XG4gICAgICAgICAgICAgICAgcHJldldpY2tDb2xvciA9IGJhci5faW50ZXJuYWxfYmFyV2lja0NvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9wID0gTWF0aC5yb3VuZChNYXRoLm1pbihiYXIuX2ludGVybmFsX29wZW5ZLCBiYXIuX2ludGVybmFsX2Nsb3NlWSkgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gTWF0aC5yb3VuZChNYXRoLm1heChiYXIuX2ludGVybmFsX29wZW5ZLCBiYXIuX2ludGVybmFsX2Nsb3NlWSkgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgaGlnaCA9IE1hdGgucm91bmQoYmFyLl9pbnRlcm5hbF9oaWdoWSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBsb3cgPSBNYXRoLnJvdW5kKGJhci5faW50ZXJuYWxfbG93WSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRYID0gTWF0aC5yb3VuZChob3Jpem9udGFsUGl4ZWxSYXRpbyAqIGJhci5faW50ZXJuYWxfeCk7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHNjYWxlZFggLSB3aWNrT2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgd2lja1dpZHRoIC0gMTtcbiAgICAgICAgICAgIGlmIChwcmV2RWRnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChwcmV2RWRnZSArIDEsIGxlZnQpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QobGVmdCwgaGlnaCwgd2lkdGgsIHRvcCAtIGhpZ2gpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGxlZnQsIGJvdHRvbSArIDEsIHdpZHRoLCBsb3cgLSBib3R0b20pO1xuICAgICAgICAgICAgcHJldkVkZ2UgPSByaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fY2FsY3VsYXRlQm9yZGVyV2lkdGgocGl4ZWxSYXRpbykge1xuICAgICAgICBsZXQgYm9yZGVyV2lkdGggPSBNYXRoLmZsb29yKDEgLyogQ29uc3RhbnRzLkJhckJvcmRlcldpZHRoICovICogcGl4ZWxSYXRpbyk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19iYXJXaWR0aCA8PSAyICogYm9yZGVyV2lkdGgpIHtcbiAgICAgICAgICAgIGJvcmRlcldpZHRoID0gTWF0aC5mbG9vcigodGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggLSAxKSAqIDAuNSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gTWF0aC5tYXgoTWF0aC5mbG9vcihwaXhlbFJhdGlvKSwgYm9yZGVyV2lkdGgpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggPD0gcmVzICogMikge1xuICAgICAgICAgICAgLy8gZG8gbm90IGRyYXcgYm9kaWVzLCByZXN0b3JlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5mbG9vcihwaXhlbFJhdGlvKSwgTWF0aC5mbG9vcigxIC8qIENvbnN0YW50cy5CYXJCb3JkZXJXaWR0aCAqLyAqIHBpeGVsUmF0aW8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0JvcmRlcihyZW5kZXJpbmdTY29wZSwgYmFycywgdmlzaWJsZVJhbmdlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjb250ZXh0OiBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSA9IHJlbmRlcmluZ1Njb3BlO1xuICAgICAgICBsZXQgcHJldkJvcmRlckNvbG9yID0gJyc7XG4gICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdGhpcy5fcHJpdmF0ZV9fY2FsY3VsYXRlQm9yZGVyV2lkdGgoaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICBsZXQgcHJldkVkZ2UgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gdmlzaWJsZVJhbmdlLmZyb207IGkgPCB2aXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYmFyID0gYmFyc1tpXTtcbiAgICAgICAgICAgIGlmIChiYXIuX2ludGVybmFsX2JhckJvcmRlckNvbG9yICE9PSBwcmV2Qm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFyLl9pbnRlcm5hbF9iYXJCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICBwcmV2Qm9yZGVyQ29sb3IgPSBiYXIuX2ludGVybmFsX2JhckJvcmRlckNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxlZnQgPSBNYXRoLnJvdW5kKGJhci5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvKSAtIE1hdGguZmxvb3IodGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggKiAwLjUpO1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgdG8gY2FsY3VsYXRlIHJpZ2h0IGJlZm9yZSBwYXRjaGluZyBsZWZ0XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGxlZnQgKyB0aGlzLl9wcml2YXRlX19iYXJXaWR0aCAtIDE7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBNYXRoLnJvdW5kKE1hdGgubWluKGJhci5faW50ZXJuYWxfb3BlblksIGJhci5faW50ZXJuYWxfY2xvc2VZKSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBNYXRoLnJvdW5kKE1hdGgubWF4KGJhci5faW50ZXJuYWxfb3BlblksIGJhci5faW50ZXJuYWxfY2xvc2VZKSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBpZiAocHJldkVkZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5tYXgocHJldkVkZ2UgKyAxLCBsZWZ0KTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5taW4obGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JhclNwYWNpbmcgKiBob3Jpem9udGFsUGl4ZWxSYXRpbyA+IDIgKiBib3JkZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIGZpbGxSZWN0SW5uZXJCb3JkZXIoY3R4LCBsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCArIDEsIGJvdHRvbSAtIHRvcCArIDEsIGJvcmRlcldpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgYm90dG9tIC0gdG9wICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2RWRnZSA9IHJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3Q2FuZGxlcyhyZW5kZXJpbmdTY29wZSwgYmFycywgdmlzaWJsZVJhbmdlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjb250ZXh0OiBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSA9IHJlbmRlcmluZ1Njb3BlO1xuICAgICAgICBsZXQgcHJldkJhckNvbG9yID0gJyc7XG4gICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdGhpcy5fcHJpdmF0ZV9fY2FsY3VsYXRlQm9yZGVyV2lkdGgoaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICBmb3IgKGxldCBpID0gdmlzaWJsZVJhbmdlLmZyb207IGkgPCB2aXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYmFyID0gYmFyc1tpXTtcbiAgICAgICAgICAgIGxldCB0b3AgPSBNYXRoLnJvdW5kKE1hdGgubWluKGJhci5faW50ZXJuYWxfb3BlblksIGJhci5faW50ZXJuYWxfY2xvc2VZKSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gTWF0aC5yb3VuZChNYXRoLm1heChiYXIuX2ludGVybmFsX29wZW5ZLCBiYXIuX2ludGVybmFsX2Nsb3NlWSkgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSBNYXRoLnJvdW5kKGJhci5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvKSAtIE1hdGguZmxvb3IodGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggKiAwLjUpO1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gbGVmdCArIHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoIC0gMTtcbiAgICAgICAgICAgIGlmIChiYXIuX2ludGVybmFsX2JhckNvbG9yICE9PSBwcmV2QmFyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXJDb2xvciA9IGJhci5faW50ZXJuYWxfYmFyQ29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhckNvbG9yO1xuICAgICAgICAgICAgICAgIHByZXZCYXJDb2xvciA9IGJhckNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JvcmRlclZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IGJvcmRlcldpZHRoO1xuICAgICAgICAgICAgICAgIHRvcCArPSBib3JkZXJXaWR0aDtcbiAgICAgICAgICAgICAgICByaWdodCAtPSBib3JkZXJXaWR0aDtcbiAgICAgICAgICAgICAgICBib3R0b20gLT0gYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wID4gYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QobGVmdCwgdG9wLCByaWdodCAtIGxlZnQgKyAxLCBib3R0b20gLSB0b3AgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgU2VyaWVzQ2FuZGxlc3RpY2tzUGFuZVZpZXcgZXh0ZW5kcyBCYXJzUGFuZVZpZXdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyID0gbmV3IFBhbmVSZW5kZXJlckNhbmRsZXN0aWNrcygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2NyZWF0ZVJhd0l0ZW0odGltZSwgYmFyLCBjb2xvcmVyKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2ludGVybmFsX19jcmVhdGVEZWZhdWx0SXRlbSh0aW1lLCBiYXIsIGNvbG9yZXIpKSwgY29sb3Jlci5faW50ZXJuYWxfYmFyU3R5bGUodGltZSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3ByZXBhcmVSZW5kZXJlckRhdGEoKSB7XG4gICAgICAgIGNvbnN0IGNhbmRsZXN0aWNrU3R5bGVQcm9wcyA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJzOiB0aGlzLl9pbnRlcm5hbF9faXRlbXMsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyU3BhY2luZzogdGhpcy5faW50ZXJuYWxfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfYmFyU3BhY2luZygpLFxuICAgICAgICAgICAgX2ludGVybmFsX3dpY2tWaXNpYmxlOiBjYW5kbGVzdGlja1N0eWxlUHJvcHMud2lja1Zpc2libGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm9yZGVyVmlzaWJsZTogY2FuZGxlc3RpY2tTdHlsZVByb3BzLmJvcmRlclZpc2libGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdmlzaWJsZVJhbmdlOiB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgQ3VzdG9tU2VyaWVzUGFuZVJlbmRlcmVyV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlUmVuZGVyZXIsIHByaWNlU2NhbGUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc291cmNlUmVuZGVyZXIgPSBzb3VyY2VSZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9IHByaWNlU2NhbGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3KHRhcmdldCwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zb3VyY2VSZW5kZXJlci5kcmF3KHRhcmdldCwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSk7XG4gICAgfVxufVxuY2xhc3MgU2VyaWVzQ3VzdG9tUGFuZVZpZXcgZXh0ZW5kcyBTZXJpZXNQYW5lVmlld0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgbW9kZWwsIHBhbmVWaWV3KSB7XG4gICAgICAgIHN1cGVyKHNlcmllcywgbW9kZWwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcgPSBwYW5lVmlldztcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyID0gbmV3IEN1c3RvbVNlcmllc1BhbmVSZW5kZXJlcldyYXBwZXIodGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcucmVuZGVyZXIoKSwgKHByaWNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlcmllcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZShwcmljZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlVmFsdWVCdWlsZGVyKHBsb3RSb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3LnByaWNlVmFsdWVCdWlsZGVyKHBsb3RSb3cpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNXaGl0ZXNwYWNlKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3LmlzV2hpdGVzcGFjZShkYXRhKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19maWxsUmF3UG9pbnRzKCkge1xuICAgICAgICBjb25zdCBjb2xvcmVyID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYmFyQ29sb3JlcigpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9faXRlbXMgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9iYXJzKCkuX2ludGVybmFsX3Jvd3MoKVxuICAgICAgICAgICAgLm1hcCgocm93KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgX2ludGVybmFsX3RpbWU6IHJvdy5faW50ZXJuYWxfaW5kZXgsIF9pbnRlcm5hbF94OiBOYU4gfSwgY29sb3Jlci5faW50ZXJuYWxfYmFyU3R5bGUocm93Ll9pbnRlcm5hbF9pbmRleCkpLCB7IF9pbnRlcm5hbF9vcmlnaW5hbERhdGE6IHJvdy5faW50ZXJuYWxfZGF0YSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY29udmVydFRvQ29vcmRpbmF0ZXMocHJpY2VTY2FsZSwgdGltZVNjYWxlKSB7XG4gICAgICAgIHRpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhlc1RvQ29vcmRpbmF0ZXModGhpcy5faW50ZXJuYWxfX2l0ZW1zLCB1bmRlZmluZWRJZk51bGwodGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fcHJlcGFyZVJlbmRlcmVyRGF0YSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcudXBkYXRlKHtcbiAgICAgICAgICAgIGJhcnM6IHRoaXMuX2ludGVybmFsX19pdGVtcy5tYXAodW53cmFwSXRlbURhdGEpLFxuICAgICAgICAgICAgYmFyU3BhY2luZzogdGhpcy5faW50ZXJuYWxfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfYmFyU3BhY2luZygpLFxuICAgICAgICAgICAgdmlzaWJsZVJhbmdlOiB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UsXG4gICAgICAgIH0sIHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdW53cmFwSXRlbURhdGEoaXRlbSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGl0ZW0uX2ludGVybmFsX3gsXG4gICAgICAgIHRpbWU6IGl0ZW0uX2ludGVybmFsX3RpbWUsXG4gICAgICAgIG9yaWdpbmFsRGF0YTogaXRlbS5faW50ZXJuYWxfb3JpZ2luYWxEYXRhLFxuICAgICAgICBiYXJDb2xvcjogaXRlbS5faW50ZXJuYWxfYmFyQ29sb3IsXG4gICAgfTtcbn1cblxuY29uc3Qgc2hvd1NwYWNpbmdNaW5pbWFsQmFyV2lkdGggPSAxO1xuY29uc3QgYWxpZ25Ub01pbmltYWxXaWR0aExpbWl0ID0gNDtcbmNsYXNzIFBhbmVSZW5kZXJlckhpc3RvZ3JhbSBleHRlbmRzIEJpdG1hcENvb3JkaW5hdGVzUGFuZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByZWNhbGN1bGF0ZWRDYWNoZSA9IFtdO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmVjYWxjdWxhdGVkQ2FjaGUgPSBbXTtcbiAgICB9XG4gICAgX2ludGVybmFsX19kcmF3SW1wbCh7IGNvbnRleHQ6IGN0eCwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2l0ZW1zLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3ByZWNhbGN1bGF0ZWRDYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZpbGxQcmVjYWxjdWxhdGVkQ2FjaGUoaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IodmVydGljYWxQaXhlbFJhdGlvKSk7XG4gICAgICAgIGNvbnN0IGhpc3RvZ3JhbUJhc2UgPSBNYXRoLnJvdW5kKCh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9oaXN0b2dyYW1CYXNlKSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgIGNvbnN0IHRvcEhpc3RvZ3JhbUJhc2UgPSBoaXN0b2dyYW1CYXNlIC0gTWF0aC5mbG9vcih0aWNrV2lkdGggLyAyKTtcbiAgICAgICAgY29uc3QgYm90dG9tSGlzdG9ncmFtQmFzZSA9IHRvcEhpc3RvZ3JhbUJhc2UgKyB0aWNrV2lkdGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbTsgaSA8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaXRlbXNbaV07XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fcHJpdmF0ZV9fcHJlY2FsY3VsYXRlZENhY2hlW2kgLSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbV07XG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZChpdGVtLl9pbnRlcm5hbF95ICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBpdGVtLl9pbnRlcm5hbF9iYXJDb2xvcjtcbiAgICAgICAgICAgIGxldCB0b3A7XG4gICAgICAgICAgICBsZXQgYm90dG9tO1xuICAgICAgICAgICAgaWYgKHkgPD0gdG9wSGlzdG9ncmFtQmFzZSkge1xuICAgICAgICAgICAgICAgIHRvcCA9IHk7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gYm90dG9tSGlzdG9ncmFtQmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvcCA9IHRvcEhpc3RvZ3JhbUJhc2U7XG4gICAgICAgICAgICAgICAgYm90dG9tID0geSAtIE1hdGguZmxvb3IodGlja1dpZHRoIC8gMikgKyB0aWNrV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoY3VycmVudC5faW50ZXJuYWxfbGVmdCwgdG9wLCBjdXJyZW50Ll9pbnRlcm5hbF9yaWdodCAtIGN1cnJlbnQuX2ludGVybmFsX2xlZnQgKyAxLCBib3R0b20gLSB0b3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgX3ByaXZhdGVfX2ZpbGxQcmVjYWxjdWxhdGVkQ2FjaGUocGl4ZWxSYXRpbykge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YSA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9pdGVtcy5sZW5ndGggPT09IDAgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmVjYWxjdWxhdGVkQ2FjaGUgPSBbXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGFjaW5nID0gTWF0aC5jZWlsKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JhclNwYWNpbmcgKiBwaXhlbFJhdGlvKSA8PSBzaG93U3BhY2luZ01pbmltYWxCYXJXaWR0aCA/IDAgOiBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHBpeGVsUmF0aW8pKTtcbiAgICAgICAgY29uc3QgY29sdW1uV2lkdGggPSBNYXRoLnJvdW5kKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JhclNwYWNpbmcgKiBwaXhlbFJhdGlvKSAtIHNwYWNpbmc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByZWNhbGN1bGF0ZWRDYWNoZSA9IG5ldyBBcnJheSh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG8gLSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbTsgaSA8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaXRlbXNbaV07XG4gICAgICAgICAgICAvLyBmb3JjZSBjYXN0IHRvIGF2b2lkIGVuc3VyZURlZmluZWQgY2FsbFxuICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQoaXRlbS5faW50ZXJuYWxfeCAqIHBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgbGV0IGxlZnQ7XG4gICAgICAgICAgICBsZXQgcmlnaHQ7XG4gICAgICAgICAgICBpZiAoY29sdW1uV2lkdGggJSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFsZldpZHRoID0gKGNvbHVtbldpZHRoIC0gMSkgLyAyO1xuICAgICAgICAgICAgICAgIGxlZnQgPSB4IC0gaGFsZldpZHRoO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0geCArIGhhbGZXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNoaWZ0IHBpeGVsIHRvIGxlZnRcbiAgICAgICAgICAgICAgICBjb25zdCBoYWxmV2lkdGggPSBjb2x1bW5XaWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHggLSBoYWxmV2lkdGg7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB4ICsgaGFsZldpZHRoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByZWNhbGN1bGF0ZWRDYWNoZVtpIC0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb21dID0ge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9sZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9yaWdodDogcmlnaHQsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3JvdW5kZWRDZW50ZXI6IHgsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2NlbnRlcjogKGl0ZW0uX2ludGVybmFsX3ggKiBwaXhlbFJhdGlvKSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGltZTogaXRlbS5faW50ZXJuYWxfdGltZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29ycmVjdCBwb3NpdGlvbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS5mcm9tICsgMTsgaSA8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fcHJpdmF0ZV9fcHJlY2FsY3VsYXRlZENhY2hlW2kgLSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbV07XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fcHJpdmF0ZV9fcHJlY2FsY3VsYXRlZENhY2hlW2kgLSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbSAtIDFdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuX2ludGVybmFsX3RpbWUgIT09IHByZXYuX2ludGVybmFsX3RpbWUgKyAxKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudC5faW50ZXJuYWxfbGVmdCAtIHByZXYuX2ludGVybmFsX3JpZ2h0ICE9PSAoc3BhY2luZyArIDEpKSB7XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBhbGlnblxuICAgICAgICAgICAgICAgIGlmIChwcmV2Ll9pbnRlcm5hbF9yb3VuZGVkQ2VudGVyID4gcHJldi5faW50ZXJuYWxfY2VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXYgd2Fzc2hpZnRlZCB0byBsZWZ0LCBzbyBhZGQgcGl4ZWwgdG8gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgcHJldi5faW50ZXJuYWxfcmlnaHQgPSBjdXJyZW50Ll9pbnRlcm5hbF9sZWZ0IC0gc3BhY2luZyAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBleHRlbmQgY3VycmVudCB0byBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuX2ludGVybmFsX2xlZnQgPSBwcmV2Ll9pbnRlcm5hbF9yaWdodCArIHNwYWNpbmcgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWluV2lkdGggPSBNYXRoLmNlaWwodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfYmFyU3BhY2luZyAqIHBpeGVsUmF0aW8pO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb207IGkgPCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX3ByaXZhdGVfX3ByZWNhbGN1bGF0ZWRDYWNoZVtpIC0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb21dO1xuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaWYgYmFyc3BhY2luZyA8IDFcbiAgICAgICAgICAgIGlmIChjdXJyZW50Ll9pbnRlcm5hbF9yaWdodCA8IGN1cnJlbnQuX2ludGVybmFsX2xlZnQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Ll9pbnRlcm5hbF9yaWdodCA9IGN1cnJlbnQuX2ludGVybmFsX2xlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGN1cnJlbnQuX2ludGVybmFsX3JpZ2h0IC0gY3VycmVudC5faW50ZXJuYWxfbGVmdCArIDE7XG4gICAgICAgICAgICBtaW5XaWR0aCA9IE1hdGgubWluKHdpZHRoLCBtaW5XaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwYWNpbmcgPiAwICYmIG1pbldpZHRoIDwgYWxpZ25Ub01pbmltYWxXaWR0aExpbWl0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb207IGkgPCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLl9wcml2YXRlX19wcmVjYWxjdWxhdGVkQ2FjaGVbaSAtIHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS5mcm9tXTtcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IGN1cnJlbnQuX2ludGVybmFsX3JpZ2h0IC0gY3VycmVudC5faW50ZXJuYWxfbGVmdCArIDE7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoID4gbWluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuX2ludGVybmFsX3JvdW5kZWRDZW50ZXIgPiBjdXJyZW50Ll9pbnRlcm5hbF9jZW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuX2ludGVybmFsX3JpZ2h0IC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Ll9pbnRlcm5hbF9sZWZ0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFNlcmllc0hpc3RvZ3JhbVBhbmVWaWV3IGV4dGVuZHMgTGluZVBhbmVWaWV3QmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19yZW5kZXJlciA9IG5ldyBQYW5lUmVuZGVyZXJIaXN0b2dyYW0oKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19jcmVhdGVSYXdJdGVtKHRpbWUsIHByaWNlLCBjb2xvcmVyKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2ludGVybmFsX19jcmVhdGVSYXdJdGVtQmFzZSh0aW1lLCBwcmljZSkpLCBjb2xvcmVyLl9pbnRlcm5hbF9iYXJTdHlsZSh0aW1lKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fcHJlcGFyZVJlbmRlcmVyRGF0YSgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pdGVtczogdGhpcy5faW50ZXJuYWxfX2l0ZW1zLFxuICAgICAgICAgICAgX2ludGVybmFsX2JhclNwYWNpbmc6IHRoaXMuX2ludGVybmFsX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2JhclNwYWNpbmcoKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlUmFuZ2U6IHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9oaXN0b2dyYW1CYXNlOiB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKS5iYXNlLCBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2ZpcnN0VmFsdWUoKSkuX2ludGVybmFsX3ZhbHVlKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKGRhdGEpO1xuICAgIH1cbn1cblxuY2xhc3MgU2VyaWVzTGluZVBhbmVWaWV3IGV4dGVuZHMgTGluZVBhbmVWaWV3QmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19yZW5kZXJlciA9IG5ldyBQYW5lUmVuZGVyZXJMaW5lKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbSh0aW1lLCBwcmljZSwgY29sb3Jlcikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbUJhc2UodGltZSwgcHJpY2UpKSwgY29sb3Jlci5faW50ZXJuYWxfYmFyU3R5bGUodGltZSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3ByZXBhcmVSZW5kZXJlckRhdGEoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfaXRlbXM6IHRoaXMuX2ludGVybmFsX19pdGVtcyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lU3R5bGU6IG9wdGlvbnMubGluZVN0eWxlLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVUeXBlOiBvcHRpb25zLmxpbmVWaXNpYmxlID8gb3B0aW9ucy5saW5lVHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lV2lkdGg6IG9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgICAgICAgX2ludGVybmFsX3BvaW50TWFya2Vyc1JhZGl1czogb3B0aW9ucy5wb2ludE1hcmtlcnNWaXNpYmxlID8gKG9wdGlvbnMucG9pbnRNYXJrZXJzUmFkaXVzIHx8IG9wdGlvbnMubGluZVdpZHRoIC8gMiArIDIpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGVSYW5nZTogdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlLFxuICAgICAgICAgICAgX2ludGVybmFsX2JhcldpZHRoOiB0aGlzLl9pbnRlcm5hbF9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9iYXJTcGFjaW5nKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19yZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YShkYXRhKTtcbiAgICB9XG59XG5cbmNvbnN0IGRlZmF1bHRSZXBsYWNlbWVudFJlID0gL1syLTldL2c7XG5jbGFzcyBUZXh0V2lkdGhDYWNoZSB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSA9IDUwKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjdHVhbFNpemUgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191c2FnZVRpY2sgPSAxO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbGRlc3RUaWNrID0gMTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGljazJMYWJlbHMgPSB7fTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21heFNpemUgPSBzaXplO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjdHVhbFNpemUgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191c2FnZVRpY2sgPSAxO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbGRlc3RUaWNrID0gMTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGljazJMYWJlbHMgPSB7fTtcbiAgICB9XG4gICAgX2ludGVybmFsX21lYXN1cmVUZXh0KGN0eCwgdGV4dCwgb3B0aW1pemF0aW9uUmVwbGFjZW1lbnRSZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZ2V0TWV0cmljcyhjdHgsIHRleHQsIG9wdGltaXphdGlvblJlcGxhY2VtZW50UmUpLndpZHRoO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfeU1pZENvcnJlY3Rpb24oY3R4LCB0ZXh0LCBvcHRpbWl6YXRpb25SZXBsYWNlbWVudFJlKSB7XG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSB0aGlzLl9wcml2YXRlX19nZXRNZXRyaWNzKGN0eCwgdGV4dCwgb3B0aW1pemF0aW9uUmVwbGFjZW1lbnRSZSk7XG4gICAgICAgIC8vIGlmIGFjdHVhbEJvdW5kaW5nQm94QXNjZW50L2FjdHVhbEJvdW5kaW5nQm94RGVzY2VudCBhcmUgbm90IHN1cHBvcnRlZCB3ZSB1c2UgMCBhcyBhIGZhbGxiYWNrXG4gICAgICAgIHJldHVybiAoKG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgfHwgMCkgLSAobWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQgfHwgMCkpIC8gMjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldE1ldHJpY3MoY3R4LCB0ZXh0LCBvcHRpbWl6YXRpb25SZXBsYWNlbWVudFJlKSB7XG4gICAgICAgIGNvbnN0IHJlID0gb3B0aW1pemF0aW9uUmVwbGFjZW1lbnRSZSB8fCBkZWZhdWx0UmVwbGFjZW1lbnRSZTtcbiAgICAgICAgY29uc3QgY2FjaGVTdHJpbmcgPSBTdHJpbmcodGV4dCkucmVwbGFjZShyZSwgJzAnKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NhY2hlLmhhcyhjYWNoZVN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX2NhY2hlLmdldChjYWNoZVN0cmluZykpLl9pbnRlcm5hbF9tZXRyaWNzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19hY3R1YWxTaXplID09PSB0aGlzLl9wcml2YXRlX19tYXhTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRlc3RWYWx1ZSA9IHRoaXMuX3ByaXZhdGVfX3RpY2syTGFiZWxzW3RoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2tdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3ByaXZhdGVfX3RpY2syTGFiZWxzW3RoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2tdO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGUuZGVsZXRlKG9sZGVzdFZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2srKztcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjdHVhbFNpemUtLTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQoY2FjaGVTdHJpbmcpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBpZiAobWV0cmljcy53aWR0aCA9PT0gMCAmJiAhIXRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBtZWFzdXJlVGV4dCBjYW4gcmV0dXJuIDAgaW4gRkYgZGVwZW5kaW5nIG9uIGEgY2FudmFzIHNpemUsIGRvbid0IGNhY2hlIGl0XG4gICAgICAgICAgICByZXR1cm4gbWV0cmljcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZS5zZXQoY2FjaGVTdHJpbmcsIHsgX2ludGVybmFsX21ldHJpY3M6IG1ldHJpY3MsIF9pbnRlcm5hbF90aWNrOiB0aGlzLl9wcml2YXRlX191c2FnZVRpY2sgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpY2syTGFiZWxzW3RoaXMuX3ByaXZhdGVfX3VzYWdlVGlja10gPSBjYWNoZVN0cmluZztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWN0dWFsU2l6ZSsrO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191c2FnZVRpY2srKztcbiAgICAgICAgcmV0dXJuIG1ldHJpY3M7XG4gICAgfVxufVxuXG5jbGFzcyBQYW5lUHJpY2VBeGlzVmlld1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0V2lkdGhDYWNoZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3UmVuZGVyZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RleHRXaWR0aENhY2hlID0gdGV4dFdpZHRoQ2FjaGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRQYXJhbXMocHJpY2VBeGlzVmlld1JlbmRlcmVyLCByZW5kZXJlck9wdGlvbnMsIGFsaWduKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdSZW5kZXJlciA9IHByaWNlQXhpc1ZpZXdSZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zID0gcmVuZGVyZXJPcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hbGlnbiA9IGFsaWduO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZHJhdyh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9ucyA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3UmVuZGVyZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3UmVuZGVyZXIuX2ludGVybmFsX2RyYXcodGFyZ2V0LCB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMsIHRoaXMuX3ByaXZhdGVfX3RleHRXaWR0aENhY2hlLCB0aGlzLl9wcml2YXRlX19hbGlnbik7XG4gICAgfVxufVxuY2xhc3MgUGFuZVByaWNlQXhpc1ZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHByaWNlQXhpc1ZpZXcsIGRhdGFTb3VyY2UsIGNoYXJ0TW9kZWwpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzVmlldyA9IHByaWNlQXhpc1ZpZXc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RleHRXaWR0aENhY2hlID0gbmV3IFRleHRXaWR0aENhY2hlKDUwKTsgLy8gd2hlbiBzaG91bGQgd2UgY2xlYXIgY2FjaGU/XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydE1vZGVsID0gY2hhcnRNb2RlbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9udFNpemUgPSAtMTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIgPSBuZXcgUGFuZVByaWNlQXhpc1ZpZXdSZW5kZXJlcih0aGlzLl9wcml2YXRlX190ZXh0V2lkdGhDYWNoZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlcigpIHtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0TW9kZWwuX2ludGVybmFsX3BhbmVGb3JTb3VyY2UodGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZSk7XG4gICAgICAgIGlmIChwYW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIHByaWNlIHNjYWxlIHdpbGwgYmUgdXNlZCB0byBmaW5kIGxhYmVsIHBsYWNlbWVudCBvbmx5IChsZWZ0LCByaWdodCwgbm9uZSlcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHBhbmUuX2ludGVybmFsX2lzT3ZlcmxheSh0aGlzLl9wcml2YXRlX19kYXRhU291cmNlKSA/IHBhbmUuX2ludGVybmFsX2RlZmF1bHRWaXNpYmxlUHJpY2VTY2FsZSgpIDogdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZS5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICBpZiAocHJpY2VTY2FsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwYW5lLl9pbnRlcm5hbF9wcmljZVNjYWxlUG9zaXRpb24ocHJpY2VTY2FsZSk7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ292ZXJsYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbC5faW50ZXJuYWxfcHJpY2VBeGlzUmVuZGVyZXJPcHRpb25zKCk7XG4gICAgICAgIGlmIChvcHRpb25zLl9pbnRlcm5hbF9mb250U2l6ZSAhPT0gdGhpcy5fcHJpdmF0ZV9fZm9udFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZvbnRTaXplID0gb3B0aW9ucy5faW50ZXJuYWxfZm9udFNpemU7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190ZXh0V2lkdGhDYWNoZS5faW50ZXJuYWxfcmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlci5faW50ZXJuYWxfc2V0UGFyYW1zKHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXcuX2ludGVybmFsX3BhbmVSZW5kZXJlcigpLCBvcHRpb25zLCBwb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yZW5kZXJlcjtcbiAgICB9XG59XG5cbmNsYXNzIEhvcml6b250YWxMaW5lUmVuZGVyZXIgZXh0ZW5kcyBCaXRtYXBDb29yZGluYXRlc1BhbmVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaGl0VGVzdCh4LCB5KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCEoKF9hID0gdGhpcy5fcHJpdmF0ZV9fZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9pbnRlcm5hbF92aXNpYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBfaW50ZXJuYWxfeTogaXRlbVksIF9pbnRlcm5hbF9saW5lV2lkdGg6IGxpbmVXaWR0aCwgX2ludGVybmFsX2V4dGVybmFsSWQ6IGV4dGVybmFsSWQgfSA9IHRoaXMuX3ByaXZhdGVfX2RhdGE7XG4gICAgICAgIC8vIGFkZCBhIGZpeGVkIGFyZWEgdGhyZXNob2xkIGFyb3VuZCBsaW5lIChZICsgd2lkdGgpIGZvciBoaXQgdGVzdFxuICAgICAgICBpZiAoeSA+PSBpdGVtWSAtIGxpbmVXaWR0aCAtIDcgLyogQ29uc3RhbnRzLkhpdFRlc3RUaHJlc2hvbGQgKi8gJiYgeSA8PSBpdGVtWSArIGxpbmVXaWR0aCArIDcgLyogQ29uc3RhbnRzLkhpdFRlc3RUaHJlc2hvbGQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2hpdFRlc3REYXRhOiB0aGlzLl9wcml2YXRlX19kYXRhLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9leHRlcm5hbElkOiBleHRlcm5hbElkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX19kcmF3SW1wbCh7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeSA9IE1hdGgucm91bmQodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgIGlmICh5IDwgMCB8fCB5ID4gYml0bWFwU2l6ZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdHgubGluZUNhcCA9ICdidXR0JztcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfY29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLmZsb29yKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2xpbmVXaWR0aCAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgc2V0TGluZVN0eWxlKGN0eCwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfbGluZVN0eWxlKTtcbiAgICAgICAgZHJhd0hvcml6b250YWxMaW5lKGN0eCwgeSwgMCwgYml0bWFwU2l6ZS53aWR0aCk7XG4gICAgfVxufVxuXG5jbGFzcyBTZXJpZXNIb3Jpem9udGFsTGluZVBhbmVWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGEgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfeTogMCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9jb2xvcjogJ3JnYmEoMCwgMCwgMCwgMCknLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVXaWR0aDogMSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lU3R5bGU6IDAgLyogTGluZVN0eWxlLlNvbGlkICovLFxuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fbGluZVJlbmRlcmVyID0gbmV3IEhvcml6b250YWxMaW5lUmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzID0gc2VyaWVzO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fbW9kZWwgPSBzZXJpZXMuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19saW5lUmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEodGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGEpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF92aXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfX3VwZGF0ZUltcGwoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX19saW5lUmVuZGVyZXI7XG4gICAgfVxufVxuXG5jbGFzcyBTZXJpZXNIb3Jpem9udGFsQmFzZUxpbmVQYW5lVmlldyBleHRlbmRzIFNlcmllc0hvcml6b250YWxMaW5lUGFuZVZpZXcge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNvbnN0cnVjdG9yXG4gICAgY29uc3RydWN0b3Ioc2VyaWVzKSB7XG4gICAgICAgIHN1cGVyKHNlcmllcyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fdXBkYXRlSW1wbCgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX3ByaWNlU2NhbGUoKTtcbiAgICAgICAgY29uc3QgbW9kZSA9IHByaWNlU2NhbGUuX2ludGVybmFsX21vZGUoKS5faW50ZXJuYWxfbW9kZTtcbiAgICAgICAgaWYgKG1vZGUgIT09IDIgLyogUHJpY2VTY2FsZU1vZGUuUGVyY2VudGFnZSAqLyAmJiBtb2RlICE9PSAzIC8qIFByaWNlU2NhbGVNb2RlLkluZGV4ZWRUbzEwMCAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcmllc09wdGlvbnMgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIGlmICghc2VyaWVzT3B0aW9ucy5iYXNlTGluZVZpc2libGUgfHwgIXRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX3Zpc2libGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fbGluZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfeSA9IHByaWNlU2NhbGUuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKGZpcnN0VmFsdWUuX2ludGVybmFsX3ZhbHVlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19saW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb2xvciA9IHNlcmllc09wdGlvbnMuYmFzZUxpbmVDb2xvcjtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX2xpbmVXaWR0aCA9IHNlcmllc09wdGlvbnMuYmFzZUxpbmVXaWR0aDtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX2xpbmVTdHlsZSA9IHNlcmllc09wdGlvbnMuYmFzZUxpbmVTdHlsZTtcbiAgICB9XG59XG5cbmNsYXNzIFNlcmllc0xhc3RQcmljZUFuaW1hdGlvblJlbmRlcmVyIGV4dGVuZHMgQml0bWFwQ29vcmRpbmF0ZXNQYW5lUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19kYXRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2RyYXdJbXBsKHsgY29udGV4dDogY3R4LCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvIH0pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX3ByaXZhdGVfX2RhdGE7XG4gICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGlja1dpZHRoID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihob3Jpem9udGFsUGl4ZWxSYXRpbykpO1xuICAgICAgICBjb25zdCBjb3JyZWN0aW9uID0gKHRpY2tXaWR0aCAlIDIpIC8gMjtcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IE1hdGgucm91bmQoZGF0YS5faW50ZXJuYWxfY2VudGVyLnggKiBob3Jpem9udGFsUGl4ZWxSYXRpbykgKyBjb3JyZWN0aW9uOyAvLyBjb3JyZWN0IHggY29vcmRpbmF0ZSBvbmx5XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSBkYXRhLl9pbnRlcm5hbF9jZW50ZXIueSAqIHZlcnRpY2FsUGl4ZWxSYXRpbztcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGRhdGEuX2ludGVybmFsX3Nlcmllc0xpbmVDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAvLyBUT0RPOiBpdCBpcyBiZXR0ZXIgdG8gaGF2ZSBkaWZmZXJlbnQgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgcmFkaWlcbiAgICAgICAgY29uc3QgY2VudGVyUG9pbnRSYWRpdXMgPSBNYXRoLm1heCgyLCBkYXRhLl9pbnRlcm5hbF9zZXJpZXNMaW5lV2lkdGggKiAxLjUpICogaG9yaXpvbnRhbFBpeGVsUmF0aW87XG4gICAgICAgIGN0eC5hcmMoY2VudGVyWCwgY2VudGVyWSwgY2VudGVyUG9pbnRSYWRpdXMsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBkYXRhLl9pbnRlcm5hbF9maWxsQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBkYXRhLl9pbnRlcm5hbF9yYWRpdXMgKiBob3Jpem9udGFsUGl4ZWxSYXRpbywgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRpY2tXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZGF0YS5faW50ZXJuYWxfc3Ryb2tlQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBkYXRhLl9pbnRlcm5hbF9yYWRpdXMgKiBob3Jpem9udGFsUGl4ZWxSYXRpbyArIHRpY2tXaWR0aCAvIDIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59XG5cbmNvbnN0IGFuaW1hdGlvblN0YWdlc0RhdGEgPSBbXG4gICAge1xuICAgICAgICBfaW50ZXJuYWxfc3RhcnQ6IDAsXG4gICAgICAgIF9pbnRlcm5hbF9lbmQ6IDAuMjUgLyogQ29uc3RhbnRzLlN0YWdlMVBlcmlvZCAqLyxcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0UmFkaXVzOiA0IC8qIENvbnN0YW50cy5TdGFnZTFTdGFydENpcmNsZVJhZGl1cyAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZFJhZGl1czogMTAgLyogQ29uc3RhbnRzLlN0YWdlMUVuZENpcmNsZVJhZGl1cyAqLyxcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0RmlsbEFscGhhOiAwLjI1IC8qIENvbnN0YW50cy5TdGFnZTFTdGFydEZpbGxBbHBoYSAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZEZpbGxBbHBoYTogMCAvKiBDb25zdGFudHMuU3RhZ2UxRW5kRmlsbEFscGhhICovLFxuICAgICAgICBfaW50ZXJuYWxfc3RhcnRTdHJva2VBbHBoYTogMC40IC8qIENvbnN0YW50cy5TdGFnZTFTdGFydFN0cm9rZUFscGhhICovLFxuICAgICAgICBfaW50ZXJuYWxfZW5kU3Ryb2tlQWxwaGE6IDAuOCAvKiBDb25zdGFudHMuU3RhZ2UxRW5kU3Ryb2tlQWxwaGEgKi8sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIF9pbnRlcm5hbF9zdGFydDogMC4yNSAvKiBDb25zdGFudHMuU3RhZ2UxUGVyaW9kICovLFxuICAgICAgICBfaW50ZXJuYWxfZW5kOiAwLjI1IC8qIENvbnN0YW50cy5TdGFnZTFQZXJpb2QgKi8gKyAwLjI3NSAvKiBDb25zdGFudHMuU3RhZ2UyUGVyaW9kICovLFxuICAgICAgICBfaW50ZXJuYWxfc3RhcnRSYWRpdXM6IDEwIC8qIENvbnN0YW50cy5TdGFnZTJTdGFydENpcmNsZVJhZGl1cyAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZFJhZGl1czogMTQgLyogQ29uc3RhbnRzLlN0YWdlMkVuZENpcmNsZVJhZGl1cyAqLyxcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0RmlsbEFscGhhOiAwIC8qIENvbnN0YW50cy5TdGFnZTJTdGFydEZpbGxBbHBoYSAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZEZpbGxBbHBoYTogMCAvKiBDb25zdGFudHMuU3RhZ2UyRW5kRmlsbEFscGhhICovLFxuICAgICAgICBfaW50ZXJuYWxfc3RhcnRTdHJva2VBbHBoYTogMC44IC8qIENvbnN0YW50cy5TdGFnZTJTdGFydFN0cm9rZUFscGhhICovLFxuICAgICAgICBfaW50ZXJuYWxfZW5kU3Ryb2tlQWxwaGE6IDAgLyogQ29uc3RhbnRzLlN0YWdlMkVuZFN0cm9rZUFscGhhICovLFxuICAgIH0sXG4gICAge1xuICAgICAgICBfaW50ZXJuYWxfc3RhcnQ6IDAuMjUgLyogQ29uc3RhbnRzLlN0YWdlMVBlcmlvZCAqLyArIDAuMjc1IC8qIENvbnN0YW50cy5TdGFnZTJQZXJpb2QgKi8sXG4gICAgICAgIF9pbnRlcm5hbF9lbmQ6IDAuMjUgLyogQ29uc3RhbnRzLlN0YWdlMVBlcmlvZCAqLyArIDAuMjc1IC8qIENvbnN0YW50cy5TdGFnZTJQZXJpb2QgKi8gKyAwLjQ3NSAvKiBDb25zdGFudHMuU3RhZ2UzUGVyaW9kICovLFxuICAgICAgICBfaW50ZXJuYWxfc3RhcnRSYWRpdXM6IDE0IC8qIENvbnN0YW50cy5TdGFnZTNTdGFydENpcmNsZVJhZGl1cyAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZFJhZGl1czogMTQgLyogQ29uc3RhbnRzLlN0YWdlM0VuZENpcmNsZVJhZGl1cyAqLyxcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0RmlsbEFscGhhOiAwIC8qIENvbnN0YW50cy5TdGFnZTNTdGFydEZpbGxBbHBoYSAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZEZpbGxBbHBoYTogMCAvKiBDb25zdGFudHMuU3RhZ2UzRW5kRmlsbEFscGhhICovLFxuICAgICAgICBfaW50ZXJuYWxfc3RhcnRTdHJva2VBbHBoYTogMCAvKiBDb25zdGFudHMuU3RhZ2UzU3RhcnRTdHJva2VBbHBoYSAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZFN0cm9rZUFscGhhOiAwIC8qIENvbnN0YW50cy5TdGFnZTNFbmRTdHJva2VBbHBoYSAqLyxcbiAgICB9LFxuXTtcbmZ1bmN0aW9uIGNvbG9yKHNlcmllc0xpbmVDb2xvciwgc3RhZ2UsIHN0YXJ0QWxwaGEsIGVuZEFscGhhKSB7XG4gICAgY29uc3QgYWxwaGEgPSBzdGFydEFscGhhICsgKGVuZEFscGhhIC0gc3RhcnRBbHBoYSkgKiBzdGFnZTtcbiAgICByZXR1cm4gYXBwbHlBbHBoYShzZXJpZXNMaW5lQ29sb3IsIGFscGhhKTtcbn1cbmZ1bmN0aW9uIHJhZGl1cyhzdGFnZSwgc3RhcnRSYWRpdXMsIGVuZFJhZGl1cykge1xuICAgIHJldHVybiBzdGFydFJhZGl1cyArIChlbmRSYWRpdXMgLSBzdGFydFJhZGl1cykgKiBzdGFnZTtcbn1cbmZ1bmN0aW9uIGFuaW1hdGlvbkRhdGEoZHVyYXRpb25TaW5jZVN0YXJ0LCBsaW5lQ29sb3IpIHtcbiAgICBjb25zdCBnbG9iYWxTdGFnZSA9IChkdXJhdGlvblNpbmNlU3RhcnQgJSAyNjAwIC8qIENvbnN0YW50cy5BbmltYXRpb25QZXJpb2QgKi8pIC8gMjYwMCAvKiBDb25zdGFudHMuQW5pbWF0aW9uUGVyaW9kICovO1xuICAgIGxldCBjdXJyZW50U3RhZ2VEYXRhO1xuICAgIGZvciAoY29uc3Qgc3RhZ2VEYXRhIG9mIGFuaW1hdGlvblN0YWdlc0RhdGEpIHtcbiAgICAgICAgaWYgKGdsb2JhbFN0YWdlID49IHN0YWdlRGF0YS5faW50ZXJuYWxfc3RhcnQgJiYgZ2xvYmFsU3RhZ2UgPD0gc3RhZ2VEYXRhLl9pbnRlcm5hbF9lbmQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGFnZURhdGEgPSBzdGFnZURhdGE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnQoY3VycmVudFN0YWdlRGF0YSAhPT0gdW5kZWZpbmVkLCAnTGFzdCBwcmljZSBhbmltYXRpb24gaW50ZXJuYWwgbG9naWMgZXJyb3InKTtcbiAgICBjb25zdCBzdWJTdGFnZSA9IChnbG9iYWxTdGFnZSAtIGN1cnJlbnRTdGFnZURhdGEuX2ludGVybmFsX3N0YXJ0KSAvIChjdXJyZW50U3RhZ2VEYXRhLl9pbnRlcm5hbF9lbmQgLSBjdXJyZW50U3RhZ2VEYXRhLl9pbnRlcm5hbF9zdGFydCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2ludGVybmFsX2ZpbGxDb2xvcjogY29sb3IobGluZUNvbG9yLCBzdWJTdGFnZSwgY3VycmVudFN0YWdlRGF0YS5faW50ZXJuYWxfc3RhcnRGaWxsQWxwaGEsIGN1cnJlbnRTdGFnZURhdGEuX2ludGVybmFsX2VuZEZpbGxBbHBoYSksXG4gICAgICAgIF9pbnRlcm5hbF9zdHJva2VDb2xvcjogY29sb3IobGluZUNvbG9yLCBzdWJTdGFnZSwgY3VycmVudFN0YWdlRGF0YS5faW50ZXJuYWxfc3RhcnRTdHJva2VBbHBoYSwgY3VycmVudFN0YWdlRGF0YS5faW50ZXJuYWxfZW5kU3Ryb2tlQWxwaGEpLFxuICAgICAgICBfaW50ZXJuYWxfcmFkaXVzOiByYWRpdXMoc3ViU3RhZ2UsIGN1cnJlbnRTdGFnZURhdGEuX2ludGVybmFsX3N0YXJ0UmFkaXVzLCBjdXJyZW50U3RhZ2VEYXRhLl9pbnRlcm5hbF9lbmRSYWRpdXMpLFxuICAgIH07XG59XG5jbGFzcyBTZXJpZXNMYXN0UHJpY2VBbmltYXRpb25QYW5lVmlldyB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyID0gbmV3IFNlcmllc0xhc3RQcmljZUFuaW1hdGlvblJlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbmRUaW1lID0gdGhpcy5fcHJpdmF0ZV9fc3RhcnRUaW1lIC0gMTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gc2VyaWVzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb25EYXRhQ2xlYXJlZCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZW5kVGltZSA9IHRoaXMuX3ByaXZhdGVfX3N0YXJ0VGltZSAtIDE7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb25OZXdSZWFsdGltZURhdGFSZWNlaXZlZCgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKS5sYXN0UHJpY2VBbmltYXRpb24gPT09IDIgLyogTGFzdFByaWNlQW5pbWF0aW9uTW9kZS5PbkRhdGFVcGRhdGUgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgY29uc3QgdGltZVRvQW5pbWF0aW9uRW5kID0gdGhpcy5fcHJpdmF0ZV9fZW5kVGltZSAtIG5vdztcbiAgICAgICAgICAgIGlmICh0aW1lVG9BbmltYXRpb25FbmQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVUb0FuaW1hdGlvbkVuZCA8IDI2MDAgLyogQ29uc3RhbnRzLkFuaW1hdGlvblBlcmlvZCAqLyAvIDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZW5kVGltZSArPSAyNjAwIC8qIENvbnN0YW50cy5BbmltYXRpb25QZXJpb2QgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0VGltZSA9IG5vdztcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2VuZFRpbWUgPSBub3cgKyAyNjAwIC8qIENvbnN0YW50cy5BbmltYXRpb25QZXJpb2QgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaW52YWxpZGF0ZVN0YWdlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFnZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Zpc2libGUoKSB7XG4gICAgICAgIC8vIGNlbnRlciBwb2ludCBpcyBhbHdheXMgdmlzaWJsZSBpZiBsYXN0UHJpY2VBbmltYXRpb24gaXMgbm90IExhc3RQcmljZUFuaW1hdGlvbk1vZGUuRGlzYWJsZWRcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfb3B0aW9ucygpLmxhc3RQcmljZUFuaW1hdGlvbiAhPT0gMCAvKiBMYXN0UHJpY2VBbmltYXRpb25Nb2RlLkRpc2FibGVkICovO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYW5pbWF0aW9uQWN0aXZlKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfb3B0aW9ucygpLmxhc3RQcmljZUFuaW1hdGlvbikge1xuICAgICAgICAgICAgY2FzZSAwIC8qIExhc3RQcmljZUFuaW1hdGlvbk1vZGUuRGlzYWJsZWQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAxIC8qIExhc3RQcmljZUFuaW1hdGlvbk1vZGUuQ29udGludW91cyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBMYXN0UHJpY2VBbmltYXRpb25Nb2RlLk9uRGF0YVVwZGF0ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCkgPD0gdGhpcy5fcHJpdmF0ZV9fZW5kVGltZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVuZGVyZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlSW1wbCgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YWdlSW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9wcml2YXRlX19zdGFnZUludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVSZW5kZXJlckRhdGFTdGFnZSgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhZ2VJbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yZW5kZXJlcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3VwZGF0ZUltcGwoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKG51bGwpO1xuICAgICAgICBjb25zdCB0aW1lU2NhbGUgPSB0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3RpbWVTY2FsZSgpO1xuICAgICAgICBjb25zdCB2aXNpYmxlUmFuZ2UgPSB0aW1lU2NhbGUuX2ludGVybmFsX3Zpc2libGVTdHJpY3RSYW5nZSgpO1xuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmICh2aXNpYmxlUmFuZ2UgPT09IG51bGwgfHwgZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfbGFzdFZhbHVlRGF0YSh0cnVlKTtcbiAgICAgICAgaWYgKGxhc3RWYWx1ZS5faW50ZXJuYWxfbm9EYXRhIHx8ICF2aXNpYmxlUmFuZ2UuX2ludGVybmFsX2NvbnRhaW5zKGxhc3RWYWx1ZS5faW50ZXJuYWxfaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdFZhbHVlUG9pbnQgPSB7XG4gICAgICAgICAgICB4OiB0aW1lU2NhbGUuX2ludGVybmFsX2luZGV4VG9Db29yZGluYXRlKGxhc3RWYWx1ZS5faW50ZXJuYWxfaW5kZXgpLFxuICAgICAgICAgICAgeTogdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKGxhc3RWYWx1ZS5faW50ZXJuYWxfcHJpY2UsIGZpcnN0VmFsdWUuX2ludGVybmFsX3ZhbHVlKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2VyaWVzTGluZUNvbG9yID0gbGFzdFZhbHVlLl9pbnRlcm5hbF9jb2xvcjtcbiAgICAgICAgY29uc3Qgc2VyaWVzTGluZVdpZHRoID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCkubGluZVdpZHRoO1xuICAgICAgICBjb25zdCBkYXRhID0gYW5pbWF0aW9uRGF0YSh0aGlzLl9wcml2YXRlX19kdXJhdGlvbigpLCBzZXJpZXNMaW5lQ29sb3IpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YSh7XG4gICAgICAgICAgICBfaW50ZXJuYWxfc2VyaWVzTGluZUNvbG9yOiBzZXJpZXNMaW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfc2VyaWVzTGluZVdpZHRoOiBzZXJpZXNMaW5lV2lkdGgsXG4gICAgICAgICAgICBfaW50ZXJuYWxfZmlsbENvbG9yOiBkYXRhLl9pbnRlcm5hbF9maWxsQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfc3Ryb2tlQ29sb3I6IGRhdGEuX2ludGVybmFsX3N0cm9rZUNvbG9yLFxuICAgICAgICAgICAgX2ludGVybmFsX3JhZGl1czogZGF0YS5faW50ZXJuYWxfcmFkaXVzLFxuICAgICAgICAgICAgX2ludGVybmFsX2NlbnRlcjogbGFzdFZhbHVlUG9pbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlUmVuZGVyZXJEYXRhU3RhZ2UoKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyRGF0YSA9IHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyLl9pbnRlcm5hbF9kYXRhKCk7XG4gICAgICAgIGlmIChyZW5kZXJlckRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhbmltYXRpb25EYXRhKHRoaXMuX3ByaXZhdGVfX2R1cmF0aW9uKCksIHJlbmRlcmVyRGF0YS5faW50ZXJuYWxfc2VyaWVzTGluZUNvbG9yKTtcbiAgICAgICAgICAgIHJlbmRlcmVyRGF0YS5faW50ZXJuYWxfZmlsbENvbG9yID0gZGF0YS5faW50ZXJuYWxfZmlsbENvbG9yO1xuICAgICAgICAgICAgcmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9zdHJva2VDb2xvciA9IGRhdGEuX2ludGVybmFsX3N0cm9rZUNvbG9yO1xuICAgICAgICAgICAgcmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9yYWRpdXMgPSBkYXRhLl9pbnRlcm5hbF9yYWRpdXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2R1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfYW5pbWF0aW9uQWN0aXZlKCkgPyBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuX3ByaXZhdGVfX3N0YXJ0VGltZSA6IDI2MDAgLyogQ29uc3RhbnRzLkFuaW1hdGlvblBlcmlvZCAqLyAtIDE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzaXplKGJhclNwYWNpbmcsIGNvZWZmKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gTWF0aC5taW4oTWF0aC5tYXgoYmFyU3BhY2luZywgMTIgLyogQ29uc3RhbnRzLk1pblNoYXBlU2l6ZSAqLyksIDMwIC8qIENvbnN0YW50cy5NYXhTaGFwZVNpemUgKi8pICogY29lZmY7XG4gICAgcmV0dXJuIGNlaWxlZE9kZChyZXN1bHQpO1xufVxuZnVuY3Rpb24gc2hhcGVTaXplKHNoYXBlLCBvcmlnaW5hbFNpemUpIHtcbiAgICBzd2l0Y2ggKHNoYXBlKSB7XG4gICAgICAgIGNhc2UgJ2Fycm93RG93bic6XG4gICAgICAgIGNhc2UgJ2Fycm93VXAnOlxuICAgICAgICAgICAgcmV0dXJuIHNpemUob3JpZ2luYWxTaXplLCAxKTtcbiAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICAgIHJldHVybiBzaXplKG9yaWdpbmFsU2l6ZSwgMC44KTtcbiAgICAgICAgY2FzZSAnc3F1YXJlJzpcbiAgICAgICAgICAgIHJldHVybiBzaXplKG9yaWdpbmFsU2l6ZSwgMC43KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVTaGFwZUhlaWdodChiYXJTcGFjaW5nKSB7XG4gICAgcmV0dXJuIGNlaWxlZEV2ZW4oc2l6ZShiYXJTcGFjaW5nLCAxKSk7XG59XG5mdW5jdGlvbiBzaGFwZU1hcmdpbihiYXJTcGFjaW5nKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHNpemUoYmFyU3BhY2luZywgMC4xKSwgMyAvKiBDb25zdGFudHMuTWluU2hhcGVNYXJnaW4gKi8pO1xufVxuXG5mdW5jdGlvbiBkcmF3U3F1YXJlKGN0eCwgY2VudGVyWCwgY2VudGVyWSwgc2l6ZSkge1xuICAgIGNvbnN0IHNxdWFyZVNpemUgPSBzaGFwZVNpemUoJ3NxdWFyZScsIHNpemUpO1xuICAgIGNvbnN0IGhhbGZTaXplID0gKHNxdWFyZVNpemUgLSAxKSAvIDI7XG4gICAgY29uc3QgbGVmdCA9IGNlbnRlclggLSBoYWxmU2l6ZTtcbiAgICBjb25zdCB0b3AgPSBjZW50ZXJZIC0gaGFsZlNpemU7XG4gICAgY3R4LmZpbGxSZWN0KGxlZnQsIHRvcCwgc3F1YXJlU2l6ZSwgc3F1YXJlU2l6ZSk7XG59XG5mdW5jdGlvbiBoaXRUZXN0U3F1YXJlKGNlbnRlclgsIGNlbnRlclksIHNpemUsIHgsIHkpIHtcbiAgICBjb25zdCBzcXVhcmVTaXplID0gc2hhcGVTaXplKCdzcXVhcmUnLCBzaXplKTtcbiAgICBjb25zdCBoYWxmU2l6ZSA9IChzcXVhcmVTaXplIC0gMSkgLyAyO1xuICAgIGNvbnN0IGxlZnQgPSBjZW50ZXJYIC0gaGFsZlNpemU7XG4gICAgY29uc3QgdG9wID0gY2VudGVyWSAtIGhhbGZTaXplO1xuICAgIHJldHVybiB4ID49IGxlZnQgJiYgeCA8PSBsZWZ0ICsgc3F1YXJlU2l6ZSAmJlxuICAgICAgICB5ID49IHRvcCAmJiB5IDw9IHRvcCArIHNxdWFyZVNpemU7XG59XG5cbmZ1bmN0aW9uIGRyYXdBcnJvdyh1cCwgY3R4LCBjZW50ZXJYLCBjZW50ZXJZLCBzaXplKSB7XG4gICAgY29uc3QgYXJyb3dTaXplID0gc2hhcGVTaXplKCdhcnJvd1VwJywgc2l6ZSk7XG4gICAgY29uc3QgaGFsZkFycm93U2l6ZSA9IChhcnJvd1NpemUgLSAxKSAvIDI7XG4gICAgY29uc3QgYmFzZVNpemUgPSBjZWlsZWRPZGQoc2l6ZSAvIDIpO1xuICAgIGNvbnN0IGhhbGZCYXNlU2l6ZSA9IChiYXNlU2l6ZSAtIDEpIC8gMjtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKHVwKSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oY2VudGVyWCAtIGhhbGZBcnJvd1NpemUsIGNlbnRlclkpO1xuICAgICAgICBjdHgubGluZVRvKGNlbnRlclgsIGNlbnRlclkgLSBoYWxmQXJyb3dTaXplKTtcbiAgICAgICAgY3R4LmxpbmVUbyhjZW50ZXJYICsgaGFsZkFycm93U2l6ZSwgY2VudGVyWSk7XG4gICAgICAgIGN0eC5saW5lVG8oY2VudGVyWCArIGhhbGZCYXNlU2l6ZSwgY2VudGVyWSk7XG4gICAgICAgIGN0eC5saW5lVG8oY2VudGVyWCArIGhhbGZCYXNlU2l6ZSwgY2VudGVyWSArIGhhbGZBcnJvd1NpemUpO1xuICAgICAgICBjdHgubGluZVRvKGNlbnRlclggLSBoYWxmQmFzZVNpemUsIGNlbnRlclkgKyBoYWxmQXJyb3dTaXplKTtcbiAgICAgICAgY3R4LmxpbmVUbyhjZW50ZXJYIC0gaGFsZkJhc2VTaXplLCBjZW50ZXJZKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oY2VudGVyWCAtIGhhbGZBcnJvd1NpemUsIGNlbnRlclkpO1xuICAgICAgICBjdHgubGluZVRvKGNlbnRlclgsIGNlbnRlclkgKyBoYWxmQXJyb3dTaXplKTtcbiAgICAgICAgY3R4LmxpbmVUbyhjZW50ZXJYICsgaGFsZkFycm93U2l6ZSwgY2VudGVyWSk7XG4gICAgICAgIGN0eC5saW5lVG8oY2VudGVyWCArIGhhbGZCYXNlU2l6ZSwgY2VudGVyWSk7XG4gICAgICAgIGN0eC5saW5lVG8oY2VudGVyWCArIGhhbGZCYXNlU2l6ZSwgY2VudGVyWSAtIGhhbGZBcnJvd1NpemUpO1xuICAgICAgICBjdHgubGluZVRvKGNlbnRlclggLSBoYWxmQmFzZVNpemUsIGNlbnRlclkgLSBoYWxmQXJyb3dTaXplKTtcbiAgICAgICAgY3R4LmxpbmVUbyhjZW50ZXJYIC0gaGFsZkJhc2VTaXplLCBjZW50ZXJZKTtcbiAgICB9XG4gICAgY3R4LmZpbGwoKTtcbn1cbmZ1bmN0aW9uIGhpdFRlc3RBcnJvdyh1cCwgY2VudGVyWCwgY2VudGVyWSwgc2l6ZSwgeCwgeSkge1xuICAgIC8vIFRPRE86IGltcGxlbWVudCBhcnJvdyBoaXQgdGVzdFxuICAgIHJldHVybiBoaXRUZXN0U3F1YXJlKGNlbnRlclgsIGNlbnRlclksIHNpemUsIHgsIHkpO1xufVxuXG5mdW5jdGlvbiBkcmF3Q2lyY2xlKGN0eCwgY2VudGVyWCwgY2VudGVyWSwgc2l6ZSkge1xuICAgIGNvbnN0IGNpcmNsZVNpemUgPSBzaGFwZVNpemUoJ2NpcmNsZScsIHNpemUpO1xuICAgIGNvbnN0IGhhbGZTaXplID0gKGNpcmNsZVNpemUgLSAxKSAvIDI7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoY2VudGVyWCwgY2VudGVyWSwgaGFsZlNpemUsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgY3R4LmZpbGwoKTtcbn1cbmZ1bmN0aW9uIGhpdFRlc3RDaXJjbGUoY2VudGVyWCwgY2VudGVyWSwgc2l6ZSwgeCwgeSkge1xuICAgIGNvbnN0IGNpcmNsZVNpemUgPSBzaGFwZVNpemUoJ2NpcmNsZScsIHNpemUpO1xuICAgIGNvbnN0IHRvbGVyYW5jZSA9IDIgKyBjaXJjbGVTaXplIC8gMjtcbiAgICBjb25zdCB4T2Zmc2V0ID0gY2VudGVyWCAtIHg7XG4gICAgY29uc3QgeU9mZnNldCA9IGNlbnRlclkgLSB5O1xuICAgIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQoeE9mZnNldCAqIHhPZmZzZXQgKyB5T2Zmc2V0ICogeU9mZnNldCk7XG4gICAgcmV0dXJuIGRpc3QgPD0gdG9sZXJhbmNlO1xufVxuXG5mdW5jdGlvbiBkcmF3VGV4dChjdHgsIHRleHQsIHgsIHkpIHtcbiAgICBjdHguZmlsbFRleHQodGV4dCwgeCwgeSk7XG59XG5mdW5jdGlvbiBoaXRUZXN0VGV4dCh0ZXh0WCwgdGV4dFksIHRleHRXaWR0aCwgdGV4dEhlaWdodCwgeCwgeSkge1xuICAgIGNvbnN0IGhhbGZIZWlnaHQgPSB0ZXh0SGVpZ2h0IC8gMjtcbiAgICByZXR1cm4geCA+PSB0ZXh0WCAmJiB4IDw9IHRleHRYICsgdGV4dFdpZHRoICYmXG4gICAgICAgIHkgPj0gdGV4dFkgLSBoYWxmSGVpZ2h0ICYmIHkgPD0gdGV4dFkgKyBoYWxmSGVpZ2h0O1xufVxuXG5jbGFzcyBTZXJpZXNNYXJrZXJzUmVuZGVyZXIgZXh0ZW5kcyBNZWRpYUNvb3JkaW5hdGVzUGFuZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RleHRXaWR0aENhY2hlID0gbmV3IFRleHRXaWR0aENhY2hlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZvbnRTaXplID0gLTE7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZvbnRGYW1pbHkgPSAnJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9udCA9ICcnO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0UGFyYW1zKGZvbnRTaXplLCBmb250RmFtaWx5KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19mb250U2l6ZSAhPT0gZm9udFNpemUgfHwgdGhpcy5fcHJpdmF0ZV9fZm9udEZhbWlseSAhPT0gZm9udEZhbWlseSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9udCA9IG1ha2VGb250KGZvbnRTaXplLCBmb250RmFtaWx5KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RleHRXaWR0aENhY2hlLl9pbnRlcm5hbF9yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9oaXRUZXN0KHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEgPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb207IGkgPCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2l0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGhpdFRlc3RJdGVtKGl0ZW0sIHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX2hpdFRlc3REYXRhOiBpdGVtLl9pbnRlcm5hbF9pbnRlcm5hbElkLFxuICAgICAgICAgICAgICAgICAgICBfaW50ZXJuYWxfZXh0ZXJuYWxJZDogaXRlbS5faW50ZXJuYWxfZXh0ZXJuYWxJZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2RyYXdJbXBsKHsgY29udGV4dDogY3R4IH0sIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEgPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICBjdHguZm9udCA9IHRoaXMuX3ByaXZhdGVfX2ZvbnQ7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbTsgaSA8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaXRlbXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbS5faW50ZXJuYWxfdGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfd2lkdGggPSB0aGlzLl9wcml2YXRlX190ZXh0V2lkdGhDYWNoZS5faW50ZXJuYWxfbWVhc3VyZVRleHQoY3R4LCBpdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF9jb250ZW50KTtcbiAgICAgICAgICAgICAgICBpdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF9oZWlnaHQgPSB0aGlzLl9wcml2YXRlX19mb250U2l6ZTtcbiAgICAgICAgICAgICAgICBpdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF94ID0gaXRlbS5faW50ZXJuYWxfeCAtIGl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX3dpZHRoIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRyYXdJdGVtKGl0ZW0sIGN0eCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBkcmF3SXRlbShpdGVtLCBjdHgpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gaXRlbS5faW50ZXJuYWxfY29sb3I7XG4gICAgaWYgKGl0ZW0uX2ludGVybmFsX3RleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkcmF3VGV4dChjdHgsIGl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX2NvbnRlbnQsIGl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX3gsIGl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX3kpO1xuICAgIH1cbiAgICBkcmF3U2hhcGUoaXRlbSwgY3R4KTtcbn1cbmZ1bmN0aW9uIGRyYXdTaGFwZShpdGVtLCBjdHgpIHtcbiAgICBpZiAoaXRlbS5faW50ZXJuYWxfc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoaXRlbS5faW50ZXJuYWxfc2hhcGUpIHtcbiAgICAgICAgY2FzZSAnYXJyb3dEb3duJzpcbiAgICAgICAgICAgIGRyYXdBcnJvdyhmYWxzZSwgY3R4LCBpdGVtLl9pbnRlcm5hbF94LCBpdGVtLl9pbnRlcm5hbF95LCBpdGVtLl9pbnRlcm5hbF9zaXplKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnYXJyb3dVcCc6XG4gICAgICAgICAgICBkcmF3QXJyb3codHJ1ZSwgY3R4LCBpdGVtLl9pbnRlcm5hbF94LCBpdGVtLl9pbnRlcm5hbF95LCBpdGVtLl9pbnRlcm5hbF9zaXplKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICAgIGRyYXdDaXJjbGUoY3R4LCBpdGVtLl9pbnRlcm5hbF94LCBpdGVtLl9pbnRlcm5hbF95LCBpdGVtLl9pbnRlcm5hbF9zaXplKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnc3F1YXJlJzpcbiAgICAgICAgICAgIGRyYXdTcXVhcmUoY3R4LCBpdGVtLl9pbnRlcm5hbF94LCBpdGVtLl9pbnRlcm5hbF95LCBpdGVtLl9pbnRlcm5hbF9zaXplKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5zdXJlTmV2ZXIoaXRlbS5faW50ZXJuYWxfc2hhcGUpO1xufVxuZnVuY3Rpb24gaGl0VGVzdEl0ZW0oaXRlbSwgeCwgeSkge1xuICAgIGlmIChpdGVtLl9pbnRlcm5hbF90ZXh0ICE9PSB1bmRlZmluZWQgJiYgaGl0VGVzdFRleHQoaXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfeCwgaXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfeSwgaXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfd2lkdGgsIGl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX2hlaWdodCwgeCwgeSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBoaXRUZXN0U2hhcGUoaXRlbSwgeCwgeSk7XG59XG5mdW5jdGlvbiBoaXRUZXN0U2hhcGUoaXRlbSwgeCwgeSkge1xuICAgIGlmIChpdGVtLl9pbnRlcm5hbF9zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoIChpdGVtLl9pbnRlcm5hbF9zaGFwZSkge1xuICAgICAgICBjYXNlICdhcnJvd0Rvd24nOlxuICAgICAgICAgICAgcmV0dXJuIGhpdFRlc3RBcnJvdyh0cnVlLCBpdGVtLl9pbnRlcm5hbF94LCBpdGVtLl9pbnRlcm5hbF95LCBpdGVtLl9pbnRlcm5hbF9zaXplLCB4LCB5KTtcbiAgICAgICAgY2FzZSAnYXJyb3dVcCc6XG4gICAgICAgICAgICByZXR1cm4gaGl0VGVzdEFycm93KGZhbHNlLCBpdGVtLl9pbnRlcm5hbF94LCBpdGVtLl9pbnRlcm5hbF95LCBpdGVtLl9pbnRlcm5hbF9zaXplLCB4LCB5KTtcbiAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICAgIHJldHVybiBoaXRUZXN0Q2lyY2xlKGl0ZW0uX2ludGVybmFsX3gsIGl0ZW0uX2ludGVybmFsX3ksIGl0ZW0uX2ludGVybmFsX3NpemUsIHgsIHkpO1xuICAgICAgICBjYXNlICdzcXVhcmUnOlxuICAgICAgICAgICAgcmV0dXJuIGhpdFRlc3RTcXVhcmUoaXRlbS5faW50ZXJuYWxfeCwgaXRlbS5faW50ZXJuYWxfeSwgaXRlbS5faW50ZXJuYWxfc2l6ZSwgeCwgeSk7XG4gICAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuZnVuY3Rpb24gZmlsbFNpemVBbmRZKHJlbmRlcmVySXRlbSwgbWFya2VyLCBzZXJpZXNEYXRhLCBvZmZzZXRzLCB0ZXh0SGVpZ2h0LCBzaGFwZU1hcmdpbiwgcHJpY2VTY2FsZSwgdGltZVNjYWxlLCBmaXJzdFZhbHVlKSB7XG4gICAgY29uc3QgaW5CYXJQcmljZSA9IGlzTnVtYmVyKHNlcmllc0RhdGEpID8gc2VyaWVzRGF0YSA6IHNlcmllc0RhdGEuX2ludGVybmFsX2Nsb3NlO1xuICAgIGNvbnN0IGhpZ2hQcmljZSA9IGlzTnVtYmVyKHNlcmllc0RhdGEpID8gc2VyaWVzRGF0YSA6IHNlcmllc0RhdGEuX2ludGVybmFsX2hpZ2g7XG4gICAgY29uc3QgbG93UHJpY2UgPSBpc051bWJlcihzZXJpZXNEYXRhKSA/IHNlcmllc0RhdGEgOiBzZXJpZXNEYXRhLl9pbnRlcm5hbF9sb3c7XG4gICAgY29uc3Qgc2l6ZU11bHRpcGxpZXIgPSBpc051bWJlcihtYXJrZXIuc2l6ZSkgPyBNYXRoLm1heChtYXJrZXIuc2l6ZSwgMCkgOiAxO1xuICAgIGNvbnN0IHNoYXBlU2l6ZSA9IGNhbGN1bGF0ZVNoYXBlSGVpZ2h0KHRpbWVTY2FsZS5faW50ZXJuYWxfYmFyU3BhY2luZygpKSAqIHNpemVNdWx0aXBsaWVyO1xuICAgIGNvbnN0IGhhbGZTaXplID0gc2hhcGVTaXplIC8gMjtcbiAgICByZW5kZXJlckl0ZW0uX2ludGVybmFsX3NpemUgPSBzaGFwZVNpemU7XG4gICAgc3dpdGNoIChtYXJrZXIucG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSAnaW5CYXInOiB7XG4gICAgICAgICAgICByZW5kZXJlckl0ZW0uX2ludGVybmFsX3kgPSBwcmljZVNjYWxlLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZShpbkJhclByaWNlLCBmaXJzdFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlckl0ZW0uX2ludGVybmFsX3RleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVySXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfeSA9IHJlbmRlcmVySXRlbS5faW50ZXJuYWxfeSArIGhhbGZTaXplICsgc2hhcGVNYXJnaW4gKyB0ZXh0SGVpZ2h0ICogKDAuNSArIDAuMSAvKiBDb25zdGFudHMuVGV4dE1hcmdpbiAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYWJvdmVCYXInOiB7XG4gICAgICAgICAgICByZW5kZXJlckl0ZW0uX2ludGVybmFsX3kgPSAocHJpY2VTY2FsZS5faW50ZXJuYWxfcHJpY2VUb0Nvb3JkaW5hdGUoaGlnaFByaWNlLCBmaXJzdFZhbHVlKSAtIGhhbGZTaXplIC0gb2Zmc2V0cy5faW50ZXJuYWxfYWJvdmVCYXIpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVySXRlbS5faW50ZXJuYWxfdGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJJdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF95ID0gcmVuZGVyZXJJdGVtLl9pbnRlcm5hbF95IC0gaGFsZlNpemUgLSB0ZXh0SGVpZ2h0ICogKDAuNSArIDAuMSAvKiBDb25zdGFudHMuVGV4dE1hcmdpbiAqLyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0cy5faW50ZXJuYWxfYWJvdmVCYXIgKz0gdGV4dEhlaWdodCAqICgxICsgMiAqIDAuMSAvKiBDb25zdGFudHMuVGV4dE1hcmdpbiAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXRzLl9pbnRlcm5hbF9hYm92ZUJhciArPSBzaGFwZVNpemUgKyBzaGFwZU1hcmdpbjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdiZWxvd0Jhcic6IHtcbiAgICAgICAgICAgIHJlbmRlcmVySXRlbS5faW50ZXJuYWxfeSA9IChwcmljZVNjYWxlLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZShsb3dQcmljZSwgZmlyc3RWYWx1ZSkgKyBoYWxmU2l6ZSArIG9mZnNldHMuX2ludGVybmFsX2JlbG93QmFyKTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlckl0ZW0uX2ludGVybmFsX3RleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVySXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfeSA9IHJlbmRlcmVySXRlbS5faW50ZXJuYWxfeSArIGhhbGZTaXplICsgc2hhcGVNYXJnaW4gKyB0ZXh0SGVpZ2h0ICogKDAuNSArIDAuMSAvKiBDb25zdGFudHMuVGV4dE1hcmdpbiAqLyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0cy5faW50ZXJuYWxfYmVsb3dCYXIgKz0gdGV4dEhlaWdodCAqICgxICsgMiAqIDAuMSAvKiBDb25zdGFudHMuVGV4dE1hcmdpbiAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXRzLl9pbnRlcm5hbF9iZWxvd0JhciArPSBzaGFwZVNpemUgKyBzaGFwZU1hcmdpbjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbnN1cmVOZXZlcihtYXJrZXIucG9zaXRpb24pO1xufVxuY2xhc3MgU2VyaWVzTWFya2Vyc1BhbmVWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMsIG1vZGVsKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXV0b1NjYWxlTWFyZ2luc0ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXV0b1NjYWxlTWFyZ2lucyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyID0gbmV3IFNlcmllc01hcmtlcnNSZW5kZXJlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXMgPSBzZXJpZXM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfaXRlbXM6IFtdLFxuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGVSYW5nZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSh1cGRhdGVUeXBlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXV0b1NjYWxlTWFyZ2luc0ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHVwZGF0ZVR5cGUgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVuZGVyZXIoYWRkQW5jaG9ycykge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfdmlzaWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19tYWtlVmFsaWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXlvdXQgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpLmxheW91dDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIuX2ludGVybmFsX3NldFBhcmFtcyhsYXlvdXQuZm9udFNpemUsIGxheW91dC5mb250RmFtaWx5KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEodGhpcy5fcHJpdmF0ZV9fZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yZW5kZXJlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX2F1dG9TY2FsZU1hcmdpbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19hdXRvU2NhbGVNYXJnaW5zSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX2luZGV4ZWRNYXJrZXJzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhclNwYWNpbmcgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2JhclNwYWNpbmcoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFwZU1hcmdpbiQxID0gc2hhcGVNYXJnaW4oYmFyU3BhY2luZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFyZ2luc0Fib3ZlQW5kQmVsb3cgPSBjYWxjdWxhdGVTaGFwZUhlaWdodChiYXJTcGFjaW5nKSAqIDEuNSArIHNoYXBlTWFyZ2luJDEgKiAyO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2F1dG9TY2FsZU1hcmdpbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3ZlOiBtYXJnaW5zQWJvdmVBbmRCZWxvdyxcbiAgICAgICAgICAgICAgICAgICAgYmVsb3c6IG1hcmdpbnNBYm92ZUFuZEJlbG93LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hdXRvU2NhbGVNYXJnaW5zID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2F1dG9TY2FsZU1hcmdpbnNJbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19hdXRvU2NhbGVNYXJnaW5zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX21ha2VWYWxpZCgpIHtcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICBjb25zdCB0aW1lU2NhbGUgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IHNlcmllc01hcmtlcnMgPSB0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX2luZGV4ZWRNYXJrZXJzKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2l0ZW1zID0gc2VyaWVzTWFya2Vycy5tYXAoKG1hcmtlcikgPT4gKHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGltZTogbWFya2VyLnRpbWUsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3g6IDAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3k6IDAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3NpemU6IDAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3NoYXBlOiBtYXJrZXIuc2hhcGUsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2NvbG9yOiBtYXJrZXIuY29sb3IsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2ludGVybmFsSWQ6IG1hcmtlci5faW50ZXJuYWxfaW50ZXJuYWxJZCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfZXh0ZXJuYWxJZDogbWFya2VyLmlkLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhSW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXlvdXRPcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX29wdGlvbnMoKS5sYXlvdXQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IHZpc2libGVCYXJzID0gdGltZVNjYWxlLl9pbnRlcm5hbF92aXNpYmxlU3RyaWN0UmFuZ2UoKTtcbiAgICAgICAgaWYgKHZpc2libGVCYXJzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICBpZiAoZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJldlRpbWVJbmRleCA9IE5hTjtcbiAgICAgICAgY29uc3Qgc2hhcGVNYXJnaW4kMSA9IHNoYXBlTWFyZ2luKHRpbWVTY2FsZS5faW50ZXJuYWxfYmFyU3BhY2luZygpKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9hYm92ZUJhcjogc2hhcGVNYXJnaW4kMSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iZWxvd0Jhcjogc2hhcGVNYXJnaW4kMSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID0gdmlzaWJsZVRpbWVkVmFsdWVzKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2l0ZW1zLCB2aXNpYmxlQmFycywgdHJ1ZSk7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb207IGluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLnRvOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBzZXJpZXNNYXJrZXJzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIudGltZSAhPT0gcHJldlRpbWVJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIG5ldyBiYXIsIHJlc2V0IHN0YWNrIGNvdW50ZXJcbiAgICAgICAgICAgICAgICBvZmZzZXRzLl9pbnRlcm5hbF9hYm92ZUJhciA9IHNoYXBlTWFyZ2luJDE7XG4gICAgICAgICAgICAgICAgb2Zmc2V0cy5faW50ZXJuYWxfYmVsb3dCYXIgPSBzaGFwZU1hcmdpbiQxO1xuICAgICAgICAgICAgICAgIHByZXZUaW1lSW5kZXggPSBtYXJrZXIudGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVySXRlbSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2l0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgIHJlbmRlcmVySXRlbS5faW50ZXJuYWxfeCA9IHRpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhUb0Nvb3JkaW5hdGUobWFya2VyLnRpbWUpO1xuICAgICAgICAgICAgaWYgKG1hcmtlci50ZXh0ICE9PSB1bmRlZmluZWQgJiYgbWFya2VyLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVySXRlbS5faW50ZXJuYWxfdGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX2NvbnRlbnQ6IG1hcmtlci50ZXh0LFxuICAgICAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeDogMCxcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX3k6IDAsXG4gICAgICAgICAgICAgICAgICAgIF9pbnRlcm5hbF93aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX2hlaWdodDogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YUF0ID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9kYXRhQXQobWFya2VyLnRpbWUpO1xuICAgICAgICAgICAgaWYgKGRhdGFBdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsbFNpemVBbmRZKHJlbmRlcmVySXRlbSwgbWFya2VyLCBkYXRhQXQsIG9mZnNldHMsIGxheW91dE9wdGlvbnMuZm9udFNpemUsIHNoYXBlTWFyZ2luJDEsIHByaWNlU2NhbGUsIHRpbWVTY2FsZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgfVxufVxuXG5jbGFzcyBTZXJpZXNQcmljZUxpbmVQYW5lVmlldyBleHRlbmRzIFNlcmllc0hvcml6b250YWxMaW5lUGFuZVZpZXcge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNvbnN0cnVjdG9yXG4gICAgY29uc3RydWN0b3Ioc2VyaWVzKSB7XG4gICAgICAgIHN1cGVyKHNlcmllcyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fdXBkYXRlSW1wbCgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2ludGVybmFsX19saW5lUmVuZGVyZXJEYXRhO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHNlcmllc09wdGlvbnMgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIGlmICghc2VyaWVzT3B0aW9ucy5wcmljZUxpbmVWaXNpYmxlIHx8ICF0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF92aXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0VmFsdWVEYXRhID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfbGFzdFZhbHVlRGF0YShzZXJpZXNPcHRpb25zLnByaWNlTGluZVNvdXJjZSA9PT0gMCAvKiBQcmljZUxpbmVTb3VyY2UuTGFzdEJhciAqLyk7XG4gICAgICAgIGlmIChsYXN0VmFsdWVEYXRhLl9pbnRlcm5hbF9ub0RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfeSA9IGxhc3RWYWx1ZURhdGEuX2ludGVybmFsX2Nvb3JkaW5hdGU7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX2NvbG9yID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfcHJpY2VMaW5lQ29sb3IobGFzdFZhbHVlRGF0YS5faW50ZXJuYWxfY29sb3IpO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9saW5lV2lkdGggPSBzZXJpZXNPcHRpb25zLnByaWNlTGluZVdpZHRoO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9saW5lU3R5bGUgPSBzZXJpZXNPcHRpb25zLnByaWNlTGluZVN0eWxlO1xuICAgIH1cbn1cblxuY2xhc3MgU2VyaWVzUHJpY2VBeGlzVmlldyBleHRlbmRzIFByaWNlQXhpc1ZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fdXBkYXRlUmVuZGVyZXJEYXRhKGF4aXNSZW5kZXJlckRhdGEsIHBhbmVSZW5kZXJlckRhdGEsIGNvbW1vblJlbmRlcmVyRGF0YSkge1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHBhbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5fcHJpdmF0ZV9fc291cmNlO1xuICAgICAgICBpZiAoIXNvdXJjZS5faW50ZXJuYWxfdmlzaWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWVzT3B0aW9ucyA9IHNvdXJjZS5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICBjb25zdCBzaG93U2VyaWVzTGFzdFZhbHVlID0gc2VyaWVzT3B0aW9ucy5sYXN0VmFsdWVWaXNpYmxlO1xuICAgICAgICBjb25zdCBzaG93U3ltYm9sTGFiZWwgPSBzb3VyY2UuX2ludGVybmFsX3RpdGxlKCkgIT09ICcnO1xuICAgICAgICBjb25zdCBzaG93UHJpY2VBbmRQZXJjZW50YWdlID0gc2VyaWVzT3B0aW9ucy5zZXJpZXNMYXN0VmFsdWVNb2RlID09PSAwIC8qIFByaWNlQXhpc0xhc3RWYWx1ZU1vZGUuTGFzdFByaWNlQW5kUGVyY2VudGFnZVZhbHVlICovO1xuICAgICAgICBjb25zdCBsYXN0VmFsdWVEYXRhID0gc291cmNlLl9pbnRlcm5hbF9sYXN0VmFsdWVEYXRhKGZhbHNlKTtcbiAgICAgICAgaWYgKGxhc3RWYWx1ZURhdGEuX2ludGVybmFsX25vRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG93U2VyaWVzTGFzdFZhbHVlKSB7XG4gICAgICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90ZXh0ID0gdGhpcy5faW50ZXJuYWxfX2F4aXNUZXh0KGxhc3RWYWx1ZURhdGEsIHNob3dTZXJpZXNMYXN0VmFsdWUsIHNob3dQcmljZUFuZFBlcmNlbnRhZ2UpO1xuICAgICAgICAgICAgYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3RleHQubGVuZ3RoICE9PSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG93U3ltYm9sTGFiZWwgfHwgc2hvd1ByaWNlQW5kUGVyY2VudGFnZSkge1xuICAgICAgICAgICAgcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGV4dCA9IHRoaXMuX2ludGVybmFsX19wYW5lVGV4dChsYXN0VmFsdWVEYXRhLCBzaG93U2VyaWVzTGFzdFZhbHVlLCBzaG93U3ltYm9sTGFiZWwsIHNob3dQcmljZUFuZFBlcmNlbnRhZ2UpO1xuICAgICAgICAgICAgcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IHBhbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3RleHQubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0VmFsdWVDb2xvciA9IHNvdXJjZS5faW50ZXJuYWxfcHJpY2VMaW5lQ29sb3IobGFzdFZhbHVlRGF0YS5faW50ZXJuYWxfY29sb3IpO1xuICAgICAgICBjb25zdCBjb2xvcnMgPSBnZW5lcmF0ZUNvbnRyYXN0Q29sb3JzKGxhc3RWYWx1ZUNvbG9yKTtcbiAgICAgICAgY29tbW9uUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9iYWNrZ3JvdW5kID0gY29sb3JzLl9pbnRlcm5hbF9iYWNrZ3JvdW5kO1xuICAgICAgICBjb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2Nvb3JkaW5hdGUgPSBsYXN0VmFsdWVEYXRhLl9pbnRlcm5hbF9jb29yZGluYXRlO1xuICAgICAgICBwYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9ib3JkZXJDb2xvciA9IHNvdXJjZS5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfYmFja2dyb3VuZENvbG9yQXRZUGVyY2VudEZyb21Ub3AobGFzdFZhbHVlRGF0YS5faW50ZXJuYWxfY29vcmRpbmF0ZSAvIHNvdXJjZS5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9oZWlnaHQoKSk7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX2JvcmRlckNvbG9yID0gbGFzdFZhbHVlQ29sb3I7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX2NvbG9yID0gY29sb3JzLl9pbnRlcm5hbF9mb3JlZ3JvdW5kO1xuICAgICAgICBwYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb2xvciA9IGNvbG9ycy5faW50ZXJuYWxfZm9yZWdyb3VuZDtcbiAgICB9XG4gICAgX2ludGVybmFsX19wYW5lVGV4dChsYXN0VmFsdWUsIHNob3dTZXJpZXNMYXN0VmFsdWUsIHNob3dTeW1ib2xMYWJlbCwgc2hvd1ByaWNlQW5kUGVyY2VudGFnZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gdGhpcy5fcHJpdmF0ZV9fc291cmNlLl9pbnRlcm5hbF90aXRsZSgpO1xuICAgICAgICBpZiAoc2hvd1N5bWJvbExhYmVsICYmIHRpdGxlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGAke3RpdGxlfSBgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG93U2VyaWVzTGFzdFZhbHVlICYmIHNob3dQcmljZUFuZFBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLl9wcml2YXRlX19zb3VyY2UuX2ludGVybmFsX3ByaWNlU2NhbGUoKS5faW50ZXJuYWxfaXNQZXJjZW50YWdlKCkgP1xuICAgICAgICAgICAgICAgIGxhc3RWYWx1ZS5faW50ZXJuYWxfZm9ybWF0dGVkUHJpY2VBYnNvbHV0ZSA6IGxhc3RWYWx1ZS5faW50ZXJuYWxfZm9ybWF0dGVkUHJpY2VQZXJjZW50YWdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudHJpbSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2F4aXNUZXh0KGxhc3RWYWx1ZURhdGEsIHNob3dTZXJpZXNMYXN0VmFsdWUsIHNob3dQcmljZUFuZFBlcmNlbnRhZ2UpIHtcbiAgICAgICAgaWYgKCFzaG93U2VyaWVzTGFzdFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaG93UHJpY2VBbmRQZXJjZW50YWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFZhbHVlRGF0YS5faW50ZXJuYWxfdGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc291cmNlLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX2lzUGVyY2VudGFnZSgpID9cbiAgICAgICAgICAgIGxhc3RWYWx1ZURhdGEuX2ludGVybmFsX2Zvcm1hdHRlZFByaWNlUGVyY2VudGFnZSA6IGxhc3RWYWx1ZURhdGEuX2ludGVybmFsX2Zvcm1hdHRlZFByaWNlQWJzb2x1dGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlRmluaXRlUmVzdWx0KG1ldGhvZCwgdmFsdWVPbmUsIHZhbHVlVHdvLCBmYWxsYmFjaykge1xuICAgIGNvbnN0IGZpcnN0RmluaXRlID0gTnVtYmVyLmlzRmluaXRlKHZhbHVlT25lKTtcbiAgICBjb25zdCBzZWNvbmRGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUodmFsdWVUd28pO1xuICAgIGlmIChmaXJzdEZpbml0ZSAmJiBzZWNvbmRGaW5pdGUpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZCh2YWx1ZU9uZSwgdmFsdWVUd28pO1xuICAgIH1cbiAgICByZXR1cm4gIWZpcnN0RmluaXRlICYmICFzZWNvbmRGaW5pdGUgPyBmYWxsYmFjayA6IChmaXJzdEZpbml0ZSA/IHZhbHVlT25lIDogdmFsdWVUd28pO1xufVxuY2xhc3MgUHJpY2VSYW5nZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKG1pblZhbHVlLCBtYXhWYWx1ZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19taW5WYWx1ZSA9IG1pblZhbHVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSA9IG1heFZhbHVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZXF1YWxzKHByKSB7XG4gICAgICAgIGlmIChwciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19taW5WYWx1ZSA9PT0gcHIuX3ByaXZhdGVfX21pblZhbHVlICYmIHRoaXMuX3ByaXZhdGVfX21heFZhbHVlID09PSBwci5fcHJpdmF0ZV9fbWF4VmFsdWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmljZVJhbmdlSW1wbCh0aGlzLl9wcml2YXRlX19taW5WYWx1ZSwgdGhpcy5fcHJpdmF0ZV9fbWF4VmFsdWUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbWluVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19taW5WYWx1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX21heFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbWF4VmFsdWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSAtIHRoaXMuX3ByaXZhdGVfX21pblZhbHVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX21heFZhbHVlID09PSB0aGlzLl9wcml2YXRlX19taW5WYWx1ZSB8fCBOdW1iZXIuaXNOYU4odGhpcy5fcHJpdmF0ZV9fbWF4VmFsdWUpIHx8IE51bWJlci5pc05hTih0aGlzLl9wcml2YXRlX19taW5WYWx1ZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tZXJnZShhbm90aGVyUmFuZ2UpIHtcbiAgICAgICAgaWYgKGFub3RoZXJSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcmljZVJhbmdlSW1wbChjb21wdXRlRmluaXRlUmVzdWx0KE1hdGgubWluLCB0aGlzLl9pbnRlcm5hbF9taW5WYWx1ZSgpLCBhbm90aGVyUmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCksIC1JbmZpbml0eSksIGNvbXB1dGVGaW5pdGVSZXN1bHQoTWF0aC5tYXgsIHRoaXMuX2ludGVybmFsX21heFZhbHVlKCksIGFub3RoZXJSYW5nZS5faW50ZXJuYWxfbWF4VmFsdWUoKSwgSW5maW5pdHkpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NjYWxlQXJvdW5kQ2VudGVyKGNvZWZmKSB7XG4gICAgICAgIGlmICghaXNOdW1iZXIoY29lZmYpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSAtIHRoaXMuX3ByaXZhdGVfX21pblZhbHVlO1xuICAgICAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZW50ZXIgPSAodGhpcy5fcHJpdmF0ZV9fbWF4VmFsdWUgKyB0aGlzLl9wcml2YXRlX19taW5WYWx1ZSkgKiAwLjU7XG4gICAgICAgIGxldCBtYXhEZWx0YSA9IHRoaXMuX3ByaXZhdGVfX21heFZhbHVlIC0gY2VudGVyO1xuICAgICAgICBsZXQgbWluRGVsdGEgPSB0aGlzLl9wcml2YXRlX19taW5WYWx1ZSAtIGNlbnRlcjtcbiAgICAgICAgbWF4RGVsdGEgKj0gY29lZmY7XG4gICAgICAgIG1pbkRlbHRhICo9IGNvZWZmO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSA9IGNlbnRlciArIG1heERlbHRhO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19taW5WYWx1ZSA9IGNlbnRlciArIG1pbkRlbHRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2hpZnQoZGVsdGEpIHtcbiAgICAgICAgaWYgKCFpc051bWJlcihkZWx0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSArPSBkZWx0YTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWluVmFsdWUgKz0gZGVsdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90b1JhdygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pblZhbHVlOiB0aGlzLl9wcml2YXRlX19taW5WYWx1ZSxcbiAgICAgICAgICAgIG1heFZhbHVlOiB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIF9pbnRlcm5hbF9mcm9tUmF3KHJhdykge1xuICAgICAgICByZXR1cm4gKHJhdyA9PT0gbnVsbCkgPyBudWxsIDogbmV3IFByaWNlUmFuZ2VJbXBsKHJhdy5taW5WYWx1ZSwgcmF3Lm1heFZhbHVlKTtcbiAgICB9XG59XG5cbmNsYXNzIEF1dG9zY2FsZUluZm9JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihwcmljZVJhbmdlLCBtYXJnaW5zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2UgPSBwcmljZVJhbmdlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJnaW5zID0gbWFyZ2lucyB8fCBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VSYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2U7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tYXJnaW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbWFyZ2lucztcbiAgICB9XG4gICAgX2ludGVybmFsX3RvUmF3KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByaWNlUmFuZ2U6IHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2UuX2ludGVybmFsX3RvUmF3KCksXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLl9wcml2YXRlX19tYXJnaW5zIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIF9pbnRlcm5hbF9mcm9tUmF3KHJhdykge1xuICAgICAgICByZXR1cm4gKHJhdyA9PT0gbnVsbCkgPyBudWxsIDogbmV3IEF1dG9zY2FsZUluZm9JbXBsKFByaWNlUmFuZ2VJbXBsLl9pbnRlcm5hbF9mcm9tUmF3KHJhdy5wcmljZVJhbmdlKSwgcmF3Lm1hcmdpbnMpO1xuICAgIH1cbn1cblxuY2xhc3MgQ3VzdG9tUHJpY2VMaW5lUGFuZVZpZXcgZXh0ZW5kcyBTZXJpZXNIb3Jpem9udGFsTGluZVBhbmVWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMsIHByaWNlTGluZSkge1xuICAgICAgICBzdXBlcihzZXJpZXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUxpbmUgPSBwcmljZUxpbmU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fdXBkYXRlSW1wbCgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2ludGVybmFsX19saW5lUmVuZGVyZXJEYXRhO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGxpbmVPcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIGlmICghdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfdmlzaWJsZSgpIHx8ICFsaW5lT3B0aW9ucy5saW5lVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLl9wcml2YXRlX19wcmljZUxpbmUuX2ludGVybmFsX3lDb29yZCgpO1xuICAgICAgICBpZiAoeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF95ID0geTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfY29sb3IgPSBsaW5lT3B0aW9ucy5jb2xvcjtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfbGluZVdpZHRoID0gbGluZU9wdGlvbnMubGluZVdpZHRoO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9saW5lU3R5bGUgPSBsaW5lT3B0aW9ucy5saW5lU3R5bGU7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX2V4dGVybmFsSWQgPSB0aGlzLl9wcml2YXRlX19wcmljZUxpbmUuX2ludGVybmFsX29wdGlvbnMoKS5pZDtcbiAgICB9XG59XG5cbmNsYXNzIEN1c3RvbVByaWNlTGluZVByaWNlQXhpc1ZpZXcgZXh0ZW5kcyBQcmljZUF4aXNWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMsIHByaWNlTGluZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXMgPSBzZXJpZXM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZSA9IHByaWNlTGluZTtcbiAgICB9XG4gICAgX2ludGVybmFsX191cGRhdGVSZW5kZXJlckRhdGEoYXhpc1JlbmRlcmVyRGF0YSwgcGFuZVJlbmRlcmVyRGF0YSwgY29tbW9uRGF0YSkge1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHBhbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZS5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICBjb25zdCBsYWJlbFZpc2libGUgPSBvcHRpb25zLmF4aXNMYWJlbFZpc2libGU7XG4gICAgICAgIGNvbnN0IHNob3dQYW5lTGFiZWwgPSBvcHRpb25zLnRpdGxlICE9PSAnJztcbiAgICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzO1xuICAgICAgICBpZiAoIWxhYmVsVmlzaWJsZSB8fCAhc2VyaWVzLl9pbnRlcm5hbF92aXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB5ID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lLl9pbnRlcm5hbF95Q29vcmQoKTtcbiAgICAgICAgaWYgKHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvd1BhbmVMYWJlbCkge1xuICAgICAgICAgICAgcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGV4dCA9IG9wdGlvbnMudGl0bGU7XG4gICAgICAgICAgICBwYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9ib3JkZXJDb2xvciA9IHNlcmllcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfYmFja2dyb3VuZENvbG9yQXRZUGVyY2VudEZyb21Ub3AoeSAvIHNlcmllcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9oZWlnaHQoKSk7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3RleHQgPSB0aGlzLl9wcml2YXRlX19mb3JtYXRQcmljZShvcHRpb25zLnByaWNlKTtcbiAgICAgICAgYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IGdlbmVyYXRlQ29udHJhc3RDb2xvcnMob3B0aW9ucy5heGlzTGFiZWxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcbiAgICAgICAgY29tbW9uRGF0YS5faW50ZXJuYWxfYmFja2dyb3VuZCA9IGNvbG9ycy5faW50ZXJuYWxfYmFja2dyb3VuZDtcbiAgICAgICAgY29uc3QgdGV4dENvbG9yID0gb3B0aW9ucy5heGlzTGFiZWxUZXh0Q29sb3IgfHwgY29sb3JzLl9pbnRlcm5hbF9mb3JlZ3JvdW5kO1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb2xvciA9IHRleHRDb2xvcjsgLy8gcHJpY2UgdGV4dFxuICAgICAgICBwYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb2xvciA9IHRleHRDb2xvcjsgLy8gdGl0bGUgdGV4dFxuICAgICAgICBjb21tb25EYXRhLl9pbnRlcm5hbF9jb29yZGluYXRlID0geTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Zvcm1hdFByaWNlKHByaWNlKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgaWYgKGZpcnN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX2Zvcm1hdFByaWNlKHByaWNlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgfVxufVxuXG5jbGFzcyBDdXN0b21QcmljZUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXMgPSBzZXJpZXM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUxpbmVWaWV3ID0gbmV3IEN1c3RvbVByaWNlTGluZVBhbmVWaWV3KHNlcmllcywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXcgPSBuZXcgQ3VzdG9tUHJpY2VMaW5lUHJpY2VBeGlzVmlldyhzZXJpZXMsIHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lUHJpY2VBeGlzVmlldyA9IG5ldyBQYW5lUHJpY2VBeGlzVmlldyh0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3LCBzZXJpZXMsIHNlcmllcy5faW50ZXJuYWxfbW9kZWwoKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBtZXJnZSh0aGlzLl9wcml2YXRlX19vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX29wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFuZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmljZUxpbmVWaWV3O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbGFiZWxQYW5lVmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVQcmljZUF4aXNWaWV3O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VBeGlzVmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXc7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZVZpZXcuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3Ll9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3lDb29yZCgpIHtcbiAgICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzO1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHNlcmllcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIGlmICh0aW1lU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSB8fCBwcmljZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBzZXJpZXMuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgaWYgKGZpcnN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmljZVNjYWxlLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZSh0aGlzLl9wcml2YXRlX19vcHRpb25zLnByaWNlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgfVxufVxuXG5jbGFzcyBQcmljZURhdGFTb3VyY2UgZXh0ZW5kcyBEYXRhU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCA9IG1vZGVsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW9kZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tb2RlbDtcbiAgICB9XG59XG5cbmNvbnN0IGJhclN0eWxlRm5NYXAgPSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIEJhcjogKGZpbmRCYXIsIGJhclN0eWxlLCBiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdXBDb2xvciA9IGJhclN0eWxlLnVwQ29sb3I7XG4gICAgICAgIGNvbnN0IGRvd25Db2xvciA9IGJhclN0eWxlLmRvd25Db2xvcjtcbiAgICAgICAgY29uc3QgY3VycmVudEJhciA9IGVuc3VyZU5vdE51bGwoZmluZEJhcihiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSk7XG4gICAgICAgIGNvbnN0IGlzVXAgPSBlbnN1cmUoY3VycmVudEJhci5faW50ZXJuYWxfdmFsdWVbMCAvKiBQbG90Um93VmFsdWVJbmRleC5PcGVuICovXSkgPD0gZW5zdXJlKGN1cnJlbnRCYXIuX2ludGVybmFsX3ZhbHVlWzMgLyogUGxvdFJvd1ZhbHVlSW5kZXguQ2xvc2UgKi9dKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJDb2xvcjogKF9hID0gY3VycmVudEJhci5faW50ZXJuYWxfY29sb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChpc1VwID8gdXBDb2xvciA6IGRvd25Db2xvciksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgQ2FuZGxlc3RpY2s6IChmaW5kQmFyLCBjYW5kbGVzdGlja1N0eWxlLCBiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB1cENvbG9yID0gY2FuZGxlc3RpY2tTdHlsZS51cENvbG9yO1xuICAgICAgICBjb25zdCBkb3duQ29sb3IgPSBjYW5kbGVzdGlja1N0eWxlLmRvd25Db2xvcjtcbiAgICAgICAgY29uc3QgYm9yZGVyVXBDb2xvciA9IGNhbmRsZXN0aWNrU3R5bGUuYm9yZGVyVXBDb2xvcjtcbiAgICAgICAgY29uc3QgYm9yZGVyRG93bkNvbG9yID0gY2FuZGxlc3RpY2tTdHlsZS5ib3JkZXJEb3duQ29sb3I7XG4gICAgICAgIGNvbnN0IHdpY2tVcENvbG9yID0gY2FuZGxlc3RpY2tTdHlsZS53aWNrVXBDb2xvcjtcbiAgICAgICAgY29uc3Qgd2lja0Rvd25Db2xvciA9IGNhbmRsZXN0aWNrU3R5bGUud2lja0Rvd25Db2xvcjtcbiAgICAgICAgY29uc3QgY3VycmVudEJhciA9IGVuc3VyZU5vdE51bGwoZmluZEJhcihiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSk7XG4gICAgICAgIGNvbnN0IGlzVXAgPSBlbnN1cmUoY3VycmVudEJhci5faW50ZXJuYWxfdmFsdWVbMCAvKiBQbG90Um93VmFsdWVJbmRleC5PcGVuICovXSkgPD0gZW5zdXJlKGN1cnJlbnRCYXIuX2ludGVybmFsX3ZhbHVlWzMgLyogUGxvdFJvd1ZhbHVlSW5kZXguQ2xvc2UgKi9dKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJDb2xvcjogKF9hID0gY3VycmVudEJhci5faW50ZXJuYWxfY29sb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChpc1VwID8gdXBDb2xvciA6IGRvd25Db2xvciksXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyQm9yZGVyQ29sb3I6IChfYiA9IGN1cnJlbnRCYXIuX2ludGVybmFsX2JvcmRlckNvbG9yKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoaXNVcCA/IGJvcmRlclVwQ29sb3IgOiBib3JkZXJEb3duQ29sb3IpLFxuICAgICAgICAgICAgX2ludGVybmFsX2JhcldpY2tDb2xvcjogKF9jID0gY3VycmVudEJhci5faW50ZXJuYWxfd2lja0NvbG9yKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoaXNVcCA/IHdpY2tVcENvbG9yIDogd2lja0Rvd25Db2xvciksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgQ3VzdG9tOiAoZmluZEJhciwgY3VzdG9tU3R5bGUsIGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjdXJyZW50QmFyID0gZW5zdXJlTm90TnVsbChmaW5kQmFyKGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJDb2xvcjogKF9hID0gY3VycmVudEJhci5faW50ZXJuYWxfY29sb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN1c3RvbVN0eWxlLmNvbG9yLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIEFyZWE6IChmaW5kQmFyLCBhcmVhU3R5bGUsIGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBjdXJyZW50QmFyID0gZW5zdXJlTm90TnVsbChmaW5kQmFyKGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJDb2xvcjogKF9hID0gY3VycmVudEJhci5faW50ZXJuYWxfbGluZUNvbG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBhcmVhU3R5bGUubGluZUNvbG9yLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVDb2xvcjogKF9iID0gY3VycmVudEJhci5faW50ZXJuYWxfbGluZUNvbG9yKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBhcmVhU3R5bGUubGluZUNvbG9yLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvcENvbG9yOiAoX2MgPSBjdXJyZW50QmFyLl9pbnRlcm5hbF90b3BDb2xvcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogYXJlYVN0eWxlLnRvcENvbG9yLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvdHRvbUNvbG9yOiAoX2QgPSBjdXJyZW50QmFyLl9pbnRlcm5hbF9ib3R0b21Db2xvcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogYXJlYVN0eWxlLmJvdHRvbUNvbG9yLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIEJhc2VsaW5lOiAoZmluZEJhciwgYmFzZWxpbmVTdHlsZSwgYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgY29uc3QgY3VycmVudEJhciA9IGVuc3VyZU5vdE51bGwoZmluZEJhcihiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSk7XG4gICAgICAgIGNvbnN0IGlzQWJvdmVCYXNlbGluZSA9IGN1cnJlbnRCYXIuX2ludGVybmFsX3ZhbHVlWzMgLyogUGxvdFJvd1ZhbHVlSW5kZXguQ2xvc2UgKi9dID49IGJhc2VsaW5lU3R5bGUuYmFzZVZhbHVlLnByaWNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX2JhckNvbG9yOiBpc0Fib3ZlQmFzZWxpbmUgPyBiYXNlbGluZVN0eWxlLnRvcExpbmVDb2xvciA6IGJhc2VsaW5lU3R5bGUuYm90dG9tTGluZUNvbG9yLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvcExpbmVDb2xvcjogKF9hID0gY3VycmVudEJhci5faW50ZXJuYWxfdG9wTGluZUNvbG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBiYXNlbGluZVN0eWxlLnRvcExpbmVDb2xvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3R0b21MaW5lQ29sb3I6IChfYiA9IGN1cnJlbnRCYXIuX2ludGVybmFsX2JvdHRvbUxpbmVDb2xvcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogYmFzZWxpbmVTdHlsZS5ib3R0b21MaW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wRmlsbENvbG9yMTogKF9jID0gY3VycmVudEJhci5faW50ZXJuYWxfdG9wRmlsbENvbG9yMSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogYmFzZWxpbmVTdHlsZS50b3BGaWxsQ29sb3IxLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvcEZpbGxDb2xvcjI6IChfZCA9IGN1cnJlbnRCYXIuX2ludGVybmFsX3RvcEZpbGxDb2xvcjIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGJhc2VsaW5lU3R5bGUudG9wRmlsbENvbG9yMixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IxOiAoX2UgPSBjdXJyZW50QmFyLl9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IxKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBiYXNlbGluZVN0eWxlLmJvdHRvbUZpbGxDb2xvcjEsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMjogKF9mID0gY3VycmVudEJhci5faW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogYmFzZWxpbmVTdHlsZS5ib3R0b21GaWxsQ29sb3IyLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIExpbmU6IChmaW5kQmFyLCBsaW5lU3R5bGUsIGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY3VycmVudEJhciA9IGVuc3VyZU5vdE51bGwoZmluZEJhcihiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyQ29sb3I6IChfYSA9IGN1cnJlbnRCYXIuX2ludGVybmFsX2NvbG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBsaW5lU3R5bGUuY29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZUNvbG9yOiAoX2IgPSBjdXJyZW50QmFyLl9pbnRlcm5hbF9jb2xvcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbGluZVN0eWxlLmNvbG9yLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIEhpc3RvZ3JhbTogKGZpbmRCYXIsIGhpc3RvZ3JhbVN0eWxlLCBiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY3VycmVudEJhciA9IGVuc3VyZU5vdE51bGwoZmluZEJhcihiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyQ29sb3I6IChfYSA9IGN1cnJlbnRCYXIuX2ludGVybmFsX2NvbG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBoaXN0b2dyYW1TdHlsZS5jb2xvcixcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbmNsYXNzIFNlcmllc0JhckNvbG9yZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19maW5kQmFyID0gKGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpID0+IHtcbiAgICAgICAgICAgIGlmIChwcmVjb21wdXRlZEJhcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVjb21wdXRlZEJhcnMuX2ludGVybmFsX3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfYmFycygpLl9pbnRlcm5hbF92YWx1ZUF0KGJhckluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gc2VyaWVzO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdHlsZUdldHRlciA9IGJhclN0eWxlRm5NYXBbc2VyaWVzLl9pbnRlcm5hbF9zZXJpZXNUeXBlKCldO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYmFyU3R5bGUoYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycykge1xuICAgICAgICAvLyBwcmVjb21wdXRlZEJhcnM6IHt2YWx1ZTogW0FycmF5IEJhclZhbHVlc10sIHByZXZpb3VzVmFsdWU6IFtBcnJheSBCYXJWYWx1ZXNdIHwgdW5kZWZpbmVkfVxuICAgICAgICAvLyBVc2VkIHRvIGF2b2lkIGJpbmFyeSBzZWFyY2ggaWYgYmFycyBhcmUgYWxyZWFkeSBrbm93blxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc3R5bGVHZXR0ZXIodGhpcy5fcHJpdmF0ZV9fZmluZEJhciwgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCksIGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTZWFyY2ggZGlyZWN0aW9uIGlmIG5vIGRhdGEgZm91bmQgYXQgcHJvdmlkZWQgaW5kZXhcbiAqL1xudmFyIE1pc21hdGNoRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChNaXNtYXRjaERpcmVjdGlvbikge1xuICAgIC8qKlxuICAgICAqIFNlYXJjaCB0aGUgbmVhcmVzdCBsZWZ0IGl0ZW1cbiAgICAgKi9cbiAgICBNaXNtYXRjaERpcmVjdGlvbltNaXNtYXRjaERpcmVjdGlvbltcIk5lYXJlc3RMZWZ0XCJdID0gLTFdID0gXCJOZWFyZXN0TGVmdFwiO1xuICAgIC8qKlxuICAgICAqIERvIG5vdCBzZWFyY2hcbiAgICAgKi9cbiAgICBNaXNtYXRjaERpcmVjdGlvbltNaXNtYXRjaERpcmVjdGlvbltcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIC8qKlxuICAgICAqIFNlYXJjaCB0aGUgbmVhcmVzdCByaWdodCBpdGVtXG4gICAgICovXG4gICAgTWlzbWF0Y2hEaXJlY3Rpb25bTWlzbWF0Y2hEaXJlY3Rpb25bXCJOZWFyZXN0UmlnaHRcIl0gPSAxXSA9IFwiTmVhcmVzdFJpZ2h0XCI7XG59KShNaXNtYXRjaERpcmVjdGlvbiB8fCAoTWlzbWF0Y2hEaXJlY3Rpb24gPSB7fSkpO1xuLy8gVE9ETzogdGhpbmsgYWJvdXQgY2hhbmdpbmcgaXQgZHluYW1pY2FsbHlcbmNvbnN0IENIVU5LX1NJWkUgPSAzMDtcbi8qKlxuICogUGxvdExpc3QgaXMgYW4gYXJyYXkgb2YgcGxvdCByb3dzXG4gKiBlYWNoIHBsb3Qgcm93IGNvbnNpc3RzIG9mIGtleSAoaW5kZXggaW4gdGltZXNjYWxlKSBhbmQgcGxvdCB2YWx1ZSBtYXBcbiAqL1xuY2xhc3MgUGxvdExpc3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19taW5NYXhDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcm93U2VhcmNoQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8vIEByZXR1cm5zIExhc3Qgcm93XG4gICAgX2ludGVybmFsX2xhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9zaXplKCkgPiAwID8gdGhpcy5fcHJpdmF0ZV9faXRlbXNbdGhpcy5fcHJpdmF0ZV9faXRlbXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZmlyc3RJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX3NpemUoKSA+IDAgPyB0aGlzLl9wcml2YXRlX19pbmRleEF0KDApIDogbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2xhc3RJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX3NpemUoKSA+IDAgPyB0aGlzLl9wcml2YXRlX19pbmRleEF0KCh0aGlzLl9wcml2YXRlX19pdGVtcy5sZW5ndGggLSAxKSkgOiBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2l0ZW1zLmxlbmd0aDtcbiAgICB9XG4gICAgX2ludGVybmFsX2lzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9zaXplKCkgPT09IDA7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jb250YWlucyhpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc2VhcmNoKGluZGV4LCAwIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5vbmUgKi8pICE9PSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdmFsdWVBdChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfc2VhcmNoKGluZGV4KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NlYXJjaChpbmRleCwgc2VhcmNoTW9kZSA9IDAgLyogTWlzbWF0Y2hEaXJlY3Rpb24uTm9uZSAqLykge1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9wcml2YXRlX19zZWFyY2goaW5kZXgsIHNlYXJjaE1vZGUpO1xuICAgICAgICBpZiAocG9zID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9wcml2YXRlX192YWx1ZUF0KHBvcykpLCB7IF9pbnRlcm5hbF9pbmRleDogdGhpcy5fcHJpdmF0ZV9faW5kZXhBdChwb3MpIH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcm93cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2l0ZW1zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbWluTWF4T25SYW5nZUNhY2hlZChzdGFydCwgZW5kLCBwbG90cykge1xuICAgICAgICAvLyB0aGlzIGNvZGUgd29ya3MgZm9yIHNpbmdsZSBzZXJpZXMgb25seVxuICAgICAgICAvLyBjb3VsZCBmYWlsIGFmdGVyIHdoaXRlc3BhY2VzIGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHBsb3Qgb2YgcGxvdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsb3RNaW5NYXggPSB0aGlzLl9wcml2YXRlX19taW5NYXhPblJhbmdlQ2FjaGVkSW1wbChzdGFydCwgZW5kLCBwbG90KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG1lcmdlTWluTWF4KHJlc3VsdCwgcGxvdE1pbk1heCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEocGxvdFJvd3MpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcm93U2VhcmNoQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWluTWF4Q2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXRlbXMgPSBwbG90Um93cztcbiAgICB9XG4gICAgX3ByaXZhdGVfX2luZGV4QXQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19pdGVtc1tvZmZzZXRdLl9pbnRlcm5hbF9pbmRleDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3ZhbHVlQXQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19pdGVtc1tvZmZzZXRdO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2VhcmNoKGluZGV4LCBzZWFyY2hNb2RlKSB7XG4gICAgICAgIGNvbnN0IGV4YWN0UG9zID0gdGhpcy5fcHJpdmF0ZV9fYnNlYXJjaChpbmRleCk7XG4gICAgICAgIGlmIChleGFjdFBvcyA9PT0gbnVsbCAmJiBzZWFyY2hNb2RlICE9PSAwIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5vbmUgKi8pIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2VhcmNoTW9kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgLTEgLyogTWlzbWF0Y2hEaXJlY3Rpb24uTmVhcmVzdExlZnQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zZWFyY2hOZWFyZXN0TGVmdChpbmRleCk7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5lYXJlc3RSaWdodCAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3NlYXJjaE5lYXJlc3RSaWdodChpbmRleCk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBzZWFyY2ggbW9kZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleGFjdFBvcztcbiAgICB9XG4gICAgX3ByaXZhdGVfX3NlYXJjaE5lYXJlc3RMZWZ0KGluZGV4KSB7XG4gICAgICAgIGxldCBuZWFyZXN0TGVmdFBvcyA9IHRoaXMuX3ByaXZhdGVfX2xvd2VyYm91bmQoaW5kZXgpO1xuICAgICAgICBpZiAobmVhcmVzdExlZnRQb3MgPiAwKSB7XG4gICAgICAgICAgICBuZWFyZXN0TGVmdFBvcyA9IG5lYXJlc3RMZWZ0UG9zIC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5lYXJlc3RMZWZ0UG9zICE9PSB0aGlzLl9wcml2YXRlX19pdGVtcy5sZW5ndGggJiYgdGhpcy5fcHJpdmF0ZV9faW5kZXhBdChuZWFyZXN0TGVmdFBvcykgPCBpbmRleCkgPyBuZWFyZXN0TGVmdFBvcyA6IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19zZWFyY2hOZWFyZXN0UmlnaHQoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbmVhcmVzdFJpZ2h0UG9zID0gdGhpcy5fcHJpdmF0ZV9fdXBwZXJib3VuZChpbmRleCk7XG4gICAgICAgIHJldHVybiAobmVhcmVzdFJpZ2h0UG9zICE9PSB0aGlzLl9wcml2YXRlX19pdGVtcy5sZW5ndGggJiYgaW5kZXggPCB0aGlzLl9wcml2YXRlX19pbmRleEF0KG5lYXJlc3RSaWdodFBvcykpID8gbmVhcmVzdFJpZ2h0UG9zIDogbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2JzZWFyY2goaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9wcml2YXRlX19sb3dlcmJvdW5kKGluZGV4KTtcbiAgICAgICAgaWYgKHN0YXJ0ICE9PSB0aGlzLl9wcml2YXRlX19pdGVtcy5sZW5ndGggJiYgIShpbmRleCA8IHRoaXMuX3ByaXZhdGVfX2l0ZW1zW3N0YXJ0XS5faW50ZXJuYWxfaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19sb3dlcmJvdW5kKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsb3dlckJvdW5kKHRoaXMuX3ByaXZhdGVfX2l0ZW1zLCBpbmRleCwgKGEsIGIpID0+IGEuX2ludGVybmFsX2luZGV4IDwgYik7XG4gICAgfVxuICAgIF9wcml2YXRlX191cHBlcmJvdW5kKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB1cHBlckJvdW5kKHRoaXMuX3ByaXZhdGVfX2l0ZW1zLCBpbmRleCwgKGEsIGIpID0+IGEuX2ludGVybmFsX2luZGV4ID4gYik7XG4gICAgfVxuICAgIF9wcml2YXRlX19wbG90TWluTWF4KHN0YXJ0SW5kZXgsIGVuZEluZGV4RXhjbHVzaXZlLCBwbG90SW5kZXgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXhFeGNsdXNpdmU7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5fcHJpdmF0ZV9faXRlbXNbaV0uX2ludGVybmFsX3ZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlc1twbG90SW5kZXhdO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTih2KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHsgX2ludGVybmFsX21pbjogdiwgX2ludGVybmFsX21heDogdiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHYgPCByZXN1bHQuX2ludGVybmFsX21pbikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuX2ludGVybmFsX21pbiA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2ID4gcmVzdWx0Ll9pbnRlcm5hbF9tYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Ll9pbnRlcm5hbF9tYXggPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbWluTWF4T25SYW5nZUNhY2hlZEltcGwoc3RhcnQsIGVuZCwgcGxvdEluZGV4KSB7XG4gICAgICAgIC8vIHRoaXMgY29kZSB3b3JrcyBmb3Igc2luZ2xlIHNlcmllcyBvbmx5XG4gICAgICAgIC8vIGNvdWxkIGZhaWwgYWZ0ZXIgd2hpdGVzcGFjZXMgaW1wbGVtZW50YXRpb25cbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIC8vIGFzc3VtZSB0aGF0IGJhciBpbmRleGVzIG9ubHkgaW5jcmVhc2VcbiAgICAgICAgY29uc3QgZmlyc3RJbmRleCA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfZmlyc3RJbmRleCgpKTtcbiAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF9sYXN0SW5kZXgoKSk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLm1heChzdGFydCwgZmlyc3RJbmRleCk7XG4gICAgICAgIGNvbnN0IGUgPSBNYXRoLm1pbihlbmQsIGxhc3RJbmRleCk7XG4gICAgICAgIGNvbnN0IGNhY2hlZExvdyA9IE1hdGguY2VpbChzIC8gQ0hVTktfU0laRSkgKiBDSFVOS19TSVpFO1xuICAgICAgICBjb25zdCBjYWNoZWRIaWdoID0gTWF0aC5tYXgoY2FjaGVkTG93LCBNYXRoLmZsb29yKGUgLyBDSFVOS19TSVpFKSAqIENIVU5LX1NJWkUpO1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fbG93ZXJib3VuZChzKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fdXBwZXJib3VuZChNYXRoLm1pbihlLCBjYWNoZWRMb3csIGVuZCkpOyAvLyBub24taW5jbHVzaXZlIGVuZFxuICAgICAgICAgICAgY29uc3QgcGxvdE1pbk1heCA9IHRoaXMuX3ByaXZhdGVfX3Bsb3RNaW5NYXgoc3RhcnRJbmRleCwgZW5kSW5kZXgsIHBsb3RJbmRleCk7XG4gICAgICAgICAgICByZXN1bHQgPSBtZXJnZU1pbk1heChyZXN1bHQsIHBsb3RNaW5NYXgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtaW5NYXhDYWNoZSA9IHRoaXMuX3ByaXZhdGVfX21pbk1heENhY2hlLmdldChwbG90SW5kZXgpO1xuICAgICAgICBpZiAobWluTWF4Q2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWluTWF4Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19taW5NYXhDYWNoZS5zZXQocGxvdEluZGV4LCBtaW5NYXhDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IGdvIGNhY2hlZFxuICAgICAgICBmb3IgKGxldCBjID0gTWF0aC5tYXgoY2FjaGVkTG93ICsgMSwgcyk7IGMgPCBjYWNoZWRIaWdoOyBjICs9IENIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rSW5kZXggPSBNYXRoLmZsb29yKGMgLyBDSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGxldCBjaHVua01pbk1heCA9IG1pbk1heENhY2hlLmdldChjaHVua0luZGV4KTtcbiAgICAgICAgICAgIGlmIChjaHVua01pbk1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtTdGFydCA9IHRoaXMuX3ByaXZhdGVfX2xvd2VyYm91bmQoY2h1bmtJbmRleCAqIENIVU5LX1NJWkUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rRW5kID0gdGhpcy5fcHJpdmF0ZV9fdXBwZXJib3VuZCgoY2h1bmtJbmRleCArIDEpICogQ0hVTktfU0laRSAtIDEpO1xuICAgICAgICAgICAgICAgIGNodW5rTWluTWF4ID0gdGhpcy5fcHJpdmF0ZV9fcGxvdE1pbk1heChjaHVua1N0YXJ0LCBjaHVua0VuZCwgcGxvdEluZGV4KTtcbiAgICAgICAgICAgICAgICBtaW5NYXhDYWNoZS5zZXQoY2h1bmtJbmRleCwgY2h1bmtNaW5NYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gbWVyZ2VNaW5NYXgocmVzdWx0LCBjaHVua01pbk1heCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGFpbFxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fbG93ZXJib3VuZChjYWNoZWRIaWdoKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fdXBwZXJib3VuZChlKTsgLy8gbm9uLWluY2x1c2l2ZSBlbmRcbiAgICAgICAgICAgIGNvbnN0IHBsb3RNaW5NYXggPSB0aGlzLl9wcml2YXRlX19wbG90TWluTWF4KHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBwbG90SW5kZXgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gbWVyZ2VNaW5NYXgocmVzdWx0LCBwbG90TWluTWF4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlTWluTWF4KGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoZmlyc3QgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlY29uZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChzZWNvbmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1lcmdlIE1pbk1heCB2YWx1ZXNcbiAgICAgICAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKGZpcnN0Ll9pbnRlcm5hbF9taW4sIHNlY29uZC5faW50ZXJuYWxfbWluKTtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGZpcnN0Ll9pbnRlcm5hbF9tYXgsIHNlY29uZC5faW50ZXJuYWxfbWF4KTtcbiAgICAgICAgICAgIHJldHVybiB7IF9pbnRlcm5hbF9taW46IG1pbiwgX2ludGVybmFsX21heDogbWF4IH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcmllc1Bsb3RMaXN0KCkge1xuICAgIHJldHVybiBuZXcgUGxvdExpc3QoKTtcbn1cblxuY2xhc3MgU2VyaWVzUHJpbWl0aXZlUmVuZGVyZXJXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlUmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFzZVJlbmRlcmVyID0gYmFzZVJlbmRlcmVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZHJhdyh0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFzZVJlbmRlcmVyLmRyYXcodGFyZ2V0KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXdCYWNrZ3JvdW5kKHRhcmdldCwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLl9wcml2YXRlX19iYXNlUmVuZGVyZXIpLmRyYXdCYWNrZ3JvdW5kKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGFyZ2V0KTtcbiAgICB9XG59XG5jbGFzcyBTZXJpZXNQcmltaXRpdmVQYW5lVmlld1dyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhbmVWaWV3KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcgPSBwYW5lVmlldztcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGJhc2VSZW5kZXJlciA9IHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3LnJlbmRlcmVyKCk7XG4gICAgICAgIGlmIChiYXNlUmVuZGVyZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5fcHJpdmF0ZV9fY2FjaGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5faW50ZXJuYWxfYmFzZSkgPT09IGJhc2VSZW5kZXJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NhY2hlLl9pbnRlcm5hbF93cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgU2VyaWVzUHJpbWl0aXZlUmVuZGVyZXJXcmFwcGVyKGJhc2VSZW5kZXJlcik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2U6IGJhc2VSZW5kZXJlcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF93cmFwcGVyOiB3cmFwcGVyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX3pPcmRlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl9wcml2YXRlX19wYW5lVmlldykuek9yZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICdub3JtYWwnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEF4aXNWaWV3RGF0YShiYXNlVmlldykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2ludGVybmFsX3RleHQ6IGJhc2VWaWV3LnRleHQoKSxcbiAgICAgICAgX2ludGVybmFsX2Nvb3JkaW5hdGU6IGJhc2VWaWV3LmNvb3JkaW5hdGUoKSxcbiAgICAgICAgX2ludGVybmFsX2ZpeGVkQ29vcmRpbmF0ZTogKF9hID0gYmFzZVZpZXcuZml4ZWRDb29yZGluYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChiYXNlVmlldyksXG4gICAgICAgIF9pbnRlcm5hbF9jb2xvcjogYmFzZVZpZXcudGV4dENvbG9yKCksXG4gICAgICAgIF9pbnRlcm5hbF9iYWNrZ3JvdW5kOiBiYXNlVmlldy5iYWNrQ29sb3IoKSxcbiAgICAgICAgX2ludGVybmFsX3Zpc2libGU6IChfYyA9IChfYiA9IGJhc2VWaWV3LnZpc2libGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGJhc2VWaWV3KSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdHJ1ZSxcbiAgICAgICAgX2ludGVybmFsX3RpY2tWaXNpYmxlOiAoX2UgPSAoX2QgPSBiYXNlVmlldy50aWNrVmlzaWJsZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoYmFzZVZpZXcpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0cnVlLFxuICAgIH07XG59XG5jbGFzcyBTZXJpZXNQcmltaXRpdmVUaW1lQXhpc1ZpZXdXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlVmlldywgdGltZVNjYWxlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyID0gbmV3IFRpbWVBeGlzVmlld1JlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VWaWV3ID0gYmFzZVZpZXc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZSA9IHRpbWVTY2FsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YShPYmplY3QuYXNzaWduKHsgX2ludGVybmFsX3dpZHRoOiB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3dpZHRoKCkgfSwgZ2V0QXhpc1ZpZXdEYXRhKHRoaXMuX3ByaXZhdGVfX2Jhc2VWaWV3KSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXI7XG4gICAgfVxufVxuY2xhc3MgU2VyaWVzUHJpbWl0aXZlUHJpY2VBeGlzVmlld1dyYXBwZXIgZXh0ZW5kcyBQcmljZUF4aXNWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlVmlldywgcHJpY2VTY2FsZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlVmlldyA9IGJhc2VWaWV3O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID0gcHJpY2VTY2FsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX191cGRhdGVSZW5kZXJlckRhdGEoYXhpc1JlbmRlcmVyRGF0YSwgcGFuZVJlbmRlcmVyRGF0YSwgY29tbW9uUmVuZGVyZXJEYXRhKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRBeGlzVmlld0RhdGEodGhpcy5fcHJpdmF0ZV9fYmFzZVZpZXcpO1xuICAgICAgICBjb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2JhY2tncm91bmQgPSBkYXRhLl9pbnRlcm5hbF9iYWNrZ3JvdW5kO1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb2xvciA9IGRhdGEuX2ludGVybmFsX2NvbG9yO1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsUGFkZGluZyA9IDIgLyAxMiAqIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2ZvbnRTaXplKCk7XG4gICAgICAgIGNvbW1vblJlbmRlcmVyRGF0YS5faW50ZXJuYWxfYWRkaXRpb25hbFBhZGRpbmdUb3AgPSBhZGRpdGlvbmFsUGFkZGluZztcbiAgICAgICAgY29tbW9uUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9hZGRpdGlvbmFsUGFkZGluZ0JvdHRvbSA9IGFkZGl0aW9uYWxQYWRkaW5nO1xuICAgICAgICBjb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2Nvb3JkaW5hdGUgPSBkYXRhLl9pbnRlcm5hbF9jb29yZGluYXRlO1xuICAgICAgICBjb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2ZpeGVkQ29vcmRpbmF0ZSA9IGRhdGEuX2ludGVybmFsX2ZpeGVkQ29vcmRpbmF0ZTtcbiAgICAgICAgYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGV4dCA9IGRhdGEuX2ludGVybmFsX3RleHQ7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSBkYXRhLl9pbnRlcm5hbF92aXNpYmxlO1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90aWNrVmlzaWJsZSA9IGRhdGEuX2ludGVybmFsX3RpY2tWaXNpYmxlO1xuICAgIH1cbn1cbmNsYXNzIFNlcmllc1ByaW1pdGl2ZVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHByaW1pdGl2ZSwgc2VyaWVzKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3c0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNWaWV3c0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzVmlld3NDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1BhbmVWaWV3c0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNQYW5lVmlld3NDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZSA9IHByaW1pdGl2ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gc2VyaWVzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpbWl0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZSkudXBkYXRlQWxsVmlld3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3BhbmVWaWV3cygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBiYXNlID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlKS5wYW5lVmlld3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW107XG4gICAgICAgIGlmICgoKF9kID0gdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXdzQ2FjaGUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5faW50ZXJuYWxfYmFzZSkgPT09IGJhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lVmlld3NDYWNoZS5faW50ZXJuYWxfd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cmFwcGVyID0gYmFzZS5tYXAoKHB3KSA9PiBuZXcgU2VyaWVzUHJpbWl0aXZlUGFuZVZpZXdXcmFwcGVyKHB3KSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3c0NhY2hlID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2U6IGJhc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfd3JhcHBlcjogd3JhcHBlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aW1lQXhpc1ZpZXdzKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IGJhc2UgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl9wcml2YXRlX19wcmltaXRpdmUpLnRpbWVBeGlzVmlld3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW107XG4gICAgICAgIGlmICgoKF9kID0gdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNWaWV3c0NhY2hlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuX2ludGVybmFsX2Jhc2UpID09PSBiYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNWaWV3c0NhY2hlLl9pbnRlcm5hbF93cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBiYXNlLm1hcCgoYXcpID0+IG5ldyBTZXJpZXNQcmltaXRpdmVUaW1lQXhpc1ZpZXdXcmFwcGVyKGF3LCB0aW1lU2NhbGUpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNWaWV3c0NhY2hlID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2U6IGJhc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfd3JhcHBlcjogd3JhcHBlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZUF4aXNWaWV3cygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBiYXNlID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlKS5wcmljZUF4aXNWaWV3cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcbiAgICAgICAgaWYgKCgoX2QgPSB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3c0NhY2hlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuX2ludGVybmFsX2Jhc2UpID09PSBiYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzVmlld3NDYWNoZS5faW50ZXJuYWxfd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBiYXNlLm1hcCgoYXcpID0+IG5ldyBTZXJpZXNQcmltaXRpdmVQcmljZUF4aXNWaWV3V3JhcHBlcihhdywgcHJpY2VTY2FsZSkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3c0NhY2hlID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2U6IGJhc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfd3JhcHBlcjogd3JhcHBlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZUF4aXNQYW5lVmlld3MoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgYmFzZSA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZSkucHJpY2VBeGlzUGFuZVZpZXdzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xuICAgICAgICBpZiAoKChfZCA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1BhbmVWaWV3c0NhY2hlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuX2ludGVybmFsX2Jhc2UpID09PSBiYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzUGFuZVZpZXdzQ2FjaGUuX2ludGVybmFsX3dyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGJhc2UubWFwKChwdykgPT4gbmV3IFNlcmllc1ByaW1pdGl2ZVBhbmVWaWV3V3JhcHBlcihwdykpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNQYW5lVmlld3NDYWNoZSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlOiBiYXNlLFxuICAgICAgICAgICAgX2ludGVybmFsX3dyYXBwZXI6IHdyYXBwZXIsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGltZUF4aXNQYW5lVmlld3MoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgYmFzZSA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZSkudGltZUF4aXNQYW5lVmlld3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW107XG4gICAgICAgIGlmICgoKF9kID0gdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNQYW5lVmlld3NDYWNoZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLl9pbnRlcm5hbF9iYXNlKSA9PT0gYmFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzUGFuZVZpZXdzQ2FjaGUuX2ludGVybmFsX3dyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGJhc2UubWFwKChwdykgPT4gbmV3IFNlcmllc1ByaW1pdGl2ZVBhbmVWaWV3V3JhcHBlcihwdykpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1BhbmVWaWV3c0NhY2hlID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2U6IGJhc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfd3JhcHBlcjogd3JhcHBlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hdXRvc2NhbGVJbmZvKHN0YXJ0VGltZVBvaW50LCBlbmRUaW1lUG9pbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiAoKF9jID0gKF9iID0gKF9hID0gdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlKS5hdXRvc2NhbGVJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgc3RhcnRUaW1lUG9pbnQsIGVuZFRpbWVQb2ludCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaGl0VGVzdCh4LCB5KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlKS5oaXRUZXN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgeCwgeSkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0UHJpbWl0aXZlUGFuZVZpZXdzKHByaW1pdGl2ZXMsIGV4dHJhY3Rvciwgek9yZGVyLCBkZXN0aW5hdGlvbikge1xuICAgIHByaW1pdGl2ZXMuZm9yRWFjaCgod3JhcHBlcikgPT4ge1xuICAgICAgICBleHRyYWN0b3Iod3JhcHBlcikuZm9yRWFjaCgocGFuZVZpZXcpID0+IHtcbiAgICAgICAgICAgIGlmIChwYW5lVmlldy5faW50ZXJuYWxfek9yZGVyKCkgIT09IHpPcmRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocGFuZVZpZXcpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHByaW1pdGl2ZVBhbmVWaWV3c0V4dHJhY3Rvcih3cmFwcGVyKSB7XG4gICAgcmV0dXJuIHdyYXBwZXIuX2ludGVybmFsX3BhbmVWaWV3cygpO1xufVxuZnVuY3Rpb24gcHJpbWl0aXZlUHJpY2VQYW5lVmlld3NFeHRyYWN0b3Iod3JhcHBlcikge1xuICAgIHJldHVybiB3cmFwcGVyLl9pbnRlcm5hbF9wcmljZUF4aXNQYW5lVmlld3MoKTtcbn1cbmZ1bmN0aW9uIHByaW1pdGl2ZVRpbWVQYW5lVmlld3NFeHRyYWN0b3Iod3JhcHBlcikge1xuICAgIHJldHVybiB3cmFwcGVyLl9pbnRlcm5hbF90aW1lQXhpc1BhbmVWaWV3cygpO1xufVxuY2xhc3MgU2VyaWVzIGV4dGVuZHMgUHJpY2VEYXRhU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCwgb3B0aW9ucywgc2VyaWVzVHlwZSwgcGFuZSwgY3VzdG9tUGFuZVZpZXcpIHtcbiAgICAgICAgc3VwZXIobW9kZWwpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gY3JlYXRlU2VyaWVzUGxvdExpc3QoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lVmlldyA9IG5ldyBTZXJpZXNQcmljZUxpbmVQYW5lVmlldyh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3VzdG9tUHJpY2VMaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlSG9yaXpvbnRhbExpbmVWaWV3ID0gbmV3IFNlcmllc0hvcml6b250YWxCYXNlTGluZVBhbmVWaWV3KHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sYXN0UHJpY2VBbmltYXRpb25QYW5lVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhckNvbG9yZXJDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5kZXhlZE1hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYW5pbWF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSA9IHNlcmllc1R5cGU7XG4gICAgICAgIGNvbnN0IHByaWNlQXhpc1ZpZXcgPSBuZXcgU2VyaWVzUHJpY2VBeGlzVmlldyh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzVmlld3MgPSBbcHJpY2VBeGlzVmlld107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVQcmljZUF4aXNWaWV3ID0gbmV3IFBhbmVQcmljZUF4aXNWaWV3KHByaWNlQXhpc1ZpZXcsIHRoaXMsIG1vZGVsKTtcbiAgICAgICAgaWYgKHNlcmllc1R5cGUgPT09ICdBcmVhJyB8fCBzZXJpZXNUeXBlID09PSAnTGluZScgfHwgc2VyaWVzVHlwZSA9PT0gJ0Jhc2VsaW5lJykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFzdFByaWNlQW5pbWF0aW9uUGFuZVZpZXcgPSBuZXcgU2VyaWVzTGFzdFByaWNlQW5pbWF0aW9uUGFuZVZpZXcodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVjcmVhdGVGb3JtYXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVjcmVhdGVQYW5lVmlld3MoY3VzdG9tUGFuZVZpZXcpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2FuaW1hdGlvblRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3ByaXZhdGVfX2FuaW1hdGlvblRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlTGluZUNvbG9yKGxhc3RCYXJDb2xvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5wcmljZUxpbmVDb2xvciB8fCBsYXN0QmFyQ29sb3I7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sYXN0VmFsdWVEYXRhKGdsb2JhbExhc3QpIHtcbiAgICAgICAgY29uc3Qgbm9EYXRhUmVzID0geyBfaW50ZXJuYWxfbm9EYXRhOiB0cnVlIH07XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfaXNFbXB0eSgpIHx8IHByaWNlU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBub0RhdGFSZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlzaWJsZUJhcnMgPSB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfdmlzaWJsZVN0cmljdFJhbmdlKCk7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmICh2aXNpYmxlQmFycyA9PT0gbnVsbCB8fCBmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9EYXRhUmVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmQgcmFuZ2Ugb2YgYmFycyBpbnNpZGUgcmFuZ2VcbiAgICAgICAgLy8gVE9ETzogbWFrZSBpdCBtb3JlIG9wdGltYWxcbiAgICAgICAgbGV0IGJhcjtcbiAgICAgICAgbGV0IGxhc3RJbmRleDtcbiAgICAgICAgaWYgKGdsb2JhbExhc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RCYXIgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9sYXN0KCk7XG4gICAgICAgICAgICBpZiAobGFzdEJhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub0RhdGFSZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYXIgPSBsYXN0QmFyO1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gbGFzdEJhci5faW50ZXJuYWxfaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbmRCYXIgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9zZWFyY2godmlzaWJsZUJhcnMuX2ludGVybmFsX3JpZ2h0KCksIC0xIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5lYXJlc3RMZWZ0ICovKTtcbiAgICAgICAgICAgIGlmIChlbmRCYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9EYXRhUmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFyID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmFsdWVBdChlbmRCYXIuX2ludGVybmFsX2luZGV4KTtcbiAgICAgICAgICAgIGlmIChiYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9EYXRhUmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEluZGV4ID0gZW5kQmFyLl9pbnRlcm5hbF9pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmljZSA9IGJhci5faW50ZXJuYWxfdmFsdWVbMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqL107XG4gICAgICAgIGNvbnN0IGJhckNvbG9yZXIgPSB0aGlzLl9pbnRlcm5hbF9iYXJDb2xvcmVyKCk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gYmFyQ29sb3Jlci5faW50ZXJuYWxfYmFyU3R5bGUobGFzdEluZGV4LCB7IF9pbnRlcm5hbF92YWx1ZTogYmFyIH0pO1xuICAgICAgICBjb25zdCBjb29yZGluYXRlID0gcHJpY2VTY2FsZS5faW50ZXJuYWxfcHJpY2VUb0Nvb3JkaW5hdGUocHJpY2UsIGZpcnN0VmFsdWUuX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ub0RhdGE6IGZhbHNlLFxuICAgICAgICAgICAgX2ludGVybmFsX3ByaWNlOiBwcmljZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90ZXh0OiBwcmljZVNjYWxlLl9pbnRlcm5hbF9mb3JtYXRQcmljZShwcmljZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpLFxuICAgICAgICAgICAgX2ludGVybmFsX2Zvcm1hdHRlZFByaWNlQWJzb2x1dGU6IHByaWNlU2NhbGUuX2ludGVybmFsX2Zvcm1hdFByaWNlQWJzb2x1dGUocHJpY2UpLFxuICAgICAgICAgICAgX2ludGVybmFsX2Zvcm1hdHRlZFByaWNlUGVyY2VudGFnZTogcHJpY2VTY2FsZS5faW50ZXJuYWxfZm9ybWF0UHJpY2VQZXJjZW50YWdlKHByaWNlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSksXG4gICAgICAgICAgICBfaW50ZXJuYWxfY29sb3I6IHN0eWxlLl9pbnRlcm5hbF9iYXJDb2xvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9jb29yZGluYXRlOiBjb29yZGluYXRlLFxuICAgICAgICAgICAgX2ludGVybmFsX2luZGV4OiBsYXN0SW5kZXgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9iYXJDb2xvcmVyKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fYmFyQ29sb3JlckNhY2hlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYmFyQ29sb3JlckNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhckNvbG9yZXJDYWNoZSA9IG5ldyBTZXJpZXNCYXJDb2xvcmVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYmFyQ29sb3JlckNhY2hlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjb25zdCB0YXJnZXRQcmljZVNjYWxlSWQgPSBvcHRpb25zLnByaWNlU2NhbGVJZDtcbiAgICAgICAgaWYgKHRhcmdldFByaWNlU2NhbGVJZCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldFByaWNlU2NhbGVJZCAhPT0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5wcmljZVNjYWxlSWQpIHtcbiAgICAgICAgICAgIC8vIHNlcmllcyBjYW5ub3QgZG8gaXQgaXRzZWxmLCBhc2sgbW9kZWxcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX21vdmVTZXJpZXNUb1NjYWxlKHRoaXMsIHRhcmdldFByaWNlU2NhbGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2UodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLnByaWNlRm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY3JlYXRlRm9ybWF0dGVyKCk7XG4gICAgICAgICAgICAvLyB1cGRhdGVkIGZvcm1hdHRlciBtaWdodCBhZmZlY3QgcmVuZGVyaW5nICBhbmQgYXMgYSBjb25zZXF1ZW5jZSBvZiB0aGlzIHRoZSB3aWR0aCBvZiBwcmljZSBheGlzIG1pZ2h0IGJlIGNoYW5nZWRcbiAgICAgICAgICAgIC8vIHRodXMgd2UgbmVlZCB0byBmb3JjZSB0aGUgY2hhcnQgdG8gZG8gYSBmdWxsIHVwZGF0ZSB0byBhcHBseSBjaGFuZ2VzIGNvcnJlY3RseVxuICAgICAgICAgICAgLy8gZnVsbCB1cGRhdGUgaXMgcXVpdGUgaGVhdnkgb3BlcmF0aW9uIGluIHRlcm1zIG9mIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBidXQgdXBkYXRpbmcgZm9ybWF0dGVyIGxvb2tzIGxpa2UgcXVpdGUgcmFyZSBzbyBmb3JjaW5nIGEgZnVsbCB1cGRhdGUgaGVyZSBzaG91bGRuJ3QgYWZmZWN0IHRoZSBwZXJmb3JtYW5jZSBhIGxvdFxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3VwZGF0ZVNvdXJjZSh0aGlzKTtcbiAgICAgICAgLy8gYSBzZXJpZXMgbWlnaHQgYWZmZWN0IGNyb3NzaGFpciBieSBzb21lIG9wdGlvbnMgKGxpa2UgY3Jvc3NoYWlyIG1hcmtlcnMpXG4gICAgICAgIC8vIHRoYXQncyB3aHkgd2UgbmVlZCB0byB1cGRhdGUgY3Jvc3NoYWlyIGFzIHdlbGxcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdXBkYXRlQ3Jvc3NoYWlyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3Ll9pbnRlcm5hbF91cGRhdGUoJ29wdGlvbnMnKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSwgdXBkYXRlSW5mbykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9zZXREYXRhKGRhdGEpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0ZU1hcmtlcnMoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcuX2ludGVybmFsX3VwZGF0ZSgnZGF0YScpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzUGFuZVZpZXcuX2ludGVybmFsX3VwZGF0ZSgnZGF0YScpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbGFzdFByaWNlQW5pbWF0aW9uUGFuZVZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGVJbmZvICYmIHVwZGF0ZUluZm8uX2ludGVybmFsX2xhc3RCYXJVcGRhdGVkT3JOZXdCYXJzQWRkZWRUb1RoZVJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFzdFByaWNlQW5pbWF0aW9uUGFuZVZpZXcuX2ludGVybmFsX29uTmV3UmVhbHRpbWVEYXRhUmVjZWl2ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFzdFByaWNlQW5pbWF0aW9uUGFuZVZpZXcuX2ludGVybmFsX29uRGF0YUNsZWFyZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VQYW5lID0gdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcGFuZUZvclNvdXJjZSh0aGlzKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcmVjYWxjdWxhdGVQYW5lKHNvdXJjZVBhbmUpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF91cGRhdGVTb3VyY2UodGhpcyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3VwZGF0ZUNyb3NzaGFpcigpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9saWdodFVwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0TWFya2VycyhkYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnMgPSBkYXRhO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0ZU1hcmtlcnMoKTtcbiAgICAgICAgY29uc3Qgc291cmNlUGFuZSA9IHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3BhbmVGb3JTb3VyY2UodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnNQYW5lVmlldy5faW50ZXJuYWxfdXBkYXRlKCdkYXRhJyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3JlY2FsY3VsYXRlUGFuZShzb3VyY2VQYW5lKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdXBkYXRlU291cmNlKHRoaXMpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF91cGRhdGVDcm9zc2hhaXIoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX21hcmtlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tYXJrZXJzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaW5kZXhlZE1hcmtlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19pbmRleGVkTWFya2VycztcbiAgICB9XG4gICAgX2ludGVybmFsX2NyZWF0ZVByaWNlTGluZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBDdXN0b21QcmljZUxpbmUodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2N1c3RvbVByaWNlTGluZXMucHVzaChyZXN1bHQpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF91cGRhdGVTb3VyY2UodGhpcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW1vdmVQcmljZUxpbmUobGluZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3ByaXZhdGVfX2N1c3RvbVByaWNlTGluZXMuaW5kZXhPZihsaW5lKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3VzdG9tUHJpY2VMaW5lcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3VwZGF0ZVNvdXJjZSh0aGlzKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Nlcmllc1R5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZmlyc3RWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgYmFyID0gdGhpcy5faW50ZXJuYWxfZmlyc3RCYXIoKTtcbiAgICAgICAgaWYgKGJhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF92YWx1ZTogYmFyLl9pbnRlcm5hbF92YWx1ZVszIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkNsb3NlICovXSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90aW1lUG9pbnQ6IGJhci5faW50ZXJuYWxfdGltZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2ludGVybmFsX2ZpcnN0QmFyKCkge1xuICAgICAgICBjb25zdCB2aXNpYmxlQmFycyA9IHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF92aXNpYmxlU3RyaWN0UmFuZ2UoKTtcbiAgICAgICAgaWYgKHZpc2libGVCYXJzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFRpbWVQb2ludCA9IHZpc2libGVCYXJzLl9pbnRlcm5hbF9sZWZ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9zZWFyY2goc3RhcnRUaW1lUG9pbnQsIDEgLyogTWlzbWF0Y2hEaXJlY3Rpb24uTmVhcmVzdFJpZ2h0ICovKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2JhcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19kYXRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGF0YUF0KHRpbWUpIHtcbiAgICAgICAgY29uc3QgcHJpY2VzID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmFsdWVBdCh0aW1lKTtcbiAgICAgICAgaWYgKHByaWNlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgPT09ICdCYXInIHx8IHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgPT09ICdDYW5kbGVzdGljaycgfHwgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSA9PT0gJ0N1c3RvbScpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX29wZW46IHByaWNlcy5faW50ZXJuYWxfdmFsdWVbMCAvKiBQbG90Um93VmFsdWVJbmRleC5PcGVuICovXSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfaGlnaDogcHJpY2VzLl9pbnRlcm5hbF92YWx1ZVsxIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkhpZ2ggKi9dLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9sb3c6IHByaWNlcy5faW50ZXJuYWxfdmFsdWVbMiAvKiBQbG90Um93VmFsdWVJbmRleC5Mb3cgKi9dLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9jbG9zZTogcHJpY2VzLl9pbnRlcm5hbF92YWx1ZVszIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkNsb3NlICovXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpY2VzLl9pbnRlcm5hbF92YWx1ZVszIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkNsb3NlICovXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfdG9wUGFuZVZpZXdzKHBhbmUpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGV4dHJhY3RQcmltaXRpdmVQYW5lVmlld3ModGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcywgcHJpbWl0aXZlUGFuZVZpZXdzRXh0cmFjdG9yLCAndG9wJywgcmVzKTtcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uUGFuZVZpZXcgPSB0aGlzLl9wcml2YXRlX19sYXN0UHJpY2VBbmltYXRpb25QYW5lVmlldztcbiAgICAgICAgaWYgKGFuaW1hdGlvblBhbmVWaWV3ID09PSBudWxsIHx8ICFhbmltYXRpb25QYW5lVmlldy5faW50ZXJuYWxfdmlzaWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19hbmltYXRpb25UaW1lb3V0SWQgPT09IG51bGwgJiYgYW5pbWF0aW9uUGFuZVZpZXcuX2ludGVybmFsX2FuaW1hdGlvbkFjdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hbmltYXRpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hbmltYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2N1cnNvclVwZGF0ZSgpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgYW5pbWF0aW9uUGFuZVZpZXcuX2ludGVybmFsX2ludmFsaWRhdGVTdGFnZSgpO1xuICAgICAgICByZXMucHVzaChhbmltYXRpb25QYW5lVmlldyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYW5lVmlld3MoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2lzT3ZlcmxheSgpKSB7XG4gICAgICAgICAgICByZXMucHVzaCh0aGlzLl9wcml2YXRlX19iYXNlSG9yaXpvbnRhbExpbmVWaWV3KTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaCh0aGlzLl9wcml2YXRlX19wYW5lVmlldywgdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lVmlldywgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1BhbmVWaWV3KTtcbiAgICAgICAgY29uc3QgcHJpY2VMaW5lVmlld3MgPSB0aGlzLl9wcml2YXRlX19jdXN0b21QcmljZUxpbmVzLm1hcCgobGluZSkgPT4gbGluZS5faW50ZXJuYWxfcGFuZVZpZXcoKSk7XG4gICAgICAgIHJlcy5wdXNoKC4uLnByaWNlTGluZVZpZXdzKTtcbiAgICAgICAgZXh0cmFjdFByaW1pdGl2ZVBhbmVWaWV3cyh0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzLCBwcmltaXRpdmVQYW5lVmlld3NFeHRyYWN0b3IsICdub3JtYWwnLCByZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYm90dG9tUGFuZVZpZXdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZXh0cmFjdFBhbmVWaWV3cyhwcmltaXRpdmVQYW5lVmlld3NFeHRyYWN0b3IsICdib3R0b20nKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlUGFuZVZpZXdzKHpPcmRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZXh0cmFjdFBhbmVWaWV3cyhwcmltaXRpdmVQcmljZVBhbmVWaWV3c0V4dHJhY3Rvciwgek9yZGVyKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3RpbWVQYW5lVmlld3Moek9yZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19leHRyYWN0UGFuZVZpZXdzKHByaW1pdGl2ZVRpbWVQYW5lVmlld3NFeHRyYWN0b3IsIHpPcmRlcik7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmltaXRpdmVIaXRUZXN0KHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZXNcbiAgICAgICAgICAgIC5tYXAoKHByaW1pdGl2ZSkgPT4gcHJpbWl0aXZlLl9pbnRlcm5hbF9oaXRUZXN0KHgsIHkpKVxuICAgICAgICAgICAgLmZpbHRlcigocmVzdWx0KSA9PiByZXN1bHQgIT09IG51bGwpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbGFiZWxQYW5lVmlld3MocGFuZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVByaWNlQXhpc1ZpZXcsXG4gICAgICAgICAgICAuLi50aGlzLl9wcml2YXRlX19jdXN0b21QcmljZUxpbmVzLm1hcCgobGluZSkgPT4gbGluZS5faW50ZXJuYWxfbGFiZWxQYW5lVmlldygpKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlQXhpc1ZpZXdzKHBhbmUsIHByaWNlU2NhbGUpIHtcbiAgICAgICAgaWYgKHByaWNlU2NhbGUgIT09IHRoaXMuX2ludGVybmFsX19wcmljZVNjYWxlICYmICF0aGlzLl9wcml2YXRlX19pc092ZXJsYXkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi50aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3c107XG4gICAgICAgIGZvciAoY29uc3QgY3VzdG9tUHJpY2VMaW5lIG9mIHRoaXMuX3ByaXZhdGVfX2N1c3RvbVByaWNlTGluZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1c3RvbVByaWNlTGluZS5faW50ZXJuYWxfcHJpY2VBeGlzVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzLmZvckVhY2goKHdyYXBwZXIpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLndyYXBwZXIuX2ludGVybmFsX3ByaWNlQXhpc1ZpZXdzKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX2ludGVybmFsX3RpbWVBeGlzVmlld3MoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzLmZvckVhY2goKHdyYXBwZXIpID0+IHtcbiAgICAgICAgICAgIHJlcy5wdXNoKC4uLndyYXBwZXIuX2ludGVybmFsX3RpbWVBeGlzVmlld3MoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXV0b3NjYWxlSW5mbyhzdGFydFRpbWVQb2ludCwgZW5kVGltZVBvaW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19vcHRpb25zLmF1dG9zY2FsZUluZm9Qcm92aWRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBhdXRvc2NhbGVJbmZvID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5hdXRvc2NhbGVJbmZvUHJvdmlkZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuX3ByaXZhdGVfX2F1dG9zY2FsZUluZm9JbXBsKHN0YXJ0VGltZVBvaW50LCBlbmRUaW1lUG9pbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAocmVzID09PSBudWxsKSA/IG51bGwgOiByZXMuX2ludGVybmFsX3RvUmF3KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBBdXRvc2NhbGVJbmZvSW1wbC5faW50ZXJuYWxfZnJvbVJhdyhhdXRvc2NhbGVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYXV0b3NjYWxlSW5mb0ltcGwoc3RhcnRUaW1lUG9pbnQsIGVuZFRpbWVQb2ludCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9taW5Nb3ZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5wcmljZUZvcm1hdC5taW5Nb3ZlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzUGFuZVZpZXcuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IHByaWNlQXhpc1ZpZXcgb2YgdGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzVmlld3MpIHtcbiAgICAgICAgICAgIHByaWNlQXhpc1ZpZXcuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY3VzdG9tUHJpY2VMaW5lIG9mIHRoaXMuX3ByaXZhdGVfX2N1c3RvbVByaWNlTGluZXMpIHtcbiAgICAgICAgICAgIGN1c3RvbVByaWNlTGluZS5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lVmlldy5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VIb3Jpem9udGFsTGluZVZpZXcuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICAoX2EgPSB0aGlzLl9wcml2YXRlX19sYXN0UHJpY2VBbmltYXRpb25QYW5lVmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcy5mb3JFYWNoKCh3cmFwcGVyKSA9PiB3cmFwcGVyLl9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cygpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVOb3ROdWxsKHN1cGVyLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbWFya2VyRGF0YUF0SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgZ2V0VmFsdWUgPSAodGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSA9PT0gJ0xpbmUnIHx8IHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgPT09ICdBcmVhJyB8fCB0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlID09PSAnQmFzZWxpbmUnKSAmJlxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5jcm9zc2hhaXJNYXJrZXJWaXNpYmxlO1xuICAgICAgICBpZiAoIWdldFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXIgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92YWx1ZUF0KGluZGV4KTtcbiAgICAgICAgaWYgKGJhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpY2UgPSBiYXIuX2ludGVybmFsX3ZhbHVlWzMgLyogUGxvdFJvd1ZhbHVlSW5kZXguQ2xvc2UgKi9dO1xuICAgICAgICBjb25zdCByYWRpdXMgPSB0aGlzLl9wcml2YXRlX19tYXJrZXJSYWRpdXMoKTtcbiAgICAgICAgY29uc3QgYm9yZGVyQ29sb3IgPSB0aGlzLl9wcml2YXRlX19tYXJrZXJCb3JkZXJDb2xvcigpO1xuICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IHRoaXMuX3ByaXZhdGVfX21hcmtlckJvcmRlcldpZHRoKCk7XG4gICAgICAgIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IHRoaXMuX3ByaXZhdGVfX21hcmtlckJhY2tncm91bmRDb2xvcihpbmRleCk7XG4gICAgICAgIHJldHVybiB7IF9pbnRlcm5hbF9wcmljZTogcHJpY2UsIF9pbnRlcm5hbF9yYWRpdXM6IHJhZGl1cywgX2ludGVybmFsX2JvcmRlckNvbG9yOiBib3JkZXJDb2xvciwgX2ludGVybmFsX2JvcmRlcldpZHRoOiBib3JkZXJXaWR0aCwgX2ludGVybmFsX2JhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudGl0bGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF92aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy52aXNpYmxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXR0YWNoUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzLnB1c2gobmV3IFNlcmllc1ByaW1pdGl2ZVdyYXBwZXIocHJpbWl0aXZlLCB0aGlzKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXRhY2hQcmltaXRpdmUoc291cmNlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZXMgPSB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzLmZpbHRlcigod3JhcHBlcikgPT4gd3JhcHBlci5faW50ZXJuYWxfcHJpbWl0aXZlKCkgIT09IHNvdXJjZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jdXN0b21TZXJpZXNQbG90VmFsdWVzQnVpbGRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3IGluc3RhbmNlb2YgU2VyaWVzQ3VzdG9tUGFuZVZpZXcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3Ll9pbnRlcm5hbF9wcmljZVZhbHVlQnVpbGRlcihkYXRhKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2ludGVybmFsX2N1c3RvbVNlcmllc1doaXRlc3BhY2VDaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3IGluc3RhbmNlb2YgU2VyaWVzQ3VzdG9tUGFuZVZpZXcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3Ll9pbnRlcm5hbF9pc1doaXRlc3BhY2UoZGF0YSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9wcml2YXRlX19pc092ZXJsYXkoKSB7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgIHJldHVybiAhaXNEZWZhdWx0UHJpY2VTY2FsZShwcmljZVNjYWxlLl9pbnRlcm5hbF9pZCgpKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2F1dG9zY2FsZUluZm9JbXBsKHN0YXJ0VGltZVBvaW50LCBlbmRUaW1lUG9pbnQpIHtcbiAgICAgICAgaWYgKCFpc0ludGVnZXIoc3RhcnRUaW1lUG9pbnQpIHx8ICFpc0ludGVnZXIoZW5kVGltZVBvaW50KSB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRoaXNcbiAgICAgICAgLy8gc2VyaWVzIGRhdGEgaXMgc3Ryb25nbHkgaGFyZGNvZGVkIHRvIGtlZXAgYmFyc1xuICAgICAgICBjb25zdCBwbG90cyA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgPT09ICdMaW5lJyB8fCB0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlID09PSAnQXJlYScgfHwgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSA9PT0gJ0Jhc2VsaW5lJyB8fCB0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlID09PSAnSGlzdG9ncmFtJ1xuICAgICAgICAgICAgPyBbMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqL11cbiAgICAgICAgICAgIDogWzIgLyogUGxvdFJvd1ZhbHVlSW5kZXguTG93ICovLCAxIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkhpZ2ggKi9dO1xuICAgICAgICBjb25zdCBiYXJzTWluTWF4ID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfbWluTWF4T25SYW5nZUNhY2hlZChzdGFydFRpbWVQb2ludCwgZW5kVGltZVBvaW50LCBwbG90cyk7XG4gICAgICAgIGxldCByYW5nZSA9IGJhcnNNaW5NYXggIT09IG51bGwgPyBuZXcgUHJpY2VSYW5nZUltcGwoYmFyc01pbk1heC5faW50ZXJuYWxfbWluLCBiYXJzTWluTWF4Ll9pbnRlcm5hbF9tYXgpIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX3Nlcmllc1R5cGUoKSA9PT0gJ0hpc3RvZ3JhbScpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLmJhc2U7XG4gICAgICAgICAgICBjb25zdCByYW5nZVdpdGhCYXNlID0gbmV3IFByaWNlUmFuZ2VJbXBsKGJhc2UsIGJhc2UpO1xuICAgICAgICAgICAgcmFuZ2UgPSByYW5nZSAhPT0gbnVsbCA/IHJhbmdlLl9pbnRlcm5hbF9tZXJnZShyYW5nZVdpdGhCYXNlKSA6IHJhbmdlV2l0aEJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hcmdpbnMgPSB0aGlzLl9wcml2YXRlX19tYXJrZXJzUGFuZVZpZXcuX2ludGVybmFsX2F1dG9TY2FsZU1hcmdpbnMoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcy5mb3JFYWNoKChwcmltaXRpdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByaW1pdGl2ZUF1dG9zY2FsZSA9IHByaW1pdGl2ZS5faW50ZXJuYWxfYXV0b3NjYWxlSW5mbyhzdGFydFRpbWVQb2ludCwgZW5kVGltZVBvaW50KTtcbiAgICAgICAgICAgIGlmIChwcmltaXRpdmVBdXRvc2NhbGUgPT09IG51bGwgfHwgcHJpbWl0aXZlQXV0b3NjYWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmltaXRpdmVBdXRvc2NhbGUucHJpY2VSYW5nZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaW1pdGl2ZVJhbmdlID0gbmV3IFByaWNlUmFuZ2VJbXBsKHByaW1pdGl2ZUF1dG9zY2FsZS5wcmljZVJhbmdlLm1pblZhbHVlLCBwcmltaXRpdmVBdXRvc2NhbGUucHJpY2VSYW5nZS5tYXhWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSByYW5nZSAhPT0gbnVsbCA/IHJhbmdlLl9pbnRlcm5hbF9tZXJnZShwcmltaXRpdmVSYW5nZSkgOiBwcmltaXRpdmVSYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmltaXRpdmVBdXRvc2NhbGUgPT09IG51bGwgfHwgcHJpbWl0aXZlQXV0b3NjYWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmltaXRpdmVBdXRvc2NhbGUubWFyZ2lucykge1xuICAgICAgICAgICAgICAgIG1hcmdpbnMgPSBtZXJnZU1hcmdpbnMobWFyZ2lucywgcHJpbWl0aXZlQXV0b3NjYWxlLm1hcmdpbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRvc2NhbGVJbmZvSW1wbChyYW5nZSwgbWFyZ2lucyk7XG4gICAgfVxuICAgIF9wcml2YXRlX19tYXJrZXJSYWRpdXMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnTGluZSc6XG4gICAgICAgICAgICBjYXNlICdBcmVhJzpcbiAgICAgICAgICAgIGNhc2UgJ0Jhc2VsaW5lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5jcm9zc2hhaXJNYXJrZXJSYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIF9wcml2YXRlX19tYXJrZXJCb3JkZXJDb2xvcigpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdMaW5lJzpcbiAgICAgICAgICAgIGNhc2UgJ0FyZWEnOlxuICAgICAgICAgICAgY2FzZSAnQmFzZWxpbmUnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3Jvc3NoYWlyTWFya2VyQm9yZGVyQ29sb3IgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLmNyb3NzaGFpck1hcmtlckJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgIGlmIChjcm9zc2hhaXJNYXJrZXJCb3JkZXJDb2xvci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzaGFpck1hcmtlckJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21hcmtlckJvcmRlcldpZHRoKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0xpbmUnOlxuICAgICAgICAgICAgY2FzZSAnQXJlYSc6XG4gICAgICAgICAgICBjYXNlICdCYXNlbGluZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuY3Jvc3NoYWlyTWFya2VyQm9yZGVyV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIF9wcml2YXRlX19tYXJrZXJCYWNrZ3JvdW5kQ29sb3IoaW5kZXgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdMaW5lJzpcbiAgICAgICAgICAgIGNhc2UgJ0FyZWEnOlxuICAgICAgICAgICAgY2FzZSAnQmFzZWxpbmUnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3Jvc3NoYWlyTWFya2VyQmFja2dyb3VuZENvbG9yID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5jcm9zc2hhaXJNYXJrZXJCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgaWYgKGNyb3NzaGFpck1hcmtlckJhY2tncm91bmRDb2xvci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzaGFpck1hcmtlckJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX2JhckNvbG9yZXIoKS5faW50ZXJuYWxfYmFyU3R5bGUoaW5kZXgpLl9pbnRlcm5hbF9iYXJDb2xvcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3JlY3JlYXRlRm9ybWF0dGVyKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucHJpY2VGb3JtYXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY3VzdG9tJzoge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlciA9IHsgZm9ybWF0OiB0aGlzLl9wcml2YXRlX19vcHRpb25zLnByaWNlRm9ybWF0LmZvcm1hdHRlciB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAndm9sdW1lJzoge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlciA9IG5ldyBWb2x1bWVGb3JtYXR0ZXIodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5wcmljZUZvcm1hdC5wcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncGVyY2VudCc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXIgPSBuZXcgUGVyY2VudGFnZUZvcm1hdHRlcih0aGlzLl9wcml2YXRlX19vcHRpb25zLnByaWNlRm9ybWF0LnByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IE1hdGgucG93KDEwLCB0aGlzLl9wcml2YXRlX19vcHRpb25zLnByaWNlRm9ybWF0LnByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyID0gbmV3IFByaWNlRm9ybWF0dGVyKHByaWNlU2NhbGUsIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucHJpY2VGb3JtYXQubWluTW92ZSAqIHByaWNlU2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9fcHJpY2VTY2FsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfX3ByaWNlU2NhbGUuX2ludGVybmFsX3VwZGF0ZUZvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19yZWNhbGN1bGF0ZU1hcmtlcnMoKSB7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3RpbWVTY2FsZSgpO1xuICAgICAgICBpZiAoIXRpbWVTY2FsZS5faW50ZXJuYWxfaGFzUG9pbnRzKCkgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbmRleGVkTWFya2VycyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0RGF0YUluZGV4ID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9maXJzdEluZGV4KCkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbmRleGVkTWFya2VycyA9IHRoaXMuX3ByaXZhdGVfX21hcmtlcnMubWFwKChtYXJrZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgZmluZCBpbmRleCBvbiB0aGUgdGltZSBzY2FsZSAoYWNyb3NzIGFsbCBzZXJpZXMpXG4gICAgICAgICAgICBjb25zdCB0aW1lUG9pbnRJbmRleCA9IGVuc3VyZU5vdE51bGwodGltZVNjYWxlLl9pbnRlcm5hbF90aW1lVG9JbmRleChtYXJrZXIudGltZSwgdHJ1ZSkpO1xuICAgICAgICAgICAgLy8gYW5kIHRoZW4gc2VhcmNoIHRoYXQgaW5kZXggaW5zaWRlIHRoZSBzZXJpZXMgZGF0YVxuICAgICAgICAgICAgY29uc3Qgc2VhcmNoTW9kZSA9IHRpbWVQb2ludEluZGV4IDwgZmlyc3REYXRhSW5kZXggPyAxIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5lYXJlc3RSaWdodCAqLyA6IC0xIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5lYXJlc3RMZWZ0ICovO1xuICAgICAgICAgICAgY29uc3Qgc2VyaWVzRGF0YUluZGV4ID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9zZWFyY2godGltZVBvaW50SW5kZXgsIHNlYXJjaE1vZGUpKS5faW50ZXJuYWxfaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRpbWU6IHNlcmllc0RhdGFJbmRleCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogbWFya2VyLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHNoYXBlOiBtYXJrZXIuc2hhcGUsXG4gICAgICAgICAgICAgICAgY29sb3I6IG1hcmtlci5jb2xvcixcbiAgICAgICAgICAgICAgICBpZDogbWFya2VyLmlkLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9pbnRlcm5hbElkOiBpbmRleCxcbiAgICAgICAgICAgICAgICB0ZXh0OiBtYXJrZXIudGV4dCxcbiAgICAgICAgICAgICAgICBzaXplOiBtYXJrZXIuc2l6ZSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFRpbWU6IG1hcmtlci5vcmlnaW5hbFRpbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3JlY3JlYXRlUGFuZVZpZXdzKGN1c3RvbVBhbmVWaWV3KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnNQYW5lVmlldyA9IG5ldyBTZXJpZXNNYXJrZXJzUGFuZVZpZXcodGhpcywgdGhpcy5faW50ZXJuYWxfbW9kZWwoKSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnQmFyJzoge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3ID0gbmV3IFNlcmllc0JhcnNQYW5lVmlldyh0aGlzLCB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0NhbmRsZXN0aWNrJzoge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3ID0gbmV3IFNlcmllc0NhbmRsZXN0aWNrc1BhbmVWaWV3KHRoaXMsIHRoaXMuX2ludGVybmFsX21vZGVsKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnTGluZSc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlldyA9IG5ldyBTZXJpZXNMaW5lUGFuZVZpZXcodGhpcywgdGhpcy5faW50ZXJuYWxfbW9kZWwoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdDdXN0b20nOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcgPSBuZXcgU2VyaWVzQ3VzdG9tUGFuZVZpZXcodGhpcywgdGhpcy5faW50ZXJuYWxfbW9kZWwoKSwgZW5zdXJlRGVmaW5lZChjdXN0b21QYW5lVmlldykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQXJlYSc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlldyA9IG5ldyBTZXJpZXNBcmVhUGFuZVZpZXcodGhpcywgdGhpcy5faW50ZXJuYWxfbW9kZWwoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdCYXNlbGluZSc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlldyA9IG5ldyBTZXJpZXNCYXNlbGluZVBhbmVWaWV3KHRoaXMsIHRoaXMuX2ludGVybmFsX21vZGVsKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnSGlzdG9ncmFtJzoge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3ID0gbmV3IFNlcmllc0hpc3RvZ3JhbVBhbmVWaWV3KHRoaXMsIHRoaXMuX2ludGVybmFsX21vZGVsKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgRXJyb3IoJ1Vua25vd24gY2hhcnQgc3R5bGUgYXNzaWduZWQ6ICcgKyB0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZXh0cmFjdFBhbmVWaWV3cyhleHRyYWN0b3IsIHpPcmRlcikge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZXh0cmFjdFByaW1pdGl2ZVBhbmVWaWV3cyh0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzLCBleHRyYWN0b3IsIHpPcmRlciwgcmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZU1hcmdpbnMoc291cmNlLCBhZGRpdGlvbmFsTWFyZ2luKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4ge1xuICAgICAgICBhYm92ZTogTWF0aC5tYXgoKF9hID0gc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlLmFib3ZlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLCBhZGRpdGlvbmFsTWFyZ2luLmFib3ZlKSxcbiAgICAgICAgYmVsb3c6IE1hdGgubWF4KChfYiA9IHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZS5iZWxvdykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCwgYWRkaXRpb25hbE1hcmdpbi5iZWxvdyksXG4gICAgfTtcbn1cblxuY2xhc3MgTWFnbmV0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYWxpZ24ocHJpY2UsIGluZGV4LCBwYW5lKSB7XG4gICAgICAgIGxldCByZXMgPSBwcmljZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubW9kZSA9PT0gMCAvKiBDcm9zc2hhaXJNb2RlLk5vcm1hbCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0UHJpY2VTY2FsZSA9IHBhbmUuX2ludGVybmFsX2RlZmF1bHRQcmljZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBkZWZhdWx0UHJpY2VTY2FsZS5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICBpZiAoZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB5ID0gZGVmYXVsdFByaWNlU2NhbGUuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKHByaWNlLCBmaXJzdFZhbHVlKTtcbiAgICAgICAgLy8gZ2V0IGFsbCBzZXJpZXNlcyBmcm9tIHRoZSBwYW5lXG4gICAgICAgIGNvbnN0IHNlcmllc2VzID0gcGFuZS5faW50ZXJuYWxfZGF0YVNvdXJjZXMoKS5maWx0ZXIoKChkcykgPT4gKGRzIGluc3RhbmNlb2YgKFNlcmllcykpKSk7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBzZXJpZXNlcy5yZWR1Y2UoKGFjYywgc2VyaWVzKSA9PiB7XG4gICAgICAgICAgICBpZiAocGFuZS5faW50ZXJuYWxfaXNPdmVybGF5KHNlcmllcykgfHwgIXNlcmllcy5faW50ZXJuYWxfdmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBzID0gc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgICAgICBjb25zdCBiYXJzID0gc2VyaWVzLl9pbnRlcm5hbF9iYXJzKCk7XG4gICAgICAgICAgICBpZiAocHMuX2ludGVybmFsX2lzRW1wdHkoKSB8fCAhYmFycy5faW50ZXJuYWxfY29udGFpbnMoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJhciA9IGJhcnMuX2ludGVybmFsX3ZhbHVlQXQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGJhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGJhciB0byBwaXhlbHNcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UHJpY2UgPSBlbnN1cmUoc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQoW3BzLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZShiYXIuX2ludGVybmFsX3ZhbHVlWzMgLyogUGxvdFJvd1ZhbHVlSW5kZXguQ2xvc2UgKi9dLCBmaXJzdFByaWNlLl9pbnRlcm5hbF92YWx1ZSldKTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2FuZGlkYXRlcy5zb3J0KCh5MSwgeTIpID0+IE1hdGguYWJzKHkxIC0geSkgLSBNYXRoLmFicyh5MiAtIHkpKTtcbiAgICAgICAgY29uc3QgbmVhcmVzdCA9IGNhbmRpZGF0ZXNbMF07XG4gICAgICAgIHJlcyA9IGRlZmF1bHRQcmljZVNjYWxlLl9pbnRlcm5hbF9jb29yZGluYXRlVG9QcmljZShuZWFyZXN0LCBmaXJzdFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5cbmNsYXNzIEdyaWRSZW5kZXJlciBleHRlbmRzIEJpdG1hcENvb3JkaW5hdGVzUGFuZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZHJhd0ltcGwoeyBjb250ZXh0OiBjdHgsIGJpdG1hcFNpemUsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8pKTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgc3Ryb2tlSW5QaXhlbChjdHgsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2RhdGEpO1xuICAgICAgICAgICAgaWYgKGRhdGEuX2ludGVybmFsX3ZlcnRMaW5lc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBkYXRhLl9pbnRlcm5hbF92ZXJ0TGluZXNDb2xvcjtcbiAgICAgICAgICAgICAgICBzZXRMaW5lU3R5bGUoY3R4LCBkYXRhLl9pbnRlcm5hbF92ZXJ0TGluZVN0eWxlKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0aW1lTWFyayBvZiBkYXRhLl9pbnRlcm5hbF90aW1lTWFya3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQodGltZU1hcmsuX2ludGVybmFsX2Nvb3JkICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIC1saW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIGJpdG1hcFNpemUuaGVpZ2h0ICsgbGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuX2ludGVybmFsX2hvcnpMaW5lc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBkYXRhLl9pbnRlcm5hbF9ob3J6TGluZXNDb2xvcjtcbiAgICAgICAgICAgICAgICBzZXRMaW5lU3R5bGUoY3R4LCBkYXRhLl9pbnRlcm5hbF9ob3J6TGluZVN0eWxlKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcmljZU1hcmsgb2YgZGF0YS5faW50ZXJuYWxfcHJpY2VNYXJrcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZChwcmljZU1hcmsuX2ludGVybmFsX2Nvb3JkICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbygtbGluZVdpZHRoLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhiaXRtYXBTaXplLndpZHRoICsgbGluZVdpZHRoLCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIEdyaWRQYW5lVmlldyB7XG4gICAgY29uc3RydWN0b3IocGFuZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlciA9IG5ldyBHcmlkUmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lID0gcGFuZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVuZGVyZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgY29uc3QgZ3JpZE9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9vcHRpb25zKCkuZ3JpZDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2hvcnpMaW5lc1Zpc2libGU6IGdyaWRPcHRpb25zLmhvcnpMaW5lcy52aXNpYmxlLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF92ZXJ0TGluZXNWaXNpYmxlOiBncmlkT3B0aW9ucy52ZXJ0TGluZXMudmlzaWJsZSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfaG9yekxpbmVzQ29sb3I6IGdyaWRPcHRpb25zLmhvcnpMaW5lcy5jb2xvcixcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdmVydExpbmVzQ29sb3I6IGdyaWRPcHRpb25zLnZlcnRMaW5lcy5jb2xvcixcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfaG9yekxpbmVTdHlsZTogZ3JpZE9wdGlvbnMuaG9yekxpbmVzLnN0eWxlLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF92ZXJ0TGluZVN0eWxlOiBncmlkT3B0aW9ucy52ZXJ0TGluZXMuc3R5bGUsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3ByaWNlTWFya3M6IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2RlZmF1bHRQcmljZVNjYWxlKCkuX2ludGVybmFsX21hcmtzKCksXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0aGlzIGNvbnZlcnNpb20gYmVjYXVzZSBUaW1lTWFyayBpcyBhIHBhcnQgb2YgZXh0ZXJuYWwgaW50ZXJmYWNlXG4gICAgICAgICAgICAgICAgLy8gYW5kIGZpZWxkcyBpbnNpZGUgVGltZU1hcmsgYXJlIG5vdCBtaW5pZmllZFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90aW1lTWFya3M6ICh0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfbWFya3MoKSB8fCBbXSkubWFwKCh0bSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBfaW50ZXJuYWxfY29vcmQ6IHRtLmNvb3JkIH07XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEoZGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yZW5kZXJlcjtcbiAgICB9XG59XG5cbmNsYXNzIEdyaWQge1xuICAgIGNvbnN0cnVjdG9yKHBhbmUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcgPSBuZXcgR3JpZFBhbmVWaWV3KHBhbmUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFuZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lVmlldztcbiAgICB9XG59XG5cbmNvbnN0IGRlZkxvZ0Zvcm11bGEgPSB7XG4gICAgX2ludGVybmFsX2xvZ2ljYWxPZmZzZXQ6IDQsXG4gICAgX2ludGVybmFsX2Nvb3JkT2Zmc2V0OiAwLjAwMDEsXG59O1xuZnVuY3Rpb24gZnJvbVBlcmNlbnQodmFsdWUsIGJhc2VWYWx1ZSkge1xuICAgIGlmIChiYXNlVmFsdWUgPCAwKSB7XG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gKHZhbHVlIC8gMTAwKSAqIGJhc2VWYWx1ZSArIGJhc2VWYWx1ZTtcbn1cbmZ1bmN0aW9uIHRvUGVyY2VudCh2YWx1ZSwgYmFzZVZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gMTAwICogKHZhbHVlIC0gYmFzZVZhbHVlKSAvIGJhc2VWYWx1ZTtcbiAgICByZXR1cm4gKGJhc2VWYWx1ZSA8IDAgPyAtcmVzdWx0IDogcmVzdWx0KTtcbn1cbmZ1bmN0aW9uIHRvUGVyY2VudFJhbmdlKHByaWNlUmFuZ2UsIGJhc2VWYWx1ZSkge1xuICAgIGNvbnN0IG1pblBlcmNlbnQgPSB0b1BlcmNlbnQocHJpY2VSYW5nZS5faW50ZXJuYWxfbWluVmFsdWUoKSwgYmFzZVZhbHVlKTtcbiAgICBjb25zdCBtYXhQZXJjZW50ID0gdG9QZXJjZW50KHByaWNlUmFuZ2UuX2ludGVybmFsX21heFZhbHVlKCksIGJhc2VWYWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBQcmljZVJhbmdlSW1wbChtaW5QZXJjZW50LCBtYXhQZXJjZW50KTtcbn1cbmZ1bmN0aW9uIGZyb21JbmRleGVkVG8xMDAodmFsdWUsIGJhc2VWYWx1ZSkge1xuICAgIHZhbHVlIC09IDEwMDtcbiAgICBpZiAoYmFzZVZhbHVlIDwgMCkge1xuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuICh2YWx1ZSAvIDEwMCkgKiBiYXNlVmFsdWUgKyBiYXNlVmFsdWU7XG59XG5mdW5jdGlvbiB0b0luZGV4ZWRUbzEwMCh2YWx1ZSwgYmFzZVZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gMTAwICogKHZhbHVlIC0gYmFzZVZhbHVlKSAvIGJhc2VWYWx1ZSArIDEwMDtcbiAgICByZXR1cm4gKGJhc2VWYWx1ZSA8IDAgPyAtcmVzdWx0IDogcmVzdWx0KTtcbn1cbmZ1bmN0aW9uIHRvSW5kZXhlZFRvMTAwUmFuZ2UocHJpY2VSYW5nZSwgYmFzZVZhbHVlKSB7XG4gICAgY29uc3QgbWluUGVyY2VudCA9IHRvSW5kZXhlZFRvMTAwKHByaWNlUmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCksIGJhc2VWYWx1ZSk7XG4gICAgY29uc3QgbWF4UGVyY2VudCA9IHRvSW5kZXhlZFRvMTAwKHByaWNlUmFuZ2UuX2ludGVybmFsX21heFZhbHVlKCksIGJhc2VWYWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBQcmljZVJhbmdlSW1wbChtaW5QZXJjZW50LCBtYXhQZXJjZW50KTtcbn1cbmZ1bmN0aW9uIHRvTG9nKHByaWNlLCBsb2dGb3JtdWxhKSB7XG4gICAgY29uc3QgbSA9IE1hdGguYWJzKHByaWNlKTtcbiAgICBpZiAobSA8IDFlLTE1KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBNYXRoLmxvZzEwKG0gKyBsb2dGb3JtdWxhLl9pbnRlcm5hbF9jb29yZE9mZnNldCkgKyBsb2dGb3JtdWxhLl9pbnRlcm5hbF9sb2dpY2FsT2Zmc2V0O1xuICAgIHJldHVybiAoKHByaWNlIDwgMCkgPyAtcmVzIDogcmVzKTtcbn1cbmZ1bmN0aW9uIGZyb21Mb2cobG9naWNhbCwgbG9nRm9ybXVsYSkge1xuICAgIGNvbnN0IG0gPSBNYXRoLmFicyhsb2dpY2FsKTtcbiAgICBpZiAobSA8IDFlLTE1KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBNYXRoLnBvdygxMCwgbSAtIGxvZ0Zvcm11bGEuX2ludGVybmFsX2xvZ2ljYWxPZmZzZXQpIC0gbG9nRm9ybXVsYS5faW50ZXJuYWxfY29vcmRPZmZzZXQ7XG4gICAgcmV0dXJuIChsb2dpY2FsIDwgMCkgPyAtcmVzIDogcmVzO1xufVxuZnVuY3Rpb24gY29udmVydFByaWNlUmFuZ2VUb0xvZyhwcmljZVJhbmdlLCBsb2dGb3JtdWxhKSB7XG4gICAgaWYgKHByaWNlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1pbiA9IHRvTG9nKHByaWNlUmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCksIGxvZ0Zvcm11bGEpO1xuICAgIGNvbnN0IG1heCA9IHRvTG9nKHByaWNlUmFuZ2UuX2ludGVybmFsX21heFZhbHVlKCksIGxvZ0Zvcm11bGEpO1xuICAgIHJldHVybiBuZXcgUHJpY2VSYW5nZUltcGwobWluLCBtYXgpO1xufVxuZnVuY3Rpb24gY2FuQ29udmVydFByaWNlUmFuZ2VGcm9tTG9nKHByaWNlUmFuZ2UsIGxvZ0Zvcm11bGEpIHtcbiAgICBpZiAocHJpY2VSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1pbiA9IGZyb21Mb2cocHJpY2VSYW5nZS5faW50ZXJuYWxfbWluVmFsdWUoKSwgbG9nRm9ybXVsYSk7XG4gICAgY29uc3QgbWF4ID0gZnJvbUxvZyhwcmljZVJhbmdlLl9pbnRlcm5hbF9tYXhWYWx1ZSgpLCBsb2dGb3JtdWxhKTtcbiAgICByZXR1cm4gaXNGaW5pdGUobWluKSAmJiBpc0Zpbml0ZShtYXgpO1xufVxuZnVuY3Rpb24gY29udmVydFByaWNlUmFuZ2VGcm9tTG9nKHByaWNlUmFuZ2UsIGxvZ0Zvcm11bGEpIHtcbiAgICBpZiAocHJpY2VSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbWluID0gZnJvbUxvZyhwcmljZVJhbmdlLl9pbnRlcm5hbF9taW5WYWx1ZSgpLCBsb2dGb3JtdWxhKTtcbiAgICBjb25zdCBtYXggPSBmcm9tTG9nKHByaWNlUmFuZ2UuX2ludGVybmFsX21heFZhbHVlKCksIGxvZ0Zvcm11bGEpO1xuICAgIHJldHVybiBuZXcgUHJpY2VSYW5nZUltcGwobWluLCBtYXgpO1xufVxuZnVuY3Rpb24gbG9nRm9ybXVsYUZvclByaWNlUmFuZ2UocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRlZkxvZ0Zvcm11bGE7XG4gICAgfVxuICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhyYW5nZS5faW50ZXJuYWxfbWF4VmFsdWUoKSAtIHJhbmdlLl9pbnRlcm5hbF9taW5WYWx1ZSgpKTtcbiAgICBpZiAoZGlmZiA+PSAxIHx8IGRpZmYgPCAxZS0xNSkge1xuICAgICAgICByZXR1cm4gZGVmTG9nRm9ybXVsYTtcbiAgICB9XG4gICAgY29uc3QgZGlnaXRzID0gTWF0aC5jZWlsKE1hdGguYWJzKE1hdGgubG9nMTAoZGlmZikpKTtcbiAgICBjb25zdCBsb2dpY2FsT2Zmc2V0ID0gZGVmTG9nRm9ybXVsYS5faW50ZXJuYWxfbG9naWNhbE9mZnNldCArIGRpZ2l0cztcbiAgICBjb25zdCBjb29yZE9mZnNldCA9IDEgLyBNYXRoLnBvdygxMCwgbG9naWNhbE9mZnNldCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2ludGVybmFsX2xvZ2ljYWxPZmZzZXQ6IGxvZ2ljYWxPZmZzZXQsXG4gICAgICAgIF9pbnRlcm5hbF9jb29yZE9mZnNldDogY29vcmRPZmZzZXQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxvZ0Zvcm11bGFzQXJlU2FtZShmMSwgZjIpIHtcbiAgICByZXR1cm4gZjEuX2ludGVybmFsX2xvZ2ljYWxPZmZzZXQgPT09IGYyLl9pbnRlcm5hbF9sb2dpY2FsT2Zmc2V0ICYmIGYxLl9pbnRlcm5hbF9jb29yZE9mZnNldCA9PT0gZjIuX2ludGVybmFsX2Nvb3JkT2Zmc2V0O1xufVxuXG5jbGFzcyBQcmljZVRpY2tTcGFuQ2FsY3VsYXRvciB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgaW50ZWdyYWxEaXZpZGVycykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW50ZWdyYWxEaXZpZGVycyA9IGludGVncmFsRGl2aWRlcnM7XG4gICAgICAgIGlmIChpc0Jhc2VEZWNpbWFsKHRoaXMuX3ByaXZhdGVfX2Jhc2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19mcmFjdGlvbmFsRGl2aWRlcnMgPSBbMiwgMi41LCAyXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZyYWN0aW9uYWxEaXZpZGVycyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgYmFzZVJlc3QgPSB0aGlzLl9wcml2YXRlX19iYXNlOyBiYXNlUmVzdCAhPT0gMTspIHtcbiAgICAgICAgICAgICAgICBpZiAoKGJhc2VSZXN0ICUgMikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZnJhY3Rpb25hbERpdmlkZXJzLnB1c2goMik7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VSZXN0IC89IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChiYXNlUmVzdCAlIDUpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZyYWN0aW9uYWxEaXZpZGVycy5wdXNoKDIsIDIuNSk7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VSZXN0IC89IDU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgYmFzZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZnJhY3Rpb25hbERpdmlkZXJzLmxlbmd0aCA+IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvbWV0aGluZyB3cm9uZyB3aXRoIGJhc2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3RpY2tTcGFuKGhpZ2gsIGxvdywgbWF4VGlja1NwYW4pIHtcbiAgICAgICAgY29uc3QgbWluTW92ZW1lbnQgPSAodGhpcy5fcHJpdmF0ZV9fYmFzZSA9PT0gMCkgPyAoMCkgOiAoMSAvIHRoaXMuX3ByaXZhdGVfX2Jhc2UpO1xuICAgICAgICBsZXQgcmVzdWx0VGlja1NwYW4gPSBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgTWF0aC5jZWlsKE1hdGgubG9nMTAoaGlnaCAtIGxvdykpKSk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGxldCBjID0gdGhpcy5fcHJpdmF0ZV9faW50ZWdyYWxEaXZpZGVyc1swXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgLy8gdGhlIHNlY29uZCBwYXJ0IGlzIGFjdHVhbCBmb3Igc21hbGwgd2l0aCB2ZXJ5IHNtYWxsIHZhbHVlcyBsaWtlIDFlLTEwXG4gICAgICAgICAgICAvLyBncmVhdGVyT3JFcXVhbCBmYWlscyBmb3Igc3VjaCB2YWx1ZXNcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFRpY2tTcGFuTGFyZ2VyTWluTW92ZW1lbnQgPSBncmVhdGVyT3JFcXVhbChyZXN1bHRUaWNrU3BhbiwgbWluTW92ZW1lbnQsIDFlLTE0IC8qIENvbnN0YW50cy5UaWNrU3BhbkVwc2lsb24gKi8pICYmIHJlc3VsdFRpY2tTcGFuID4gKG1pbk1vdmVtZW50ICsgMWUtMTQgLyogQ29uc3RhbnRzLlRpY2tTcGFuRXBzaWxvbiAqLyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRUaWNrU3Bhbkxhcmdlck1heFRpY2tTcGFuID0gZ3JlYXRlck9yRXF1YWwocmVzdWx0VGlja1NwYW4sIG1heFRpY2tTcGFuICogYywgMWUtMTQgLyogQ29uc3RhbnRzLlRpY2tTcGFuRXBzaWxvbiAqLyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRUaWNrU3BhbkxhcmdlcjEgPSBncmVhdGVyT3JFcXVhbChyZXN1bHRUaWNrU3BhbiwgMSwgMWUtMTQgLyogQ29uc3RhbnRzLlRpY2tTcGFuRXBzaWxvbiAqLyk7XG4gICAgICAgICAgICBjb25zdCBoYXZlVG9Db250aW51ZSA9IHJlc3VsdFRpY2tTcGFuTGFyZ2VyTWluTW92ZW1lbnQgJiYgcmVzdWx0VGlja1NwYW5MYXJnZXJNYXhUaWNrU3BhbiAmJiByZXN1bHRUaWNrU3BhbkxhcmdlcjE7XG4gICAgICAgICAgICBpZiAoIWhhdmVUb0NvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRUaWNrU3BhbiAvPSBjO1xuICAgICAgICAgICAgYyA9IHRoaXMuX3ByaXZhdGVfX2ludGVncmFsRGl2aWRlcnNbKytpbmRleCAlIHRoaXMuX3ByaXZhdGVfX2ludGVncmFsRGl2aWRlcnMubGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0VGlja1NwYW4gPD0gKG1pbk1vdmVtZW50ICsgMWUtMTQgLyogQ29uc3RhbnRzLlRpY2tTcGFuRXBzaWxvbiAqLykpIHtcbiAgICAgICAgICAgIHJlc3VsdFRpY2tTcGFuID0gbWluTW92ZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0VGlja1NwYW4gPSBNYXRoLm1heCgxLCByZXN1bHRUaWNrU3Bhbik7XG4gICAgICAgIGlmICgodGhpcy5fcHJpdmF0ZV9fZnJhY3Rpb25hbERpdmlkZXJzLmxlbmd0aCA+IDApICYmIGVxdWFsKHJlc3VsdFRpY2tTcGFuLCAxLCAxZS0xNCAvKiBDb25zdGFudHMuVGlja1NwYW5FcHNpbG9uICovKSkge1xuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgYyA9IHRoaXMuX3ByaXZhdGVfX2ZyYWN0aW9uYWxEaXZpZGVyc1swXTtcbiAgICAgICAgICAgIHdoaWxlIChncmVhdGVyT3JFcXVhbChyZXN1bHRUaWNrU3BhbiwgbWF4VGlja1NwYW4gKiBjLCAxZS0xNCAvKiBDb25zdGFudHMuVGlja1NwYW5FcHNpbG9uICovKSAmJiByZXN1bHRUaWNrU3BhbiA+IChtaW5Nb3ZlbWVudCArIDFlLTE0IC8qIENvbnN0YW50cy5UaWNrU3BhbkVwc2lsb24gKi8pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VGlja1NwYW4gLz0gYztcbiAgICAgICAgICAgICAgICBjID0gdGhpcy5fcHJpdmF0ZV9fZnJhY3Rpb25hbERpdmlkZXJzWysraW5kZXggJSB0aGlzLl9wcml2YXRlX19mcmFjdGlvbmFsRGl2aWRlcnMubGVuZ3RoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0VGlja1NwYW47XG4gICAgfVxufVxuXG5jb25zdCBUSUNLX0RFTlNJVFkgPSAyLjU7XG5jbGFzcyBQcmljZVRpY2tNYXJrQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IocHJpY2VTY2FsZSwgYmFzZSwgY29vcmRpbmF0ZVRvTG9naWNhbEZ1bmMsIGxvZ2ljYWxUb0Nvb3JkaW5hdGVGdW5jKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPSBwcmljZVNjYWxlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29vcmRpbmF0ZVRvTG9naWNhbEZ1bmMgPSBjb29yZGluYXRlVG9Mb2dpY2FsRnVuYztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFRvQ29vcmRpbmF0ZUZ1bmMgPSBsb2dpY2FsVG9Db29yZGluYXRlRnVuYztcbiAgICB9XG4gICAgX2ludGVybmFsX3RpY2tTcGFuKGhpZ2gsIGxvdykge1xuICAgICAgICBpZiAoaGlnaCA8IGxvdykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoaWdoIDwgbG93Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NhbGVIZWlnaHQgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9oZWlnaHQoKTtcbiAgICAgICAgY29uc3QgbWFya0hlaWdodCA9IHRoaXMuX3ByaXZhdGVfX3RpY2tNYXJrSGVpZ2h0KCk7XG4gICAgICAgIGNvbnN0IG1heFRpY2tTcGFuID0gKGhpZ2ggLSBsb3cpICogbWFya0hlaWdodCAvIHNjYWxlSGVpZ2h0O1xuICAgICAgICBjb25zdCBzcGFuQ2FsY3VsYXRvcjEgPSBuZXcgUHJpY2VUaWNrU3BhbkNhbGN1bGF0b3IodGhpcy5fcHJpdmF0ZV9fYmFzZSwgWzIsIDIuNSwgMl0pO1xuICAgICAgICBjb25zdCBzcGFuQ2FsY3VsYXRvcjIgPSBuZXcgUHJpY2VUaWNrU3BhbkNhbGN1bGF0b3IodGhpcy5fcHJpdmF0ZV9fYmFzZSwgWzIsIDIsIDIuNV0pO1xuICAgICAgICBjb25zdCBzcGFuQ2FsY3VsYXRvcjMgPSBuZXcgUHJpY2VUaWNrU3BhbkNhbGN1bGF0b3IodGhpcy5fcHJpdmF0ZV9fYmFzZSwgWzIuNSwgMiwgMl0pO1xuICAgICAgICBjb25zdCBzcGFucyA9IFtdO1xuICAgICAgICBzcGFucy5wdXNoKHNwYW5DYWxjdWxhdG9yMS5faW50ZXJuYWxfdGlja1NwYW4oaGlnaCwgbG93LCBtYXhUaWNrU3BhbiksIHNwYW5DYWxjdWxhdG9yMi5faW50ZXJuYWxfdGlja1NwYW4oaGlnaCwgbG93LCBtYXhUaWNrU3BhbiksIHNwYW5DYWxjdWxhdG9yMy5faW50ZXJuYWxfdGlja1NwYW4oaGlnaCwgbG93LCBtYXhUaWNrU3BhbikpO1xuICAgICAgICByZXR1cm4gbWluKHNwYW5zKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlYnVpbGRUaWNrTWFya3MoKSB7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlO1xuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gcHJpY2VTY2FsZS5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICBpZiAoZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya3MgPSBbXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2FsZUhlaWdodCA9IHByaWNlU2NhbGUuX2ludGVybmFsX2hlaWdodCgpO1xuICAgICAgICBjb25zdCBib3R0b20gPSB0aGlzLl9wcml2YXRlX19jb29yZGluYXRlVG9Mb2dpY2FsRnVuYyhzY2FsZUhlaWdodCAtIDEsIGZpcnN0VmFsdWUpO1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLl9wcml2YXRlX19jb29yZGluYXRlVG9Mb2dpY2FsRnVuYygwLCBmaXJzdFZhbHVlKTtcbiAgICAgICAgY29uc3QgZXh0cmFUb3BCb3R0b21NYXJnaW4gPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9vcHRpb25zKCkuZW50aXJlVGV4dE9ubHkgPyB0aGlzLl9wcml2YXRlX19mb250SGVpZ2h0KCkgLyAyIDogMDtcbiAgICAgICAgY29uc3QgbWluQ29vcmQgPSBleHRyYVRvcEJvdHRvbU1hcmdpbjtcbiAgICAgICAgY29uc3QgbWF4Q29vcmQgPSBzY2FsZUhlaWdodCAtIDEgLSBleHRyYVRvcEJvdHRvbU1hcmdpbjtcbiAgICAgICAgY29uc3QgaGlnaCA9IE1hdGgubWF4KGJvdHRvbSwgdG9wKTtcbiAgICAgICAgY29uc3QgbG93ID0gTWF0aC5taW4oYm90dG9tLCB0b3ApO1xuICAgICAgICBpZiAoaGlnaCA9PT0gbG93KSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrcyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gdGhpcy5faW50ZXJuYWxfdGlja1NwYW4oaGlnaCwgbG93KTtcbiAgICAgICAgbGV0IG1vZCA9IGhpZ2ggJSBzcGFuO1xuICAgICAgICBtb2QgKz0gbW9kIDwgMCA/IHNwYW4gOiAwO1xuICAgICAgICBjb25zdCBzaWduID0gKGhpZ2ggPj0gbG93KSA/IDEgOiAtMTtcbiAgICAgICAgbGV0IHByZXZDb29yZCA9IG51bGw7XG4gICAgICAgIGxldCB0YXJnZXRJbmRleCA9IDA7XG4gICAgICAgIGZvciAobGV0IGxvZ2ljYWwgPSBoaWdoIC0gbW9kOyBsb2dpY2FsID4gbG93OyBsb2dpY2FsIC09IHNwYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkID0gdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFRvQ29vcmRpbmF0ZUZ1bmMobG9naWNhbCwgZmlyc3RWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBwbGFjZSBmb3IgaXRcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgcmVxdWlyZWQgZm9yIGxvZyBzY2FsZVxuICAgICAgICAgICAgaWYgKHByZXZDb29yZCAhPT0gbnVsbCAmJiBNYXRoLmFicyhjb29yZCAtIHByZXZDb29yZCkgPCB0aGlzLl9wcml2YXRlX190aWNrTWFya0hlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBhIHRpY2sgbWFyayBpcyBwYXJ0aWFsbHkgdmlzaWJsZSBhbmQgc2tpcCBpdCBpZiBlbnRpcmVUZXh0T25seSBpcyB0cnVlXG4gICAgICAgICAgICBpZiAoY29vcmQgPCBtaW5Db29yZCB8fCBjb29yZCA+IG1heENvb3JkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0SW5kZXggPCB0aGlzLl9wcml2YXRlX19tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrc1t0YXJnZXRJbmRleF0uX2ludGVybmFsX2Nvb3JkID0gY29vcmQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya3NbdGFyZ2V0SW5kZXhdLl9pbnRlcm5hbF9sYWJlbCA9IHByaWNlU2NhbGUuX2ludGVybmFsX2Zvcm1hdExvZ2ljYWwobG9naWNhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX2Nvb3JkOiBjb29yZCxcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX2xhYmVsOiBwcmljZVNjYWxlLl9pbnRlcm5hbF9mb3JtYXRMb2dpY2FsKGxvZ2ljYWwpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0SW5kZXgrKztcbiAgICAgICAgICAgIHByZXZDb29yZCA9IGNvb3JkO1xuICAgICAgICAgICAgaWYgKHByaWNlU2NhbGUuX2ludGVybmFsX2lzTG9nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyByZWNhbGMgc3BhblxuICAgICAgICAgICAgICAgIHNwYW4gPSB0aGlzLl9pbnRlcm5hbF90aWNrU3Bhbihsb2dpY2FsICogc2lnbiwgbG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrcy5sZW5ndGggPSB0YXJnZXRJbmRleDtcbiAgICB9XG4gICAgX2ludGVybmFsX21hcmtzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbWFya3M7XG4gICAgfVxuICAgIF9wcml2YXRlX19mb250SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfZm9udFNpemUoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3RpY2tNYXJrSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuX3ByaXZhdGVfX2ZvbnRIZWlnaHQoKSAqIFRJQ0tfREVOU0lUWSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzb3J0U291cmNlcyhzb3VyY2VzKSB7XG4gICAgcmV0dXJuIHNvdXJjZXMuc2xpY2UoKS5zb3J0KChzMSwgczIpID0+IHtcbiAgICAgICAgcmV0dXJuIChlbnN1cmVOb3ROdWxsKHMxLl9pbnRlcm5hbF96b3JkZXIoKSkgLSBlbnN1cmVOb3ROdWxsKHMyLl9pbnRlcm5hbF96b3JkZXIoKSkpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHByaWNlIHNjYWxlIG1vZGUuXG4gKi9cbnZhciBQcmljZVNjYWxlTW9kZTtcbihmdW5jdGlvbiAoUHJpY2VTY2FsZU1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBQcmljZSBzY2FsZSBzaG93cyBwcmljZXMuIFByaWNlIHJhbmdlIGNoYW5nZXMgbGluZWFybHkuXG4gICAgICovXG4gICAgUHJpY2VTY2FsZU1vZGVbUHJpY2VTY2FsZU1vZGVbXCJOb3JtYWxcIl0gPSAwXSA9IFwiTm9ybWFsXCI7XG4gICAgLyoqXG4gICAgICogUHJpY2Ugc2NhbGUgc2hvd3MgcHJpY2VzLiBQcmljZSByYW5nZSBjaGFuZ2VzIGxvZ2FyaXRobWljYWxseS5cbiAgICAgKi9cbiAgICBQcmljZVNjYWxlTW9kZVtQcmljZVNjYWxlTW9kZVtcIkxvZ2FyaXRobWljXCJdID0gMV0gPSBcIkxvZ2FyaXRobWljXCI7XG4gICAgLyoqXG4gICAgICogUHJpY2Ugc2NhbGUgc2hvd3MgcGVyY2VudGFnZSB2YWx1ZXMgYWNjb3JkaW5nIHRoZSBmaXJzdCB2aXNpYmxlIHZhbHVlIG9mIHRoZSBwcmljZSBzY2FsZS5cbiAgICAgKiBUaGUgZmlyc3QgdmlzaWJsZSB2YWx1ZSBpcyAwJSBpbiB0aGlzIG1vZGUuXG4gICAgICovXG4gICAgUHJpY2VTY2FsZU1vZGVbUHJpY2VTY2FsZU1vZGVbXCJQZXJjZW50YWdlXCJdID0gMl0gPSBcIlBlcmNlbnRhZ2VcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBhcyBwZXJjZW50YWdlIG1vZGUsIGJ1dCB0aGUgZmlyc3QgdmFsdWUgaXMgbW92ZWQgdG8gMTAwLlxuICAgICAqL1xuICAgIFByaWNlU2NhbGVNb2RlW1ByaWNlU2NhbGVNb2RlW1wiSW5kZXhlZFRvMTAwXCJdID0gM10gPSBcIkluZGV4ZWRUbzEwMFwiO1xufSkoUHJpY2VTY2FsZU1vZGUgfHwgKFByaWNlU2NhbGVNb2RlID0ge30pKTtcbmNvbnN0IHBlcmNlbnRhZ2VGb3JtYXR0ZXIgPSBuZXcgUGVyY2VudGFnZUZvcm1hdHRlcigpO1xuY29uc3QgZGVmYXVsdFByaWNlRm9ybWF0dGVyID0gbmV3IFByaWNlRm9ybWF0dGVyKDEwMCwgMSk7XG5jbGFzcyBQcmljZVNjYWxlIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgb3B0aW9ucywgbGF5b3V0T3B0aW9ucywgbG9jYWxpemF0aW9uT3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnRlcm5hbEhlaWdodENhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2VTbmFwc2hvdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkRm9yUmFuZ2UgPSB7IF9pbnRlcm5hbF9pc1ZhbGlkOiBmYWxzZSwgX2ludGVybmFsX3Zpc2libGVCYXJzOiBudWxsIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmdpbkFib3ZlID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFyZ2luQmVsb3cgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbk1hcmtzQ2hhbmdlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlQ2hhbmdlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZWRPcmRlcmVkU291cmNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zY2FsZVN0YXJ0UG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyID0gZGVmYXVsdFByaWNlRm9ybWF0dGVyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhID0gbG9nRm9ybXVsYUZvclByaWNlUmFuZ2UobnVsbCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2lkID0gaWQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sYXlvdXRPcHRpb25zID0gbGF5b3V0T3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9jYWxpemF0aW9uT3B0aW9ucyA9IGxvY2FsaXphdGlvbk9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtCdWlsZGVyID0gbmV3IFByaWNlVGlja01hcmtCdWlsZGVyKHRoaXMsIDEwMCwgdGhpcy5fcHJpdmF0ZV9fY29vcmRpbmF0ZVRvTG9naWNhbC5iaW5kKHRoaXMpLCB0aGlzLl9wcml2YXRlX19sb2dpY2FsVG9Db29yZGluYXRlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19pZDtcbiAgICB9XG4gICAgX2ludGVybmFsX29wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2UodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUZvcm1hdHRlcigpO1xuICAgICAgICBpZiAob3B0aW9ucy5tb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldE1vZGUoeyBfaW50ZXJuYWxfbW9kZTogb3B0aW9ucy5tb2RlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNjYWxlTWFyZ2lucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBlbnN1cmVEZWZpbmVkKG9wdGlvbnMuc2NhbGVNYXJnaW5zLnRvcCk7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBlbnN1cmVEZWZpbmVkKG9wdGlvbnMuc2NhbGVNYXJnaW5zLmJvdHRvbSk7XG4gICAgICAgICAgICBpZiAodG9wIDwgMCB8fCB0b3AgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRvcCBtYXJnaW4gLSBleHBlY3QgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBnaXZlbj0ke3RvcH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChib3R0b20gPCAwIHx8IGJvdHRvbSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYm90dG9tIG1hcmdpbiAtIGV4cGVjdCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIGdpdmVuPSR7Ym90dG9tfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcCArIGJvdHRvbSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWFyZ2lucyAtIHN1bSBvZiBtYXJnaW5zIG11c3QgYmUgbGVzcyB0aGFuIDEsIGdpdmVuPSR7dG9wICsgYm90dG9tfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZUludGVybmFsSGVpZ2h0Q2FjaGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pc0F1dG9TY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuYXV0b1NjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNMb2coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLm1vZGUgPT09IDEgLyogUHJpY2VTY2FsZU1vZGUuTG9nYXJpdGhtaWMgKi87XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pc1BlcmNlbnRhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLm1vZGUgPT09IDIgLyogUHJpY2VTY2FsZU1vZGUuUGVyY2VudGFnZSAqLztcbiAgICB9XG4gICAgX2ludGVybmFsX2lzSW5kZXhlZFRvMTAwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5tb2RlID09PSAzIC8qIFByaWNlU2NhbGVNb2RlLkluZGV4ZWRUbzEwMCAqLztcbiAgICB9XG4gICAgX2ludGVybmFsX21vZGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYXV0b1NjYWxlOiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmF1dG9TY2FsZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pc0ludmVydGVkOiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmludmVydFNjYWxlLFxuICAgICAgICAgICAgX2ludGVybmFsX21vZGU6IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubW9kZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBfaW50ZXJuYWxfc2V0TW9kZShuZXdNb2RlKSB7XG4gICAgICAgIGNvbnN0IG9sZE1vZGUgPSB0aGlzLl9pbnRlcm5hbF9tb2RlKCk7XG4gICAgICAgIGxldCBwcmljZVJhbmdlID0gbnVsbDtcbiAgICAgICAgaWYgKG5ld01vZGUuX2ludGVybmFsX2F1dG9TY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zLmF1dG9TY2FsZSA9IG5ld01vZGUuX2ludGVybmFsX2F1dG9TY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3TW9kZS5faW50ZXJuYWxfbW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zLm1vZGUgPSBuZXdNb2RlLl9pbnRlcm5hbF9tb2RlO1xuICAgICAgICAgICAgaWYgKG5ld01vZGUuX2ludGVybmFsX21vZGUgPT09IDIgLyogUHJpY2VTY2FsZU1vZGUuUGVyY2VudGFnZSAqLyB8fCBuZXdNb2RlLl9pbnRlcm5hbF9tb2RlID09PSAzIC8qIFByaWNlU2NhbGVNb2RlLkluZGV4ZWRUbzEwMCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuYXV0b1NjYWxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBhZnRlciBtYWtpbmcgcmVidWlsZFRpY2tNYXJrcyBsYXp5XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZEZvclJhbmdlLl9pbnRlcm5hbF9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmaW5lIHdoaWNoIHNjYWxlIGNvbnZlcnRlZCBmcm9tXG4gICAgICAgIGlmIChvbGRNb2RlLl9pbnRlcm5hbF9tb2RlID09PSAxIC8qIFByaWNlU2NhbGVNb2RlLkxvZ2FyaXRobWljICovICYmIG5ld01vZGUuX2ludGVybmFsX21vZGUgIT09IG9sZE1vZGUuX2ludGVybmFsX21vZGUpIHtcbiAgICAgICAgICAgIGlmIChjYW5Db252ZXJ0UHJpY2VSYW5nZUZyb21Mb2codGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZSwgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSkpIHtcbiAgICAgICAgICAgICAgICBwcmljZVJhbmdlID0gY29udmVydFByaWNlUmFuZ2VGcm9tTG9nKHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2UsIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEpO1xuICAgICAgICAgICAgICAgIGlmIChwcmljZVJhbmdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldFByaWNlUmFuZ2UocHJpY2VSYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5hdXRvU2NhbGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlZmluZSB3aGljaCBzY2FsZSBjb252ZXJ0ZWQgdG9cbiAgICAgICAgaWYgKG5ld01vZGUuX2ludGVybmFsX21vZGUgPT09IDEgLyogUHJpY2VTY2FsZU1vZGUuTG9nYXJpdGhtaWMgKi8gJiYgbmV3TW9kZS5faW50ZXJuYWxfbW9kZSAhPT0gb2xkTW9kZS5faW50ZXJuYWxfbW9kZSkge1xuICAgICAgICAgICAgcHJpY2VSYW5nZSA9IGNvbnZlcnRQcmljZVJhbmdlVG9Mb2codGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZSwgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSk7XG4gICAgICAgICAgICBpZiAocHJpY2VSYW5nZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldFByaWNlUmFuZ2UocHJpY2VSYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZUNoYW5nZWQgPSBvbGRNb2RlLl9pbnRlcm5hbF9tb2RlICE9PSB0aGlzLl9wcml2YXRlX19vcHRpb25zLm1vZGU7XG4gICAgICAgIGlmIChtb2RlQ2hhbmdlZCAmJiAob2xkTW9kZS5faW50ZXJuYWxfbW9kZSA9PT0gMiAvKiBQcmljZVNjYWxlTW9kZS5QZXJjZW50YWdlICovIHx8IHRoaXMuX2ludGVybmFsX2lzUGVyY2VudGFnZSgpKSkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlRm9ybWF0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGVDaGFuZ2VkICYmIChvbGRNb2RlLl9pbnRlcm5hbF9tb2RlID09PSAzIC8qIFByaWNlU2NhbGVNb2RlLkluZGV4ZWRUbzEwMCAqLyB8fCB0aGlzLl9pbnRlcm5hbF9pc0luZGV4ZWRUbzEwMCgpKSkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlRm9ybWF0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld01vZGUuX2ludGVybmFsX2lzSW52ZXJ0ZWQgIT09IHVuZGVmaW5lZCAmJiBvbGRNb2RlLl9pbnRlcm5hbF9pc0ludmVydGVkICE9PSBuZXdNb2RlLl9pbnRlcm5hbF9pc0ludmVydGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zLmludmVydFNjYWxlID0gbmV3TW9kZS5faW50ZXJuYWxfaXNJbnZlcnRlZDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX29uSXNJbnZlcnRlZENoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlQ2hhbmdlZC5faW50ZXJuYWxfZmlyZShvbGRNb2RlLCB0aGlzLl9pbnRlcm5hbF9tb2RlKCkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW9kZUNoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tb2RlQ2hhbmdlZDtcbiAgICB9XG4gICAgX2ludGVybmFsX2ZvbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbGF5b3V0T3B0aW9ucy5mb250U2l6ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2hlaWdodDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldEhlaWdodCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faGVpZ2h0ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hlaWdodCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlSW50ZXJuYWxIZWlnaHRDYWNoZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrc0NhY2hlID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2ludGVybmFsSGVpZ2h0KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW50ZXJuYWxIZWlnaHRDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2ludGVybmFsSGVpZ2h0Q2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5faW50ZXJuYWxfaGVpZ2h0KCkgLSB0aGlzLl9wcml2YXRlX190b3BNYXJnaW5QeCgpIC0gdGhpcy5fcHJpdmF0ZV9fYm90dG9tTWFyZ2luUHgoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW50ZXJuYWxIZWlnaHRDYWNoZSA9IHJlcztcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlUmFuZ2UoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21ha2VTdXJlSXRJc1ZhbGlkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0UHJpY2VSYW5nZShuZXdQcmljZVJhbmdlLCBpc0ZvcmNlU2V0VmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb2xkUHJpY2VSYW5nZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2U7XG4gICAgICAgIGlmICghaXNGb3JjZVNldFZhbHVlICYmXG4gICAgICAgICAgICAhKG9sZFByaWNlUmFuZ2UgPT09IG51bGwgJiYgbmV3UHJpY2VSYW5nZSAhPT0gbnVsbCkgJiZcbiAgICAgICAgICAgIChvbGRQcmljZVJhbmdlID09PSBudWxsIHx8IG9sZFByaWNlUmFuZ2UuX2ludGVybmFsX2VxdWFscyhuZXdQcmljZVJhbmdlKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrc0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZSA9IG5ld1ByaWNlUmFuZ2U7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pc0VtcHR5KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYWtlU3VyZUl0SXNWYWxpZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faGVpZ2h0ID09PSAwIHx8ICF0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlIHx8IHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2UuX2ludGVybmFsX2lzRW1wdHkoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2ludmVydGVkQ29vcmRpbmF0ZShjb29yZGluYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9pc0ludmVydGVkKCkgPyBjb29yZGluYXRlIDogdGhpcy5faW50ZXJuYWxfaGVpZ2h0KCkgLSAxIC0gY29vcmRpbmF0ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKHByaWNlLCBiYXNlVmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzUGVyY2VudGFnZSgpKSB7XG4gICAgICAgICAgICBwcmljZSA9IHRvUGVyY2VudChwcmljZSwgYmFzZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pbnRlcm5hbF9pc0luZGV4ZWRUbzEwMCgpKSB7XG4gICAgICAgICAgICBwcmljZSA9IHRvSW5kZXhlZFRvMTAwKHByaWNlLCBiYXNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sb2dpY2FsVG9Db29yZGluYXRlKHByaWNlLCBiYXNlVmFsdWUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcG9pbnRzQXJyYXlUb0Nvb3JkaW5hdGVzKHBvaW50cywgYmFzZVZhbHVlLCB2aXNpYmxlUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFrZVN1cmVJdElzVmFsaWQoKTtcbiAgICAgICAgY29uc3QgYmggPSB0aGlzLl9wcml2YXRlX19ib3R0b21NYXJnaW5QeCgpO1xuICAgICAgICBjb25zdCByYW5nZSA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfcHJpY2VSYW5nZSgpKTtcbiAgICAgICAgY29uc3QgbWluID0gcmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCk7XG4gICAgICAgIGNvbnN0IG1heCA9IHJhbmdlLl9pbnRlcm5hbF9tYXhWYWx1ZSgpO1xuICAgICAgICBjb25zdCBpaCA9ICh0aGlzLl9pbnRlcm5hbF9pbnRlcm5hbEhlaWdodCgpIC0gMSk7XG4gICAgICAgIGNvbnN0IGlzSW52ZXJ0ZWQgPSB0aGlzLl9pbnRlcm5hbF9pc0ludmVydGVkKCk7XG4gICAgICAgIGNvbnN0IGhtbSA9IGloIC8gKG1heCAtIG1pbik7XG4gICAgICAgIGNvbnN0IGZyb21JbmRleCA9ICh2aXNpYmxlUmFuZ2UgPT09IHVuZGVmaW5lZCkgPyAwIDogdmlzaWJsZVJhbmdlLmZyb207XG4gICAgICAgIGNvbnN0IHRvSW5kZXggPSAodmlzaWJsZVJhbmdlID09PSB1bmRlZmluZWQpID8gcG9pbnRzLmxlbmd0aCA6IHZpc2libGVSYW5nZS50bztcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtRm4gPSB0aGlzLl9wcml2YXRlX19nZXRDb29yZGluYXRlVHJhbnNmb3JtZXIoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb21JbmRleDsgaSA8IHRvSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICBjb25zdCBwcmljZSA9IHBvaW50Ll9pbnRlcm5hbF9wcmljZTtcbiAgICAgICAgICAgIGlmIChpc05hTihwcmljZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsb2dpY2FsID0gcHJpY2U7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtRm4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dpY2FsID0gdHJhbnNmb3JtRm4ocG9pbnQuX2ludGVybmFsX3ByaWNlLCBiYXNlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW52Q29vcmRpbmF0ZSA9IGJoICsgaG1tICogKGxvZ2ljYWwgLSBtaW4pO1xuICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZSA9IGlzSW52ZXJ0ZWQgPyBpbnZDb29yZGluYXRlIDogdGhpcy5fcHJpdmF0ZV9faGVpZ2h0IC0gMSAtIGludkNvb3JkaW5hdGU7XG4gICAgICAgICAgICBwb2ludC5faW50ZXJuYWxfeSA9IGNvb3JkaW5hdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX2JhclByaWNlc1RvQ29vcmRpbmF0ZXMocHJpY2VzTGlzdCwgYmFzZVZhbHVlLCB2aXNpYmxlUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFrZVN1cmVJdElzVmFsaWQoKTtcbiAgICAgICAgY29uc3QgYmggPSB0aGlzLl9wcml2YXRlX19ib3R0b21NYXJnaW5QeCgpO1xuICAgICAgICBjb25zdCByYW5nZSA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfcHJpY2VSYW5nZSgpKTtcbiAgICAgICAgY29uc3QgbWluID0gcmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCk7XG4gICAgICAgIGNvbnN0IG1heCA9IHJhbmdlLl9pbnRlcm5hbF9tYXhWYWx1ZSgpO1xuICAgICAgICBjb25zdCBpaCA9ICh0aGlzLl9pbnRlcm5hbF9pbnRlcm5hbEhlaWdodCgpIC0gMSk7XG4gICAgICAgIGNvbnN0IGlzSW52ZXJ0ZWQgPSB0aGlzLl9pbnRlcm5hbF9pc0ludmVydGVkKCk7XG4gICAgICAgIGNvbnN0IGhtbSA9IGloIC8gKG1heCAtIG1pbik7XG4gICAgICAgIGNvbnN0IGZyb21JbmRleCA9ICh2aXNpYmxlUmFuZ2UgPT09IHVuZGVmaW5lZCkgPyAwIDogdmlzaWJsZVJhbmdlLmZyb207XG4gICAgICAgIGNvbnN0IHRvSW5kZXggPSAodmlzaWJsZVJhbmdlID09PSB1bmRlZmluZWQpID8gcHJpY2VzTGlzdC5sZW5ndGggOiB2aXNpYmxlUmFuZ2UudG87XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybUZuID0gdGhpcy5fcHJpdmF0ZV9fZ2V0Q29vcmRpbmF0ZVRyYW5zZm9ybWVyKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tSW5kZXg7IGkgPCB0b0luZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJhciA9IHByaWNlc0xpc3RbaV07XG4gICAgICAgICAgICBsZXQgb3BlbkxvZ2ljYWwgPSBiYXIuX2ludGVybmFsX29wZW47XG4gICAgICAgICAgICBsZXQgaGlnaExvZ2ljYWwgPSBiYXIuX2ludGVybmFsX2hpZ2g7XG4gICAgICAgICAgICBsZXQgbG93TG9naWNhbCA9IGJhci5faW50ZXJuYWxfbG93O1xuICAgICAgICAgICAgbGV0IGNsb3NlTG9naWNhbCA9IGJhci5faW50ZXJuYWxfY2xvc2U7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtRm4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcGVuTG9naWNhbCA9IHRyYW5zZm9ybUZuKGJhci5faW50ZXJuYWxfb3BlbiwgYmFzZVZhbHVlKTtcbiAgICAgICAgICAgICAgICBoaWdoTG9naWNhbCA9IHRyYW5zZm9ybUZuKGJhci5faW50ZXJuYWxfaGlnaCwgYmFzZVZhbHVlKTtcbiAgICAgICAgICAgICAgICBsb3dMb2dpY2FsID0gdHJhbnNmb3JtRm4oYmFyLl9pbnRlcm5hbF9sb3csIGJhc2VWYWx1ZSk7XG4gICAgICAgICAgICAgICAgY2xvc2VMb2dpY2FsID0gdHJhbnNmb3JtRm4oYmFyLl9pbnRlcm5hbF9jbG9zZSwgYmFzZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbnZDb29yZGluYXRlID0gYmggKyBobW0gKiAob3BlbkxvZ2ljYWwgLSBtaW4pO1xuICAgICAgICAgICAgbGV0IGNvb3JkaW5hdGUgPSBpc0ludmVydGVkID8gaW52Q29vcmRpbmF0ZSA6IHRoaXMuX3ByaXZhdGVfX2hlaWdodCAtIDEgLSBpbnZDb29yZGluYXRlO1xuICAgICAgICAgICAgYmFyLl9pbnRlcm5hbF9vcGVuWSA9IGNvb3JkaW5hdGU7XG4gICAgICAgICAgICBpbnZDb29yZGluYXRlID0gYmggKyBobW0gKiAoaGlnaExvZ2ljYWwgLSBtaW4pO1xuICAgICAgICAgICAgY29vcmRpbmF0ZSA9IGlzSW52ZXJ0ZWQgPyBpbnZDb29yZGluYXRlIDogdGhpcy5fcHJpdmF0ZV9faGVpZ2h0IC0gMSAtIGludkNvb3JkaW5hdGU7XG4gICAgICAgICAgICBiYXIuX2ludGVybmFsX2hpZ2hZID0gY29vcmRpbmF0ZTtcbiAgICAgICAgICAgIGludkNvb3JkaW5hdGUgPSBiaCArIGhtbSAqIChsb3dMb2dpY2FsIC0gbWluKTtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSBpc0ludmVydGVkID8gaW52Q29vcmRpbmF0ZSA6IHRoaXMuX3ByaXZhdGVfX2hlaWdodCAtIDEgLSBpbnZDb29yZGluYXRlO1xuICAgICAgICAgICAgYmFyLl9pbnRlcm5hbF9sb3dZID0gY29vcmRpbmF0ZTtcbiAgICAgICAgICAgIGludkNvb3JkaW5hdGUgPSBiaCArIGhtbSAqIChjbG9zZUxvZ2ljYWwgLSBtaW4pO1xuICAgICAgICAgICAgY29vcmRpbmF0ZSA9IGlzSW52ZXJ0ZWQgPyBpbnZDb29yZGluYXRlIDogdGhpcy5fcHJpdmF0ZV9faGVpZ2h0IC0gMSAtIGludkNvb3JkaW5hdGU7XG4gICAgICAgICAgICBiYXIuX2ludGVybmFsX2Nsb3NlWSA9IGNvb3JkaW5hdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX2Nvb3JkaW5hdGVUb1ByaWNlKGNvb3JkaW5hdGUsIGJhc2VWYWx1ZSkge1xuICAgICAgICBjb25zdCBsb2dpY2FsID0gdGhpcy5fcHJpdmF0ZV9fY29vcmRpbmF0ZVRvTG9naWNhbChjb29yZGluYXRlLCBiYXNlVmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfbG9naWNhbFRvUHJpY2UobG9naWNhbCwgYmFzZVZhbHVlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2xvZ2ljYWxUb1ByaWNlKGxvZ2ljYWwsIGJhc2VWYWx1ZSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBsb2dpY2FsO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNQZXJjZW50YWdlKCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZnJvbVBlcmNlbnQodmFsdWUsIGJhc2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faW50ZXJuYWxfaXNJbmRleGVkVG8xMDAoKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBmcm9tSW5kZXhlZFRvMTAwKHZhbHVlLCBiYXNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RhdGFTb3VyY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcmRlcmVkU291cmNlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NhY2hlZE9yZGVyZWRTb3VyY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2FjaGVkT3JkZXJlZFNvdXJjZXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNvdXJjZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZHMgPSB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlc1tpXTtcbiAgICAgICAgICAgIGlmIChkcy5faW50ZXJuYWxfem9yZGVyKCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkcy5faW50ZXJuYWxfc2V0Wm9yZGVyKGkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZXMucHVzaChkcyk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlcyA9IHNvcnRTb3VyY2VzKHNvdXJjZXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZWRPcmRlcmVkU291cmNlcyA9IHNvdXJjZXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jYWNoZWRPcmRlcmVkU291cmNlcztcbiAgICB9XG4gICAgX2ludGVybmFsX2FkZERhdGFTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5pbmRleE9mKHNvdXJjZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVGb3JtYXR0ZXIoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfaW52YWxpZGF0ZVNvdXJjZXNDYWNoZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVtb3ZlRGF0YVNvdXJjZShzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIGlzIG5vdCBhdHRhY2hlZCB0byBzY2FsZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldE1vZGUoe1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9hdXRvU2NhbGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGlmIG5vIHNvdXJjZXMgb24gcHJpY2Ugc2NhbGUgbGV0J3MgY2xlYXIgcHJpY2UgcmFuZ2UgY2FjaGUgYXMgd2VsbCBhcyBlbmFibGluZyBhdXRvIHNjYWxlXG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRQcmljZVJhbmdlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUZvcm1hdHRlcigpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9pbnZhbGlkYXRlU291cmNlc0NhY2hlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9maXJzdFZhbHVlKCkge1xuICAgICAgICAvLyBUT0RPOiBjYWNoZSB0aGUgcmVzdWx0XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHNvdXJjZS5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGZpcnN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdGltZVBvaW50IDwgcmVzdWx0Ll9pbnRlcm5hbF90aW1lUG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmaXJzdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyBudWxsIDogcmVzdWx0Ll9pbnRlcm5hbF92YWx1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2lzSW52ZXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmludmVydFNjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbWFya3MoKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWVJc051bGwgPSB0aGlzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCkgPT09IG51bGw7XG4gICAgICAgIC8vIGRvIG5vdCByZWNhbGN1bGF0ZSBtYXJrcyBpZiBmaXJzdFZhbHVlSXNOdWxsIGlzIHRydWUgYmVjYXVzZSBpbiB0aGlzIGNhc2Ugd2UnbGwgYWx3YXlzIGdldCBlbXB0eSByZXN1bHRcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaW4gY2FzZSB3aGVuIGEgc2VyaWVzIGhhZCBzb21lIGRhdGEgYW5kIHRoZW4geW91IHNldCBlbXB0eSBkYXRhIHRvIGl0IChpbiBhIHNpbXBsaWZpZWQgY2FzZSlcbiAgICAgICAgLy8gd2UgY291bGQgZGlzcGxheSBhbiBlbXB0eSBwcmljZSBzY2FsZSwgYnV0IHRoaXMgaXMgbm90IGdvb2QgZnJvbSBVWFxuICAgICAgICAvLyBzbyBpbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBrZWVwIGFuIHByZXZpb3VzIG1hcmtzIHRvIGRpc3BsYXkgdGhlbSBvbiB0aGUgc2NhbGVcbiAgICAgICAgLy8gYXMgb25lIG9mIHBvc3NpYmxlIGV4YW1wbGVzIGZvciB0aGlzIHNpdHVhdGlvbiBjb3VsZCBiZSB0aGUgZm9sbG93aW5nOlxuICAgICAgICAvLyBsZXQncyBzYXkgeW91IGhhdmUgYSBzdHVkeS9pbmRpY2F0b3IgYXR0YWNoZWQgdG8gYSBwcmljZSBzY2FsZSBhbmQgdGhlbiB5b3UgZGVjaWRlIHRvIHN0b3AgaXQsIGkuZS4gcmVtb3ZlIGl0cyBkYXRhIGJlY2F1c2Ugb2YgaXRzIHZpc2liaWxpdHlcbiAgICAgICAgLy8gYSB1c2VyIHdpbGwgc2VlIHRoZSBwcmV2aW91cyBtYXJrcyBvbiB0aGUgc2NhbGUgdW50aWwgeW91IHR1cm4gb24geW91ciBzdHVkeSBiYWNrIG9yIHJlbW92ZSBpdCBmcm9tIHRoZSBjaGFydCBjb21wbGV0ZWx5XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19tYXJrc0NhY2hlICE9PSBudWxsICYmIChmaXJzdFZhbHVlSXNOdWxsIHx8IHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUuX2ludGVybmFsX2ZpcnN0VmFsdWVJc051bGwgPT09IGZpcnN0VmFsdWVJc051bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbWFya3NDYWNoZS5faW50ZXJuYWxfbWFya3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya0J1aWxkZXIuX2ludGVybmFsX3JlYnVpbGRUaWNrTWFya3MoKTtcbiAgICAgICAgY29uc3QgbWFya3MgPSB0aGlzLl9wcml2YXRlX19tYXJrQnVpbGRlci5faW50ZXJuYWxfbWFya3MoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya3NDYWNoZSA9IHsgX2ludGVybmFsX21hcmtzOiBtYXJrcywgX2ludGVybmFsX2ZpcnN0VmFsdWVJc051bGw6IGZpcnN0VmFsdWVJc051bGwgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25NYXJrc0NoYW5nZWQuX2ludGVybmFsX2ZpcmUoKTtcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb25NYXJrc0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vbk1hcmtzQ2hhbmdlZDtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXJ0U2NhbGUoeCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNQZXJjZW50YWdlKCkgfHwgdGhpcy5faW50ZXJuYWxfaXNJbmRleGVkVG8xMDAoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zY2FsZVN0YXJ0UG9pbnQgIT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludmVydCB4XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NjYWxlU3RhcnRQb2ludCA9IHRoaXMuX3ByaXZhdGVfX2hlaWdodCAtIHg7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2VTbmFwc2hvdCA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfcHJpY2VSYW5nZSgpKS5faW50ZXJuYWxfY2xvbmUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NjYWxlVG8oeCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNQZXJjZW50YWdlKCkgfHwgdGhpcy5faW50ZXJuYWxfaXNJbmRleGVkVG8xMDAoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zY2FsZVN0YXJ0UG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRNb2RlKHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9hdXRvU2NhbGU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gaW52ZXJ0IHhcbiAgICAgICAgeCA9IHRoaXMuX3ByaXZhdGVfX2hlaWdodCAtIHg7XG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjYWxlQ29lZmYgPSAodGhpcy5fcHJpdmF0ZV9fc2NhbGVTdGFydFBvaW50ICsgKHRoaXMuX3ByaXZhdGVfX2hlaWdodCAtIDEpICogMC4yKSAvICh4ICsgKHRoaXMuX3ByaXZhdGVfX2hlaWdodCAtIDEpICogMC4yKTtcbiAgICAgICAgY29uc3QgbmV3UHJpY2VSYW5nZSA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90KS5faW50ZXJuYWxfY2xvbmUoKTtcbiAgICAgICAgc2NhbGVDb2VmZiA9IE1hdGgubWF4KHNjYWxlQ29lZmYsIDAuMSk7XG4gICAgICAgIG5ld1ByaWNlUmFuZ2UuX2ludGVybmFsX3NjYWxlQXJvdW5kQ2VudGVyKHNjYWxlQ29lZmYpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRQcmljZVJhbmdlKG5ld1ByaWNlUmFuZ2UpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZW5kU2NhbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc1BlcmNlbnRhZ2UoKSB8fCB0aGlzLl9pbnRlcm5hbF9pc0luZGV4ZWRUbzEwMCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2NhbGVTdGFydFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90ID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXJ0U2Nyb2xsKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzQXV0b1NjYWxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCAhPT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlU25hcHNob3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCA9IHg7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2VTbmFwc2hvdCA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfcHJpY2VSYW5nZSgpKS5faW50ZXJuYWxfY2xvbmUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Njcm9sbFRvKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzQXV0b1NjYWxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaWNlVW5pdHNQZXJQaXhlbCA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfcHJpY2VSYW5nZSgpKS5faW50ZXJuYWxfbGVuZ3RoKCkgLyAodGhpcy5faW50ZXJuYWxfaW50ZXJuYWxIZWlnaHQoKSAtIDEpO1xuICAgICAgICBsZXQgcGl4ZWxEZWx0YSA9IHggLSB0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50O1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNJbnZlcnRlZCgpKSB7XG4gICAgICAgICAgICBwaXhlbERlbHRhICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaWNlRGVsdGEgPSBwaXhlbERlbHRhICogcHJpY2VVbml0c1BlclBpeGVsO1xuICAgICAgICBjb25zdCBuZXdQcmljZVJhbmdlID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlU25hcHNob3QpLl9pbnRlcm5hbF9jbG9uZSgpO1xuICAgICAgICBuZXdQcmljZVJhbmdlLl9pbnRlcm5hbF9zaGlmdChwcmljZURlbHRhKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0UHJpY2VSYW5nZShuZXdQcmljZVJhbmdlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya3NDYWNoZSA9IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9lbmRTY3JvbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0F1dG9TY2FsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Njcm9sbFN0YXJ0UG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90ID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2Zvcm1hdHRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUZvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9mb3JtYXRQcmljZShwcmljZSwgZmlyc3RWYWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubW9kZSkge1xuICAgICAgICAgICAgY2FzZSAyIC8qIFByaWNlU2NhbGVNb2RlLlBlcmNlbnRhZ2UgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFBlcmNlbnRhZ2UodG9QZXJjZW50KHByaWNlLCBmaXJzdFZhbHVlKSk7XG4gICAgICAgICAgICBjYXNlIDMgLyogUHJpY2VTY2FsZU1vZGUuSW5kZXhlZFRvMTAwICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9mb3JtYXR0ZXIoKS5mb3JtYXQodG9JbmRleGVkVG8xMDAocHJpY2UsIGZpcnN0VmFsdWUpKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFByaWNlKHByaWNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfZm9ybWF0TG9naWNhbChsb2dpY2FsKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5tb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDIgLyogUHJpY2VTY2FsZU1vZGUuUGVyY2VudGFnZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0UGVyY2VudGFnZShsb2dpY2FsKTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBQcmljZVNjYWxlTW9kZS5JbmRleGVkVG8xMDAgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX2Zvcm1hdHRlcigpLmZvcm1hdChsb2dpY2FsKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFByaWNlKGxvZ2ljYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9mb3JtYXRQcmljZUFic29sdXRlKHByaWNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19mb3JtYXRQcmljZShwcmljZSwgZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXJTb3VyY2UoKSkuX2ludGVybmFsX2Zvcm1hdHRlcigpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Zvcm1hdFByaWNlUGVyY2VudGFnZShwcmljZSwgYmFzZVZhbHVlKSB7XG4gICAgICAgIHByaWNlID0gdG9QZXJjZW50KHByaWNlLCBiYXNlVmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0UGVyY2VudGFnZShwcmljZSwgcGVyY2VudGFnZUZvcm1hdHRlcik7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zb3VyY2VzRm9yQXV0b1NjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZWNhbGN1bGF0ZVByaWNlUmFuZ2UodmlzaWJsZUJhcnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWRGb3JSYW5nZSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlQmFyczogdmlzaWJsZUJhcnMsXG4gICAgICAgICAgICBfaW50ZXJuYWxfaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cygpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMuZm9yRWFjaCgocykgPT4gcy5faW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGVGb3JtYXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUgPSBudWxsO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXJTb3VyY2UgPSB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXJTb3VyY2UoKTtcbiAgICAgICAgbGV0IGJhc2UgPSAxMDA7XG4gICAgICAgIGlmIChmb3JtYXR0ZXJTb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGJhc2UgPSBNYXRoLnJvdW5kKDEgLyBmb3JtYXR0ZXJTb3VyY2UuX2ludGVybmFsX21pbk1vdmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyID0gZGVmYXVsdFByaWNlRm9ybWF0dGVyO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNQZXJjZW50YWdlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlciA9IHBlcmNlbnRhZ2VGb3JtYXR0ZXI7XG4gICAgICAgICAgICBiYXNlID0gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ludGVybmFsX2lzSW5kZXhlZFRvMTAwKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlciA9IG5ldyBQcmljZUZvcm1hdHRlcigxMDAsIDEpO1xuICAgICAgICAgICAgYmFzZSA9IDEwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXR0ZXJTb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2VyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyID0gZm9ybWF0dGVyU291cmNlLl9pbnRlcm5hbF9mb3JtYXR0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrQnVpbGRlciA9IG5ldyBQcmljZVRpY2tNYXJrQnVpbGRlcih0aGlzLCBiYXNlLCB0aGlzLl9wcml2YXRlX19jb29yZGluYXRlVG9Mb2dpY2FsLmJpbmQodGhpcyksIHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxUb0Nvb3JkaW5hdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtCdWlsZGVyLl9pbnRlcm5hbF9yZWJ1aWxkVGlja01hcmtzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pbnZhbGlkYXRlU291cmNlc0NhY2hlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZWRPcmRlcmVkU291cmNlcyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSB7QGxpbmsgSVByaWNlRGF0YVNvdXJjZX0gdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIFwiZm9ybWF0dGVyIHNvdXJjZVwiICh0YWtlIG1pbk1vdmUgZm9yIGZvcm1hdHRlcikuXG4gICAgICovXG4gICAgX3ByaXZhdGVfX2Zvcm1hdHRlclNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzWzBdIHx8IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX190b3BNYXJnaW5QeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX2lzSW52ZXJ0ZWQoKVxuICAgICAgICAgICAgPyB0aGlzLl9wcml2YXRlX19vcHRpb25zLnNjYWxlTWFyZ2lucy5ib3R0b20gKiB0aGlzLl9pbnRlcm5hbF9oZWlnaHQoKSArIHRoaXMuX3ByaXZhdGVfX21hcmdpbkJlbG93XG4gICAgICAgICAgICA6IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuc2NhbGVNYXJnaW5zLnRvcCAqIHRoaXMuX2ludGVybmFsX2hlaWdodCgpICsgdGhpcy5fcHJpdmF0ZV9fbWFyZ2luQWJvdmU7XG4gICAgfVxuICAgIF9wcml2YXRlX19ib3R0b21NYXJnaW5QeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX2lzSW52ZXJ0ZWQoKVxuICAgICAgICAgICAgPyB0aGlzLl9wcml2YXRlX19vcHRpb25zLnNjYWxlTWFyZ2lucy50b3AgKiB0aGlzLl9pbnRlcm5hbF9oZWlnaHQoKSArIHRoaXMuX3ByaXZhdGVfX21hcmdpbkFib3ZlXG4gICAgICAgICAgICA6IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuc2NhbGVNYXJnaW5zLmJvdHRvbSAqIHRoaXMuX2ludGVybmFsX2hlaWdodCgpICsgdGhpcy5fcHJpdmF0ZV9fbWFyZ2luQmVsb3c7XG4gICAgfVxuICAgIF9wcml2YXRlX19tYWtlU3VyZUl0SXNWYWxpZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZEZvclJhbmdlLl9pbnRlcm5hbF9pc1ZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZEZvclJhbmdlLl9pbnRlcm5hbF9pc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY2FsY3VsYXRlUHJpY2VSYW5nZUltcGwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9faW52YWxpZGF0ZUludGVybmFsSGVpZ2h0Q2FjaGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludGVybmFsSGVpZ2h0Q2FjaGUgPSBudWxsO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbG9naWNhbFRvQ29vcmRpbmF0ZShsb2dpY2FsLCBiYXNlVmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFrZVN1cmVJdElzVmFsaWQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbG9naWNhbCA9IHRoaXMuX2ludGVybmFsX2lzTG9nKCkgJiYgbG9naWNhbCA/IHRvTG9nKGxvZ2ljYWwsIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEpIDogbG9naWNhbDtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX3ByaWNlUmFuZ2UoKSk7XG4gICAgICAgIGNvbnN0IGludkNvb3JkaW5hdGUgPSB0aGlzLl9wcml2YXRlX19ib3R0b21NYXJnaW5QeCgpICtcbiAgICAgICAgICAgICh0aGlzLl9pbnRlcm5hbF9pbnRlcm5hbEhlaWdodCgpIC0gMSkgKiAobG9naWNhbCAtIHJhbmdlLl9pbnRlcm5hbF9taW5WYWx1ZSgpKSAvIHJhbmdlLl9pbnRlcm5hbF9sZW5ndGgoKTtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZSA9IHRoaXMuX2ludGVybmFsX2ludmVydGVkQ29vcmRpbmF0ZShpbnZDb29yZGluYXRlKTtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gICAgfVxuICAgIF9wcml2YXRlX19jb29yZGluYXRlVG9Mb2dpY2FsKGNvb3JkaW5hdGUsIGJhc2VWYWx1ZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYWtlU3VyZUl0SXNWYWxpZCgpO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnZDb29yZGluYXRlID0gdGhpcy5faW50ZXJuYWxfaW52ZXJ0ZWRDb29yZGluYXRlKGNvb3JkaW5hdGUpO1xuICAgICAgICBjb25zdCByYW5nZSA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfcHJpY2VSYW5nZSgpKTtcbiAgICAgICAgY29uc3QgbG9naWNhbCA9IHJhbmdlLl9pbnRlcm5hbF9taW5WYWx1ZSgpICsgcmFuZ2UuX2ludGVybmFsX2xlbmd0aCgpICpcbiAgICAgICAgICAgICgoaW52Q29vcmRpbmF0ZSAtIHRoaXMuX3ByaXZhdGVfX2JvdHRvbU1hcmdpblB4KCkpIC8gKHRoaXMuX2ludGVybmFsX2ludGVybmFsSGVpZ2h0KCkgLSAxKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9pc0xvZygpID8gZnJvbUxvZyhsb2dpY2FsLCB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhKSA6IGxvZ2ljYWw7XG4gICAgfVxuICAgIF9wcml2YXRlX19vbklzSW52ZXJ0ZWRDaGFuZ2VkKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrc0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya0J1aWxkZXIuX2ludGVybmFsX3JlYnVpbGRUaWNrTWFya3MoKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBfcHJpdmF0ZV9fcmVjYWxjdWxhdGVQcmljZVJhbmdlSW1wbCgpIHtcbiAgICAgICAgY29uc3QgdmlzaWJsZUJhcnMgPSB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZEZvclJhbmdlLl9pbnRlcm5hbF92aXNpYmxlQmFycztcbiAgICAgICAgaWYgKHZpc2libGVCYXJzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByaWNlUmFuZ2UgPSBudWxsO1xuICAgICAgICBjb25zdCBzb3VyY2VzID0gdGhpcy5faW50ZXJuYWxfc291cmNlc0ZvckF1dG9TY2FsZSgpO1xuICAgICAgICBsZXQgbWFyZ2luQWJvdmUgPSAwO1xuICAgICAgICBsZXQgbWFyZ2luQmVsb3cgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZS5faW50ZXJuYWxfdmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gc291cmNlLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0b1NjYWxlSW5mbyA9IHNvdXJjZS5faW50ZXJuYWxfYXV0b3NjYWxlSW5mbyh2aXNpYmxlQmFycy5faW50ZXJuYWxfbGVmdCgpLCB2aXNpYmxlQmFycy5faW50ZXJuYWxfcmlnaHQoKSk7XG4gICAgICAgICAgICBsZXQgc291cmNlUmFuZ2UgPSBhdXRvU2NhbGVJbmZvICYmIGF1dG9TY2FsZUluZm8uX2ludGVybmFsX3ByaWNlUmFuZ2UoKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VSYW5nZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBQcmljZVNjYWxlTW9kZS5Mb2dhcml0aG1pYyAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVJhbmdlID0gY29udmVydFByaWNlUmFuZ2VUb0xvZyhzb3VyY2VSYW5nZSwgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyIC8qIFByaWNlU2NhbGVNb2RlLlBlcmNlbnRhZ2UgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VSYW5nZSA9IHRvUGVyY2VudFJhbmdlKHNvdXJjZVJhbmdlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzIC8qIFByaWNlU2NhbGVNb2RlLkluZGV4ZWRUbzEwMCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVJhbmdlID0gdG9JbmRleGVkVG8xMDBSYW5nZShzb3VyY2VSYW5nZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmljZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaWNlUmFuZ2UgPSBzb3VyY2VSYW5nZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByaWNlUmFuZ2UgPSBwcmljZVJhbmdlLl9pbnRlcm5hbF9tZXJnZShlbnN1cmVOb3ROdWxsKHNvdXJjZVJhbmdlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhdXRvU2NhbGVJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmdpbnMgPSBhdXRvU2NhbGVJbmZvLl9pbnRlcm5hbF9tYXJnaW5zKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJnaW5zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5BYm92ZSA9IE1hdGgubWF4KG1hcmdpbkFib3ZlLCBtYXJnaW5zLmFib3ZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkJlbG93ID0gTWF0aC5tYXgobWFyZ2luQWJvdmUsIG1hcmdpbnMuYmVsb3cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJnaW5BYm92ZSAhPT0gdGhpcy5fcHJpdmF0ZV9fbWFyZ2luQWJvdmUgfHwgbWFyZ2luQmVsb3cgIT09IHRoaXMuX3ByaXZhdGVfX21hcmdpbkJlbG93KSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJnaW5BYm92ZSA9IG1hcmdpbkFib3ZlO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFyZ2luQmVsb3cgPSBtYXJnaW5CZWxvdztcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZUludGVybmFsSGVpZ2h0Q2FjaGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpY2VSYW5nZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8ga2VlcCBjdXJyZW50IHJhbmdlIGlzIG5ldyBpcyBlbXB0eVxuICAgICAgICAgICAgaWYgKHByaWNlUmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCkgPT09IHByaWNlUmFuZ2UuX2ludGVybmFsX21heFZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXJTb3VyY2UgPSB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXJTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5Nb3ZlID0gZm9ybWF0dGVyU291cmNlID09PSBudWxsIHx8IHRoaXMuX2ludGVybmFsX2lzUGVyY2VudGFnZSgpIHx8IHRoaXMuX2ludGVybmFsX2lzSW5kZXhlZFRvMTAwKCkgPyAxIDogZm9ybWF0dGVyU291cmNlLl9pbnRlcm5hbF9taW5Nb3ZlKCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgcHJpY2UgcmFuZ2UgaXMgZGVnZW5lcmF0ZWQgdG8gMSBwb2ludCBsZXQncyBleHRlbmQgaXQgYnkgMTAgbWluIG1vdmUgdmFsdWVzXG4gICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgaW5jb3JyZWN0IHJhbmdlIGFuZCBlbXB0eSAoYmxhbmspIHNjYWxlIChpbiBjYXNlIG9mIG1pbiB0aWNrIG11Y2ggZ3JlYXRlciB0aGFuIDEpXG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5kVmFsdWUgPSA1ICogbWluTW92ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNMb2coKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmljZVJhbmdlID0gY29udmVydFByaWNlUmFuZ2VGcm9tTG9nKHByaWNlUmFuZ2UsIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmljZVJhbmdlID0gbmV3IFByaWNlUmFuZ2VJbXBsKHByaWNlUmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCkgLSBleHRlbmRWYWx1ZSwgcHJpY2VSYW5nZS5faW50ZXJuYWxfbWF4VmFsdWUoKSArIGV4dGVuZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNMb2coKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmljZVJhbmdlID0gY29udmVydFByaWNlUmFuZ2VUb0xvZyhwcmljZVJhbmdlLCB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNMb2coKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd1JhbmdlID0gY29udmVydFByaWNlUmFuZ2VGcm9tTG9nKHByaWNlUmFuZ2UsIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xvZ0Zvcm11bGEgPSBsb2dGb3JtdWxhRm9yUHJpY2VSYW5nZShyYXdSYW5nZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2dGb3JtdWxhc0FyZVNhbWUobmV3TG9nRm9ybXVsYSwgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3U25hcHNob3QgPSB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlU25hcHNob3QgIT09IG51bGwgPyBjb252ZXJ0UHJpY2VSYW5nZUZyb21Mb2codGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90LCB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEgPSBuZXdMb2dGb3JtdWxhO1xuICAgICAgICAgICAgICAgICAgICBwcmljZVJhbmdlID0gY29udmVydFByaWNlUmFuZ2VUb0xvZyhyYXdSYW5nZSwgbmV3TG9nRm9ybXVsYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdTbmFwc2hvdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90ID0gY29udmVydFByaWNlUmFuZ2VUb0xvZyhyYXdTbmFwc2hvdCwgbmV3TG9nRm9ybXVsYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRQcmljZVJhbmdlKHByaWNlUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVzZXQgZW1wdHkgdG8gZGVmYXVsdFxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRQcmljZVJhbmdlKG5ldyBQcmljZVJhbmdlSW1wbCgtMC41LCAwLjUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhID0gbG9nRm9ybXVsYUZvclByaWNlUmFuZ2UobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWRGb3JSYW5nZS5faW50ZXJuYWxfaXNWYWxpZCA9IHRydWU7XG4gICAgfVxuICAgIF9wcml2YXRlX19nZXRDb29yZGluYXRlVHJhbnNmb3JtZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc1BlcmNlbnRhZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvUGVyY2VudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pbnRlcm5hbF9pc0luZGV4ZWRUbzEwMCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9JbmRleGVkVG8xMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faW50ZXJuYWxfaXNMb2coKSkge1xuICAgICAgICAgICAgcmV0dXJuIChwcmljZSkgPT4gdG9Mb2cocHJpY2UsIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZm9ybWF0VmFsdWUodmFsdWUsIGZvcm1hdHRlciwgZmFsbGJhY2tGb3JtYXR0ZXIpIHtcbiAgICAgICAgaWYgKGZvcm1hdHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZmFsbGJhY2tGb3JtYXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZhbGxiYWNrRm9ybWF0dGVyID0gdGhpcy5faW50ZXJuYWxfZm9ybWF0dGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsbGJhY2tGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyKHZhbHVlKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Zvcm1hdFByaWNlKHByaWNlLCBmYWxsYmFja0Zvcm1hdHRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0VmFsdWUocHJpY2UsIHRoaXMuX3ByaXZhdGVfX2xvY2FsaXphdGlvbk9wdGlvbnMucHJpY2VGb3JtYXR0ZXIsIGZhbGxiYWNrRm9ybWF0dGVyKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Zvcm1hdFBlcmNlbnRhZ2UocGVyY2VudGFnZSwgZmFsbGJhY2tGb3JtYXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFZhbHVlKHBlcmNlbnRhZ2UsIHRoaXMuX3ByaXZhdGVfX2xvY2FsaXphdGlvbk9wdGlvbnMucGVyY2VudGFnZUZvcm1hdHRlciwgZmFsbGJhY2tGb3JtYXR0ZXIpO1xuICAgIH1cbn1cblxuY29uc3QgREVGQVVMVF9TVFJFVENIX0ZBQ1RPUiA9IDEwMDA7XG5jbGFzcyBQYW5lIHtcbiAgICBjb25zdHJ1Y3Rvcih0aW1lU2NhbGUsIG1vZGVsKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX292ZXJsYXlTb3VyY2VzQnlTY2FsZUlkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX193aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0cmV0Y2hGYWN0b3IgPSBERUZBVUxUX1NUUkVUQ0hfRkFDVE9SO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZWRPcmRlcmVkU291cmNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Rlc3Ryb3llZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUgPSB0aW1lU2NhbGU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2dyaWQgPSBuZXcgR3JpZCh0aGlzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1vZGVsLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fY3JlYXRlUHJpY2VTY2FsZShcImxlZnRcIiAvKiBEZWZhdWx0UHJpY2VTY2FsZUlkLkxlZnQgKi8sIG9wdGlvbnMubGVmdFByaWNlU2NhbGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19jcmVhdGVQcmljZVNjYWxlKFwicmlnaHRcIiAvKiBEZWZhdWx0UHJpY2VTY2FsZUlkLlJpZ2h0ICovLCBvcHRpb25zLnJpZ2h0UHJpY2VTY2FsZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlLl9pbnRlcm5hbF9tb2RlQ2hhbmdlZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUodGhpcy5fcHJpdmF0ZV9fb25QcmljZVNjYWxlTW9kZUNoYW5nZWQuYmluZCh0aGlzLCB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZSksIHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUuX2ludGVybmFsX21vZGVDaGFuZ2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19vblByaWNlU2NhbGVNb2RlQ2hhbmdlZC5iaW5kKHRoaXMsIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VTY2FsZSksIHRoaXMpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9hcHBseVNjYWxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2FwcGx5U2NhbGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVmdFByaWNlU2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlLl9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucy5sZWZ0UHJpY2VTY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucmlnaHRQcmljZVNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUuX2ludGVybmFsX2FwcGx5T3B0aW9ucyhvcHRpb25zLnJpZ2h0UHJpY2VTY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxpemF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZS5faW50ZXJuYWxfdXBkYXRlRm9ybWF0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUuX2ludGVybmFsX3VwZGF0ZUZvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm92ZXJsYXlQcmljZVNjYWxlcykge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlQXJyYXlzID0gQXJyYXkuZnJvbSh0aGlzLl9wcml2YXRlX19vdmVybGF5U291cmNlc0J5U2NhbGVJZC52YWx1ZXMoKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFyciBvZiBzb3VyY2VBcnJheXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gZW5zdXJlTm90TnVsbChhcnJbMF0uX2ludGVybmFsX3ByaWNlU2NhbGUoKSk7XG4gICAgICAgICAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMub3ZlcmxheVByaWNlU2NhbGVzKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbGl6YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfdXBkYXRlRm9ybWF0dGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZVNjYWxlQnlJZChpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgICAgICBjYXNlIFwibGVmdFwiIC8qIERlZmF1bHRQcmljZVNjYWxlSWQuTGVmdCAqLzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiIC8qIERlZmF1bHRQcmljZVNjYWxlSWQuUmlnaHQgKi86IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19vdmVybGF5U291cmNlc0J5U2NhbGVJZC5oYXMoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5zdXJlRGVmaW5lZCh0aGlzLl9wcml2YXRlX19vdmVybGF5U291cmNlc0J5U2NhbGVJZC5nZXQoaWQpKVswXS5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcHJpY2VTY2FsZXNPcHRpb25zQ2hhbmdlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGUuX2ludGVybmFsX21vZGVDaGFuZ2VkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUuX2ludGVybmFsX21vZGVDaGFuZ2VkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuX2ludGVybmFsX2Rlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Rlc3Ryb3llZC5faW50ZXJuYWxfZmlyZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RyZXRjaEZhY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3N0cmV0Y2hGYWN0b3I7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRTdHJldGNoRmFjdG9yKGZhY3Rvcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdHJldGNoRmFjdG9yID0gZmFjdG9yO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW9kZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tb2RlbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3dpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fd2lkdGg7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9oZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19oZWlnaHQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRXaWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX193aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVBbGxTb3VyY2VzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGUuX2ludGVybmFsX3NldEhlaWdodChoZWlnaHQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUuX2ludGVybmFsX3NldEhlaWdodChoZWlnaHQpO1xuICAgICAgICAvLyBwcm9jZXNzIG92ZXJsYXlzXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLmZvckVhY2goKGRzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNPdmVybGF5KGRzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSBkcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmljZVNjYWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX3NldEhlaWdodChoZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUFsbFNvdXJjZXMoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RhdGFTb3VyY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pc092ZXJsYXkoc291cmNlKSB7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSBzb3VyY2UuX2ludGVybmFsX3ByaWNlU2NhbGUoKTtcbiAgICAgICAgaWYgKHByaWNlU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZSAhPT0gcHJpY2VTY2FsZSAmJiB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUgIT09IHByaWNlU2NhbGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hZGREYXRhU291cmNlKHNvdXJjZSwgdGFyZ2V0U2NhbGVJZCwgek9yZGVyKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFpPcmRlciA9ICh6T3JkZXIgIT09IHVuZGVmaW5lZCkgPyB6T3JkZXIgOiB0aGlzLl9wcml2YXRlX19nZXRaT3JkZXJNaW5NYXgoKS5faW50ZXJuYWxfbWF4Wk9yZGVyICsgMTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5zZXJ0RGF0YVNvdXJjZShzb3VyY2UsIHRhcmdldFNjYWxlSWQsIHRhcmdldFpPcmRlcik7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW1vdmVEYXRhU291cmNlKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcbiAgICAgICAgYXNzZXJ0KGluZGV4ICE9PSAtMSwgJ3JlbW92ZURhdGFTb3VyY2U6IGludmFsaWQgZGF0YSBzb3VyY2UnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZUlkID0gZW5zdXJlTm90TnVsbChzb3VyY2UuX2ludGVybmFsX3ByaWNlU2NhbGUoKSkuX2ludGVybmFsX2lkKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19vdmVybGF5U291cmNlc0J5U2NhbGVJZC5oYXMocHJpY2VTY2FsZUlkKSkge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheVNvdXJjZXMgPSBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX292ZXJsYXlTb3VyY2VzQnlTY2FsZUlkLmdldChwcmljZVNjYWxlSWQpKTtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlJbmRleCA9IG92ZXJsYXlTb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcbiAgICAgICAgICAgIGlmIChvdmVybGF5SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheVNvdXJjZXMuc3BsaWNlKG92ZXJsYXlJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXlTb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vdmVybGF5U291cmNlc0J5U2NhbGVJZC5kZWxldGUocHJpY2VTY2FsZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHNvdXJjZS5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICAvLyBpZiBzb3VyY2UgaGFzIG93bmVyLCBpdCByZXR1cm5zIG93bmVyJ3MgcHJpY2Ugc2NhbGVcbiAgICAgICAgLy8gYW5kIGl0IGRvZXMgbm90IGhhdmUgc291cmNlIGluIHRoZWlyIGxpc3RcbiAgICAgICAgaWYgKHByaWNlU2NhbGUgJiYgcHJpY2VTY2FsZS5faW50ZXJuYWxfZGF0YVNvdXJjZXMoKS5pbmRleE9mKHNvdXJjZSkgPj0gMCkge1xuICAgICAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfcmVtb3ZlRGF0YVNvdXJjZShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmljZVNjYWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9pbnZhbGlkYXRlU291cmNlc0NhY2hlKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZVByaWNlU2NhbGUocHJpY2VTY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGVkT3JkZXJlZFNvdXJjZXMgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VTY2FsZVBvc2l0aW9uKHByaWNlU2NhbGUpIHtcbiAgICAgICAgaWYgKHByaWNlU2NhbGUgPT09IHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmljZVNjYWxlID09PSB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnb3ZlcmxheSc7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sZWZ0UHJpY2VTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmlnaHRQcmljZVNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RhcnRTY2FsZVByaWNlKHByaWNlU2NhbGUsIHgpIHtcbiAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfc3RhcnRTY2FsZSh4KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NjYWxlUHJpY2VUbyhwcmljZVNjYWxlLCB4KSB7XG4gICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX3NjYWxlVG8oeCk7XG4gICAgICAgIC8vIFRPRE86IGJlIG1vcmUgc21hcnQgYW5kIHVwZGF0ZSBvbmx5IGFmZmVjdGVkIHZpZXdzXG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUFsbFNvdXJjZXMoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2VuZFNjYWxlUHJpY2UocHJpY2VTY2FsZSkge1xuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9lbmRTY2FsZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RhcnRTY3JvbGxQcmljZShwcmljZVNjYWxlLCB4KSB7XG4gICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX3N0YXJ0U2Nyb2xsKHgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2Nyb2xsUHJpY2VUbyhwcmljZVNjYWxlLCB4KSB7XG4gICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX3Njcm9sbFRvKHgpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVBbGxTb3VyY2VzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9lbmRTY3JvbGxQcmljZShwcmljZVNjYWxlKSB7XG4gICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX2VuZFNjcm9sbCgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlQWxsU291cmNlcygpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgICAgICAgICBzb3VyY2UuX2ludGVybmFsX3VwZGF0ZUFsbFZpZXdzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVmYXVsdFByaWNlU2NhbGUoKSB7XG4gICAgICAgIGxldCBwcmljZVNjYWxlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9vcHRpb25zKCkucmlnaHRQcmljZVNjYWxlLnZpc2libGUgJiYgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlLl9pbnRlcm5hbF9kYXRhU291cmNlcygpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VTY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpLmxlZnRQcmljZVNjYWxlLnZpc2libGUgJiYgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGUuX2ludGVybmFsX2RhdGFTb3VyY2VzKCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXNbMF0uX2ludGVybmFsX3ByaWNlU2NhbGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpY2VTY2FsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VTY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJpY2VTY2FsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RlZmF1bHRWaXNpYmxlUHJpY2VTY2FsZSgpIHtcbiAgICAgICAgbGV0IHByaWNlU2NhbGUgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX29wdGlvbnMoKS5yaWdodFByaWNlU2NhbGUudmlzaWJsZSkge1xuICAgICAgICAgICAgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VTY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpLmxlZnRQcmljZVNjYWxlLnZpc2libGUpIHtcbiAgICAgICAgICAgIHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJpY2VTY2FsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VTY2FsZShwcmljZVNjYWxlKSB7XG4gICAgICAgIGlmIChwcmljZVNjYWxlID09PSBudWxsIHx8ICFwcmljZVNjYWxlLl9pbnRlcm5hbF9pc0F1dG9TY2FsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVjYWxjdWxhdGVQcmljZVNjYWxlSW1wbChwcmljZVNjYWxlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Jlc2V0UHJpY2VTY2FsZShwcmljZVNjYWxlKSB7XG4gICAgICAgIGNvbnN0IHZpc2libGVCYXJzID0gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF92aXNpYmxlU3RyaWN0UmFuZ2UoKTtcbiAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfc2V0TW9kZSh7IF9pbnRlcm5hbF9hdXRvU2NhbGU6IHRydWUgfSk7XG4gICAgICAgIGlmICh2aXNpYmxlQmFycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVJhbmdlKHZpc2libGVCYXJzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVBbGxTb3VyY2VzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb21lbnRhcnlBdXRvU2NhbGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY2FsY3VsYXRlUHJpY2VTY2FsZUltcGwodGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0ZVByaWNlU2NhbGVJbXBsKHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VTY2FsZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZWNhbGN1bGF0ZSgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVNjYWxlKHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVNjYWxlKHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VTY2FsZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLmZvckVhY2goKGRzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNPdmVybGF5KGRzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VTY2FsZShkcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUFsbFNvdXJjZXMoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcmRlcmVkU291cmNlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NhY2hlZE9yZGVyZWRTb3VyY2VzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZWRPcmRlcmVkU291cmNlcyA9IHNvcnRTb3VyY2VzKHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2FjaGVkT3JkZXJlZFNvdXJjZXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vbkRlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Rlc3Ryb3llZDtcbiAgICB9XG4gICAgX2ludGVybmFsX2dyaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19ncmlkO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcmVjYWxjdWxhdGVQcmljZVNjYWxlSW1wbChwcmljZVNjYWxlKSB7XG4gICAgICAgIC8vIFRPRE86IGNhbiB1c2UgdGhpcyBjaGVja3NcbiAgICAgICAgY29uc3Qgc291cmNlRm9yQXV0b1NjYWxlID0gcHJpY2VTY2FsZS5faW50ZXJuYWxfc291cmNlc0ZvckF1dG9TY2FsZSgpO1xuICAgICAgICBpZiAoc291cmNlRm9yQXV0b1NjYWxlICYmIHNvdXJjZUZvckF1dG9TY2FsZS5sZW5ndGggPiAwICYmICF0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgY29uc3QgdmlzaWJsZUJhcnMgPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3Zpc2libGVTdHJpY3RSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKHZpc2libGVCYXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVJhbmdlKHZpc2libGVCYXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cygpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZ2V0Wk9yZGVyTWluTWF4KCkge1xuICAgICAgICBjb25zdCBzb3VyY2VzID0gdGhpcy5faW50ZXJuYWxfb3JkZXJlZFNvdXJjZXMoKTtcbiAgICAgICAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBfaW50ZXJuYWxfbWluWk9yZGVyOiAwLCBfaW50ZXJuYWxfbWF4Wk9yZGVyOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1pblpPcmRlciA9IDA7XG4gICAgICAgIGxldCBtYXhaT3JkZXIgPSAwO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNvdXJjZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRzID0gc291cmNlc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IHpPcmRlciA9IGRzLl9pbnRlcm5hbF96b3JkZXIoKTtcbiAgICAgICAgICAgIGlmICh6T3JkZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoek9yZGVyIDwgbWluWk9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblpPcmRlciA9IHpPcmRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHpPcmRlciA+IG1heFpPcmRlcikge1xuICAgICAgICAgICAgICAgICAgICBtYXhaT3JkZXIgPSB6T3JkZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IF9pbnRlcm5hbF9taW5aT3JkZXI6IG1pblpPcmRlciwgX2ludGVybmFsX21heFpPcmRlcjogbWF4Wk9yZGVyIH07XG4gICAgfVxuICAgIF9wcml2YXRlX19pbnNlcnREYXRhU291cmNlKHNvdXJjZSwgcHJpY2VTY2FsZUlkLCB6T3JkZXIpIHtcbiAgICAgICAgbGV0IHByaWNlU2NhbGUgPSB0aGlzLl9pbnRlcm5hbF9wcmljZVNjYWxlQnlJZChwcmljZVNjYWxlSWQpO1xuICAgICAgICBpZiAocHJpY2VTY2FsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX2NyZWF0ZVByaWNlU2NhbGUocHJpY2VTY2FsZUlkLCB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpLm92ZXJsYXlQcmljZVNjYWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgICBpZiAoIWlzRGVmYXVsdFByaWNlU2NhbGUocHJpY2VTY2FsZUlkKSkge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheVNvdXJjZXMgPSB0aGlzLl9wcml2YXRlX19vdmVybGF5U291cmNlc0J5U2NhbGVJZC5nZXQocHJpY2VTY2FsZUlkKSB8fCBbXTtcbiAgICAgICAgICAgIG92ZXJsYXlTb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX292ZXJsYXlTb3VyY2VzQnlTY2FsZUlkLnNldChwcmljZVNjYWxlSWQsIG92ZXJsYXlTb3VyY2VzKTtcbiAgICAgICAgfVxuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9hZGREYXRhU291cmNlKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZS5faW50ZXJuYWxfc2V0UHJpY2VTY2FsZShwcmljZVNjYWxlKTtcbiAgICAgICAgc291cmNlLl9pbnRlcm5hbF9zZXRab3JkZXIoek9yZGVyKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVNjYWxlKHByaWNlU2NhbGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZWRPcmRlcmVkU291cmNlcyA9IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19vblByaWNlU2NhbGVNb2RlQ2hhbmdlZChwcmljZVNjYWxlLCBvbGRNb2RlLCBuZXdNb2RlKSB7XG4gICAgICAgIGlmIChvbGRNb2RlLl9pbnRlcm5hbF9tb2RlID09PSBuZXdNb2RlLl9pbnRlcm5hbF9tb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW9tZW50YXJ5IGF1dG8gc2NhbGUgaWYgd2UgdG9nZ2xlIHBlcmNlbnRhZ2UvaW5kZXhlZFRvMTAwIG1vZGVcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVjYWxjdWxhdGVQcmljZVNjYWxlSW1wbChwcmljZVNjYWxlKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NyZWF0ZVByaWNlU2NhbGUoaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWN0dWFsT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyB2aXNpYmxlOiB0cnVlLCBhdXRvU2NhbGU6IHRydWUgfSwgY2xvbmUob3B0aW9ucykpO1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gbmV3IFByaWNlU2NhbGUoaWQsIGFjdHVhbE9wdGlvbnMsIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9vcHRpb25zKCkubGF5b3V0LCB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpLmxvY2FsaXphdGlvbik7XG4gICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX3NldEhlaWdodCh0aGlzLl9pbnRlcm5hbF9oZWlnaHQoKSk7XG4gICAgICAgIHJldHVybiBwcmljZVNjYWxlO1xuICAgIH1cbn1cblxuY2xhc3MgRm9ybWF0dGVkTGFiZWxzQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKGZvcm1hdCwgaG9yelNjYWxlQmVoYXZpb3IsIHNpemUgPSA1MCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hY3R1YWxTaXplID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXNhZ2VUaWNrID0gMTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb2xkZXN0VGljayA9IDE7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aWNrMkxhYmVscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvciA9IGhvcnpTY2FsZUJlaGF2aW9yO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXhTaXplID0gc2l6ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Zvcm1hdCh0aWNrTWFyaykge1xuICAgICAgICBjb25zdCB0aW1lID0gdGlja01hcmsudGltZTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5jYWNoZUtleSh0aW1lKTtcbiAgICAgICAgY29uc3QgdGljayA9IHRoaXMuX3ByaXZhdGVfX2NhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgIGlmICh0aWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aWNrLl9pbnRlcm5hbF9zdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2FjdHVhbFNpemUgPT09IHRoaXMuX3ByaXZhdGVfX21heFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZGVzdFZhbHVlID0gdGhpcy5fcHJpdmF0ZV9fdGljazJMYWJlbHMuZ2V0KHRoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2spO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGljazJMYWJlbHMuZGVsZXRlKHRoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2spO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGUuZGVsZXRlKGVuc3VyZURlZmluZWQob2xkZXN0VmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2srKztcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjdHVhbFNpemUtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHIgPSB0aGlzLl9wcml2YXRlX19mb3JtYXQodGlja01hcmspO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZS5zZXQoY2FjaGVLZXksIHsgX2ludGVybmFsX3N0cmluZzogc3RyLCBfaW50ZXJuYWxfdGljazogdGhpcy5fcHJpdmF0ZV9fdXNhZ2VUaWNrIH0pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aWNrMkxhYmVscy5zZXQodGhpcy5fcHJpdmF0ZV9fdXNhZ2VUaWNrLCBjYWNoZUtleSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjdHVhbFNpemUrKztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXNhZ2VUaWNrKys7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufVxuXG5jbGFzcyBSYW5nZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGFzc2VydChsZWZ0IDw9IHJpZ2h0LCAncmlnaHQgc2hvdWxkIGJlID49IGxlZnQnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0ID0gcmlnaHQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbGVmdDtcbiAgICB9XG4gICAgX2ludGVybmFsX3JpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmlnaHQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JpZ2h0IC0gdGhpcy5fcHJpdmF0ZV9fbGVmdCArIDE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jb250YWlucyhpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbGVmdCA8PSBpbmRleCAmJiBpbmRleCA8PSB0aGlzLl9wcml2YXRlX19yaWdodDtcbiAgICB9XG4gICAgX2ludGVybmFsX2VxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbGVmdCA9PT0gb3RoZXIuX2ludGVybmFsX2xlZnQoKSAmJiB0aGlzLl9wcml2YXRlX19yaWdodCA9PT0gb3RoZXIuX2ludGVybmFsX3JpZ2h0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXJlUmFuZ2VzRXF1YWwoZmlyc3QsIHNlY29uZCkge1xuICAgIGlmIChmaXJzdCA9PT0gbnVsbCB8fCBzZWNvbmQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0ID09PSBzZWNvbmQ7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdC5faW50ZXJuYWxfZXF1YWxzKHNlY29uZCk7XG59XG5cbmNsYXNzIFRpY2tNYXJrcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQnlXZWlnaHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5pZm9ybURpc3RyaWJ1dGlvbiA9IGZhbHNlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0VW5pZm9ybURpc3RyaWJ1dGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5pZm9ybURpc3RyaWJ1dGlvbiA9IHZhbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGUgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0VGltZVNjYWxlUG9pbnRzKG5ld1BvaW50cywgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW1vdmVNYXJrc1NpbmNlSW5kZXgoZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSBmaXJzdENoYW5nZWRQb2ludEluZGV4OyBpbmRleCA8IG5ld1BvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gbmV3UG9pbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGxldCBtYXJrc0ZvcldlaWdodCA9IHRoaXMuX3ByaXZhdGVfX21hcmtzQnlXZWlnaHQuZ2V0KHBvaW50LnRpbWVXZWlnaHQpO1xuICAgICAgICAgICAgaWYgKG1hcmtzRm9yV2VpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrc0ZvcldlaWdodCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQnlXZWlnaHQuc2V0KHBvaW50LnRpbWVXZWlnaHQsIG1hcmtzRm9yV2VpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcmtzRm9yV2VpZ2h0LnB1c2goe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICB0aW1lOiBwb2ludC50aW1lLFxuICAgICAgICAgICAgICAgIHdlaWdodDogcG9pbnQudGltZVdlaWdodCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFRpbWU6IHBvaW50Lm9yaWdpbmFsVGltZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9idWlsZChzcGFjaW5nLCBtYXhXaWR0aCkge1xuICAgICAgICBjb25zdCBtYXhJbmRleGVzUGVyTWFyayA9IE1hdGguY2VpbChtYXhXaWR0aCAvIHNwYWNpbmcpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2FjaGUgPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fY2FjaGUuX2ludGVybmFsX21heEluZGV4ZXNQZXJNYXJrICE9PSBtYXhJbmRleGVzUGVyTWFyaykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGUgPSB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX21hcmtzOiB0aGlzLl9wcml2YXRlX19idWlsZE1hcmtzSW1wbChtYXhJbmRleGVzUGVyTWFyayksXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX21heEluZGV4ZXNQZXJNYXJrOiBtYXhJbmRleGVzUGVyTWFyayxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NhY2hlLl9pbnRlcm5hbF9tYXJrcztcbiAgICB9XG4gICAgX3ByaXZhdGVfX3JlbW92ZU1hcmtzU2luY2VJbmRleChzaW5jZUluZGV4KSB7XG4gICAgICAgIGlmIChzaW5jZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrc0J5V2VpZ2h0LmNsZWFyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2VpZ2h0c1RvQ2xlYXIgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya3NCeVdlaWdodC5mb3JFYWNoKChtYXJrcywgdGltZVdlaWdodCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNpbmNlSW5kZXggPD0gbWFya3NbMF0uaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzVG9DbGVhci5wdXNoKHRpbWVXZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFya3Muc3BsaWNlKGxvd2VyQm91bmQobWFya3MsIHNpbmNlSW5kZXgsICh0bSkgPT4gdG0uaW5kZXggPCBzaW5jZUluZGV4KSwgSW5maW5pdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCB3ZWlnaHQgb2Ygd2VpZ2h0c1RvQ2xlYXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQnlXZWlnaHQuZGVsZXRlKHdlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2J1aWxkTWFya3NJbXBsKG1heEluZGV4ZXNQZXJNYXJrKSB7XG4gICAgICAgIGxldCBtYXJrcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHdlaWdodCBvZiBBcnJheS5mcm9tKHRoaXMuX3ByaXZhdGVfX21hcmtzQnlXZWlnaHQua2V5cygpKS5zb3J0KChhLCBiKSA9PiBiIC0gYSkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fbWFya3NCeVdlaWdodC5nZXQod2VpZ2h0KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQnVpbHQgdGlja01hcmtzIGFyZSBub3cgcHJldk1hcmtzLCBhbmQgbWFya3MgaXQgYXMgbmV3IGFycmF5XG4gICAgICAgICAgICBjb25zdCBwcmV2TWFya3MgPSBtYXJrcztcbiAgICAgICAgICAgIG1hcmtzID0gW107XG4gICAgICAgICAgICBjb25zdCBwcmV2TWFya3NMZW5ndGggPSBwcmV2TWFya3MubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHByZXZNYXJrc1BvaW50ZXIgPSAwO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFdlaWdodCA9IGVuc3VyZURlZmluZWQodGhpcy5fcHJpdmF0ZV9fbWFya3NCeVdlaWdodC5nZXQod2VpZ2h0KSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50V2VpZ2h0TGVuZ3RoID0gY3VycmVudFdlaWdodC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcmlnaHRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgbGV0IGxlZnRJbmRleCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudFdlaWdodExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFyayA9IGN1cnJlbnRXZWlnaHRbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gbWFyay5pbmRleDtcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaW5kZXhlcyB3aXRoIHdoaWNoIGN1cnJlbnQgaW5kZXggd2lsbCBiZSBjb21wYXJlZFxuICAgICAgICAgICAgICAgIC8vIEFsbCBtYXJrcyB0byB0aGUgcmlnaHQgaXMgbW92ZWQgdG8gbmV3IGFycmF5XG4gICAgICAgICAgICAgICAgd2hpbGUgKHByZXZNYXJrc1BvaW50ZXIgPCBwcmV2TWFya3NMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdE1hcmsgPSBwcmV2TWFya3NbcHJldk1hcmtzUG9pbnRlcl07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGxhc3RNYXJrLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4IDwgY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2TWFya3NQb2ludGVyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKGxhc3RNYXJrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmlnaHRJbmRleCAtIGN1cnJlbnRJbmRleCA+PSBtYXhJbmRleGVzUGVyTWFyayAmJiBjdXJyZW50SW5kZXggLSBsZWZ0SW5kZXggPj0gbWF4SW5kZXhlc1Blck1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGlja01hcmsgZml0cy4gUGxhY2UgaXQgaW50byBuZXcgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgbWFya3MucHVzaChtYXJrKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdEluZGV4ID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3VuaWZvcm1EaXN0cmlidXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2TWFya3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQbGFjZSBhbGwgdW51c2VkIHRpY2tNYXJrcyBpbnRvIG5ldyBhcnJheTtcbiAgICAgICAgICAgIGZvciAoOyBwcmV2TWFya3NQb2ludGVyIDwgcHJldk1hcmtzTGVuZ3RoOyBwcmV2TWFya3NQb2ludGVyKyspIHtcbiAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKHByZXZNYXJrc1twcmV2TWFya3NQb2ludGVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbn1cblxuY2xhc3MgVGltZVNjYWxlVmlzaWJsZVJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2dpY2FsUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlID0gbG9naWNhbFJhbmdlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RyaWN0UmFuZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sb2dpY2FsUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2VJbXBsKE1hdGguZmxvb3IodGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlLl9pbnRlcm5hbF9sZWZ0KCkpLCBNYXRoLmNlaWwodGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlLl9pbnRlcm5hbF9yaWdodCgpKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sb2dpY2FsUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sb2dpY2FsUmFuZ2U7XG4gICAgfVxuICAgIHN0YXRpYyBfaW50ZXJuYWxfaW52YWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lU2NhbGVWaXNpYmxlUmFuZ2UobnVsbCk7XG4gICAgfVxufVxuXG5jb25zdCBkZWZhdWx0VGlja01hcmtNYXhDaGFyYWN0ZXJMZW5ndGggPSA4O1xuZnVuY3Rpb24gbWFya1dpdGhHcmVhdGVyV2VpZ2h0KGEsIGIpIHtcbiAgICByZXR1cm4gYS53ZWlnaHQgPiBiLndlaWdodCA/IGEgOiBiO1xufVxuY2xhc3MgVGltZVNjYWxlIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCwgb3B0aW9ucywgbG9jYWxpemF0aW9uT3B0aW9ucywgaG9yelNjYWxlQmVoYXZpb3IpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fd2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlSW5kZXhPck51bGwgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NjYWxlU3RhcnRQb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpY2tNYXJrcyA9IG5ldyBUaWNrTWFya3MoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVkQnlXZWlnaHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZSA9IFRpbWVTY2FsZVZpc2libGVSYW5nZS5faW50ZXJuYWxfaW52YWxpZCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVCYXJzQ2hhbmdlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb2dpY2FsUmFuZ2VDaGFuZ2VkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnNBcHBsaWVkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbW1vblRyYW5zaXRpb25TdGFydFN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZU1hcmtzQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sYWJlbHMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvY2FsaXphdGlvbk9wdGlvbnMgPSBsb2NhbGl6YXRpb25PcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodE9mZnNldCA9IG9wdGlvbnMucmlnaHRPZmZzZXQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcgPSBvcHRpb25zLmJhclNwYWNpbmc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yID0gaG9yelNjYWxlQmVoYXZpb3I7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZURhdGVUaW1lRm9ybWF0dGVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpY2tNYXJrcy5faW50ZXJuYWxfc2V0VW5pZm9ybURpc3RyaWJ1dGlvbihvcHRpb25zLnVuaWZvcm1EaXN0cmlidXRpb24pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseUxvY2FsaXphdGlvbk9wdGlvbnMobG9jYWxpemF0aW9uT3B0aW9ucykge1xuICAgICAgICBtZXJnZSh0aGlzLl9wcml2YXRlX19sb2NhbGl6YXRpb25PcHRpb25zLCBsb2NhbGl6YXRpb25PcHRpb25zKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZVRpY2tNYXJrcygpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVEYXRlVGltZUZvcm1hdHRlcigpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMsIGxvY2FsaXphdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBtZXJnZSh0aGlzLl9wcml2YXRlX19vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuZml4TGVmdEVkZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RvRml4TGVmdEVkZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5maXhSaWdodEVkZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RvRml4UmlnaHRFZGdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90ZSB0aGF0IGJhciBzcGFjaW5nIHNob3VsZCBiZSBhcHBsaWVkIGJlZm9yZSByaWdodCBvZmZzZXRcbiAgICAgICAgLy8gYmVjYXVzZSByaWdodCBvZmZzZXQgZGVwZW5kcyBvbiBiYXIgc3BhY2luZ1xuICAgICAgICBpZiAob3B0aW9ucy5iYXJTcGFjaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9zZXRCYXJTcGFjaW5nKG9wdGlvbnMuYmFyU3BhY2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucmlnaHRPZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KG9wdGlvbnMucmlnaHRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1pbkJhclNwYWNpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8geWVzLCBpZiB3ZSBhcHBseSBtaW4gYmFyIHNwYWNpbmcgdGhlbiB3ZSBuZWVkIHRvIGNvcnJlY3QgYmFyIHNwYWNpbmdcbiAgICAgICAgICAgIC8vIHRoZSBlYXNpZXN0IHdheSBpcyB0byBhcHBseSBpdCBvbmNlIGFnYWluXG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2V0QmFyU3BhY2luZygoX2EgPSBvcHRpb25zLmJhclNwYWNpbmcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVUaWNrTWFya3MoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlRGF0ZVRpbWVGb3JtYXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9uc0FwcGxpZWQuX2ludGVybmFsX2ZpcmUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2luZGV4VG9UaW1lKGluZGV4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wcml2YXRlX19wb2ludHNbaW5kZXhdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGltZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2luZGV4VG9UaW1lU2NhbGVQb2ludChpbmRleCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9wcml2YXRlX19wb2ludHNbaW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGltZVRvSW5kZXgodGltZSwgZmluZE5lYXJlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3BvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAvLyBubyB0aW1lIHBvaW50cyBhdmFpbGFibGVcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkodGltZSkgPiB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkodGhpcy5fcHJpdmF0ZV9fcG9pbnRzW3RoaXMuX3ByaXZhdGVfX3BvaW50cy5sZW5ndGggLSAxXS50aW1lKSkge1xuICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlXG4gICAgICAgICAgICByZXR1cm4gZmluZE5lYXJlc3QgPyB0aGlzLl9wcml2YXRlX19wb2ludHMubGVuZ3RoIC0gMSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSBsb3dlckJvdW5kKHRoaXMuX3ByaXZhdGVfX3BvaW50cywgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KHRpbWUpLCAoYSwgYikgPT4gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KGEudGltZSkgPCBiKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleSh0aW1lKSA8IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleSh0aGlzLl9wcml2YXRlX19wb2ludHNbaW5kZXhdLnRpbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmluZE5lYXJlc3QgPyBpbmRleCA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3dpZHRoID09PSAwIHx8IHRoaXMuX3ByaXZhdGVfX3BvaW50cy5sZW5ndGggPT09IDAgfHwgdGhpcy5fcHJpdmF0ZV9fYmFzZUluZGV4T3JOdWxsID09PSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaGFzUG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcG9pbnRzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8vIHN0cmljdCByYW5nZTogaW50ZWdlciBpbmRpY2VzIG9mIHRoZSBiYXJzIGluIHRoZSB2aXNpYmxlIHJhbmdlIHJvdW5kZWQgaW4gbW9yZSB3aWRlIGRpcmVjdGlvblxuICAgIF9pbnRlcm5hbF92aXNpYmxlU3RyaWN0UmFuZ2UoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZVZpc2libGVSYW5nZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlLl9pbnRlcm5hbF9zdHJpY3RSYW5nZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdmlzaWJsZUxvZ2ljYWxSYW5nZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlVmlzaWJsZVJhbmdlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2UuX2ludGVybmFsX2xvZ2ljYWxSYW5nZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdmlzaWJsZVRpbWVSYW5nZSgpIHtcbiAgICAgICAgY29uc3QgdmlzaWJsZUJhcnMgPSB0aGlzLl9pbnRlcm5hbF92aXNpYmxlU3RyaWN0UmFuZ2UoKTtcbiAgICAgICAgaWYgKHZpc2libGVCYXJzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgICAgIGZyb206IHZpc2libGVCYXJzLl9pbnRlcm5hbF9sZWZ0KCksXG4gICAgICAgICAgICB0bzogdmlzaWJsZUJhcnMuX2ludGVybmFsX3JpZ2h0KCksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF90aW1lUmFuZ2VGb3JMb2dpY2FsUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGltZVJhbmdlRm9yTG9naWNhbFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSBNYXRoLnJvdW5kKHJhbmdlLmZyb20pO1xuICAgICAgICBjb25zdCB0byA9IE1hdGgucm91bmQocmFuZ2UudG8pO1xuICAgICAgICBjb25zdCBmaXJzdEluZGV4ID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19maXJzdEluZGV4KCkpO1xuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2xhc3RJbmRleCgpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfaW5kZXhUb1RpbWVTY2FsZVBvaW50KE1hdGgubWF4KGZpcnN0SW5kZXgsIGZyb20pKSksXG4gICAgICAgICAgICB0bzogZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF9pbmRleFRvVGltZVNjYWxlUG9pbnQoTWF0aC5taW4obGFzdEluZGV4LCB0bykpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2ludGVybmFsX2xvZ2ljYWxSYW5nZUZvclRpbWVSYW5nZShyYW5nZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF90aW1lVG9JbmRleChyYW5nZS5mcm9tLCB0cnVlKSksXG4gICAgICAgICAgICB0bzogZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF90aW1lVG9JbmRleChyYW5nZS50bywgdHJ1ZSkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX193aWR0aDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFdpZHRoKG5ld1dpZHRoKSB7XG4gICAgICAgIGlmICghaXNGaW5pdGUobmV3V2lkdGgpIHx8IG5ld1dpZHRoIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fd2lkdGggPT09IG5ld1dpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2hlbiB3ZSBjaGFuZ2UgdGhlIHdpZHRoIGFuZCB3ZSBuZWVkIHRvIGNvcnJlY3QgdmlzaWJsZSByYW5nZSBiZWNhdXNlIG9mIGZpeGluZyBsZWZ0IGVkZ2VcbiAgICAgICAgLy8gd2UgbmVlZCB0byBjaGVjayB0aGUgcHJldmlvdXMgdmlzaWJsZSByYW5nZSByYXRoZXIgdGhhbiB0aGUgbmV3IG9uZVxuICAgICAgICAvLyBiZWNhdXNlIGl0IG1pZ2h0IGJlIHVwZGF0ZWQgYnkgY2hhbmdpbmcgd2lkdGgsIGJhciBzcGFjaW5nLCBldGNcbiAgICAgICAgLy8gYnV0IHdlIG5lZWQgdG8gdHJ5IHRvIGtlZXAgdGhlIHNhbWUgcmFuZ2VcbiAgICAgICAgY29uc3QgcHJldmlvdXNWaXNpYmxlUmFuZ2UgPSB0aGlzLl9pbnRlcm5hbF92aXNpYmxlTG9naWNhbFJhbmdlKCk7XG4gICAgICAgIGNvbnN0IG9sZFdpZHRoID0gdGhpcy5fcHJpdmF0ZV9fd2lkdGg7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3dpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubG9ja1Zpc2libGVUaW1lUmFuZ2VPblJlc2l6ZSAmJiBvbGRXaWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gcmVjYWxjdWxhdGUgYmFyIHNwYWNpbmdcbiAgICAgICAgICAgIGNvbnN0IG5ld0JhclNwYWNpbmcgPSB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nICogbmV3V2lkdGggLyBvbGRXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcgPSBuZXdCYXJTcGFjaW5nO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRpbWUgc2NhbGUgaXMgc2Nyb2xsZWQgdG8gdGhlIGVuZCBvZiBkYXRhIGFuZCB3ZSBoYXZlIGZpeGVkIHJpZ2h0IGVkZ2VcbiAgICAgICAgLy8ga2VlcCBsZWZ0IGVkZ2UgaW5zdGVhZCBvZiByaWdodFxuICAgICAgICAvLyB3ZSBuZWVkIGl0IHRvIGF2b2lkIFwic2hha2luZ1wiIGlmIHRoZSBsYXN0IGJhciB2aXNpYmlsaXR5IGFmZmVjdHMgdGltZSBzY2FsZSB3aWR0aFxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5maXhMZWZ0RWRnZSkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IGxvZ2ljYWwgbGVmdCByYW5nZSBtZWFucyBub3QgdGhlIG1pZGRsZSBvZiBhIGJhciAoaXQncyB0aGUgbGVmdCBib3JkZXIpXG4gICAgICAgICAgICBpZiAocHJldmlvdXNWaXNpYmxlUmFuZ2UgIT09IG51bGwgJiYgcHJldmlvdXNWaXNpYmxlUmFuZ2UuX2ludGVybmFsX2xlZnQoKSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBvbGRXaWR0aCAtIG5ld1dpZHRoO1xuICAgICAgICAgICAgICAgIC8vIHJlZHVjZSAgX3JpZ2h0T2Zmc2V0IG1lYW5zIG1vdmUgcmlnaHRcbiAgICAgICAgICAgICAgICAvLyB3ZSBjb3VsZCBtb3ZlIG1vcmUgdGhhbiByZXF1aXJlZCAtIHRoaXMgd2lsbCBiZSBmaXhlZCBieSBfY29ycmVjdE9mZnNldCgpXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgLT0gTWF0aC5yb3VuZChkZWx0YSAvIHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcpICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRpbmcgYmFyIHNwYWNpbmcgc2hvdWxkIGJlIGZpcnN0IGJlY2F1c2UgcmlnaHQgb2Zmc2V0IGRlcGVuZHMgb24gaXRcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29ycmVjdEJhclNwYWNpbmcoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29ycmVjdE9mZnNldCgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaW5kZXhUb0Nvb3JkaW5hdGUoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzRW1wdHkoKSB8fCAhaXNJbnRlZ2VyKGluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gdGhpcy5faW50ZXJuYWxfYmFzZUluZGV4KCk7XG4gICAgICAgIGNvbnN0IGRlbHRhRnJvbVJpZ2h0ID0gYmFzZUluZGV4ICsgdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgLSBpbmRleDtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZSA9IHRoaXMuX3ByaXZhdGVfX3dpZHRoIC0gKGRlbHRhRnJvbVJpZ2h0ICsgMC41KSAqIHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcgLSAxO1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2luZGV4ZXNUb0Nvb3JkaW5hdGVzKHBvaW50cywgdmlzaWJsZVJhbmdlKSB7XG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2ludGVybmFsX2Jhc2VJbmRleCgpO1xuICAgICAgICBjb25zdCBpbmRleEZyb20gPSAodmlzaWJsZVJhbmdlID09PSB1bmRlZmluZWQpID8gMCA6IHZpc2libGVSYW5nZS5mcm9tO1xuICAgICAgICBjb25zdCBpbmRleFRvID0gKHZpc2libGVSYW5nZSA9PT0gdW5kZWZpbmVkKSA/IHBvaW50cy5sZW5ndGggOiB2aXNpYmxlUmFuZ2UudG87XG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleEZyb207IGkgPCBpbmRleFRvOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcG9pbnRzW2ldLl9pbnRlcm5hbF90aW1lO1xuICAgICAgICAgICAgY29uc3QgZGVsdGFGcm9tUmlnaHQgPSBiYXNlSW5kZXggKyB0aGlzLl9wcml2YXRlX19yaWdodE9mZnNldCAtIGluZGV4O1xuICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZSA9IHRoaXMuX3ByaXZhdGVfX3dpZHRoIC0gKGRlbHRhRnJvbVJpZ2h0ICsgMC41KSAqIHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcgLSAxO1xuICAgICAgICAgICAgcG9pbnRzW2ldLl9pbnRlcm5hbF94ID0gY29vcmRpbmF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfY29vcmRpbmF0ZVRvSW5kZXgoeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0Zsb2F0SW5kZXgoeCkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0UmlnaHRPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3JlY2FsY3VsYXRlQWxsUGFuZXMoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9iYXJTcGFjaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZztcbiAgICB9XG4gICAgX2ludGVybmFsX3NldEJhclNwYWNpbmcobmV3QmFyU3BhY2luZykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRCYXJTcGFjaW5nKG5ld0JhclNwYWNpbmcpO1xuICAgICAgICAvLyBkbyBub3QgYWxsb3cgc2Nyb2xsIG91dCBvZiB2aXNpYmxlIGJhcnNcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29ycmVjdE9mZnNldCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfcmVjYWxjdWxhdGVBbGxQYW5lcygpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JpZ2h0T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQ7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgX2ludGVybmFsX21hcmtzKCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdGltZU1hcmtzQ2FjaGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX190aW1lTWFya3NDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZztcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpLmxheW91dC5mb250U2l6ZTtcbiAgICAgICAgY29uc3QgcGl4ZWxzUGVyOENoYXJhY3RlcnMgPSAoZm9udFNpemUgKyA0KSAqIDU7XG4gICAgICAgIGNvbnN0IHBpeGVsc1BlckNoYXJhY3RlciA9IHBpeGVsc1BlcjhDaGFyYWN0ZXJzIC8gZGVmYXVsdFRpY2tNYXJrTWF4Q2hhcmFjdGVyTGVuZ3RoO1xuICAgICAgICBjb25zdCBtYXhMYWJlbFdpZHRoID0gcGl4ZWxzUGVyQ2hhcmFjdGVyICogKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudGlja01hcmtNYXhDaGFyYWN0ZXJMZW5ndGggfHwgZGVmYXVsdFRpY2tNYXJrTWF4Q2hhcmFjdGVyTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaW5kZXhQZXJMYWJlbCA9IE1hdGgucm91bmQobWF4TGFiZWxXaWR0aCAvIHNwYWNpbmcpO1xuICAgICAgICBjb25zdCB2aXNpYmxlQmFycyA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfdmlzaWJsZVN0cmljdFJhbmdlKCkpO1xuICAgICAgICBjb25zdCBmaXJzdEJhciA9IE1hdGgubWF4KHZpc2libGVCYXJzLl9pbnRlcm5hbF9sZWZ0KCksIHZpc2libGVCYXJzLl9pbnRlcm5hbF9sZWZ0KCkgLSBpbmRleFBlckxhYmVsKTtcbiAgICAgICAgY29uc3QgbGFzdEJhciA9IE1hdGgubWF4KHZpc2libGVCYXJzLl9pbnRlcm5hbF9yaWdodCgpLCB2aXNpYmxlQmFycy5faW50ZXJuYWxfcmlnaHQoKSAtIGluZGV4UGVyTGFiZWwpO1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX3ByaXZhdGVfX3RpY2tNYXJrcy5faW50ZXJuYWxfYnVpbGQoc3BhY2luZywgbWF4TGFiZWxXaWR0aCk7XG4gICAgICAgIC8vIGFjY29yZGluZyB0byBpbmRleFBlckxhYmVsIHZhbHVlIHRoaXMgdmFsdWUgbWVhbnMgXCJlYXJsaWVzdCBpbmRleCB3aGljaCBfbWlnaHQgYmVfIHVzZWQgYXMgdGhlIHNlY29uZCBsYWJlbCBvbiB0aW1lIHNjYWxlXCJcbiAgICAgICAgY29uc3QgZWFybGllc3RJbmRleE9mU2Vjb25kTGFiZWwgPSB0aGlzLl9wcml2YXRlX19maXJzdEluZGV4KCkgKyBpbmRleFBlckxhYmVsO1xuICAgICAgICAvLyBhY2NvcmRpbmcgdG8gaW5kZXhQZXJMYWJlbCB2YWx1ZSB0aGlzIHZhbHVlIG1lYW5zIFwiZWFybGllc3QgaW5kZXggd2hpY2ggX21pZ2h0IGJlXyB1c2VkIGFzIHRoZSBzZWNvbmQgbGFzdCBsYWJlbCBvbiB0aW1lIHNjYWxlXCJcbiAgICAgICAgY29uc3QgaW5kZXhPZlNlY29uZExhc3RMYWJlbCA9IHRoaXMuX3ByaXZhdGVfX2xhc3RJbmRleCgpIC0gaW5kZXhQZXJMYWJlbDtcbiAgICAgICAgY29uc3QgaXNBbGxTY2FsaW5nQW5kU2Nyb2xsaW5nRGlzYWJsZWQgPSB0aGlzLl9wcml2YXRlX19pc0FsbFNjYWxpbmdBbmRTY3JvbGxpbmdEaXNhYmxlZCgpO1xuICAgICAgICBjb25zdCBpc0xlZnRFZGdlRml4ZWQgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLmZpeExlZnRFZGdlIHx8IGlzQWxsU2NhbGluZ0FuZFNjcm9sbGluZ0Rpc2FibGVkO1xuICAgICAgICBjb25zdCBpc1JpZ2h0RWRnZUZpeGVkID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5maXhSaWdodEVkZ2UgfHwgaXNBbGxTY2FsaW5nQW5kU2Nyb2xsaW5nRGlzYWJsZWQ7XG4gICAgICAgIGxldCB0YXJnZXRJbmRleCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgdG0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICghKGZpcnN0QmFyIDw9IHRtLmluZGV4ICYmIHRtLmluZGV4IDw9IGxhc3RCYXIpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGFiZWw7XG4gICAgICAgICAgICBpZiAodGFyZ2V0SW5kZXggPCB0aGlzLl9wcml2YXRlX19sYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSB0aGlzLl9wcml2YXRlX19sYWJlbHNbdGFyZ2V0SW5kZXhdO1xuICAgICAgICAgICAgICAgIGxhYmVsLmNvb3JkID0gdGhpcy5faW50ZXJuYWxfaW5kZXhUb0Nvb3JkaW5hdGUodG0uaW5kZXgpO1xuICAgICAgICAgICAgICAgIGxhYmVsLmxhYmVsID0gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0TGFiZWwodG0pO1xuICAgICAgICAgICAgICAgIGxhYmVsLndlaWdodCA9IHRtLndlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhYmVsID0ge1xuICAgICAgICAgICAgICAgICAgICBuZWVkQWxpZ25Db29yZGluYXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29vcmQ6IHRoaXMuX2ludGVybmFsX2luZGV4VG9Db29yZGluYXRlKHRtLmluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuX3ByaXZhdGVfX2Zvcm1hdExhYmVsKHRtKSxcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiB0bS53ZWlnaHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZyA+IChtYXhMYWJlbFdpZHRoIC8gMikgJiYgIWlzQWxsU2NhbGluZ0FuZFNjcm9sbGluZ0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIHRoZW4gbGV0J3Mgc2hvdyBhbGwgdGljayBtYXJrcyBhcyB1c3VhbFxuICAgICAgICAgICAgICAgIGxhYmVsLm5lZWRBbGlnbkNvb3JkaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIGEgdXNlciBpcyBhYmxlIHRvIHNjcm9sbCBhZnRlciBhIHRpY2sgbWFyayB0aGVuIHNob3cgaXQgYXMgdXN1YWwsIG90aGVyd2lzZSB0aGUgY29vcmRpbmF0ZSBtaWdodCBiZSBhbGlnbmVkXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGluZGV4IGlzIGZvciB0aGUgc2Vjb25kIChsYXN0KSBsYWJlbCBvciBsYXRlciAoZWFybGllcikgdGhlbiBtb3N0IGxpa2VseSB0aGlzIGxhYmVsIG1pZ2h0IGJlIGRpc3BsYXllZCB3aXRob3V0IGNvcnJlY3RpbmcgdGhlIGNvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICBsYWJlbC5uZWVkQWxpZ25Db29yZGluYXRlID0gKGlzTGVmdEVkZ2VGaXhlZCAmJiB0bS5pbmRleCA8PSBlYXJsaWVzdEluZGV4T2ZTZWNvbmRMYWJlbCkgfHwgKGlzUmlnaHRFZGdlRml4ZWQgJiYgdG0uaW5kZXggPj0gaW5kZXhPZlNlY29uZExhc3RMYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xhYmVscy5sZW5ndGggPSB0YXJnZXRJbmRleDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZU1hcmtzQ2FjaGUgPSB0aGlzLl9wcml2YXRlX19sYWJlbHM7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sYWJlbHM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZXN0b3JlRGVmYXVsdCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRCYXJTcGFjaW5nKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuYmFyU3BhY2luZyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucmlnaHRPZmZzZXQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0QmFzZUluZGV4KGJhc2VJbmRleCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VJbmRleE9yTnVsbCA9IGJhc2VJbmRleDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29ycmVjdE9mZnNldCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kb0ZpeExlZnRFZGdlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFpvb20gaW4vb3V0IHRoZSBzY2FsZSBhcm91bmQgYSBgem9vbVBvaW50YCBvbiBgc2NhbGVgIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHpvb21Qb2ludCAtIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gYXBwbHkgdGhlIHpvb20uXG4gICAgICogSWYgYHJpZ2h0QmFyU3RheXNPblNjcm9sbGAgb3B0aW9uIGlzIGRpc2FibGVkLCB0aGVuIHdpbGwgYmUgdXNlZCB0byByZXN0b3JlIHJpZ2h0IG9mZnNldC5cbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBab29tIHZhbHVlIChpbiAxLzEwIHBhcnRzIG9mIGN1cnJlbnQgYmFyIHNwYWNpbmcpLlxuICAgICAqIE5lZ2F0aXZlIHZhbHVlIG1lYW5zIHpvb20gb3V0LCBwb3NpdGl2ZSAtIHpvb20gaW4uXG4gICAgICovXG4gICAgX2ludGVybmFsX3pvb20oem9vbVBvaW50LCBzY2FsZSkge1xuICAgICAgICBjb25zdCBmbG9hdEluZGV4QXRab29tUG9pbnQgPSB0aGlzLl9wcml2YXRlX19jb29yZGluYXRlVG9GbG9hdEluZGV4KHpvb21Qb2ludCk7XG4gICAgICAgIGNvbnN0IGJhclNwYWNpbmcgPSB0aGlzLl9pbnRlcm5hbF9iYXJTcGFjaW5nKCk7XG4gICAgICAgIGNvbnN0IG5ld0JhclNwYWNpbmcgPSBiYXJTcGFjaW5nICsgc2NhbGUgKiAoYmFyU3BhY2luZyAvIDEwKTtcbiAgICAgICAgLy8gem9vbSBpbi9vdXQgYmFyIHNwYWNpbmdcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0QmFyU3BhY2luZyhuZXdCYXJTcGFjaW5nKTtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19vcHRpb25zLnJpZ2h0QmFyU3RheXNPblNjcm9sbCkge1xuICAgICAgICAgICAgLy8gYW5kIHRoZW4gY29ycmVjdCByaWdodCBvZmZzZXQgdG8gbW92ZSBpbmRleCB1bmRlciB6b29tUG9pbnQgYmFjayB0byBpdHMgY29vcmRpbmF0ZVxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0UmlnaHRPZmZzZXQodGhpcy5faW50ZXJuYWxfcmlnaHRPZmZzZXQoKSArIChmbG9hdEluZGV4QXRab29tUG9pbnQgLSB0aGlzLl9wcml2YXRlX19jb29yZGluYXRlVG9GbG9hdEluZGV4KHpvb21Qb2ludCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RhcnRTY2FsZSh4KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50KSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9lbmRTY3JvbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2NhbGVTdGFydFBvaW50ICE9PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX2NvbW1vblRyYW5zaXRpb25TdGFydFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NjYWxlU3RhcnRQb2ludCA9IHg7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NhdmVDb21tb25UcmFuc2l0aW9uc1N0YXJ0U3RhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NjYWxlVG8oeCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY29tbW9uVHJhbnNpdGlvblN0YXJ0U3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydExlbmd0aEZyb21SaWdodCA9IGNsYW1wKHRoaXMuX3ByaXZhdGVfX3dpZHRoIC0geCwgMCwgdGhpcy5fcHJpdmF0ZV9fd2lkdGgpO1xuICAgICAgICBjb25zdCBjdXJyZW50TGVuZ3RoRnJvbVJpZ2h0ID0gY2xhbXAodGhpcy5fcHJpdmF0ZV9fd2lkdGggLSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3NjYWxlU3RhcnRQb2ludCksIDAsIHRoaXMuX3ByaXZhdGVfX3dpZHRoKTtcbiAgICAgICAgaWYgKHN0YXJ0TGVuZ3RoRnJvbVJpZ2h0ID09PSAwIHx8IGN1cnJlbnRMZW5ndGhGcm9tUmlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRCYXJTcGFjaW5nKHRoaXMuX3ByaXZhdGVfX2NvbW1vblRyYW5zaXRpb25TdGFydFN0YXRlLl9pbnRlcm5hbF9iYXJTcGFjaW5nICogc3RhcnRMZW5ndGhGcm9tUmlnaHQgLyBjdXJyZW50TGVuZ3RoRnJvbVJpZ2h0KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2VuZFNjYWxlKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2NhbGVTdGFydFBvaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2NhbGVTdGFydFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJDb21tb25UcmFuc2l0aW9uc1N0YXJ0U3RhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXJ0U2Nyb2xsKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Njcm9sbFN0YXJ0UG9pbnQgIT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fY29tbW9uVHJhbnNpdGlvblN0YXJ0U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCA9IHg7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NhdmVDb21tb25UcmFuc2l0aW9uc1N0YXJ0U3RhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Njcm9sbFRvKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Njcm9sbFN0YXJ0UG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaGlmdEluTG9naWNhbCA9ICh0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50IC0geCkgLyB0aGlzLl9pbnRlcm5hbF9iYXJTcGFjaW5nKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0ID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19jb21tb25UcmFuc2l0aW9uU3RhcnRTdGF0ZSkuX2ludGVybmFsX3JpZ2h0T2Zmc2V0ICsgc2hpZnRJbkxvZ2ljYWw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gZG8gbm90IGFsbG93IHNjcm9sbCBvdXQgb2YgdmlzaWJsZSBiYXJzXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RPZmZzZXQoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2VuZFNjcm9sbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Njcm9sbFN0YXJ0UG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJDb21tb25UcmFuc2l0aW9uc1N0YXJ0U3RhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Njcm9sbFRvUmVhbFRpbWUoKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3Njcm9sbFRvT2Zmc2V0QW5pbWF0ZWQodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5yaWdodE9mZnNldCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY3JvbGxUb09mZnNldEFuaW1hdGVkKG9mZnNldCwgYW5pbWF0aW9uRHVyYXRpb24gPSA0MDAgLyogQ29uc3RhbnRzLkRlZmF1bHRBbmltYXRpb25EdXJhdGlvbiAqLykge1xuICAgICAgICBpZiAoIWlzRmluaXRlKG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgZmluaXRlIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNGaW5pdGUoYW5pbWF0aW9uRHVyYXRpb24pIHx8IGFuaW1hdGlvbkR1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhbmltYXRpb25EdXJhdGlvbiAob3B0aW9uYWwpIG11c3QgYmUgZmluaXRlIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0O1xuICAgICAgICBjb25zdCBhbmltYXRpb25TdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2V0VGltZVNjYWxlQW5pbWF0aW9uKHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9maW5pc2hlZDogKHRpbWUpID0+ICh0aW1lIC0gYW5pbWF0aW9uU3RhcnQpIC8gYW5pbWF0aW9uRHVyYXRpb24gPj0gMSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9nZXRQb3NpdGlvbjogKHRpbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb25Qcm9ncmVzcyA9ICh0aW1lIC0gYW5pbWF0aW9uU3RhcnQpIC8gYW5pbWF0aW9uRHVyYXRpb247XG4gICAgICAgICAgICAgICAgY29uc3QgZmluaXNoQW5pbWF0aW9uID0gYW5pbWF0aW9uUHJvZ3Jlc3MgPj0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoQW5pbWF0aW9uID8gb2Zmc2V0IDogc291cmNlICsgKG9mZnNldCAtIHNvdXJjZSkgKiBhbmltYXRpb25Qcm9ncmVzcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKG5ld1BvaW50cywgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BvaW50cyA9IG5ld1BvaW50cztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGlja01hcmtzLl9pbnRlcm5hbF9zZXRUaW1lU2NhbGVQb2ludHMobmV3UG9pbnRzLCBmaXJzdENoYW5nZWRQb2ludEluZGV4KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29ycmVjdE9mZnNldCgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdmlzaWJsZUJhcnNDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZUJhcnNDaGFuZ2VkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbG9naWNhbFJhbmdlQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxSYW5nZUNoYW5nZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcHRpb25zQXBwbGllZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnNBcHBsaWVkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYmFzZUluZGV4KCkge1xuICAgICAgICAvLyBudWxsIGlzIHVzZWQgdG8ga25vd24gdGhhdCBiYXNlSW5kZXggaXMgbm90IHNldCB5ZXRcbiAgICAgICAgLy8gc28gaW4gbWV0aG9kcyB3aGljaCBzaG91bGQga25vd24gd2hldGhlciBpdCBpcyBzZXQgb3Igbm90XG4gICAgICAgIC8vIHdlIHNob3VsZCBjaGVjayBmaWVsZCBgX2Jhc2VJbmRleE9yTnVsbGAgaW5zdGVhZCBvZiBnZXR0ZXIgYGJhc2VJbmRleCgpYFxuICAgICAgICAvLyBzZWUgbWluUmlnaHRPZmZzZXQgZm9yIGV4YW1wbGVcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Jhc2VJbmRleE9yTnVsbCB8fCAwO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0VmlzaWJsZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHJhbmdlLl9pbnRlcm5hbF9jb3VudCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRCYXJTcGFjaW5nKHRoaXMuX3ByaXZhdGVfX3dpZHRoIC8gbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgPSByYW5nZS5faW50ZXJuYWxfcmlnaHQoKSAtIHRoaXMuX2ludGVybmFsX2Jhc2VJbmRleCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb3JyZWN0T2Zmc2V0KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3JlY2FsY3VsYXRlQWxsUGFuZXMoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9maXRDb250ZW50KCkge1xuICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXMuX3ByaXZhdGVfX2ZpcnN0SW5kZXgoKTtcbiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMuX3ByaXZhdGVfX2xhc3RJbmRleCgpO1xuICAgICAgICBpZiAoZmlyc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3NldFZpc2libGVSYW5nZShuZXcgUmFuZ2VJbXBsKGZpcnN0LCBsYXN0ICsgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5yaWdodE9mZnNldCkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0TG9naWNhbFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IGJhclJhbmdlID0gbmV3IFJhbmdlSW1wbChyYW5nZS5mcm9tLCByYW5nZS50byk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3NldFZpc2libGVSYW5nZShiYXJSYW5nZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9mb3JtYXREYXRlVGltZSh0aW1lU2NhbGVQb2ludCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbG9jYWxpemF0aW9uT3B0aW9ucy50aW1lRm9ybWF0dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sb2NhbGl6YXRpb25PcHRpb25zLnRpbWVGb3JtYXR0ZXIodGltZVNjYWxlUG9pbnQub3JpZ2luYWxUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IuZm9ybWF0SG9yekl0ZW0odGltZVNjYWxlUG9pbnQudGltZSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19pc0FsbFNjYWxpbmdBbmRTY3JvbGxpbmdEaXNhYmxlZCgpIHtcbiAgICAgICAgY29uc3QgeyBoYW5kbGVTY3JvbGwsIGhhbmRsZVNjYWxlIH0gPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICByZXR1cm4gIWhhbmRsZVNjcm9sbC5ob3J6VG91Y2hEcmFnXG4gICAgICAgICAgICAmJiAhaGFuZGxlU2Nyb2xsLm1vdXNlV2hlZWxcbiAgICAgICAgICAgICYmICFoYW5kbGVTY3JvbGwucHJlc3NlZE1vdXNlTW92ZVxuICAgICAgICAgICAgJiYgIWhhbmRsZVNjcm9sbC52ZXJ0VG91Y2hEcmFnXG4gICAgICAgICAgICAmJiAhaGFuZGxlU2NhbGUuYXhpc0RvdWJsZUNsaWNrUmVzZXQudGltZVxuICAgICAgICAgICAgJiYgIWhhbmRsZVNjYWxlLmF4aXNQcmVzc2VkTW91c2VNb3ZlLnRpbWVcbiAgICAgICAgICAgICYmICFoYW5kbGVTY2FsZS5tb3VzZVdoZWVsXG4gICAgICAgICAgICAmJiAhaGFuZGxlU2NhbGUucGluY2g7XG4gICAgfVxuICAgIF9wcml2YXRlX19maXJzdEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcG9pbnRzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiAwO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbGFzdEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcG9pbnRzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiAodGhpcy5fcHJpdmF0ZV9fcG9pbnRzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcmlnaHRPZmZzZXRGb3JDb29yZGluYXRlKHgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9wcml2YXRlX193aWR0aCAtIDEgLSB4KSAvIHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmc7XG4gICAgfVxuICAgIF9wcml2YXRlX19jb29yZGluYXRlVG9GbG9hdEluZGV4KHgpIHtcbiAgICAgICAgY29uc3QgZGVsdGFGcm9tUmlnaHQgPSB0aGlzLl9wcml2YXRlX19yaWdodE9mZnNldEZvckNvb3JkaW5hdGUoeCk7XG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2ludGVybmFsX2Jhc2VJbmRleCgpO1xuICAgICAgICBjb25zdCBpbmRleCA9IGJhc2VJbmRleCArIHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0IC0gZGVsdGFGcm9tUmlnaHQ7XG4gICAgICAgIC8vIEphdmFTY3JpcHQgdXNlcyB2ZXJ5IHN0cmFuZ2Ugcm91bmRpbmdcbiAgICAgICAgLy8gd2UgbmVlZCByb3VuZGluZyB0byBhdm9pZCBwcm9ibGVtcyB3aXRoIGNhbGN1bGF0aW9uIGVycm9yc1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChpbmRleCAqIDEwMDAwMDApIC8gMTAwMDAwMDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3NldEJhclNwYWNpbmcobmV3QmFyU3BhY2luZykge1xuICAgICAgICBjb25zdCBvbGRCYXJTcGFjaW5nID0gdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZyA9IG5ld0JhclNwYWNpbmc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RCYXJTcGFjaW5nKCk7XG4gICAgICAgIC8vIHRoaXMuX2JhclNwYWNpbmcgbWlnaHQgYmUgY2hhbmdlZCBpbiBfY29ycmVjdEJhclNwYWNpbmdcbiAgICAgICAgaWYgKG9sZEJhclNwYWNpbmcgIT09IHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jlc2V0VGltZU1hcmtzQ2FjaGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlVmlzaWJsZVJhbmdlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlSW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2V0VmlzaWJsZVJhbmdlKFRpbWVTY2FsZVZpc2libGVSYW5nZS5faW50ZXJuYWxfaW52YWxpZCgpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9pbnRlcm5hbF9iYXNlSW5kZXgoKTtcbiAgICAgICAgY29uc3QgbmV3QmFyc0xlbmd0aCA9IHRoaXMuX3ByaXZhdGVfX3dpZHRoIC8gdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZztcbiAgICAgICAgY29uc3QgcmlnaHRCb3JkZXIgPSB0aGlzLl9wcml2YXRlX19yaWdodE9mZnNldCArIGJhc2VJbmRleDtcbiAgICAgICAgY29uc3QgbGVmdEJvcmRlciA9IHJpZ2h0Qm9yZGVyIC0gbmV3QmFyc0xlbmd0aCArIDE7XG4gICAgICAgIGNvbnN0IGxvZ2ljYWxSYW5nZSA9IG5ldyBSYW5nZUltcGwobGVmdEJvcmRlciwgcmlnaHRCb3JkZXIpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRWaXNpYmxlUmFuZ2UobmV3IFRpbWVTY2FsZVZpc2libGVSYW5nZShsb2dpY2FsUmFuZ2UpKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NvcnJlY3RCYXJTcGFjaW5nKCkge1xuICAgICAgICBjb25zdCBtaW5CYXJTcGFjaW5nID0gdGhpcy5fcHJpdmF0ZV9fbWluQmFyU3BhY2luZygpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZyA8IG1pbkJhclNwYWNpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcgPSBtaW5CYXJTcGFjaW5nO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX193aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhpcyAoMSAvIENvbnN0YW50cy5NaW5WaXNpYmxlQmFyc0NvdW50KSA+PSBjb2VmZiBpbiBtYXggYmFyIHNwYWNpbmcgKGl0J3MgMC41IGhlcmUpXG4gICAgICAgICAgICBjb25zdCBtYXhCYXJTcGFjaW5nID0gdGhpcy5fcHJpdmF0ZV9fd2lkdGggKiAwLjU7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZyA+IG1heEJhclNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nID0gbWF4QmFyU3BhY2luZztcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX21pbkJhclNwYWNpbmcoKSB7XG4gICAgICAgIC8vIGlmIGJvdGggb3B0aW9ucyBhcmUgZW5hYmxlZCB0aGVuIGxpbWl0IGJhciBzcGFjaW5nIHNvIHRoYXQgem9vbWluZy1vdXQgaXMgbm90IHBvc3NpYmxlXG4gICAgICAgIC8vIGlmIGl0IHdvdWxkIGNhdXNlIGVpdGhlciB0aGUgZmlyc3Qgb3IgbGFzdCBwb2ludHMgdG8gbW92ZSB0b28gZmFyIGZyb20gYW4gZWRnZVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5maXhMZWZ0RWRnZSAmJiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmZpeFJpZ2h0RWRnZSAmJiB0aGlzLl9wcml2YXRlX19wb2ludHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fd2lkdGggLyB0aGlzLl9wcml2YXRlX19wb2ludHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLm1pbkJhclNwYWNpbmc7XG4gICAgfVxuICAgIF9wcml2YXRlX19jb3JyZWN0T2Zmc2V0KCkge1xuICAgICAgICAvLyBibG9jayBzY3JvbGxpbmcgb2YgdG8gZnV0dXJlXG4gICAgICAgIGNvbnN0IG1heFJpZ2h0T2Zmc2V0ID0gdGhpcy5fcHJpdmF0ZV9fbWF4UmlnaHRPZmZzZXQoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0ID4gbWF4UmlnaHRPZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0ID0gbWF4UmlnaHRPZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmxvY2sgc2Nyb2xsaW5nIG9mIHRvIHBhc3RcbiAgICAgICAgY29uc3QgbWluUmlnaHRPZmZzZXQgPSB0aGlzLl9wcml2YXRlX19taW5SaWdodE9mZnNldCgpO1xuICAgICAgICBpZiAobWluUmlnaHRPZmZzZXQgIT09IG51bGwgJiYgdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgPCBtaW5SaWdodE9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgPSBtaW5SaWdodE9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbWluUmlnaHRPZmZzZXQoKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0SW5kZXggPSB0aGlzLl9wcml2YXRlX19maXJzdEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX3ByaXZhdGVfX2Jhc2VJbmRleE9yTnVsbDtcbiAgICAgICAgaWYgKGZpcnN0SW5kZXggPT09IG51bGwgfHwgYmFzZUluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXJzRXN0aW1hdGlvbiA9IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuZml4TGVmdEVkZ2VcbiAgICAgICAgICAgID8gdGhpcy5fcHJpdmF0ZV9fd2lkdGggLyB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nXG4gICAgICAgICAgICA6IE1hdGgubWluKDIgLyogQ29uc3RhbnRzLk1pblZpc2libGVCYXJzQ291bnQgKi8sIHRoaXMuX3ByaXZhdGVfX3BvaW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZmlyc3RJbmRleCAtIGJhc2VJbmRleCAtIDEgKyBiYXJzRXN0aW1hdGlvbjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21heFJpZ2h0T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5maXhSaWdodEVkZ2VcbiAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgOiAodGhpcy5fcHJpdmF0ZV9fd2lkdGggLyB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nKSAtIE1hdGgubWluKDIgLyogQ29uc3RhbnRzLk1pblZpc2libGVCYXJzQ291bnQgKi8sIHRoaXMuX3ByaXZhdGVfX3BvaW50cy5sZW5ndGgpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2F2ZUNvbW1vblRyYW5zaXRpb25zU3RhcnRTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29tbW9uVHJhbnNpdGlvblN0YXJ0U3RhdGUgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyU3BhY2luZzogdGhpcy5faW50ZXJuYWxfYmFyU3BhY2luZygpLFxuICAgICAgICAgICAgX2ludGVybmFsX3JpZ2h0T2Zmc2V0OiB0aGlzLl9pbnRlcm5hbF9yaWdodE9mZnNldCgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY2xlYXJDb21tb25UcmFuc2l0aW9uc1N0YXJ0U3RhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbW1vblRyYW5zaXRpb25TdGFydFN0YXRlID0gbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Zvcm1hdExhYmVsKHRpY2tNYXJrKSB7XG4gICAgICAgIGxldCBmb3JtYXR0ZXIgPSB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZWRCeVdlaWdodC5nZXQodGlja01hcmsud2VpZ2h0KTtcbiAgICAgICAgaWYgKGZvcm1hdHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVkTGFiZWxzQ2FjaGUoKG1hcmspID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0TGFiZWxJbXBsKG1hcmspO1xuICAgICAgICAgICAgfSwgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVkQnlXZWlnaHQuc2V0KHRpY2tNYXJrLndlaWdodCwgZm9ybWF0dGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLl9pbnRlcm5hbF9mb3JtYXQodGlja01hcmspO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZm9ybWF0TGFiZWxJbXBsKHRpY2tNYXJrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5mb3JtYXRUaWNrbWFyayh0aWNrTWFyaywgdGhpcy5fcHJpdmF0ZV9fbG9jYWxpemF0aW9uT3B0aW9ucyk7XG4gICAgfVxuICAgIF9wcml2YXRlX19zZXRWaXNpYmxlUmFuZ2UobmV3VmlzaWJsZVJhbmdlKSB7XG4gICAgICAgIGNvbnN0IG9sZFZpc2libGVSYW5nZSA9IHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlID0gbmV3VmlzaWJsZVJhbmdlO1xuICAgICAgICBpZiAoIWFyZVJhbmdlc0VxdWFsKG9sZFZpc2libGVSYW5nZS5faW50ZXJuYWxfc3RyaWN0UmFuZ2UoKSwgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlLl9pbnRlcm5hbF9zdHJpY3RSYW5nZSgpKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZUJhcnNDaGFuZ2VkLl9pbnRlcm5hbF9maXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcmVSYW5nZXNFcXVhbChvbGRWaXNpYmxlUmFuZ2UuX2ludGVybmFsX2xvZ2ljYWxSYW5nZSgpLCB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2UuX2ludGVybmFsX2xvZ2ljYWxSYW5nZSgpKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlQ2hhbmdlZC5faW50ZXJuYWxfZmlyZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlc2V0IG9ubHkgY29vcmRzIGluIGNhc2Ugd2hlbiB0aGlzLl92aXNpYmxlQmFycyBoYXMgbm90IGJlZW4gY2hhbmdlZFxuICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNldFRpbWVNYXJrc0NhY2hlKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19yZXNldFRpbWVNYXJrc0NhY2hlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lTWFya3NDYWNoZSA9IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19pbnZhbGlkYXRlVGlja01hcmtzKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNldFRpbWVNYXJrc0NhY2hlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlZEJ5V2VpZ2h0LmNsZWFyKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVEYXRlVGltZUZvcm1hdHRlcigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IudXBkYXRlRm9ybWF0dGVyKHRoaXMuX3ByaXZhdGVfX2xvY2FsaXphdGlvbk9wdGlvbnMpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZG9GaXhMZWZ0RWRnZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19vcHRpb25zLmZpeExlZnRFZGdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RJbmRleCA9IHRoaXMuX3ByaXZhdGVfX2ZpcnN0SW5kZXgoKTtcbiAgICAgICAgaWYgKGZpcnN0SW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aXNpYmxlUmFuZ2UgPSB0aGlzLl9pbnRlcm5hbF92aXNpYmxlU3RyaWN0UmFuZ2UoKTtcbiAgICAgICAgaWYgKHZpc2libGVSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbHRhID0gdmlzaWJsZVJhbmdlLl9pbnRlcm5hbF9sZWZ0KCkgLSBmaXJzdEluZGV4O1xuICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0RWRnZU9mZnNldCA9IHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0IC0gZGVsdGEgLSAxO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0UmlnaHRPZmZzZXQobGVmdEVkZ2VPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RCYXJTcGFjaW5nKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19kb0ZpeFJpZ2h0RWRnZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29ycmVjdE9mZnNldCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb3JyZWN0QmFyU3BhY2luZygpO1xuICAgIH1cbn1cblxuY2xhc3MgV2F0ZXJtYXJrUmVuZGVyZXIgZXh0ZW5kcyBNZWRpYUNvb3JkaW5hdGVzUGFuZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21ldHJpY3NDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZHJhd0ltcGwocmVuZGVyaW5nU2NvcGUpIHsgfVxuICAgIF9pbnRlcm5hbF9fZHJhd0JhY2tncm91bmRJbXBsKHJlbmRlcmluZ1Njb3BlKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY29udGV4dDogY3R4LCBtZWRpYVNpemUgfSA9IHJlbmRlcmluZ1Njb3BlO1xuICAgICAgICBsZXQgdGV4dEhlaWdodCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9saW5lcykge1xuICAgICAgICAgICAgaWYgKGxpbmUuX2ludGVybmFsX3RleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZm9udCA9IGxpbmUuX2ludGVybmFsX2ZvbnQ7XG4gICAgICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSB0aGlzLl9wcml2YXRlX19tZXRyaWNzKGN0eCwgbGluZS5faW50ZXJuYWxfdGV4dCk7XG4gICAgICAgICAgICBpZiAodGV4dFdpZHRoID4gbWVkaWFTaXplLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGluZS5faW50ZXJuYWxfem9vbSA9IG1lZGlhU2l6ZS53aWR0aCAvIHRleHRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmUuX2ludGVybmFsX3pvb20gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dEhlaWdodCArPSBsaW5lLl9pbnRlcm5hbF9saW5lSGVpZ2h0ICogbGluZS5faW50ZXJuYWxfem9vbTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmVydE9mZnNldCA9IDA7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmVydEFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHZlcnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICB2ZXJ0T2Zmc2V0ID0gTWF0aC5tYXgoKG1lZGlhU2l6ZS5oZWlnaHQgLSB0ZXh0SGVpZ2h0KSAvIDIsIDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB2ZXJ0T2Zmc2V0ID0gTWF0aC5tYXgoKG1lZGlhU2l6ZS5oZWlnaHQgLSB0ZXh0SGVpZ2h0KSwgMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2NvbG9yO1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfbGluZXMpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBsZXQgaG9yek9mZnNldCA9IDA7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2hvcnpBbGlnbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICBob3J6T2Zmc2V0ID0gbGluZS5faW50ZXJuYWxfbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgaG9yek9mZnNldCA9IG1lZGlhU2l6ZS53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgIGhvcnpPZmZzZXQgPSBtZWRpYVNpemUud2lkdGggLSAxIC0gbGluZS5faW50ZXJuYWxfbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShob3J6T2Zmc2V0LCB2ZXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgICAgICAgIGN0eC5mb250ID0gbGluZS5faW50ZXJuYWxfZm9udDtcbiAgICAgICAgICAgIGN0eC5zY2FsZShsaW5lLl9pbnRlcm5hbF96b29tLCBsaW5lLl9pbnRlcm5hbF96b29tKTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChsaW5lLl9pbnRlcm5hbF90ZXh0LCAwLCBsaW5lLl9pbnRlcm5hbF92ZXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB2ZXJ0T2Zmc2V0ICs9IGxpbmUuX2ludGVybmFsX2xpbmVIZWlnaHQgKiBsaW5lLl9pbnRlcm5hbF96b29tO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19tZXRyaWNzKGN0eCwgdGV4dCkge1xuICAgICAgICBjb25zdCBmb250Q2FjaGUgPSB0aGlzLl9wcml2YXRlX19mb250Q2FjaGUoY3R4LmZvbnQpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZm9udENhY2hlLmdldCh0ZXh0KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgICAgICAgICBmb250Q2FjaGUuc2V0KHRleHQsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2ZvbnRDYWNoZShmb250KSB7XG4gICAgICAgIGxldCBmb250Q2FjaGUgPSB0aGlzLl9wcml2YXRlX19tZXRyaWNzQ2FjaGUuZ2V0KGZvbnQpO1xuICAgICAgICBpZiAoZm9udENhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvbnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21ldHJpY3NDYWNoZS5zZXQoZm9udCwgZm9udENhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9udENhY2hlO1xuICAgIH1cbn1cblxuY2xhc3MgV2F0ZXJtYXJrUGFuZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyRGF0YSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9jb2xvcjogJycsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZXM6IFtdLFxuICAgICAgICAgICAgX2ludGVybmFsX3ZlcnRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICBfaW50ZXJuYWxfaG9yekFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIgPSBuZXcgV2F0ZXJtYXJrUmVuZGVyZXIodGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJEYXRhKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVJbXBsKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yZW5kZXJlcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3VwZGF0ZUltcGwoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19zb3VyY2UuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyRGF0YTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IG9wdGlvbnMudmlzaWJsZTtcbiAgICAgICAgaWYgKCFkYXRhLl9pbnRlcm5hbF92aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5faW50ZXJuYWxfY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9ob3J6QWxpZ24gPSBvcHRpb25zLmhvcnpBbGlnbjtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfdmVydEFsaWduID0gb3B0aW9ucy52ZXJ0QWxpZ247XG4gICAgICAgIGRhdGEuX2ludGVybmFsX2xpbmVzID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90ZXh0OiBvcHRpb25zLnRleHQsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2ZvbnQ6IG1ha2VGb250KG9wdGlvbnMuZm9udFNpemUsIG9wdGlvbnMuZm9udEZhbWlseSwgb3B0aW9ucy5mb250U3R5bGUpLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lSGVpZ2h0OiBvcHRpb25zLmZvbnRTaXplICogMS4yLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF92ZXJ0T2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF96b29tOiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG59XG5cbmNsYXNzIFdhdGVybWFyayBleHRlbmRzIERhdGFTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlldyA9IG5ldyBXYXRlcm1hcmtQYW5lVmlldyh0aGlzKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlQXhpc1ZpZXdzKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYW5lVmlld3MoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXddO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cygpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgIH1cbn1cblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJfYnVpbGQtdGltZS1jb25zdGFudHNcIiAvPlxuLyoqXG4gKiBEZXRlcm1pbmUgaG93IHRvIGV4aXQgdGhlIHRyYWNraW5nIG1vZGUuXG4gKlxuICogQnkgZGVmYXVsdCwgbW9iaWxlIHVzZXJzIHdpbGwgbG9uZyBwcmVzcyB0byBkZWFjdGl2YXRlIHRoZSBzY3JvbGwgYW5kIGhhdmUgdGhlIGFiaWxpdHkgdG8gY2hlY2sgdmFsdWVzIGFuZCBkYXRlcy5cbiAqIEFub3RoZXIgcHJlc3MgaXMgcmVxdWlyZWQgdG8gYWN0aXZhdGUgdGhlIHNjcm9sbCwgYmUgYWJsZSB0byBtb3ZlIGxlZnQvcmlnaHQsIHpvb20sIGV0Yy5cbiAqL1xudmFyIFRyYWNraW5nTW9kZUV4aXRNb2RlO1xuKGZ1bmN0aW9uIChUcmFja2luZ01vZGVFeGl0TW9kZSkge1xuICAgIC8qKlxuICAgICAqIFRyYWNraW5nIE1vZGUgd2lsbCBiZSBkZWFjdGl2YXRlZCBvbiB0b3VjaCBlbmQgZXZlbnQuXG4gICAgICovXG4gICAgVHJhY2tpbmdNb2RlRXhpdE1vZGVbVHJhY2tpbmdNb2RlRXhpdE1vZGVbXCJPblRvdWNoRW5kXCJdID0gMF0gPSBcIk9uVG91Y2hFbmRcIjtcbiAgICAvKipcbiAgICAgKiBUcmFja2luZyBNb2RlIHdpbGwgYmUgZGVhY3RpdmF0ZWQgb24gdGhlIG5leHQgdGFwIGV2ZW50LlxuICAgICAqL1xuICAgIFRyYWNraW5nTW9kZUV4aXRNb2RlW1RyYWNraW5nTW9kZUV4aXRNb2RlW1wiT25OZXh0VGFwXCJdID0gMV0gPSBcIk9uTmV4dFRhcFwiO1xufSkoVHJhY2tpbmdNb2RlRXhpdE1vZGUgfHwgKFRyYWNraW5nTW9kZUV4aXRNb2RlID0ge30pKTtcbmNsYXNzIENoYXJ0TW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKGludmFsaWRhdGVIYW5kbGVyLCBvcHRpb25zLCBob3J6U2NhbGVCZWhhdmlvcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNlcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX193aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvdmVyZWRTb3VyY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlc09wdGlvbnNDaGFuZ2VkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2dyYWRpZW50Q29sb3JzQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlSGFuZGxlciA9IGludmFsaWRhdGVIYW5kbGVyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IgPSBob3J6U2NhbGVCZWhhdmlvcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIgPSBuZXcgUHJpY2VBeGlzUmVuZGVyZXJPcHRpb25zUHJvdmlkZXIodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZSA9IG5ldyBUaW1lU2NhbGUodGhpcywgb3B0aW9ucy50aW1lU2NhbGUsIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubG9jYWxpemF0aW9uLCBob3J6U2NhbGVCZWhhdmlvcik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpciA9IG5ldyBDcm9zc2hhaXIodGhpcywgb3B0aW9ucy5jcm9zc2hhaXIpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYWduZXQgPSBuZXcgTWFnbmV0KG9wdGlvbnMuY3Jvc3NoYWlyKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fd2F0ZXJtYXJrID0gbmV3IFdhdGVybWFyayh0aGlzLCBvcHRpb25zLndhdGVybWFyayk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX2NyZWF0ZVBhbmUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXNbMF0uX2ludGVybmFsX3NldFN0cmV0Y2hGYWN0b3IoREVGQVVMVF9TVFJFVENIX0ZBQ1RPUiAqIDIpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYWNrZ3JvdW5kVG9wQ29sb3IgPSB0aGlzLl9wcml2YXRlX19nZXRCYWNrZ3JvdW5kQ29sb3IoMCAvKiBCYWNrZ3JvdW5kQ29sb3JTaWRlLlRvcCAqLyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhY2tncm91bmRCb3R0b21Db2xvciA9IHRoaXMuX3ByaXZhdGVfX2dldEJhY2tncm91bmRDb2xvcigxIC8qIEJhY2tncm91bmRDb2xvclNpZGUuQm90dG9tICovKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Z1bGxVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUoSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2Z1bGwoKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9saWdodFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZShJbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfbGlnaHQoKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jdXJzb3JVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUobmV3IEludmFsaWRhdGVNYXNrKDEgLyogSW52YWxpZGF0aW9uTGV2ZWwuQ3Vyc29yICovKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGVTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGludiA9IHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGlvbk1hc2tGb3JTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZShpbnYpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaG92ZXJlZFNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2hvdmVyZWRTb3VyY2U7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRIb3ZlcmVkU291cmNlKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBwcmV2U291cmNlID0gdGhpcy5fcHJpdmF0ZV9faG92ZXJlZFNvdXJjZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faG92ZXJlZFNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgaWYgKHByZXZTb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZVNvdXJjZShwcmV2U291cmNlLl9pbnRlcm5hbF9zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZVNvdXJjZShzb3VyY2UuX2ludGVybmFsX3NvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX29wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2UodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzLmZvckVhY2goKHApID0+IHAuX2ludGVybmFsX2FwcGx5U2NhbGVPcHRpb25zKG9wdGlvbnMpKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudGltZVNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMudGltZVNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5sb2NhbGl6YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9hcHBseUxvY2FsaXphdGlvbk9wdGlvbnMob3B0aW9ucy5sb2NhbGl6YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmxlZnRQcmljZVNjYWxlIHx8IG9wdGlvbnMucmlnaHRQcmljZVNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlc09wdGlvbnNDaGFuZ2VkLl9pbnRlcm5hbF9maXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFja2dyb3VuZFRvcENvbG9yID0gdGhpcy5fcHJpdmF0ZV9fZ2V0QmFja2dyb3VuZENvbG9yKDAgLyogQmFja2dyb3VuZENvbG9yU2lkZS5Ub3AgKi8pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYWNrZ3JvdW5kQm90dG9tQ29sb3IgPSB0aGlzLl9wcml2YXRlX19nZXRCYWNrZ3JvdW5kQ29sb3IoMSAvKiBCYWNrZ3JvdW5kQ29sb3JTaWRlLkJvdHRvbSAqLyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX2Z1bGxVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2FwcGx5UHJpY2VTY2FsZU9wdGlvbnMocHJpY2VTY2FsZUlkLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChwcmljZVNjYWxlSWQgPT09IFwibGVmdFwiIC8qIERlZmF1bHRQcmljZVNjYWxlSWQuTGVmdCAqLykge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfYXBwbHlPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBsZWZ0UHJpY2VTY2FsZTogb3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByaWNlU2NhbGVJZCA9PT0gXCJyaWdodFwiIC8qIERlZmF1bHRQcmljZVNjYWxlSWQuUmlnaHQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2FwcGx5T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgcmlnaHRQcmljZVNjYWxlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5faW50ZXJuYWxfZmluZFByaWNlU2NhbGUocHJpY2VTY2FsZUlkKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJ5aW5nIHRvIGFwcGx5IHByaWNlIHNjYWxlIG9wdGlvbnMgd2l0aCBpbmNvcnJlY3QgSUQ6ICR7cHJpY2VTY2FsZUlkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcy5faW50ZXJuYWxfcHJpY2VTY2FsZS5faW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlc09wdGlvbnNDaGFuZ2VkLl9pbnRlcm5hbF9maXJlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9maW5kUHJpY2VTY2FsZShwcmljZVNjYWxlSWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBwYW5lIG9mIHRoaXMuX3ByaXZhdGVfX3BhbmVzKSB7XG4gICAgICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gcGFuZS5faW50ZXJuYWxfcHJpY2VTY2FsZUJ5SWQocHJpY2VTY2FsZUlkKTtcbiAgICAgICAgICAgIGlmIChwcmljZVNjYWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX3BhbmU6IHBhbmUsXG4gICAgICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9wcmljZVNjYWxlOiBwcmljZVNjYWxlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aW1lU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX190aW1lU2NhbGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYW5lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfd2F0ZXJtYXJrU291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fd2F0ZXJtYXJrO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY3Jvc3NoYWlyU291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY3Jvc3NoYWlyTW92ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFBhbmVIZWlnaHQocGFuZSwgaGVpZ2h0KSB7XG4gICAgICAgIHBhbmUuX2ludGVybmFsX3NldEhlaWdodChoZWlnaHQpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZUFsbFBhbmVzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRXaWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX193aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3NldFdpZHRoKHRoaXMuX3ByaXZhdGVfX3dpZHRoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXMuZm9yRWFjaCgocGFuZSkgPT4gcGFuZS5faW50ZXJuYWxfc2V0V2lkdGgod2lkdGgpKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVBbGxQYW5lcygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY3JlYXRlUGFuZShpbmRleCkge1xuICAgICAgICBjb25zdCBwYW5lID0gbmV3IFBhbmUodGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLCB0aGlzKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzLnNwbGljZShpbmRleCwgMCwgcGFuZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhZGRpbmcgdG8gdGhlIGVuZCAtIGNvbW1vbiBjYXNlXG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lcy5wdXNoKHBhbmUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdHVhbEluZGV4ID0gKGluZGV4ID09PSB1bmRlZmluZWQpID8gdGhpcy5fcHJpdmF0ZV9fcGFuZXMubGVuZ3RoIC0gMSA6IGluZGV4O1xuICAgICAgICAvLyB3ZSBhbHdheXMgZG8gYXV0b3NjYWxpbmcgb24gdGhlIGNyZWF0aW9uXG4gICAgICAgIC8vIGlmIGF1dG9zY2FsZSBvcHRpb24gaXMgdHJ1ZSwgaXQgaXMgb2ssIGp1c3QgcmVjYWxjdWxhdGUgYnkgaW52YWxpZGF0aW9uIG1hc2tcbiAgICAgICAgLy8gaWYgYXV0b3NjYWxlIG9wdGlvbiBpcyBmYWxzZSwgYXV0b3NjYWxlIGFueXdheSBvbiB0aGUgZmlyc3QgZHJhd1xuICAgICAgICAvLyBhbHNvIHRoZXJlIGlzIGEgc2NlbmFyaW8gd2hlbiBhdXRvc2NhbGUgaXMgdHJ1ZSBpbiBjb25zdHJ1Y3RvciBhbmQgZmFsc2UgbGF0ZXIgb24gYXBwbHlPcHRpb25zXG4gICAgICAgIGNvbnN0IG1hc2sgPSBJbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfZnVsbCgpO1xuICAgICAgICBtYXNrLl9pbnRlcm5hbF9pbnZhbGlkYXRlUGFuZShhY3R1YWxJbmRleCwge1xuICAgICAgICAgICAgX2ludGVybmFsX2xldmVsOiAwIC8qIEludmFsaWRhdGlvbkxldmVsLk5vbmUgKi8sXG4gICAgICAgICAgICBfaW50ZXJuYWxfYXV0b1NjYWxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZShtYXNrKTtcbiAgICAgICAgcmV0dXJuIHBhbmU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdGFydFNjYWxlUHJpY2UocGFuZSwgcHJpY2VTY2FsZSwgeCkge1xuICAgICAgICBwYW5lLl9pbnRlcm5hbF9zdGFydFNjYWxlUHJpY2UocHJpY2VTY2FsZSwgeCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY2FsZVByaWNlVG8ocGFuZSwgcHJpY2VTY2FsZSwgeCkge1xuICAgICAgICBwYW5lLl9pbnRlcm5hbF9zY2FsZVByaWNlVG8ocHJpY2VTY2FsZSwgeCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUNyb3NzaGFpcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKHRoaXMuX3ByaXZhdGVfX3BhbmVJbnZhbGlkYXRpb25NYXNrKHBhbmUsIDIgLyogSW52YWxpZGF0aW9uTGV2ZWwuTGlnaHQgKi8pKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2VuZFNjYWxlUHJpY2UocGFuZSwgcHJpY2VTY2FsZSkge1xuICAgICAgICBwYW5lLl9pbnRlcm5hbF9lbmRTY2FsZVByaWNlKHByaWNlU2NhbGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKHRoaXMuX3ByaXZhdGVfX3BhbmVJbnZhbGlkYXRpb25NYXNrKHBhbmUsIDIgLyogSW52YWxpZGF0aW9uTGV2ZWwuTGlnaHQgKi8pKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXJ0U2Nyb2xsUHJpY2UocGFuZSwgcHJpY2VTY2FsZSwgeCkge1xuICAgICAgICBpZiAocHJpY2VTY2FsZS5faW50ZXJuYWxfaXNBdXRvU2NhbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhbmUuX2ludGVybmFsX3N0YXJ0U2Nyb2xsUHJpY2UocHJpY2VTY2FsZSwgeCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY3JvbGxQcmljZVRvKHBhbmUsIHByaWNlU2NhbGUsIHgpIHtcbiAgICAgICAgaWYgKHByaWNlU2NhbGUuX2ludGVybmFsX2lzQXV0b1NjYWxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYW5lLl9pbnRlcm5hbF9zY3JvbGxQcmljZVRvKHByaWNlU2NhbGUsIHgpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVDcm9zc2hhaXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZSh0aGlzLl9wcml2YXRlX19wYW5lSW52YWxpZGF0aW9uTWFzayhwYW5lLCAyIC8qIEludmFsaWRhdGlvbkxldmVsLkxpZ2h0ICovKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9lbmRTY3JvbGxQcmljZShwYW5lLCBwcmljZVNjYWxlKSB7XG4gICAgICAgIGlmIChwcmljZVNjYWxlLl9pbnRlcm5hbF9pc0F1dG9TY2FsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGFuZS5faW50ZXJuYWxfZW5kU2Nyb2xsUHJpY2UocHJpY2VTY2FsZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUodGhpcy5fcHJpdmF0ZV9fcGFuZUludmFsaWRhdGlvbk1hc2socGFuZSwgMiAvKiBJbnZhbGlkYXRpb25MZXZlbC5MaWdodCAqLykpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVzZXRQcmljZVNjYWxlKHBhbmUsIHByaWNlU2NhbGUpIHtcbiAgICAgICAgcGFuZS5faW50ZXJuYWxfcmVzZXRQcmljZVNjYWxlKHByaWNlU2NhbGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKHRoaXMuX3ByaXZhdGVfX3BhbmVJbnZhbGlkYXRpb25NYXNrKHBhbmUsIDIgLyogSW52YWxpZGF0aW9uTGV2ZWwuTGlnaHQgKi8pKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXJ0U2NhbGVUaW1lKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfc3RhcnRTY2FsZShwb3NpdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFpvb20gaW4vb3V0IHRoZSBjaGFydCAoZGVwZW5kcyBvbiBzY2FsZSB2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9pbnRYIC0gWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBhcHBseSB0aGUgem9vbSAodGhlIHBvaW50IHdoaWNoIHNob3VsZCBzdGF5IG9uIGl0cyBwbGFjZSlcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBab29tIHZhbHVlLiBOZWdhdGl2ZSB2YWx1ZSBtZWFucyB6b29tIG91dCwgcG9zaXRpdmUgLSB6b29tIGluLlxuICAgICAqL1xuICAgIF9pbnRlcm5hbF96b29tVGltZShwb2ludFgsIHNjYWxlKSB7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX2ludGVybmFsX3RpbWVTY2FsZSgpO1xuICAgICAgICBpZiAodGltZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkgfHwgc2NhbGUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lU2NhbGVXaWR0aCA9IHRpbWVTY2FsZS5faW50ZXJuYWxfd2lkdGgoKTtcbiAgICAgICAgcG9pbnRYID0gTWF0aC5tYXgoMSwgTWF0aC5taW4ocG9pbnRYLCB0aW1lU2NhbGVXaWR0aCkpO1xuICAgICAgICB0aW1lU2NhbGUuX2ludGVybmFsX3pvb20ocG9pbnRYLCBzY2FsZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3JlY2FsY3VsYXRlQWxsUGFuZXMoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Njcm9sbENoYXJ0KHgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc3RhcnRTY3JvbGxUaW1lKDApO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zY3JvbGxUaW1lVG8oeCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX2VuZFNjcm9sbFRpbWUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NjYWxlVGltZVRvKHgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9zY2FsZVRvKHgpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZUFsbFBhbmVzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9lbmRTY2FsZVRpbWUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfZW5kU2NhbGUoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXJ0U2Nyb2xsVGltZSh4KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfc3RhcnRTY3JvbGwoeCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY3JvbGxUaW1lVG8oeCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3Njcm9sbFRvKHgpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZUFsbFBhbmVzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9lbmRTY3JvbGxUaW1lKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2VuZFNjcm9sbCgpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9saWdodFVwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2VyaWVzZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zZXJpZXNlcztcbiAgICB9XG4gICAgX2ludGVybmFsX3NldEFuZFNhdmVDdXJyZW50UG9zaXRpb24oeCwgeSwgZXZlbnQsIHBhbmUsIHNraXBFdmVudCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIuX2ludGVybmFsX3NhdmVPcmlnaW5Db29yZCh4LCB5KTtcbiAgICAgICAgbGV0IHByaWNlID0gTmFOO1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2Nvb3JkaW5hdGVUb0luZGV4KHgpO1xuICAgICAgICBjb25zdCB2aXNpYmxlQmFycyA9IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfdmlzaWJsZVN0cmljdFJhbmdlKCk7XG4gICAgICAgIGlmICh2aXNpYmxlQmFycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLm1pbihNYXRoLm1heCh2aXNpYmxlQmFycy5faW50ZXJuYWxfbGVmdCgpLCBpbmRleCksIHZpc2libGVCYXJzLl9pbnRlcm5hbF9yaWdodCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gcGFuZS5faW50ZXJuYWxfZGVmYXVsdFByaWNlU2NhbGUoKTtcbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHByaWNlU2NhbGUuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgaWYgKGZpcnN0VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByaWNlID0gcHJpY2VTY2FsZS5faW50ZXJuYWxfY29vcmRpbmF0ZVRvUHJpY2UoeSwgZmlyc3RWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJpY2UgPSB0aGlzLl9wcml2YXRlX19tYWduZXQuX2ludGVybmFsX2FsaWduKHByaWNlLCBpbmRleCwgcGFuZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfc2V0UG9zaXRpb24oaW5kZXgsIHByaWNlLCBwYW5lKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfY3Vyc29yVXBkYXRlKCk7XG4gICAgICAgIGlmICghc2tpcEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZC5faW50ZXJuYWxfZmlyZSh0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIuX2ludGVybmFsX2FwcGxpZWRJbmRleCgpLCB7IHgsIHkgfSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEEgcG9zaXRpb24gcHJvdmlkZWQgZXh0ZXJuYWwgKG5vdCBmcm9tIGFuIGludGVybmFsIGV2ZW50IGxpc3RlbmVyKVxuICAgIF9pbnRlcm5hbF9zZXRBbmRTYXZlU3ludGhldGljUG9zaXRpb24ocHJpY2UsIGhvcml6b250YWxQb3NpdGlvbiwgcGFuZSkge1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gcGFuZS5faW50ZXJuYWxfZGVmYXVsdFByaWNlU2NhbGUoKTtcbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHByaWNlU2NhbGUuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgeSA9IHByaWNlU2NhbGUuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKHByaWNlLCBlbnN1cmVOb3ROdWxsKGZpcnN0VmFsdWUpKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3RpbWVUb0luZGV4KGhvcml6b250YWxQb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2luZGV4VG9Db29yZGluYXRlKGVuc3VyZU5vdE51bGwoaW5kZXgpKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0QW5kU2F2ZUN1cnJlbnRQb3NpdGlvbih4LCB5LCBudWxsLCBwYW5lLCB0cnVlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2NsZWFyQ3VycmVudFBvc2l0aW9uKHNraXBFdmVudCkge1xuICAgICAgICBjb25zdCBjcm9zc2hhaXIgPSB0aGlzLl9pbnRlcm5hbF9jcm9zc2hhaXJTb3VyY2UoKTtcbiAgICAgICAgY3Jvc3NoYWlyLl9pbnRlcm5hbF9jbGVhclBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX2N1cnNvclVwZGF0ZSgpO1xuICAgICAgICBpZiAoIXNraXBFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyTW92ZWQuX2ludGVybmFsX2ZpcmUobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZUNyb3NzaGFpcigpIHtcbiAgICAgICAgLy8gYXBwbHkgbWFnbmV0XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIuX2ludGVybmFsX3BhbmUoKTtcbiAgICAgICAgaWYgKHBhbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIuX2ludGVybmFsX29yaWdpbkNvb3JkWCgpO1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfb3JpZ2luQ29vcmRZKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRBbmRTYXZlQ3VycmVudFBvc2l0aW9uKHgsIHksIG51bGwsIHBhbmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZVRpbWVTY2FsZShuZXdCYXNlSW5kZXgsIG5ld1BvaW50cywgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCkge1xuICAgICAgICBjb25zdCBvbGRGaXJzdFRpbWUgPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2luZGV4VG9UaW1lKDApO1xuICAgICAgICBpZiAobmV3UG9pbnRzICE9PSB1bmRlZmluZWQgJiYgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3VwZGF0ZShuZXdQb2ludHMsIGZpcnN0Q2hhbmdlZFBvaW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0ZpcnN0VGltZSA9IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhUb1RpbWUoMCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYXNlSW5kZXggPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2Jhc2VJbmRleCgpO1xuICAgICAgICBjb25zdCB2aXNpYmxlQmFycyA9IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfdmlzaWJsZVN0cmljdFJhbmdlKCk7XG4gICAgICAgIC8vIGlmIHRpbWUgc2NhbGUgY2Fubm90IHJldHVybiBjdXJyZW50IHZpc2libGUgYmFycyByYW5nZSAoZS5nLiB0aW1lIHNjYWxlIGhhcyB6ZXJvLXdpZHRoKVxuICAgICAgICAvLyB0aGVuIHdlIGRvIG5vdCBuZWVkIHRvIHVwZGF0ZSByaWdodCBvZmZzZXQgdG8gc2hpZnQgdmlzaWJsZSBiYXJzIHJhbmdlIHRvIGhhdmUgdGhlIHNhbWUgcmlnaHQgb2Zmc2V0IGFzIHdlIGhhdmUgYmVmb3JlIG5ldyBiYXJcbiAgICAgICAgLy8gKGFuZCBhY3R1YWxseSB3ZSBjYW5ub3QpXG4gICAgICAgIGlmICh2aXNpYmxlQmFycyAhPT0gbnVsbCAmJiBvbGRGaXJzdFRpbWUgIT09IG51bGwgJiYgbmV3Rmlyc3RUaW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBpc0xhc3RTZXJpZXNCYXJWaXNpYmxlID0gdmlzaWJsZUJhcnMuX2ludGVybmFsX2NvbnRhaW5zKGN1cnJlbnRCYXNlSW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgaXNMZWZ0QmFyU2hpZnRUb0xlZnQgPSB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkob2xkRmlyc3RUaW1lKSA+IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleShuZXdGaXJzdFRpbWUpO1xuICAgICAgICAgICAgY29uc3QgaXNTZXJpZXNQb2ludHNBZGRlZCA9IG5ld0Jhc2VJbmRleCAhPT0gbnVsbCAmJiBuZXdCYXNlSW5kZXggPiBjdXJyZW50QmFzZUluZGV4O1xuICAgICAgICAgICAgY29uc3QgaXNTZXJpZXNQb2ludHNBZGRlZFRvUmlnaHQgPSBpc1Nlcmllc1BvaW50c0FkZGVkICYmICFpc0xlZnRCYXJTaGlmdFRvTGVmdDtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93U2hpZnRXaGVuUmVwbGFjaW5nV2hpdGVzcGFjZSA9IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfb3B0aW9ucygpLmFsbG93U2hpZnRWaXNpYmxlUmFuZ2VPbldoaXRlc3BhY2VSZXBsYWNlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VkRXhpc3RpbmdXaGl0ZXNwYWNlID0gZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgbmVlZFNoaWZ0VmlzaWJsZVJhbmdlT25OZXdCYXIgPSBpc0xhc3RTZXJpZXNCYXJWaXNpYmxlICYmICghcmVwbGFjZWRFeGlzdGluZ1doaXRlc3BhY2UgfHwgYWxsb3dTaGlmdFdoZW5SZXBsYWNpbmdXaGl0ZXNwYWNlKSAmJiB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKS5zaGlmdFZpc2libGVSYW5nZU9uTmV3QmFyO1xuICAgICAgICAgICAgaWYgKGlzU2VyaWVzUG9pbnRzQWRkZWRUb1JpZ2h0ICYmICFuZWVkU2hpZnRWaXNpYmxlUmFuZ2VPbk5ld0Jhcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBlbnNhdGlvblNoaWZ0ID0gbmV3QmFzZUluZGV4IC0gY3VycmVudEJhc2VJbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfcmlnaHRPZmZzZXQoKSAtIGNvbXBlbnNhdGlvblNoaWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3NldEJhc2VJbmRleChuZXdCYXNlSW5kZXgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVjYWxjdWxhdGVQYW5lKHBhbmUpIHtcbiAgICAgICAgaWYgKHBhbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhbmUuX2ludGVybmFsX3JlY2FsY3VsYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3BhbmVGb3JTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLl9wcml2YXRlX19wYW5lcy5maW5kKChwKSA9PiBwLl9pbnRlcm5hbF9vcmRlcmVkU291cmNlcygpLmluY2x1ZGVzKHNvdXJjZSkpO1xuICAgICAgICByZXR1cm4gcGFuZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHBhbmU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZWNhbGN1bGF0ZUFsbFBhbmVzKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX193YXRlcm1hcmsuX2ludGVybmFsX3VwZGF0ZUFsbFZpZXdzKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzLmZvckVhY2goKHApID0+IHAuX2ludGVybmFsX3JlY2FsY3VsYXRlKCkpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVDcm9zc2hhaXIoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Rlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzLmZvckVhY2goKHApID0+IHAuX2ludGVybmFsX2Rlc3Ryb3koKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzLmxlbmd0aCA9IDA7XG4gICAgICAgIC8vIHRvIGF2b2lkIG1lbWxlYWtzXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubG9jYWxpemF0aW9uLnByaWNlRm9ybWF0dGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zLmxvY2FsaXphdGlvbi5wZXJjZW50YWdlRm9ybWF0dGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zLmxvY2FsaXphdGlvbi50aW1lRm9ybWF0dGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnNQcm92aWRlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlQXhpc1JlbmRlcmVyT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZVNjYWxlc09wdGlvbnNDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZXNPcHRpb25zQ2hhbmdlZDtcbiAgICB9XG4gICAgX2ludGVybmFsX2NyZWF0ZVNlcmllcyhzZXJpZXNUeXBlLCBvcHRpb25zLCBjdXN0b21QYW5lVmlldykge1xuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZXNbMF07XG4gICAgICAgIGNvbnN0IHNlcmllcyA9IHRoaXMuX3ByaXZhdGVfX2NyZWF0ZVNlcmllcyhvcHRpb25zLCBzZXJpZXNUeXBlLCBwYW5lLCBjdXN0b21QYW5lVmlldyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc2VzLnB1c2goc2VyaWVzKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Nlcmllc2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gY2FsbCBmdWxsVXBkYXRlIHRvIHJlY2FsY3VsYXRlIGNoYXJ0J3MgcGFydHMgZ2VvbWV0cnlcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2Z1bGxVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmllcztcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbW92ZVNlcmllcyhzZXJpZXMpIHtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX2ludGVybmFsX3BhbmVGb3JTb3VyY2Uoc2VyaWVzKTtcbiAgICAgICAgY29uc3Qgc2VyaWVzSW5kZXggPSB0aGlzLl9wcml2YXRlX19zZXJpZXNlcy5pbmRleE9mKHNlcmllcyk7XG4gICAgICAgIGFzc2VydChzZXJpZXNJbmRleCAhPT0gLTEsICdTZXJpZXMgbm90IGZvdW5kJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc2VzLnNwbGljZShzZXJpZXNJbmRleCwgMSk7XG4gICAgICAgIGVuc3VyZU5vdE51bGwocGFuZSkuX2ludGVybmFsX3JlbW92ZURhdGFTb3VyY2Uoc2VyaWVzKTtcbiAgICAgICAgaWYgKHNlcmllcy5faW50ZXJuYWxfZGVzdHJveSkge1xuICAgICAgICAgICAgc2VyaWVzLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX21vdmVTZXJpZXNUb1NjYWxlKHNlcmllcywgdGFyZ2V0U2NhbGVJZCkge1xuICAgICAgICBjb25zdCBwYW5lID0gZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF9wYW5lRm9yU291cmNlKHNlcmllcykpO1xuICAgICAgICBwYW5lLl9pbnRlcm5hbF9yZW1vdmVEYXRhU291cmNlKHNlcmllcyk7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRhcmdldFNjYWxlSWQgZXhpc3RzXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2ludGVybmFsX2ZpbmRQcmljZVNjYWxlKHRhcmdldFNjYWxlSWQpO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBuZXcgc2NhbGUgb24gdGhlIHNhbWUgcGFuZVxuICAgICAgICAgICAgY29uc3Qgek9yZGVyID0gc2VyaWVzLl9pbnRlcm5hbF96b3JkZXIoKTtcbiAgICAgICAgICAgIHBhbmUuX2ludGVybmFsX2FkZERhdGFTb3VyY2Uoc2VyaWVzLCB0YXJnZXRTY2FsZUlkLCB6T3JkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgbW92ZSB0byB0aGUgbmV3IHNjYWxlIG9mIHRoZSBzYW1lIHBhbmUsIGtlZXAgem9yZGVyXG4gICAgICAgICAgICAvLyBpZiBtb3ZlIHRvIG5ldyBwYW5lXG4gICAgICAgICAgICBjb25zdCB6T3JkZXIgPSAodGFyZ2V0Ll9pbnRlcm5hbF9wYW5lID09PSBwYW5lKSA/IHNlcmllcy5faW50ZXJuYWxfem9yZGVyKCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0YXJnZXQuX2ludGVybmFsX3BhbmUuX2ludGVybmFsX2FkZERhdGFTb3VyY2Uoc2VyaWVzLCB0YXJnZXRTY2FsZUlkLCB6T3JkZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9maXRDb250ZW50KCkge1xuICAgICAgICBjb25zdCBtYXNrID0gSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2xpZ2h0KCk7XG4gICAgICAgIG1hc2suX2ludGVybmFsX3NldEZpdENvbnRlbnQoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZShtYXNrKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFRhcmdldExvZ2ljYWxSYW5nZShyYW5nZSkge1xuICAgICAgICBjb25zdCBtYXNrID0gSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2xpZ2h0KCk7XG4gICAgICAgIG1hc2suX2ludGVybmFsX2FwcGx5UmFuZ2UocmFuZ2UpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKG1hc2spO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVzZXRUaW1lU2NhbGUoKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBJbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfbGlnaHQoKTtcbiAgICAgICAgbWFzay5faW50ZXJuYWxfcmVzZXRUaW1lU2NhbGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZShtYXNrKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldEJhclNwYWNpbmcoc3BhY2luZykge1xuICAgICAgICBjb25zdCBtYXNrID0gSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2xpZ2h0KCk7XG4gICAgICAgIG1hc2suX2ludGVybmFsX3NldEJhclNwYWNpbmcoc3BhY2luZyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUobWFzayk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRSaWdodE9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IEludmFsaWRhdGVNYXNrLl9pbnRlcm5hbF9saWdodCgpO1xuICAgICAgICBtYXNrLl9pbnRlcm5hbF9zZXRSaWdodE9mZnNldChvZmZzZXQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKG1hc2spO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0VGltZVNjYWxlQW5pbWF0aW9uKGFuaW1hdGlvbikge1xuICAgICAgICBjb25zdCBtYXNrID0gSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2xpZ2h0KCk7XG4gICAgICAgIG1hc2suX2ludGVybmFsX3NldFRpbWVTY2FsZUFuaW1hdGlvbihhbmltYXRpb24pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKG1hc2spO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RvcFRpbWVTY2FsZUFuaW1hdGlvbigpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IEludmFsaWRhdGVNYXNrLl9pbnRlcm5hbF9saWdodCgpO1xuICAgICAgICBtYXNrLl9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUobWFzayk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZWZhdWx0VmlzaWJsZVByaWNlU2NhbGVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucmlnaHRQcmljZVNjYWxlLnZpc2libGUgPyBcInJpZ2h0XCIgLyogRGVmYXVsdFByaWNlU2NhbGVJZC5SaWdodCAqLyA6IFwibGVmdFwiIC8qIERlZmF1bHRQcmljZVNjYWxlSWQuTGVmdCAqLztcbiAgICB9XG4gICAgX2ludGVybmFsX2JhY2tncm91bmRCb3R0b21Db2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2JhY2tncm91bmRCb3R0b21Db2xvcjtcbiAgICB9XG4gICAgX2ludGVybmFsX2JhY2tncm91bmRUb3BDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2JhY2tncm91bmRUb3BDb2xvcjtcbiAgICB9XG4gICAgX2ludGVybmFsX2JhY2tncm91bmRDb2xvckF0WVBlcmNlbnRGcm9tVG9wKHBlcmNlbnQpIHtcbiAgICAgICAgY29uc3QgYm90dG9tQ29sb3IgPSB0aGlzLl9wcml2YXRlX19iYWNrZ3JvdW5kQm90dG9tQ29sb3I7XG4gICAgICAgIGNvbnN0IHRvcENvbG9yID0gdGhpcy5fcHJpdmF0ZV9fYmFja2dyb3VuZFRvcENvbG9yO1xuICAgICAgICBpZiAoYm90dG9tQ29sb3IgPT09IHRvcENvbG9yKSB7XG4gICAgICAgICAgICAvLyBzb2xpZCBiYWNrZ3JvdW5kXG4gICAgICAgICAgICByZXR1cm4gYm90dG9tQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ3JhZGllbnQgYmFja2dyb3VuZFxuICAgICAgICAvLyBwZXJjZW50IHNob3VsZCBiZSBmcm9tIDAgdG8gMTAwICh3ZSdyZSB1c2luZyBvbmx5IGludGVnZXIgdmFsdWVzIHRvIG1ha2UgY2FjaGUgbW9yZSBlZmZpY2llbnQpXG4gICAgICAgIHBlcmNlbnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIE1hdGgucm91bmQocGVyY2VudCAqIDEwMCkpKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2dyYWRpZW50Q29sb3JzQ2FjaGUgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2dyYWRpZW50Q29sb3JzQ2FjaGUuX2ludGVybmFsX3RvcENvbG9yICE9PSB0b3BDb2xvciB8fCB0aGlzLl9wcml2YXRlX19ncmFkaWVudENvbG9yc0NhY2hlLl9pbnRlcm5hbF9ib3R0b21Db2xvciAhPT0gYm90dG9tQ29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2dyYWRpZW50Q29sb3JzQ2FjaGUgPSB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3RvcENvbG9yOiB0b3BDb2xvcixcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tQ29sb3I6IGJvdHRvbUNvbG9yLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9jb2xvcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWRWYWx1ZSA9IHRoaXMuX3ByaXZhdGVfX2dyYWRpZW50Q29sb3JzQ2FjaGUuX2ludGVybmFsX2NvbG9ycy5nZXQocGVyY2VudCk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBncmFkaWVudENvbG9yQXRQZXJjZW50KHRvcENvbG9yLCBib3R0b21Db2xvciwgcGVyY2VudCAvIDEwMCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2dyYWRpZW50Q29sb3JzQ2FjaGUuX2ludGVybmFsX2NvbG9ycy5zZXQocGVyY2VudCwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3BhbmVJbnZhbGlkYXRpb25NYXNrKHBhbmUsIGxldmVsKSB7XG4gICAgICAgIGNvbnN0IGludiA9IG5ldyBJbnZhbGlkYXRlTWFzayhsZXZlbCk7XG4gICAgICAgIGlmIChwYW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3ByaXZhdGVfX3BhbmVzLmluZGV4T2YocGFuZSk7XG4gICAgICAgICAgICBpbnYuX2ludGVybmFsX2ludmFsaWRhdGVQYW5lKGluZGV4LCB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2xldmVsOiBsZXZlbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnY7XG4gICAgfVxuICAgIF9wcml2YXRlX19pbnZhbGlkYXRpb25NYXNrRm9yU291cmNlKHNvdXJjZSwgaW52YWxpZGF0ZVR5cGUpIHtcbiAgICAgICAgaWYgKGludmFsaWRhdGVUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGludmFsaWRhdGVUeXBlID0gMiAvKiBJbnZhbGlkYXRpb25MZXZlbC5MaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZUludmFsaWRhdGlvbk1hc2sodGhpcy5faW50ZXJuYWxfcGFuZUZvclNvdXJjZShzb3VyY2UpLCBpbnZhbGlkYXRlVHlwZSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19pbnZhbGlkYXRlKG1hc2spIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlSGFuZGxlcihtYXNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lcy5mb3JFYWNoKChwYW5lKSA9PiBwYW5lLl9pbnRlcm5hbF9ncmlkKCkuX2ludGVybmFsX3BhbmVWaWV3KCkuX2ludGVybmFsX3VwZGF0ZSgpKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NyZWF0ZVNlcmllcyhvcHRpb25zLCBzZXJpZXNUeXBlLCBwYW5lLCBjdXN0b21QYW5lVmlldykge1xuICAgICAgICBjb25zdCBzZXJpZXMgPSBuZXcgU2VyaWVzKHRoaXMsIG9wdGlvbnMsIHNlcmllc1R5cGUsIHBhbmUsIGN1c3RvbVBhbmVWaWV3KTtcbiAgICAgICAgY29uc3QgdGFyZ2V0U2NhbGVJZCA9IG9wdGlvbnMucHJpY2VTY2FsZUlkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnByaWNlU2NhbGVJZCA6IHRoaXMuX2ludGVybmFsX2RlZmF1bHRWaXNpYmxlUHJpY2VTY2FsZUlkKCk7XG4gICAgICAgIHBhbmUuX2ludGVybmFsX2FkZERhdGFTb3VyY2Uoc2VyaWVzLCB0YXJnZXRTY2FsZUlkKTtcbiAgICAgICAgaWYgKCFpc0RlZmF1bHRQcmljZVNjYWxlKHRhcmdldFNjYWxlSWQpKSB7XG4gICAgICAgICAgICAvLyBsZXQncyBhcHBseSB0aGF0IG9wdGlvbnMgYWdhaW4gdG8gYXBwbHkgbWFyZ2luc1xuICAgICAgICAgICAgc2VyaWVzLl9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmllcztcbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldEJhY2tncm91bmRDb2xvcihzaWRlKSB7XG4gICAgICAgIGNvbnN0IGxheW91dE9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLmxheW91dDtcbiAgICAgICAgaWYgKGxheW91dE9wdGlvbnMuYmFja2dyb3VuZC50eXBlID09PSBcImdyYWRpZW50XCIgLyogQ29sb3JUeXBlLlZlcnRpY2FsR3JhZGllbnQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBzaWRlID09PSAwIC8qIEJhY2tncm91bmRDb2xvclNpZGUuVG9wICovID9cbiAgICAgICAgICAgICAgICBsYXlvdXRPcHRpb25zLmJhY2tncm91bmQudG9wQ29sb3IgOlxuICAgICAgICAgICAgICAgIGxheW91dE9wdGlvbnMuYmFja2dyb3VuZC5ib3R0b21Db2xvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF5b3V0T3B0aW9ucy5iYWNrZ3JvdW5kLmNvbG9yO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsbFVwRG93bkNhbmRsZXN0aWNrc0NvbG9ycyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuYm9yZGVyQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmJvcmRlclVwQ29sb3IgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgICAgICBvcHRpb25zLmJvcmRlckRvd25Db2xvciA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndpY2tDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMud2lja1VwQ29sb3IgPSBvcHRpb25zLndpY2tDb2xvcjtcbiAgICAgICAgb3B0aW9ucy53aWNrRG93bkNvbG9yID0gb3B0aW9ucy53aWNrQ29sb3I7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB0eXBlIG9mIHRoZSBsYXN0IHByaWNlIGFuaW1hdGlvbiBmb3Igc2VyaWVzIHN1Y2ggYXMgYXJlYSBvciBsaW5lLlxuICovXG52YXIgTGFzdFByaWNlQW5pbWF0aW9uTW9kZTtcbihmdW5jdGlvbiAoTGFzdFByaWNlQW5pbWF0aW9uTW9kZSkge1xuICAgIC8qKlxuICAgICAqIEFuaW1hdGlvbiBpcyBhbHdheXMgZGlzYWJsZWRcbiAgICAgKi9cbiAgICBMYXN0UHJpY2VBbmltYXRpb25Nb2RlW0xhc3RQcmljZUFuaW1hdGlvbk1vZGVbXCJEaXNhYmxlZFwiXSA9IDBdID0gXCJEaXNhYmxlZFwiO1xuICAgIC8qKlxuICAgICAqIEFuaW1hdGlvbiBpcyBhbHdheXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBMYXN0UHJpY2VBbmltYXRpb25Nb2RlW0xhc3RQcmljZUFuaW1hdGlvbk1vZGVbXCJDb250aW51b3VzXCJdID0gMV0gPSBcIkNvbnRpbnVvdXNcIjtcbiAgICAvKipcbiAgICAgKiBBbmltYXRpb24gaXMgYWN0aXZlIGFmdGVyIG5ldyBkYXRhLlxuICAgICAqL1xuICAgIExhc3RQcmljZUFuaW1hdGlvbk1vZGVbTGFzdFByaWNlQW5pbWF0aW9uTW9kZVtcIk9uRGF0YVVwZGF0ZVwiXSA9IDJdID0gXCJPbkRhdGFVcGRhdGVcIjtcbn0pKExhc3RQcmljZUFuaW1hdGlvbk1vZGUgfHwgKExhc3RQcmljZUFuaW1hdGlvbk1vZGUgPSB7fSkpO1xuZnVuY3Rpb24gcHJlY2lzaW9uQnlNaW5Nb3ZlKG1pbk1vdmUpIHtcbiAgICBpZiAobWluTW92ZSA+PSAxKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yICg7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgY29uc3QgaW50UGFydCA9IE1hdGgucm91bmQobWluTW92ZSk7XG4gICAgICAgIGNvbnN0IGZyYWN0UGFydCA9IE1hdGguYWJzKGludFBhcnQgLSBtaW5Nb3ZlKTtcbiAgICAgICAgaWYgKGZyYWN0UGFydCA8IDFlLTgpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIG1pbk1vdmUgPSBtaW5Nb3ZlICogMTA7XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBzb3VyY2Ugb2YgZGF0YSB0byBiZSB1c2VkIGZvciB0aGUgaG9yaXpvbnRhbCBwcmljZSBsaW5lLlxuICovXG52YXIgUHJpY2VMaW5lU291cmNlO1xuKGZ1bmN0aW9uIChQcmljZUxpbmVTb3VyY2UpIHtcbiAgICAvKipcbiAgICAgKiBVc2UgdGhlIGxhc3QgYmFyIGRhdGEuXG4gICAgICovXG4gICAgUHJpY2VMaW5lU291cmNlW1ByaWNlTGluZVNvdXJjZVtcIkxhc3RCYXJcIl0gPSAwXSA9IFwiTGFzdEJhclwiO1xuICAgIC8qKlxuICAgICAqIFVzZSB0aGUgbGFzdCB2aXNpYmxlIGRhdGEgb2YgdGhlIGNoYXJ0IHZpZXdwb3J0LlxuICAgICAqL1xuICAgIFByaWNlTGluZVNvdXJjZVtQcmljZUxpbmVTb3VyY2VbXCJMYXN0VmlzaWJsZVwiXSA9IDFdID0gXCJMYXN0VmlzaWJsZVwiO1xufSkoUHJpY2VMaW5lU291cmNlIHx8IChQcmljZUxpbmVTb3VyY2UgPSB7fSkpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0eXBlIG9mIGNvbG9yLlxuICovXG52YXIgQ29sb3JUeXBlO1xuKGZ1bmN0aW9uIChDb2xvclR5cGUpIHtcbiAgICAvKiogU29saWQgY29sb3IgKi9cbiAgICBDb2xvclR5cGVbXCJTb2xpZFwiXSA9IFwic29saWRcIjtcbiAgICAvKiogVmVydGljYWwgZ3JhZGllbnQgY29sb3IgKi9cbiAgICBDb2xvclR5cGVbXCJWZXJ0aWNhbEdyYWRpZW50XCJdID0gXCJncmFkaWVudFwiO1xufSkoQ29sb3JUeXBlIHx8IChDb2xvclR5cGUgPSB7fSkpO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgdGltZSB2YWx1ZSBpcyBhIGJ1c2luZXNzIGRheSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHRpbWUgLSBUaGUgdGltZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBgdGltZWAgaXMgYSB7QGxpbmsgQnVzaW5lc3NEYXl9IG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0J1c2luZXNzRGF5KHRpbWUpIHtcbiAgICByZXR1cm4gIWlzTnVtYmVyKHRpbWUpICYmICFpc1N0cmluZyh0aW1lKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB0aW1lIHZhbHVlIGlzIGEgVVRDIHRpbWVzdGFtcCBudW1iZXIuXG4gKlxuICogQHBhcmFtIHRpbWUgLSBUaGUgdGltZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBgdGltZWAgaXMgYSB7QGxpbmsgVVRDVGltZXN0YW1wfSBudW1iZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNVVENUaW1lc3RhbXAodGltZSkge1xuICAgIHJldHVybiBpc051bWJlcih0aW1lKTtcbn1cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdHlwZSBvZiBhIHRpY2sgbWFyayBvbiB0aGUgdGltZSBheGlzLlxuICovXG52YXIgVGlja01hcmtUeXBlO1xuKGZ1bmN0aW9uIChUaWNrTWFya1R5cGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc3RhcnQgb2YgdGhlIHllYXIgKGUuZy4gaXQncyB0aGUgZmlyc3QgdGljayBtYXJrIGluIGEgeWVhcikuXG4gICAgICovXG4gICAgVGlja01hcmtUeXBlW1RpY2tNYXJrVHlwZVtcIlllYXJcIl0gPSAwXSA9IFwiWWVhclwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzdGFydCBvZiB0aGUgbW9udGggKGUuZy4gaXQncyB0aGUgZmlyc3QgdGljayBtYXJrIGluIGEgbW9udGgpLlxuICAgICAqL1xuICAgIFRpY2tNYXJrVHlwZVtUaWNrTWFya1R5cGVbXCJNb250aFwiXSA9IDFdID0gXCJNb250aFwiO1xuICAgIC8qKlxuICAgICAqIEEgZGF5IG9mIHRoZSBtb250aC5cbiAgICAgKi9cbiAgICBUaWNrTWFya1R5cGVbVGlja01hcmtUeXBlW1wiRGF5T2ZNb250aFwiXSA9IDJdID0gXCJEYXlPZk1vbnRoXCI7XG4gICAgLyoqXG4gICAgICogQSB0aW1lIHdpdGhvdXQgc2Vjb25kcy5cbiAgICAgKi9cbiAgICBUaWNrTWFya1R5cGVbVGlja01hcmtUeXBlW1wiVGltZVwiXSA9IDNdID0gXCJUaW1lXCI7XG4gICAgLyoqXG4gICAgICogQSB0aW1lIHdpdGggc2Vjb25kcy5cbiAgICAgKi9cbiAgICBUaWNrTWFya1R5cGVbVGlja01hcmtUeXBlW1wiVGltZVdpdGhTZWNvbmRzXCJdID0gNF0gPSBcIlRpbWVXaXRoU2Vjb25kc1wiO1xufSkoVGlja01hcmtUeXBlIHx8IChUaWNrTWFya1R5cGUgPSB7fSkpO1xuXG5jb25zdCBnZXRNb250aCA9IChkYXRlKSA9PiBkYXRlLmdldFVUQ01vbnRoKCkgKyAxO1xuY29uc3QgZ2V0RGF5ID0gKGRhdGUpID0+IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuY29uc3QgZ2V0WWVhciA9IChkYXRlKSA9PiBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG5jb25zdCBkZCA9IChkYXRlKSA9PiBudW1iZXJUb1N0cmluZ1dpdGhMZWFkaW5nWmVybyhnZXREYXkoZGF0ZSksIDIpO1xuY29uc3QgTU1NTSA9IChkYXRlLCBsb2NhbGUpID0+IG5ldyBEYXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgZGF0ZS5nZXRVVENNb250aCgpLCAxKVxuICAgIC50b0xvY2FsZVN0cmluZyhsb2NhbGUsIHsgbW9udGg6ICdsb25nJyB9KTtcbmNvbnN0IE1NTSA9IChkYXRlLCBsb2NhbGUpID0+IG5ldyBEYXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgZGF0ZS5nZXRVVENNb250aCgpLCAxKVxuICAgIC50b0xvY2FsZVN0cmluZyhsb2NhbGUsIHsgbW9udGg6ICdzaG9ydCcgfSk7XG5jb25zdCBNTSA9IChkYXRlKSA9PiBudW1iZXJUb1N0cmluZ1dpdGhMZWFkaW5nWmVybyhnZXRNb250aChkYXRlKSwgMik7XG5jb25zdCB5eSA9IChkYXRlKSA9PiBudW1iZXJUb1N0cmluZ1dpdGhMZWFkaW5nWmVybyhnZXRZZWFyKGRhdGUpICUgMTAwLCAyKTtcbmNvbnN0IHl5eXkgPSAoZGF0ZSkgPT4gbnVtYmVyVG9TdHJpbmdXaXRoTGVhZGluZ1plcm8oZ2V0WWVhcihkYXRlKSwgNCk7XG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGZvcm1hdFxuICAgICAgICAucmVwbGFjZSgveXl5eS9nLCB5eXl5KGRhdGUpKVxuICAgICAgICAucmVwbGFjZSgveXkvZywgeXkoZGF0ZSkpXG4gICAgICAgIC5yZXBsYWNlKC9NTU1NL2csIE1NTU0oZGF0ZSwgbG9jYWxlKSlcbiAgICAgICAgLnJlcGxhY2UoL01NTS9nLCBNTU0oZGF0ZSwgbG9jYWxlKSlcbiAgICAgICAgLnJlcGxhY2UoL01NL2csIE1NKGRhdGUpKVxuICAgICAgICAucmVwbGFjZSgvZGQvZywgZGQoZGF0ZSkpO1xufVxuXG5jbGFzcyBEYXRlRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlRm9ybWF0ID0gJ3l5eXktTU0tZGQnLCBsb2NhbGUgPSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0ZUZvcm1hdCA9IGRhdGVGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvY2FsZSA9IGxvY2FsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Zvcm1hdChkYXRlKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXREYXRlKGRhdGUsIHRoaXMuX3ByaXZhdGVfX2RhdGVGb3JtYXQsIHRoaXMuX3ByaXZhdGVfX2xvY2FsZSk7XG4gICAgfVxufVxuXG5jbGFzcyBUaW1lRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihmb3JtYXQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0U3RyID0gZm9ybWF0IHx8ICclaDolbTolcyc7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9mb3JtYXQoZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0U3RyLnJlcGxhY2UoJyVoJywgbnVtYmVyVG9TdHJpbmdXaXRoTGVhZGluZ1plcm8oZGF0ZS5nZXRVVENIb3VycygpLCAyKSkuXG4gICAgICAgICAgICByZXBsYWNlKCclbScsIG51bWJlclRvU3RyaW5nV2l0aExlYWRpbmdaZXJvKGRhdGUuZ2V0VVRDTWludXRlcygpLCAyKSkuXG4gICAgICAgICAgICByZXBsYWNlKCclcycsIG51bWJlclRvU3RyaW5nV2l0aExlYWRpbmdaZXJvKGRhdGUuZ2V0VVRDU2Vjb25kcygpLCAyKSk7XG4gICAgfVxufVxuXG5jb25zdCBkZWZhdWx0UGFyYW1zID0ge1xuICAgIF9pbnRlcm5hbF9kYXRlRm9ybWF0OiAneXl5eS1NTS1kZCcsXG4gICAgX2ludGVybmFsX3RpbWVGb3JtYXQ6ICclaDolbTolcycsXG4gICAgX2ludGVybmFsX2RhdGVUaW1lU2VwYXJhdG9yOiAnICcsXG4gICAgX2ludGVybmFsX2xvY2FsZTogJ2RlZmF1bHQnLFxufTtcbmNsYXNzIERhdGVUaW1lRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXJQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRlRm9ybWF0dGVyID0gbmV3IERhdGVGb3JtYXR0ZXIoZm9ybWF0dGVyUGFyYW1zLl9pbnRlcm5hbF9kYXRlRm9ybWF0LCBmb3JtYXR0ZXJQYXJhbXMuX2ludGVybmFsX2xvY2FsZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVGb3JtYXR0ZXIgPSBuZXcgVGltZUZvcm1hdHRlcihmb3JtYXR0ZXJQYXJhbXMuX2ludGVybmFsX3RpbWVGb3JtYXQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXBhcmF0b3IgPSBmb3JtYXR0ZXJQYXJhbXMuX2ludGVybmFsX2RhdGVUaW1lU2VwYXJhdG9yO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZm9ybWF0KGRhdGVUaW1lKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLl9wcml2YXRlX19kYXRlRm9ybWF0dGVyLl9pbnRlcm5hbF9mb3JtYXQoZGF0ZVRpbWUpfSR7dGhpcy5fcHJpdmF0ZV9fc2VwYXJhdG9yfSR7dGhpcy5fcHJpdmF0ZV9fdGltZUZvcm1hdHRlci5faW50ZXJuYWxfZm9ybWF0KGRhdGVUaW1lKX1gO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRpY2tNYXJrRm9ybWF0dGVyKHRpbWVQb2ludCwgdGlja01hcmtUeXBlLCBsb2NhbGUpIHtcbiAgICBjb25zdCBmb3JtYXRPcHRpb25zID0ge307XG4gICAgc3dpdGNoICh0aWNrTWFya1R5cGUpIHtcbiAgICAgICAgY2FzZSAwIC8qIFRpY2tNYXJrVHlwZS5ZZWFyICovOlxuICAgICAgICAgICAgZm9ybWF0T3B0aW9ucy55ZWFyID0gJ251bWVyaWMnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBUaWNrTWFya1R5cGUuTW9udGggKi86XG4gICAgICAgICAgICBmb3JtYXRPcHRpb25zLm1vbnRoID0gJ3Nob3J0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogVGlja01hcmtUeXBlLkRheU9mTW9udGggKi86XG4gICAgICAgICAgICBmb3JtYXRPcHRpb25zLmRheSA9ICdudW1lcmljJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogVGlja01hcmtUeXBlLlRpbWUgKi86XG4gICAgICAgICAgICBmb3JtYXRPcHRpb25zLmhvdXIxMiA9IGZhbHNlO1xuICAgICAgICAgICAgZm9ybWF0T3B0aW9ucy5ob3VyID0gJzItZGlnaXQnO1xuICAgICAgICAgICAgZm9ybWF0T3B0aW9ucy5taW51dGUgPSAnMi1kaWdpdCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0IC8qIFRpY2tNYXJrVHlwZS5UaW1lV2l0aFNlY29uZHMgKi86XG4gICAgICAgICAgICBmb3JtYXRPcHRpb25zLmhvdXIxMiA9IGZhbHNlO1xuICAgICAgICAgICAgZm9ybWF0T3B0aW9ucy5ob3VyID0gJzItZGlnaXQnO1xuICAgICAgICAgICAgZm9ybWF0T3B0aW9ucy5taW51dGUgPSAnMi1kaWdpdCc7XG4gICAgICAgICAgICBmb3JtYXRPcHRpb25zLnNlY29uZCA9ICcyLWRpZ2l0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBkYXRlID0gdGltZVBvaW50Ll9pbnRlcm5hbF9idXNpbmVzc0RheSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gbmV3IERhdGUodGltZVBvaW50Ll9pbnRlcm5hbF90aW1lc3RhbXAgKiAxMDAwKVxuICAgICAgICA6IG5ldyBEYXRlKERhdGUuVVRDKHRpbWVQb2ludC5faW50ZXJuYWxfYnVzaW5lc3NEYXkueWVhciwgdGltZVBvaW50Ll9pbnRlcm5hbF9idXNpbmVzc0RheS5tb250aCAtIDEsIHRpbWVQb2ludC5faW50ZXJuYWxfYnVzaW5lc3NEYXkuZGF5KSk7XG4gICAgLy8gZnJvbSBnaXZlbiBkYXRlIHdlIHNob3VsZCB1c2Ugb25seSBhcyBVVEMgZGF0ZSBvciB0aW1lc3RhbXBcbiAgICAvLyBidXQgdG8gZm9ybWF0IGFzIGxvY2FsZSBkYXRlIHdlIGNhbiBjb252ZXJ0IFVUQyBkYXRlIHRvIGxvY2FsIGRhdGVcbiAgICBjb25zdCBsb2NhbERhdGVGcm9tVXRjID0gbmV3IERhdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCBkYXRlLmdldFVUQ01vbnRoKCksIGRhdGUuZ2V0VVRDRGF0ZSgpLCBkYXRlLmdldFVUQ0hvdXJzKCksIGRhdGUuZ2V0VVRDTWludXRlcygpLCBkYXRlLmdldFVUQ1NlY29uZHMoKSwgZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKSk7XG4gICAgcmV0dXJuIGxvY2FsRGF0ZUZyb21VdGMudG9Mb2NhbGVTdHJpbmcobG9jYWxlLCBmb3JtYXRPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaG91cnMoY291bnQpIHtcbiAgICByZXR1cm4gY291bnQgKiA2MCAqIDYwICogMTAwMDtcbn1cbmZ1bmN0aW9uIG1pbnV0ZXMoY291bnQpIHtcbiAgICByZXR1cm4gY291bnQgKiA2MCAqIDEwMDA7XG59XG5mdW5jdGlvbiBzZWNvbmRzKGNvdW50KSB7XG4gICAgcmV0dXJuIGNvdW50ICogMTAwMDtcbn1cbmNvbnN0IGludHJhZGF5V2VpZ2h0RGl2aXNvcnMgPSBbXG4gICAgeyBfaW50ZXJuYWxfZGl2aXNvcjogc2Vjb25kcygxKSwgX2ludGVybmFsX3dlaWdodDogMTAgLyogVGlja01hcmtXZWlnaHQuU2Vjb25kICovIH0sXG4gICAgeyBfaW50ZXJuYWxfZGl2aXNvcjogbWludXRlcygxKSwgX2ludGVybmFsX3dlaWdodDogMjAgLyogVGlja01hcmtXZWlnaHQuTWludXRlMSAqLyB9LFxuICAgIHsgX2ludGVybmFsX2Rpdmlzb3I6IG1pbnV0ZXMoNSksIF9pbnRlcm5hbF93ZWlnaHQ6IDIxIC8qIFRpY2tNYXJrV2VpZ2h0Lk1pbnV0ZTUgKi8gfSxcbiAgICB7IF9pbnRlcm5hbF9kaXZpc29yOiBtaW51dGVzKDMwKSwgX2ludGVybmFsX3dlaWdodDogMjIgLyogVGlja01hcmtXZWlnaHQuTWludXRlMzAgKi8gfSxcbiAgICB7IF9pbnRlcm5hbF9kaXZpc29yOiBob3VycygxKSwgX2ludGVybmFsX3dlaWdodDogMzAgLyogVGlja01hcmtXZWlnaHQuSG91cjEgKi8gfSxcbiAgICB7IF9pbnRlcm5hbF9kaXZpc29yOiBob3VycygzKSwgX2ludGVybmFsX3dlaWdodDogMzEgLyogVGlja01hcmtXZWlnaHQuSG91cjMgKi8gfSxcbiAgICB7IF9pbnRlcm5hbF9kaXZpc29yOiBob3Vycyg2KSwgX2ludGVybmFsX3dlaWdodDogMzIgLyogVGlja01hcmtXZWlnaHQuSG91cjYgKi8gfSxcbiAgICB7IF9pbnRlcm5hbF9kaXZpc29yOiBob3VycygxMiksIF9pbnRlcm5hbF93ZWlnaHQ6IDMzIC8qIFRpY2tNYXJrV2VpZ2h0LkhvdXIxMiAqLyB9LFxuXTtcbmZ1bmN0aW9uIHdlaWdodEJ5VGltZShjdXJyZW50RGF0ZSwgcHJldkRhdGUpIHtcbiAgICBpZiAoY3VycmVudERhdGUuZ2V0VVRDRnVsbFllYXIoKSAhPT0gcHJldkRhdGUuZ2V0VVRDRnVsbFllYXIoKSkge1xuICAgICAgICByZXR1cm4gNzAgLyogVGlja01hcmtXZWlnaHQuWWVhciAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoY3VycmVudERhdGUuZ2V0VVRDTW9udGgoKSAhPT0gcHJldkRhdGUuZ2V0VVRDTW9udGgoKSkge1xuICAgICAgICByZXR1cm4gNjAgLyogVGlja01hcmtXZWlnaHQuTW9udGggKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1cnJlbnREYXRlLmdldFVUQ0RhdGUoKSAhPT0gcHJldkRhdGUuZ2V0VVRDRGF0ZSgpKSB7XG4gICAgICAgIHJldHVybiA1MCAvKiBUaWNrTWFya1dlaWdodC5EYXkgKi87XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBpbnRyYWRheVdlaWdodERpdmlzb3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChNYXRoLmZsb29yKHByZXZEYXRlLmdldFRpbWUoKSAvIGludHJhZGF5V2VpZ2h0RGl2aXNvcnNbaV0uX2ludGVybmFsX2Rpdmlzb3IpICE9PSBNYXRoLmZsb29yKGN1cnJlbnREYXRlLmdldFRpbWUoKSAvIGludHJhZGF5V2VpZ2h0RGl2aXNvcnNbaV0uX2ludGVybmFsX2Rpdmlzb3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50cmFkYXlXZWlnaHREaXZpc29yc1tpXS5faW50ZXJuYWxfd2VpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwIC8qIFRpY2tNYXJrV2VpZ2h0Lkxlc3NUaGFuU2Vjb25kICovO1xufVxuZnVuY3Rpb24gY2FzdCh0KSB7XG4gICAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBmaWxsV2VpZ2h0c0ZvclBvaW50cyhzb3J0ZWRUaW1lUG9pbnRzLCBzdGFydEluZGV4ID0gMCkge1xuICAgIGlmIChzb3J0ZWRUaW1lUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwcmV2VGltZSA9IHN0YXJ0SW5kZXggPT09IDAgPyBudWxsIDogY2FzdChzb3J0ZWRUaW1lUG9pbnRzW3N0YXJ0SW5kZXggLSAxXS50aW1lKS5faW50ZXJuYWxfdGltZXN0YW1wO1xuICAgIGxldCBwcmV2RGF0ZSA9IHByZXZUaW1lICE9PSBudWxsID8gbmV3IERhdGUocHJldlRpbWUgKiAxMDAwKSA6IG51bGw7XG4gICAgbGV0IHRvdGFsVGltZURpZmYgPSAwO1xuICAgIGZvciAobGV0IGluZGV4ID0gc3RhcnRJbmRleDsgaW5kZXggPCBzb3J0ZWRUaW1lUG9pbnRzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICBjb25zdCBjdXJyZW50UG9pbnQgPSBzb3J0ZWRUaW1lUG9pbnRzW2luZGV4XTtcbiAgICAgICAgY29uc3QgY3VycmVudERhdGUgPSBuZXcgRGF0ZShjYXN0KGN1cnJlbnRQb2ludC50aW1lKS5faW50ZXJuYWxfdGltZXN0YW1wICogMTAwMCk7XG4gICAgICAgIGlmIChwcmV2RGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY3VycmVudFBvaW50LnRpbWVXZWlnaHQgPSB3ZWlnaHRCeVRpbWUoY3VycmVudERhdGUsIHByZXZEYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0b3RhbFRpbWVEaWZmICs9IGNhc3QoY3VycmVudFBvaW50LnRpbWUpLl9pbnRlcm5hbF90aW1lc3RhbXAgLSAocHJldlRpbWUgfHwgY2FzdChjdXJyZW50UG9pbnQudGltZSkuX2ludGVybmFsX3RpbWVzdGFtcCk7XG4gICAgICAgIHByZXZUaW1lID0gY2FzdChjdXJyZW50UG9pbnQudGltZSkuX2ludGVybmFsX3RpbWVzdGFtcDtcbiAgICAgICAgcHJldkRhdGUgPSBjdXJyZW50RGF0ZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0SW5kZXggPT09IDAgJiYgc29ydGVkVGltZVBvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIGxldCdzIGd1ZXNzIGEgd2VpZ2h0IGZvciB0aGUgZmlyc3QgcG9pbnRcbiAgICAgICAgLy8gbGV0J3Mgc2F5IHRoZSBwcmV2aW91cyBwb2ludCB3YXMgYXZlcmFnZSB0aW1lIGJhY2sgaW4gdGhlIGhpc3RvcnlcbiAgICAgICAgY29uc3QgYXZlcmFnZVRpbWVEaWZmID0gTWF0aC5jZWlsKHRvdGFsVGltZURpZmYgLyAoc29ydGVkVGltZVBvaW50cy5sZW5ndGggLSAxKSk7XG4gICAgICAgIGNvbnN0IGFwcHJveFByZXZEYXRlID0gbmV3IERhdGUoKGNhc3Qoc29ydGVkVGltZVBvaW50c1swXS50aW1lKS5faW50ZXJuYWxfdGltZXN0YW1wIC0gYXZlcmFnZVRpbWVEaWZmKSAqIDEwMDApO1xuICAgICAgICBzb3J0ZWRUaW1lUG9pbnRzWzBdLnRpbWVXZWlnaHQgPSB3ZWlnaHRCeVRpbWUobmV3IERhdGUoY2FzdChzb3J0ZWRUaW1lUG9pbnRzWzBdLnRpbWUpLl9pbnRlcm5hbF90aW1lc3RhbXAgKiAxMDAwKSwgYXBwcm94UHJldkRhdGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYnVzaW5lc3NEYXlDb252ZXJ0ZXIodGltZSkge1xuICAgIGxldCBidXNpbmVzc0RheSA9IHRpbWU7XG4gICAgaWYgKGlzU3RyaW5nKHRpbWUpKSB7XG4gICAgICAgIGJ1c2luZXNzRGF5ID0gc3RyaW5nVG9CdXNpbmVzc0RheSh0aW1lKTtcbiAgICB9XG4gICAgaWYgKCFpc0J1c2luZXNzRGF5KGJ1c2luZXNzRGF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RpbWUgbXVzdCBiZSBvZiB0eXBlIEJ1c2luZXNzRGF5Jyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyhidXNpbmVzc0RheS55ZWFyLCBidXNpbmVzc0RheS5tb250aCAtIDEsIGJ1c2luZXNzRGF5LmRheSwgMCwgMCwgMCwgMCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIF9pbnRlcm5hbF90aW1lc3RhbXA6IE1hdGgucm91bmQoZGF0ZS5nZXRUaW1lKCkgLyAxMDAwKSxcbiAgICAgICAgX2ludGVybmFsX2J1c2luZXNzRGF5OiBidXNpbmVzc0RheSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdGltZXN0YW1wQ29udmVydGVyKHRpbWUpIHtcbiAgICBpZiAoIWlzVVRDVGltZXN0YW1wKHRpbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGltZSBtdXN0IGJlIG9mIHR5cGUgaXNVVENUaW1lc3RhbXAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2ludGVybmFsX3RpbWVzdGFtcDogdGltZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gc2VsZWN0VGltZUNvbnZlcnRlcihkYXRhKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNCdXNpbmVzc0RheShkYXRhWzBdLnRpbWUpIHx8IGlzU3RyaW5nKGRhdGFbMF0udGltZSkpIHtcbiAgICAgICAgcmV0dXJuIGJ1c2luZXNzRGF5Q29udmVydGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGltZXN0YW1wQ29udmVydGVyO1xufVxuY29uc3QgdmFsaWREYXRlUmVnZXggPSAvXlxcZFxcZFxcZFxcZC1cXGRcXGQtXFxkXFxkJC87XG5mdW5jdGlvbiBjb252ZXJ0VGltZSh0aW1lKSB7XG4gICAgaWYgKGlzVVRDVGltZXN0YW1wKHRpbWUpKSB7XG4gICAgICAgIHJldHVybiB0aW1lc3RhbXBDb252ZXJ0ZXIodGltZSk7XG4gICAgfVxuICAgIGlmICghaXNCdXNpbmVzc0RheSh0aW1lKSkge1xuICAgICAgICByZXR1cm4gYnVzaW5lc3NEYXlDb252ZXJ0ZXIoc3RyaW5nVG9CdXNpbmVzc0RheSh0aW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBidXNpbmVzc0RheUNvbnZlcnRlcih0aW1lKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQnVzaW5lc3NEYXkodmFsdWUpIHtcbiAgICB7XG4gICAgICAgIC8vIGluIHNvbWUgYnJvd3NlcnMgKEkgbG9vayBhdCB5b3VyIENocm9tZSkgdGhlIERhdGUgY29uc3RydWN0b3IgbWF5IGFjY2VwdCBpbnZhbGlkIGRhdGUgc3RyaW5nXG4gICAgICAgIC8vIGJ1dCBwYXJzZXMgdGhlbSBpbiAnaW1wbGVtZW50YXRpb24gc3BlY2lmaWMnIHdheVxuICAgICAgICAvLyBmb3IgZXhhbXBsZSAyMDE5LTEtMSBpc24ndCB0aGUgc2FtZSBhcyAyMDE5LTAxLTAxIChmb3IgQ2hyb21lIGJvdGggYXJlICd2YWxpZCcgZGF0ZSBzdHJpbmdzKVxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTY4OTM5XG4gICAgICAgIC8vIHNvLCB3ZSBuZWVkIHRvIGJlIHN1cmUgdGhhdCBkYXRlIGhhcyB2YWxpZCBmb3JtYXQgdG8gYXZvaWQgc3RyYW5nZSBiZWhhdmlvciBhbmQgaG91cnMgb2YgZGVidWdnaW5nXG4gICAgICAgIC8vIGJ1dCBsZXQncyBkbyB0aGlzIGluIGRldmVsb3BtZW50IGJ1aWxkIG9ubHkgYmVjYXVzZSBvZiBwZXJmXG4gICAgICAgIGlmICghdmFsaWREYXRlUmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRlIHN0cmluZz0ke3ZhbHVlfSwgZXhwZWN0ZWQgZm9ybWF0PXl5eXktbW0tZGRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkID0gbmV3IERhdGUodmFsdWUpO1xuICAgIGlmIChpc05hTihkLmdldFRpbWUoKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGUgc3RyaW5nPSR7dmFsdWV9LCBleHBlY3RlZCBmb3JtYXQ9eXl5eS1tbS1kZGApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkYXk6IGQuZ2V0VVRDRGF0ZSgpLFxuICAgICAgICBtb250aDogZC5nZXRVVENNb250aCgpICsgMSxcbiAgICAgICAgeWVhcjogZC5nZXRVVENGdWxsWWVhcigpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0U3RyaW5nVG9CdXNpbmVzc0RheSh2YWx1ZSkge1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZS50aW1lKSkge1xuICAgICAgICB2YWx1ZS50aW1lID0gc3RyaW5nVG9CdXNpbmVzc0RheSh2YWx1ZS50aW1lKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0U3RyaW5nc1RvQnVzaW5lc3NEYXlzKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5mb3JFYWNoKGNvbnZlcnRTdHJpbmdUb0J1c2luZXNzRGF5KTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB3ZWlnaHRUb1RpY2tNYXJrVHlwZSh3ZWlnaHQsIHRpbWVWaXNpYmxlLCBzZWNvbmRzVmlzaWJsZSkge1xuICAgIHN3aXRjaCAod2VpZ2h0KSB7XG4gICAgICAgIGNhc2UgMCAvKiBUaWNrTWFya1dlaWdodC5MZXNzVGhhblNlY29uZCAqLzpcbiAgICAgICAgY2FzZSAxMCAvKiBUaWNrTWFya1dlaWdodC5TZWNvbmQgKi86XG4gICAgICAgICAgICByZXR1cm4gdGltZVZpc2libGVcbiAgICAgICAgICAgICAgICA/IChzZWNvbmRzVmlzaWJsZSA/IDQgLyogVGlja01hcmtUeXBlLlRpbWVXaXRoU2Vjb25kcyAqLyA6IDMgLyogVGlja01hcmtUeXBlLlRpbWUgKi8pXG4gICAgICAgICAgICAgICAgOiAyIC8qIFRpY2tNYXJrVHlwZS5EYXlPZk1vbnRoICovO1xuICAgICAgICBjYXNlIDIwIC8qIFRpY2tNYXJrV2VpZ2h0Lk1pbnV0ZTEgKi86XG4gICAgICAgIGNhc2UgMjEgLyogVGlja01hcmtXZWlnaHQuTWludXRlNSAqLzpcbiAgICAgICAgY2FzZSAyMiAvKiBUaWNrTWFya1dlaWdodC5NaW51dGUzMCAqLzpcbiAgICAgICAgY2FzZSAzMCAvKiBUaWNrTWFya1dlaWdodC5Ib3VyMSAqLzpcbiAgICAgICAgY2FzZSAzMSAvKiBUaWNrTWFya1dlaWdodC5Ib3VyMyAqLzpcbiAgICAgICAgY2FzZSAzMiAvKiBUaWNrTWFya1dlaWdodC5Ib3VyNiAqLzpcbiAgICAgICAgY2FzZSAzMyAvKiBUaWNrTWFya1dlaWdodC5Ib3VyMTIgKi86XG4gICAgICAgICAgICByZXR1cm4gdGltZVZpc2libGUgPyAzIC8qIFRpY2tNYXJrVHlwZS5UaW1lICovIDogMiAvKiBUaWNrTWFya1R5cGUuRGF5T2ZNb250aCAqLztcbiAgICAgICAgY2FzZSA1MCAvKiBUaWNrTWFya1dlaWdodC5EYXkgKi86XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBUaWNrTWFya1R5cGUuRGF5T2ZNb250aCAqLztcbiAgICAgICAgY2FzZSA2MCAvKiBUaWNrTWFya1dlaWdodC5Nb250aCAqLzpcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFRpY2tNYXJrVHlwZS5Nb250aCAqLztcbiAgICAgICAgY2FzZSA3MCAvKiBUaWNrTWFya1dlaWdodC5ZZWFyICovOlxuICAgICAgICAgICAgcmV0dXJuIDAgLyogVGlja01hcmtUeXBlLlllYXIgKi87XG4gICAgfVxufVxuY2xhc3MgSG9yelNjYWxlQmVoYXZpb3JUaW1lIHtcbiAgICBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucztcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnVwZGF0ZUZvcm1hdHRlcihvcHRpb25zLmxvY2FsaXphdGlvbik7XG4gICAgfVxuICAgIHByZXByb2Nlc3NEYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnZlcnRTdHJpbmdzVG9CdXNpbmVzc0RheXMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb252ZXJ0U3RyaW5nVG9CdXNpbmVzc0RheShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVDb252ZXJ0ZXJUb0ludGVybmFsT2JqKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGVuc3VyZU5vdE51bGwoc2VsZWN0VGltZUNvbnZlcnRlcihkYXRhKSk7XG4gICAgfVxuICAgIGtleShpdGVtKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmIFwiX2ludGVybmFsX3RpbWVzdGFtcFwiIGluIGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLl9pbnRlcm5hbF90aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXkodGhpcy5jb252ZXJ0SG9yekl0ZW1Ub0ludGVybmFsKGl0ZW0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWNoZUtleShpdGVtKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBpdGVtO1xuICAgICAgICByZXR1cm4gdGltZS5faW50ZXJuYWxfYnVzaW5lc3NEYXkgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBuZXcgRGF0ZSh0aW1lLl9pbnRlcm5hbF90aW1lc3RhbXAgKiAxMDAwKS5nZXRUaW1lKClcbiAgICAgICAgICAgIDogbmV3IERhdGUoRGF0ZS5VVEModGltZS5faW50ZXJuYWxfYnVzaW5lc3NEYXkueWVhciwgdGltZS5faW50ZXJuYWxfYnVzaW5lc3NEYXkubW9udGggLSAxLCB0aW1lLl9pbnRlcm5hbF9idXNpbmVzc0RheS5kYXkpKS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGNvbnZlcnRIb3J6SXRlbVRvSW50ZXJuYWwoaXRlbSkge1xuICAgICAgICByZXR1cm4gY29udmVydFRpbWUoaXRlbSk7XG4gICAgfVxuICAgIHVwZGF0ZUZvcm1hdHRlcihvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGVGb3JtYXQgPSBvcHRpb25zLmRhdGVGb3JtYXQ7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpbWVTY2FsZS50aW1lVmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0ZVRpbWVGb3JtYXR0ZXIgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXIoe1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9kYXRlRm9ybWF0OiBkYXRlRm9ybWF0LFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90aW1lRm9ybWF0OiB0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpbWVTY2FsZS5zZWNvbmRzVmlzaWJsZSA/ICclaDolbTolcycgOiAnJWg6JW0nLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9kYXRlVGltZVNlcGFyYXRvcjogJyAgICcsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2xvY2FsZTogb3B0aW9ucy5sb2NhbGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGVUaW1lRm9ybWF0dGVyID0gbmV3IERhdGVGb3JtYXR0ZXIoZGF0ZUZvcm1hdCwgb3B0aW9ucy5sb2NhbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcm1hdEhvcnpJdGVtKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgdHAgPSBpdGVtO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZGF0ZVRpbWVGb3JtYXR0ZXIuX2ludGVybmFsX2Zvcm1hdChuZXcgRGF0ZSh0cC5faW50ZXJuYWxfdGltZXN0YW1wICogMTAwMCkpO1xuICAgIH1cbiAgICBmb3JtYXRUaWNrbWFyayh0aWNrTWFyaywgbG9jYWxpemF0aW9uT3B0aW9ucykge1xuICAgICAgICBjb25zdCB0aWNrTWFya1R5cGUgPSB3ZWlnaHRUb1RpY2tNYXJrVHlwZSh0aWNrTWFyay53ZWlnaHQsIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudGltZVNjYWxlLnRpbWVWaXNpYmxlLCB0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpbWVTY2FsZS5zZWNvbmRzVmlzaWJsZSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpbWVTY2FsZTtcbiAgICAgICAgaWYgKG9wdGlvbnMudGlja01hcmtGb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGlja01hcmtTdHJpbmcgPSBvcHRpb25zLnRpY2tNYXJrRm9ybWF0dGVyKHRpY2tNYXJrLm9yaWdpbmFsVGltZSwgdGlja01hcmtUeXBlLCBsb2NhbGl6YXRpb25PcHRpb25zLmxvY2FsZSk7XG4gICAgICAgICAgICBpZiAodGlja01hcmtTdHJpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGlja01hcmtTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRUaWNrTWFya0Zvcm1hdHRlcih0aWNrTWFyay50aW1lLCB0aWNrTWFya1R5cGUsIGxvY2FsaXphdGlvbk9wdGlvbnMubG9jYWxlKTtcbiAgICB9XG4gICAgbWF4VGlja01hcmtXZWlnaHQodGlja01hcmtzKSB7XG4gICAgICAgIGxldCBtYXhXZWlnaHQgPSB0aWNrTWFya3MucmVkdWNlKG1hcmtXaXRoR3JlYXRlcldlaWdodCwgdGlja01hcmtzWzBdKS53ZWlnaHQ7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZTogaXQgbG9va3Mgc3RyYW5nZSBpZiAxNTowMCBpcyBib2xkIGJ1dCAxNDowMCBpcyBub3RcbiAgICAgICAgLy8gc28gaWYgbWF4V2VpZ2h0ID4gVGlja01hcmtXZWlnaHQuSG91cjEgYW5kIDwgVGlja01hcmtXZWlnaHQuRGF5IHJlZHVjZSBpdCB0byBUaWNrTWFya1dlaWdodC5Ib3VyMVxuICAgICAgICBpZiAobWF4V2VpZ2h0ID4gMzAgLyogVGlja01hcmtXZWlnaHQuSG91cjEgKi8gJiYgbWF4V2VpZ2h0IDwgNTAgLyogVGlja01hcmtXZWlnaHQuRGF5ICovKSB7XG4gICAgICAgICAgICBtYXhXZWlnaHQgPSAzMCAvKiBUaWNrTWFya1dlaWdodC5Ib3VyMSAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4V2VpZ2h0O1xuICAgIH1cbiAgICBmaWxsV2VpZ2h0c0ZvclBvaW50cyhzb3J0ZWRUaW1lUG9pbnRzLCBzdGFydEluZGV4KSB7XG4gICAgICAgIGZpbGxXZWlnaHRzRm9yUG9pbnRzKHNvcnRlZFRpbWVQb2ludHMsIHN0YXJ0SW5kZXgpO1xuICAgIH1cbiAgICBzdGF0aWMgX2ludGVybmFsX2FwcGx5RGVmYXVsdHMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbWVyZ2UoeyBsb2NhbGl6YXRpb246IHsgZGF0ZUZvcm1hdDogJ2RkIE1NTSBcXCd5eScgfSB9LCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFdoZW4geW91J3JlIHRyeWluZyB0byB1c2UgdGhlIGxpYnJhcnkgaW4gc2VydmVyLXNpZGUgY29udGV4dCAoZm9yIGluc3RhbmNlIGluIFNTUilcbiAqIHlvdSBkb24ndCBoYXZlIHNvbWUgYnJvd3Nlci1zcGVjaWZpYyB2YXJpYWJsZXMgbGlrZSBuYXZpZ2F0b3Igb3Igd2luZG93XG4gKiBhbmQgaWYgdGhlIGxpYnJhcnkgd2lsbCB1c2UgdGhlbSBvbiB0aGUgdG9wIGxldmVsIG9mIHRoZSBsaWJyYXJ5XG4gKiB0aGUgaW1wb3J0IHdpbGwgZmFpbCBkdWUgUmVmZXJlbmNlRXJyb3JcbiAqIHRodXMsIHRoaXMgYWxsb3dzIHVzZSB0aGUgbmF2aWdhdG9yIG9uIHRoZSB0b3AgbGV2ZWwgYW5kIGJlaW5nIGltcG9ydGVkIGluIHNlcnZlci1zaWRlIGNvbnRleHQgYXMgd2VsbFxuICogU2VlIGlzc3VlICM0NDZcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC90c2xpbnQvY29uZmlnXG5jb25zdCBpc1J1bm5pbmdPbkNsaWVudFNpZGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuZnVuY3Rpb24gaXNGRigpIHtcbiAgICBpZiAoIWlzUnVubmluZ09uQ2xpZW50U2lkZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSA+IC0xO1xufVxuZnVuY3Rpb24gaXNJT1MoKSB7XG4gICAgaWYgKCFpc1J1bm5pbmdPbkNsaWVudFNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICByZXR1cm4gL2lQaG9uZXxpUGFkfGlQb2QvLnRlc3Qod2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSk7XG59XG5mdW5jdGlvbiBpc0Nocm9tZSgpIHtcbiAgICBpZiAoIWlzUnVubmluZ09uQ2xpZW50U2lkZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cuY2hyb21lICE9PSB1bmRlZmluZWQ7XG59XG4vLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgYnJvd3NlciBpcyBydW5uaW5nIG9uIHdpbmRvd3MuXG5mdW5jdGlvbiBpc1dpbmRvd3MoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghaXNSdW5uaW5nT25DbGllbnRTaWRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gbW9yZSBhY2N1cmF0ZSBpZiBhdmFpbGFibGVcbiAgICBpZiAoKF9hID0gbmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wbGF0Zm9ybSkge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEucGxhdGZvcm0gPT09ICdXaW5kb3dzJztcbiAgICB9XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd3aW4nKSA+PSAwO1xufVxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgQ2hyb21pdW0gYmFzZWQuXG5mdW5jdGlvbiBpc0Nocm9taXVtQmFzZWQoKSB7XG4gICAgaWYgKCFpc1J1bm5pbmdPbkNsaWVudFNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIW5hdmlnYXRvci51c2VyQWdlbnREYXRhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnREYXRhLmJyYW5kcy5zb21lKChicmFuZCkgPT4ge1xuICAgICAgICByZXR1cm4gYnJhbmQuYnJhbmQuaW5jbHVkZXMoJ0Nocm9taXVtJyk7XG4gICAgfSk7XG59XG5cbi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwiX2J1aWxkLXRpbWUtY29uc3RhbnRzXCIgLz5cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICB9XG59XG5cbi8vIG9uIEhpLURQSSBDU1Mgc2l6ZSAqIERldmljZSBQaXhlbCBSYXRpbyBzaG91bGQgYmUgaW50ZWdlciB0byBhdm9pZCBzbW9vdGhpbmdcbi8vIEZvciBjaGFydCB3aWRnZXQgd2UgZGVjcmVhc2UgdGhlIHNpemUgYmVjYXVzZSB3ZSBtdXN0IGJlIGluc2lkZSBjb250YWluZXIuXG4vLyBGb3IgdGltZSBheGlzIHRoaXMgaXMgbm90IGltcG9ydGFudCwgc2luY2UgaXQganVzdCBhZmZlY3RzIHNwYWNlIGZvciBwYW5lIHdpZGdldHNcbmZ1bmN0aW9uIHN1Z2dlc3RDaGFydFNpemUob3JpZ2luYWxTaXplKSB7XG4gICAgY29uc3QgaW50ZWdlcldpZHRoID0gTWF0aC5mbG9vcihvcmlnaW5hbFNpemUud2lkdGgpO1xuICAgIGNvbnN0IGludGVnZXJIZWlnaHQgPSBNYXRoLmZsb29yKG9yaWdpbmFsU2l6ZS5oZWlnaHQpO1xuICAgIGNvbnN0IHdpZHRoID0gaW50ZWdlcldpZHRoIC0gKGludGVnZXJXaWR0aCAlIDIpO1xuICAgIGNvbnN0IGhlaWdodCA9IGludGVnZXJIZWlnaHQgLSAoaW50ZWdlckhlaWdodCAlIDIpO1xuICAgIHJldHVybiBzaXplJDEoeyB3aWR0aCwgaGVpZ2h0IH0pO1xufVxuZnVuY3Rpb24gc3VnZ2VzdFRpbWVTY2FsZUhlaWdodChvcmlnaW5hbEhlaWdodCkge1xuICAgIHJldHVybiBvcmlnaW5hbEhlaWdodCArIChvcmlnaW5hbEhlaWdodCAlIDIpO1xufVxuZnVuY3Rpb24gc3VnZ2VzdFByaWNlU2NhbGVXaWR0aChvcmlnaW5hbFdpZHRoKSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsV2lkdGggKyAob3JpZ2luYWxXaWR0aCAlIDIpO1xufVxuXG5mdW5jdGlvbiBkaXN0YW5jZUJldHdlZW5Qb2ludHMocG9zMSwgcG9zMikge1xuICAgIHJldHVybiBwb3MxLl9pbnRlcm5hbF9wb3NpdGlvbiAtIHBvczIuX2ludGVybmFsX3Bvc2l0aW9uO1xufVxuZnVuY3Rpb24gc3BlZWRQeFBlck1TZWMocG9zMSwgcG9zMiwgbWF4U3BlZWQpIHtcbiAgICBjb25zdCBzcGVlZCA9IChwb3MxLl9pbnRlcm5hbF9wb3NpdGlvbiAtIHBvczIuX2ludGVybmFsX3Bvc2l0aW9uKSAvIChwb3MxLl9pbnRlcm5hbF90aW1lIC0gcG9zMi5faW50ZXJuYWxfdGltZSk7XG4gICAgcmV0dXJuIE1hdGguc2lnbihzcGVlZCkgKiBNYXRoLm1pbihNYXRoLmFicyhzcGVlZCksIG1heFNwZWVkKTtcbn1cbmZ1bmN0aW9uIGR1cmF0aW9uTVNlYyhzcGVlZCwgZHVtcGluZ0NvZWZmKSB7XG4gICAgY29uc3QgbG5EdW1waW5nQ29lZmYgPSBNYXRoLmxvZyhkdW1waW5nQ29lZmYpO1xuICAgIHJldHVybiBNYXRoLmxvZygoMSAvKiBDb25zdGFudHMuRXBzaWxvbkRpc3RhbmNlICovICogbG5EdW1waW5nQ29lZmYpIC8gLXNwZWVkKSAvIChsbkR1bXBpbmdDb2VmZik7XG59XG5jbGFzcyBLaW5ldGljQW5pbWF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtaW5TcGVlZCwgbWF4U3BlZWQsIGR1bXBpbmdDb2VmZiwgbWluTW92ZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjEgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hbmltYXRpb25TdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHVyYXRpb25Nc2VjcyA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NwZWVkUHhQZXJNc2VjID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWluU3BlZWQgPSBtaW5TcGVlZDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWF4U3BlZWQgPSBtYXhTcGVlZDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHVtcGluZ0NvZWZmID0gZHVtcGluZ0NvZWZmO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19taW5Nb3ZlID0gbWluTW92ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2FkZFBvc2l0aW9uKHBvc2l0aW9uLCB0aW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wb3NpdGlvbjEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wb3NpdGlvbjEuX2ludGVybmFsX3RpbWUgPT09IHRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjEuX2ludGVybmFsX3Bvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMS5faW50ZXJuYWxfcG9zaXRpb24gLSBwb3NpdGlvbikgPCB0aGlzLl9wcml2YXRlX19taW5Nb3ZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uNCA9IHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24zID0gdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24yO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjIgPSB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjE7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMSA9IHsgX2ludGVybmFsX3RpbWU6IHRpbWUsIF9pbnRlcm5hbF9wb3NpdGlvbjogcG9zaXRpb24gfTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXJ0KHBvc2l0aW9uLCB0aW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wb3NpdGlvbjEgPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24yID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWUgLSB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjEuX2ludGVybmFsX3RpbWUgPiA1MCAvKiBDb25zdGFudHMuTWF4U3RhcnREZWxheSAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBhbGwgdGhlIHJlc3QgcGFyYW1ldGVycyB3ZSBzaG91bGQgY2FsY3VsYXRlIHRoZSBzcGVlZCBhZiBmaXJzdFxuICAgICAgICBsZXQgdG90YWxEaXN0YW5jZSA9IDA7XG4gICAgICAgIGNvbnN0IHNwZWVkMSA9IHNwZWVkUHhQZXJNU2VjKHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMSwgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24yLCB0aGlzLl9wcml2YXRlX19tYXhTcGVlZCk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlMSA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyh0aGlzLl9wcml2YXRlX19wb3NpdGlvbjEsIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMik7XG4gICAgICAgIC8vIFdlJ3JlIGNhbGN1bGF0aW5nIHdlaWdodGVkIGF2ZXJhZ2Ugc3BlZWRcbiAgICAgICAgLy8gVGhhbiBtb3JlIGRpc3RhbmNlIGZvciBhIHNlZ21lbnQsIHRoYW4gbW9yZSBpdHMgd2VpZ2h0XG4gICAgICAgIGNvbnN0IHNwZWVkSXRlbXMgPSBbc3BlZWQxXTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VJdGVtcyA9IFtkaXN0YW5jZTFdO1xuICAgICAgICB0b3RhbERpc3RhbmNlICs9IGRpc3RhbmNlMTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc3BlZWQyID0gc3BlZWRQeFBlck1TZWModGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24yLCB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjMsIHRoaXMuX3ByaXZhdGVfX21heFNwZWVkKTtcbiAgICAgICAgICAgIC8vIHN0b3AgYXQgdGhpcyBtb21lbnQgaWYgZGlyZWN0aW9uIG9mIHRoZSBzZWdtZW50IGlzIG9wcG9zaXRlXG4gICAgICAgICAgICBpZiAoTWF0aC5zaWduKHNwZWVkMikgPT09IE1hdGguc2lnbihzcGVlZDEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UyID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMiwgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24zKTtcbiAgICAgICAgICAgICAgICBzcGVlZEl0ZW1zLnB1c2goc3BlZWQyKTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZUl0ZW1zLnB1c2goZGlzdGFuY2UyKTtcbiAgICAgICAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IGRpc3RhbmNlMjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcG9zaXRpb240ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwZWVkMyA9IHNwZWVkUHhQZXJNU2VjKHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMywgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb240LCB0aGlzLl9wcml2YXRlX19tYXhTcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLnNpZ24oc3BlZWQzKSA9PT0gTWF0aC5zaWduKHNwZWVkMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlMyA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyh0aGlzLl9wcml2YXRlX19wb3NpdGlvbjMsIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVlZEl0ZW1zLnB1c2goc3BlZWQzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlSXRlbXMucHVzaChkaXN0YW5jZTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxEaXN0YW5jZSArPSBkaXN0YW5jZTM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdFNwZWVkID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVlZEl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRTcGVlZCArPSBkaXN0YW5jZUl0ZW1zW2ldIC8gdG90YWxEaXN0YW5jZSAqIHNwZWVkSXRlbXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguYWJzKHJlc3VsdFNwZWVkKSA8IHRoaXMuX3ByaXZhdGVfX21pblNwZWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYW5pbWF0aW9uU3RhcnRQb3NpdGlvbiA9IHsgX2ludGVybmFsX3Bvc2l0aW9uOiBwb3NpdGlvbiwgX2ludGVybmFsX3RpbWU6IHRpbWUgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3BlZWRQeFBlck1zZWMgPSByZXN1bHRTcGVlZDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHVyYXRpb25Nc2VjcyA9IGR1cmF0aW9uTVNlYyhNYXRoLmFicyhyZXN1bHRTcGVlZCksIHRoaXMuX3ByaXZhdGVfX2R1bXBpbmdDb2VmZik7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRQb3NpdGlvbih0aW1lKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2FuaW1hdGlvblN0YXJ0UG9zaXRpb24pO1xuICAgICAgICBjb25zdCBkdXJhdGlvbk1zZWNzID0gdGltZSAtIHN0YXJ0UG9zaXRpb24uX2ludGVybmFsX3RpbWU7XG4gICAgICAgIHJldHVybiBzdGFydFBvc2l0aW9uLl9pbnRlcm5hbF9wb3NpdGlvbiArIHRoaXMuX3ByaXZhdGVfX3NwZWVkUHhQZXJNc2VjICogKE1hdGgucG93KHRoaXMuX3ByaXZhdGVfX2R1bXBpbmdDb2VmZiwgZHVyYXRpb25Nc2VjcykgLSAxKSAvIChNYXRoLmxvZyh0aGlzLl9wcml2YXRlX19kdW1waW5nQ29lZmYpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2ZpbmlzaGVkKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2FuaW1hdGlvblN0YXJ0UG9zaXRpb24gPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fcHJvZ3Jlc3NEdXJhdGlvbih0aW1lKSA9PT0gdGhpcy5fcHJpdmF0ZV9fZHVyYXRpb25Nc2VjcztcbiAgICB9XG4gICAgX3ByaXZhdGVfX3Byb2dyZXNzRHVyYXRpb24odGltZSkge1xuICAgICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19hbmltYXRpb25TdGFydFBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aW1lIC0gc3RhcnRQb3NpdGlvbi5faW50ZXJuYWxfdGltZTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHByb2dyZXNzLCB0aGlzLl9wcml2YXRlX19kdXJhdGlvbk1zZWNzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJvdW5kQ2FudmFzKHBhcmVudEVsZW1lbnQsIHNpemUpIHtcbiAgICBjb25zdCBkb2MgPSBlbnN1cmVOb3ROdWxsKHBhcmVudEVsZW1lbnQub3duZXJEb2N1bWVudCk7XG4gICAgY29uc3QgY2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICBjb25zdCBiaW5kaW5nID0gYmluZENhbnZhc0VsZW1lbnRCaXRtYXBTaXplVG8oY2FudmFzLCB7XG4gICAgICAgIHR5cGU6ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBhbGxvd1Jlc2l6ZU9ic2VydmVyOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtOiAoYml0bWFwU2l6ZSwgY2FudmFzRWxlbWVudENsaWVudFNpemUpID0+ICh7XG4gICAgICAgICAgICB3aWR0aDogTWF0aC5tYXgoYml0bWFwU2l6ZS53aWR0aCwgY2FudmFzRWxlbWVudENsaWVudFNpemUud2lkdGgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChiaXRtYXBTaXplLmhlaWdodCwgY2FudmFzRWxlbWVudENsaWVudFNpemUuaGVpZ2h0KSxcbiAgICAgICAgfSksXG4gICAgfSk7XG4gICAgYmluZGluZy5yZXNpemVDYW52YXNFbGVtZW50KHNpemUpO1xuICAgIHJldHVybiBiaW5kaW5nO1xufVxuZnVuY3Rpb24gcmVsZWFzZUNhbnZhcyhjYW52YXMpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBmaXhlcyB0aGUgaU9TIFNhZmFyaSBlcnJvciBcIlRvdGFsIGNhbnZhcyBtZW1vcnkgdXNlIGV4Y2VlZHMgdGhlIG1heGltdW0gbGltaXRcIi5cbiAgICAvLyBTZWVtcyB0aGF0IGlPUyBTYWZhcmkgc3RvcmVzIGNhbnZhcyBlbGVtZW50cyBmb3Igc29tZSBhZGRpdGlvbmFsIHRpbWUgaW50ZXJuYWxseS5cbiAgICAvLyBTbyBpZiB3ZSBjcmVhdGUvZGVzdHJveSBhIGxvdCBvZiBjYW52YXMgZWxlbWVudHMgaW4gYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSB3ZSBjYW4gZ2V0IHRoaXMgZXJyb3IuXG4gICAgLy8gV2UgcmVzaXplIHRoZSBjYW52YXMgdG8gMXgxIHBpeGVscyB0byBmb3JjZSBpdCB0byByZWxlYXNlIG1lbW1vcnkgcmVzb3VyY2VzLlxuICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgKF9hID0gY2FudmFzLmdldENvbnRleHQoJzJkJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGVhclJlY3QoMCwgMCwgMSwgMSk7XG59XG5cbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKHJlbmRlcmVyLCB0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpIHtcbiAgICBpZiAocmVuZGVyZXIuX2ludGVybmFsX2RyYXdCYWNrZ3JvdW5kKSB7XG4gICAgICAgIHJlbmRlcmVyLl9pbnRlcm5hbF9kcmF3QmFja2dyb3VuZCh0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRyYXdGb3JlZ3JvdW5kKHJlbmRlcmVyLCB0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpIHtcbiAgICByZW5kZXJlci5faW50ZXJuYWxfZHJhdyh0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpO1xufVxuZnVuY3Rpb24gZHJhd1NvdXJjZVBhbmVWaWV3cyhwYW5lVmlld3NHZXR0ZXIsIGRyYXdSZW5kZXJlckZuLCBzb3VyY2UsIHBhbmUpIHtcbiAgICBjb25zdCBwYW5lVmlld3MgPSBwYW5lVmlld3NHZXR0ZXIoc291cmNlLCBwYW5lKTtcbiAgICBmb3IgKGNvbnN0IHBhbmVWaWV3IG9mIHBhbmVWaWV3cykge1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IHBhbmVWaWV3Ll9pbnRlcm5hbF9yZW5kZXJlcigpO1xuICAgICAgICBpZiAocmVuZGVyZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRyYXdSZW5kZXJlckZuKHJlbmRlcmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcHJldmVudFNjcm9sbEJ5V2hlZWxDbGljayhlbCkge1xuICAgIGlmICghaXNDaHJvbWUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChlKSA9PiB7XG4gICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMSAvKiBNb3VzZUV2ZW50QnV0dG9uLk1pZGRsZSAqLykge1xuICAgICAgICAgICAgLy8gcHJldmVudCBpbmNvcnJlY3Qgc2Nyb2xsaW5nIGV2ZW50XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbn1cblxuLy8gVE9ETzogZ2V0IHJpZCBvZiBhIGxvdCBvZiBib29sZWFuIGZsYWdzLCBwcm9iYWJseSB3ZSBzaG91bGQgcmVwbGFjZSBpdCB3aXRoIHNvbWUgZW51bVxuY2xhc3MgTW91c2VFdmVudEhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja1Bvc2l0aW9uID0geyBfaW50ZXJuYWxfeDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBfaW50ZXJuYWxfeTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFwVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFwUG9zaXRpb24gPSB7IF9pbnRlcm5hbF94OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIF9pbnRlcm5hbF95OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9uZ1RhcFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvbmdUYXBBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VNb3ZlU3RhcnRQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvdWNoTW92ZVN0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3VjaE1vdmVFeGNlZWRlZE1hbmhhdHRhbkRpc3RhbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbmNlbENsaWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbmNlbFRhcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU91dHNpZGVNb3VzZUV2ZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlT3V0c2lkZVRvdWNoRXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb2JpbGVTYWZhcmlFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU1vdXNlbW92ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFBpbmNoTWlkZGxlUG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFBpbmNoRGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19waW5jaFByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmV2ZW50VG91Y2hEcmFnUHJvY2VzcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZVByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFzdFRvdWNoRXZlbnRUaW1lU3RhbXAgPSAwO1xuICAgICAgICAvLyBmb3IgdG91Y2hzdGFydC90b3VjaG1vdmUvdG91Y2hlbmQgZXZlbnRzIHdlIGhhbmRsZSBvbmx5IGZpcnN0IHRvdWNoXG4gICAgICAgIC8vIGkuZS4gd2UgZG9uJ3Qgc3VwcG9ydCBzZXZlcmFsIGFjdGl2ZSB0b3VjaGVzIGF0IHRoZSBzYW1lIHRpbWUgKGV4Y2VwdCBwaW5jaCBldmVudClcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWN0aXZlVG91Y2hJZCA9IG51bGw7XG4gICAgICAgIC8vIGFjY2VwdCBhbGwgbW91c2UgbGVhdmUgZXZlbnRzIGlmIGl0J3Mgbm90IGFuIGlPUyBkZXZpY2VcbiAgICAgICAgLy8gc2VlIF9tb3VzZUVudGVySGFuZGxlciwgX21vdXNlTW92ZUhhbmRsZXIsIF9tb3VzZUxlYXZlSGFuZGxlclxuICAgICAgICB0aGlzLl9wcml2YXRlX19hY2NlcHRNb3VzZUxlYXZlID0gIWlzSU9TKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbiBGaXJlZm94IG1vdXNlIGV2ZW50cyBkb250J3QgZmlyZSBpZiB0aGUgbW91c2UgcG9zaXRpb24gaXMgb3V0c2lkZSBvZiB0aGUgYnJvd3NlcidzIGJvcmRlci5cbiAgICAgICAgICogVG8gcHJldmVudCB0aGUgbW91c2UgZnJvbSBoYW5naW5nIHdoaWxlIHByZXNzZWQgd2UncmUgc3Vic2NyaWJpbmcgb24gdGhlIG1vdXNlbGVhdmUgZXZlbnQgb2YgdGhlIGRvY3VtZW50IGVsZW1lbnQuXG4gICAgICAgICAqIFdlJ3JlIHN1YnNjcmliaW5nIG9uIG1vdXNlbGVhdmUsIGJ1dCB0aGlzIGV2ZW50IGlzIGFjdHVhbGx5IGZpcmVkIG9uIG1vdXNldXAgb3V0c2lkZSBvZiB0aGUgYnJvd3NlcidzIGJvcmRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uRmlyZWZveE91dHNpZGVNb3VzZVVwID0gKG1vdXNlVXBFdmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VVcEhhbmRsZXIobW91c2VVcEV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhZmFyaSBkb2Vzbid0IGZpcmUgdG91Y2hzdGFydC9tb3VzZWRvd24gZXZlbnRzIG9uIGRvdWJsZSB0YXAgc2luY2UgaU9TIDEzLlxuICAgICAgICAgKiBUaGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNvbHV0aW9uczpcbiAgICAgICAgICogMSkgQ2FsbCBwcmV2ZW50RGVmYXVsdCBpbiB0b3VjaEVuZCBoYW5kbGVyLiBCdXQgaXQgYWxzbyBwcmV2ZW50cyBjbGljayBldmVudCBmcm9tIGZpcmluZy5cbiAgICAgICAgICogMikgQWRkIGxpc3RlbmVyIG9uIGRibGNsaWNrIGV2ZW50IHRoYXQgZmlyZXMgd2l0aCB0aGUgcHJlY2VkaW5nIG1vdXNlZG93bi9tb3VzZXVwLlxuICAgICAgICAgKiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9ydW1zL3RocmVhZC8xMjUwNzNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uTW9iaWxlU2FmYXJpRG91YmxlQ2xpY2sgPSAoZGJsQ2xpY2tFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ZpcmVzVG91Y2hFdmVudHMoZGJsQ2xpY2tFdmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wYXRFdmVudCA9IHRoaXMuX3ByaXZhdGVfX21ha2VDb21wYXRFdmVudChkYmxDbGlja0V2ZW50KTtcbiAgICAgICAgICAgICAgICArK3RoaXMuX3ByaXZhdGVfX3RhcENvdW50O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX190YXBUaW1lb3V0SWQgJiYgdGhpcy5fcHJpdmF0ZV9fdGFwQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgX2ludGVybmFsX21hbmhhdHRhbkRpc3RhbmNlOiBtYW5oYXR0YW5EaXN0YW5jZSB9ID0gdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3VzZU1vdmVXaXRoRG93bkluZm8oZ2V0UG9zaXRpb24oZGJsQ2xpY2tFdmVudCksIHRoaXMuX3ByaXZhdGVfX3RhcFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hbmhhdHRhbkRpc3RhbmNlIDwgMzAgLyogQ29uc3RhbnRzLkRvdWJsZVRhcE1hbmhhdHRhbkRpc3RhbmNlICovICYmICF0aGlzLl9wcml2YXRlX19jYW5jZWxUYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Byb2Nlc3NUb3VjaEV2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9kb3VibGVUYXBFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVzZXRUYXBUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGF0RXZlbnQgPSB0aGlzLl9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQoZGJsQ2xpY2tFdmVudCk7XG4gICAgICAgICAgICAgICAgKyt0aGlzLl9wcml2YXRlX19jbGlja0NvdW50O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jbGlja1RpbWVvdXRJZCAmJiB0aGlzLl9wcml2YXRlX19jbGlja0NvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IF9pbnRlcm5hbF9tYW5oYXR0YW5EaXN0YW5jZTogbWFuaGF0dGFuRGlzdGFuY2UgfSA9IHRoaXMuX3ByaXZhdGVfX3RvdWNoTW91c2VNb3ZlV2l0aERvd25JbmZvKGdldFBvc2l0aW9uKGRibENsaWNrRXZlbnQpLCB0aGlzLl9wcml2YXRlX19jbGlja1Bvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hbmhhdHRhbkRpc3RhbmNlIDwgNSAvKiBDb25zdGFudHMuRG91YmxlQ2xpY2tNYW5oYXR0YW5EaXN0YW5jZSAqLyAmJiAhdGhpcy5fcHJpdmF0ZV9fY2FuY2VsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Byb2Nlc3NNb3VzZUV2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9tb3VzZURvdWJsZUNsaWNrRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jlc2V0Q2xpY2tUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5pdCgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlT3V0c2lkZU1vdXNlRXZlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU91dHNpZGVNb3VzZUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVPdXRzaWRlTW91c2VFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU91dHNpZGVUb3VjaEV2ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVPdXRzaWRlVG91Y2hFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlT3V0c2lkZVRvdWNoRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb3VzZW1vdmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU1vdXNlbW92ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb2JpbGVTYWZhcmlFdmVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW9iaWxlU2FmYXJpRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU1vYmlsZVNhZmFyaUV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJMb25nVGFwVGltZW91dCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNldENsaWNrVGltZW91dCgpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VFbnRlckhhbmRsZXIoZW50ZXJFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb3VzZW1vdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm91bmRNb3VzZU1vdmVIYW5kbGVyID0gdGhpcy5fcHJpdmF0ZV9fbW91c2VNb3ZlSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU1vdXNlbW92ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBib3VuZE1vdXNlTW92ZUhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgYm91bmRNb3VzZU1vdmVIYW5kbGVyKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ZpcmVzVG91Y2hFdmVudHMoZW50ZXJFdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wYXRFdmVudCA9IHRoaXMuX3ByaXZhdGVfX21ha2VDb21wYXRFdmVudChlbnRlckV2ZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc01vdXNlRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX21vdXNlRW50ZXJFdmVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjY2VwdE1vdXNlTGVhdmUgPSB0cnVlO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcmVzZXRDbGlja1RpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jbGlja1RpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3ByaXZhdGVfX2NsaWNrVGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja1Bvc2l0aW9uID0geyBfaW50ZXJuYWxfeDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBfaW50ZXJuYWxfeTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIH07XG4gICAgfVxuICAgIF9wcml2YXRlX19yZXNldFRhcFRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX190YXBUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9wcml2YXRlX190YXBUaW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFwVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFwUG9zaXRpb24gPSB7IF9pbnRlcm5hbF94OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIF9pbnRlcm5hbF95OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21vdXNlTW92ZUhhbmRsZXIobW92ZUV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19tb3VzZVByZXNzZWQgfHwgdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3ZlU3RhcnRQb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19maXJlc1RvdWNoRXZlbnRzKG1vdmVFdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wYXRFdmVudCA9IHRoaXMuX3ByaXZhdGVfX21ha2VDb21wYXRFdmVudChtb3ZlRXZlbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzTW91c2VFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfbW91c2VNb3ZlRXZlbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hY2NlcHRNb3VzZUxlYXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3RvdWNoTW92ZUhhbmRsZXIobW92ZUV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHRvdWNoID0gdG91Y2hXaXRoSWQobW92ZUV2ZW50LmNoYW5nZWRUb3VjaGVzLCBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2FjdGl2ZVRvdWNoSWQpKTtcbiAgICAgICAgaWYgKHRvdWNoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFzdFRvdWNoRXZlbnRUaW1lU3RhbXAgPSBldmVudFRpbWVTdGFtcChtb3ZlRXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhcnRQaW5jaE1pZGRsZVBvaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByZXZlbnRUb3VjaERyYWdQcm9jZXNzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJldmVudCBwaW5jaCBpZiBtb3ZlIGV2ZW50IGNvbWVzIGZhc3RlciB0aGFuIHRoZSBzZWNvbmQgdG91Y2hcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGluY2hQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBtb3ZlSW5mbyA9IHRoaXMuX3ByaXZhdGVfX3RvdWNoTW91c2VNb3ZlV2l0aERvd25JbmZvKGdldFBvc2l0aW9uKHRvdWNoKSwgZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX190b3VjaE1vdmVTdGFydFBvc2l0aW9uKSk7XG4gICAgICAgIGNvbnN0IHsgX2ludGVybmFsX3hPZmZzZXQ6IHhPZmZzZXQsIF9pbnRlcm5hbF95T2Zmc2V0OiB5T2Zmc2V0LCBfaW50ZXJuYWxfbWFuaGF0dGFuRGlzdGFuY2U6IG1hbmhhdHRhbkRpc3RhbmNlIH0gPSBtb3ZlSW5mbztcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX190b3VjaE1vdmVFeGNlZWRlZE1hbmhhdHRhbkRpc3RhbmNlICYmIG1hbmhhdHRhbkRpc3RhbmNlIDwgNSAvKiBDb25zdGFudHMuQ2FuY2VsVGFwTWFuaGF0dGFuRGlzdGFuY2UgKi8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3RvdWNoTW92ZUV4Y2VlZGVkTWFuaGF0dGFuRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRpbWUgd2hlbiBjdXJyZW50IHBvc2l0aW9uIGV4Y2VlZGVkIG1hbmhhdHRhbiBkaXN0YW5jZVxuICAgICAgICAgICAgLy8gdmVydGljYWwgZHJhZyBpcyBtb3JlIGltcG9ydGFudCB0aGFuIGhvcml6b250YWwgZHJhZ1xuICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBzY3JvbGwgdGhlIHBhZ2UgdmVydGljYWxseSBvZnRlbiB0aGFuIGhvcml6b250YWxseVxuICAgICAgICAgICAgY29uc3QgY29ycmVjdGVkWE9mZnNldCA9IHhPZmZzZXQgKiAwLjU7XG4gICAgICAgICAgICAvLyBhIGRyYWcgY2FuIGJlIG9ubHkgaWYgdG91Y2ggcGFnZSBzY3JvbGwgaXNuJ3QgYWxsb3dlZFxuICAgICAgICAgICAgY29uc3QgaXNWZXJ0RHJhZyA9IHlPZmZzZXQgPj0gY29ycmVjdGVkWE9mZnNldCAmJiAhdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5faW50ZXJuYWxfdHJlYXRWZXJ0VG91Y2hEcmFnQXNQYWdlU2Nyb2xsKCk7XG4gICAgICAgICAgICBjb25zdCBpc0hvcnpEcmFnID0gY29ycmVjdGVkWE9mZnNldCA+IHlPZmZzZXQgJiYgIXRoaXMuX3ByaXZhdGVfX29wdGlvbnMuX2ludGVybmFsX3RyZWF0SG9yelRvdWNoRHJhZ0FzUGFnZVNjcm9sbCgpO1xuICAgICAgICAgICAgLy8gaWYgZHJhZyBldmVudCBoYXBwZW5lZCB0aGVuIHdlIHNob3VsZCByZXZlcnQgcHJldmVudERlZmF1bHQgc3RhdGUgdG8gb3JpZ2luYWwgb25lXG4gICAgICAgICAgICAvLyBhbmQgdHJ5IHRvIHByb2Nlc3MgdGhlIGRyYWcgZXZlbnRcbiAgICAgICAgICAgIC8vIGVsc2Ugd2Ugc2hvdWxkbid0IHByZXZlbnQgZGVmYXVsdCBvZiB0aGUgZXZlbnQgYW5kIGlnbm9yZSBwcm9jZXNzaW5nIHRoZSBkcmFnIGV2ZW50XG4gICAgICAgICAgICBpZiAoIWlzVmVydERyYWcgJiYgIWlzSG9yekRyYWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmV2ZW50VG91Y2hEcmFnUHJvY2VzcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190b3VjaE1vdmVFeGNlZWRlZE1hbmhhdHRhbkRpc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGlmIG1hbmhhdHRhbiBkaXN0YW5jZSBpcyBtb3JlIHRoYXQgNSAtIHdlIHNob3VsZCBjYW5jZWwgdGFwIGV2ZW50XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYW5jZWxUYXAgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJMb25nVGFwVGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVzZXRUYXBUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19wcmV2ZW50VG91Y2hEcmFnUHJvY2Vzcykge1xuICAgICAgICAgICAgY29uc3QgY29tcGF0RXZlbnQgPSB0aGlzLl9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQobW92ZUV2ZW50LCB0b3VjaCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzVG91Y2hFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfdG91Y2hNb3ZlRXZlbnQpO1xuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIHByZXZlbnQgZGVmYXVsdCBpbiBjYXNlIG9mIHRvdWNoIG9ubHlcbiAgICAgICAgICAgIC8vIHRvIHByZXZlbnQgc2Nyb2xsIG9mIHRoZSBwYWdlXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChtb3ZlRXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZU1vdmVXaXRoRG93bkhhbmRsZXIobW92ZUV2ZW50KSB7XG4gICAgICAgIGlmIChtb3ZlRXZlbnQuYnV0dG9uICE9PSAwIC8qIE1vdXNlRXZlbnRCdXR0b24uTGVmdCAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vdmVJbmZvID0gdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3VzZU1vdmVXaXRoRG93bkluZm8oZ2V0UG9zaXRpb24obW92ZUV2ZW50KSwgZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19tb3VzZU1vdmVTdGFydFBvc2l0aW9uKSk7XG4gICAgICAgIGNvbnN0IHsgX2ludGVybmFsX21hbmhhdHRhbkRpc3RhbmNlOiBtYW5oYXR0YW5EaXN0YW5jZSB9ID0gbW92ZUluZm87XG4gICAgICAgIGlmIChtYW5oYXR0YW5EaXN0YW5jZSA+PSA1IC8qIENvbnN0YW50cy5DYW5jZWxDbGlja01hbmhhdHRhbkRpc3RhbmNlICovKSB7XG4gICAgICAgICAgICAvLyBpZiBtYW5oYXR0YW4gZGlzdGFuY2UgaXMgbW9yZSB0aGF0IDUgLSB3ZSBzaG91bGQgY2FuY2VsIGNsaWNrIGV2ZW50XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYW5jZWxDbGljayA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNldENsaWNrVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jYW5jZWxDbGljaykge1xuICAgICAgICAgICAgLy8gaWYgdGhpcy5fY2FuY2VsQ2xpY2sgaXMgdHJ1ZSwgdGhhdCBtZWFucyB0aGF0IG1pbmltdW0gbWFuaGF0dGFuIGRpc3RhbmNlIGlzIGFscmVhZHkgZXhjZWVkZWRcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhdEV2ZW50ID0gdGhpcy5fcHJpdmF0ZV9fbWFrZUNvbXBhdEV2ZW50KG1vdmVFdmVudCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzTW91c2VFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfcHJlc3NlZE1vdXNlTW92ZUV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fdG91Y2hNb3VzZU1vdmVXaXRoRG93bkluZm8oY3VycmVudFBvc2l0aW9uLCBzdGFydFBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHhPZmZzZXQgPSBNYXRoLmFicyhzdGFydFBvc2l0aW9uLl9pbnRlcm5hbF94IC0gY3VycmVudFBvc2l0aW9uLl9pbnRlcm5hbF94KTtcbiAgICAgICAgY29uc3QgeU9mZnNldCA9IE1hdGguYWJzKHN0YXJ0UG9zaXRpb24uX2ludGVybmFsX3kgLSBjdXJyZW50UG9zaXRpb24uX2ludGVybmFsX3kpO1xuICAgICAgICBjb25zdCBtYW5oYXR0YW5EaXN0YW5jZSA9IHhPZmZzZXQgKyB5T2Zmc2V0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX3hPZmZzZXQ6IHhPZmZzZXQsXG4gICAgICAgICAgICBfaW50ZXJuYWxfeU9mZnNldDogeU9mZnNldCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9tYW5oYXR0YW5EaXN0YW5jZTogbWFuaGF0dGFuRGlzdGFuY2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgX3ByaXZhdGVfX3RvdWNoRW5kSGFuZGxlcih0b3VjaEVuZEV2ZW50KSB7XG4gICAgICAgIGxldCB0b3VjaCA9IHRvdWNoV2l0aElkKHRvdWNoRW5kRXZlbnQuY2hhbmdlZFRvdWNoZXMsIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fYWN0aXZlVG91Y2hJZCkpO1xuICAgICAgICBpZiAodG91Y2ggPT09IG51bGwgJiYgdG91Y2hFbmRFdmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmcsIHNvbWVob3cgd2UgbWlzc2VkIHRoZSByZXF1aXJlZCB0b3VjaGVuZCBldmVudFxuICAgICAgICAgICAgLy8gcHJvYmFibHkgdGhlIGJyb3dzZXIgaGFzIG5vdCBzZW50IHRoaXMgZXZlbnRcbiAgICAgICAgICAgIHRvdWNoID0gdG91Y2hFbmRFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19hY3RpdmVUb3VjaElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFzdFRvdWNoRXZlbnRUaW1lU3RhbXAgPSBldmVudFRpbWVTdGFtcCh0b3VjaEVuZEV2ZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJMb25nVGFwVGltZW91dCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3VjaE1vdmVTdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBhdEV2ZW50ID0gdGhpcy5fcHJpdmF0ZV9fbWFrZUNvbXBhdEV2ZW50KHRvdWNoRW5kRXZlbnQsIHRvdWNoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc1RvdWNoRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX3RvdWNoRW5kRXZlbnQpO1xuICAgICAgICArK3RoaXMuX3ByaXZhdGVfX3RhcENvdW50O1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdGFwVGltZW91dElkICYmIHRoaXMuX3ByaXZhdGVfX3RhcENvdW50ID4gMSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCBib3RoIGNsaWNrcyBhcmUgbmVhciBlbm91Z2hcbiAgICAgICAgICAgIGNvbnN0IHsgX2ludGVybmFsX21hbmhhdHRhbkRpc3RhbmNlOiBtYW5oYXR0YW5EaXN0YW5jZSB9ID0gdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3VzZU1vdmVXaXRoRG93bkluZm8oZ2V0UG9zaXRpb24odG91Y2gpLCB0aGlzLl9wcml2YXRlX190YXBQb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAobWFuaGF0dGFuRGlzdGFuY2UgPCAzMCAvKiBDb25zdGFudHMuRG91YmxlVGFwTWFuaGF0dGFuRGlzdGFuY2UgKi8gJiYgIXRoaXMuX3ByaXZhdGVfX2NhbmNlbFRhcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Byb2Nlc3NUb3VjaEV2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9kb3VibGVUYXBFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNldFRhcFRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fY2FuY2VsVGFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc1RvdWNoRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX3RhcEV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgZmlyZSBtb3VzZSBldmVudHMgaWYgdGFwIGhhbmRsZXIgd2FzIGV4ZWN1dGVkXG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBjbGljayBldmVudCBvbiBuZXcgZG9tIGVsZW1lbnQgKHdobyBhcHBlYXJlZCBhZnRlciB0YXApXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX3RhcEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KHRvdWNoRW5kRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV2ZW50LCBmb3IgZXhhbXBsZSwgc2FmYXJpJ3MgZGJsY2xpY2stdG8tem9vbSBvciBmYXN0LWNsaWNrIGFmdGVyIGxvbmctdGFwXG4gICAgICAgIC8vIHdlIGhhbmRsZSBtb3VzZURvdWJsZUNsaWNrRXZlbnQgaGVyZSBvdXJzZWx2ZXNcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3RhcENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCh0b3VjaEVuZEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2hFbmRFdmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2xvbmdUYXBBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sb25nVGFwQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBuYXRpdmUgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCh0b3VjaEVuZEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VVcEhhbmRsZXIobW91c2VVcEV2ZW50KSB7XG4gICAgICAgIGlmIChtb3VzZVVwRXZlbnQuYnV0dG9uICE9PSAwIC8qIE1vdXNlRXZlbnRCdXR0b24uTGVmdCAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBhdEV2ZW50ID0gdGhpcy5fcHJpdmF0ZV9fbWFrZUNvbXBhdEV2ZW50KG1vdXNlVXBFdmVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlTW92ZVN0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZVByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ZGKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX3ByaXZhdGVfX29uRmlyZWZveE91dHNpZGVNb3VzZVVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZmlyZXNUb3VjaEV2ZW50cyhtb3VzZVVwRXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc01vdXNlRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX21vdXNlVXBFdmVudCk7XG4gICAgICAgICsrdGhpcy5fcHJpdmF0ZV9fY2xpY2tDb3VudDtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NsaWNrVGltZW91dElkICYmIHRoaXMuX3ByaXZhdGVfX2NsaWNrQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IGJvdGggY2xpY2tzIGFyZSBuZWFyIGVub3VnaFxuICAgICAgICAgICAgY29uc3QgeyBfaW50ZXJuYWxfbWFuaGF0dGFuRGlzdGFuY2U6IG1hbmhhdHRhbkRpc3RhbmNlIH0gPSB0aGlzLl9wcml2YXRlX190b3VjaE1vdXNlTW92ZVdpdGhEb3duSW5mbyhnZXRQb3NpdGlvbihtb3VzZVVwRXZlbnQpLCB0aGlzLl9wcml2YXRlX19jbGlja1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChtYW5oYXR0YW5EaXN0YW5jZSA8IDUgLyogQ29uc3RhbnRzLkRvdWJsZUNsaWNrTWFuaGF0dGFuRGlzdGFuY2UgKi8gJiYgIXRoaXMuX3ByaXZhdGVfX2NhbmNlbENsaWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc01vdXNlRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX21vdXNlRG91YmxlQ2xpY2tFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNldENsaWNrVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19jYW5jZWxDbGljaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Byb2Nlc3NNb3VzZUV2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9tb3VzZUNsaWNrRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19jbGVhckxvbmdUYXBUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbG9uZ1RhcFRpbWVvdXRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9wcml2YXRlX19sb25nVGFwVGltZW91dElkKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9uZ1RhcFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX190b3VjaFN0YXJ0SGFuZGxlcihkb3duRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2FjdGl2ZVRvdWNoSWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3VjaCA9IGRvd25FdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWN0aXZlVG91Y2hJZCA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xhc3RUb3VjaEV2ZW50VGltZVN0YW1wID0gZXZlbnRUaW1lU3RhbXAoZG93bkV2ZW50KTtcbiAgICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSB0aGlzLl9wcml2YXRlX190YXJnZXQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbmNlbFRhcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3VjaE1vdmVFeGNlZWRlZE1hbmhhdHRhbkRpc3RhbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByZXZlbnRUb3VjaERyYWdQcm9jZXNzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvdWNoTW92ZVN0YXJ0UG9zaXRpb24gPSBnZXRQb3NpdGlvbih0b3VjaCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBib3VuZFRvdWNoTW92ZVdpdGhEb3duSGFuZGxlciA9IHRoaXMuX3ByaXZhdGVfX3RvdWNoTW92ZUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kVG91Y2hFbmRIYW5kbGVyID0gdGhpcy5fcHJpdmF0ZV9fdG91Y2hFbmRIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByb290RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBib3VuZFRvdWNoTW92ZVdpdGhEb3duSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBib3VuZFRvdWNoRW5kSGFuZGxlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgYm91bmRUb3VjaE1vdmVXaXRoRG93bkhhbmRsZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGJvdW5kVG91Y2hFbmRIYW5kbGVyLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJMb25nVGFwVGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9uZ1RhcFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fcHJpdmF0ZV9fbG9uZ1RhcEhhbmRsZXIuYmluZCh0aGlzLCBkb3duRXZlbnQpLCAyNDAgLyogRGVsYXkuTG9uZ1RhcCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcGF0RXZlbnQgPSB0aGlzLl9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQoZG93bkV2ZW50LCB0b3VjaCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Byb2Nlc3NUb3VjaEV2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF90b3VjaFN0YXJ0RXZlbnQpO1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3RhcFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFwQ291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFwVGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl9wcml2YXRlX19yZXNldFRhcFRpbWVvdXQuYmluZCh0aGlzKSwgNTAwIC8qIERlbGF5LlJlc2V0Q2xpY2sgKi8pO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFwUG9zaXRpb24gPSBnZXRQb3NpdGlvbih0b3VjaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX21vdXNlRG93bkhhbmRsZXIoZG93bkV2ZW50KSB7XG4gICAgICAgIGlmIChkb3duRXZlbnQuYnV0dG9uICE9PSAwIC8qIE1vdXNlRXZlbnRCdXR0b24uTGVmdCAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBpZiAoaXNGRigpKSB7XG4gICAgICAgICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5fcHJpdmF0ZV9fb25GaXJlZm94T3V0c2lkZU1vdXNlVXApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbmNlbENsaWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlTW92ZVN0YXJ0UG9zaXRpb24gPSBnZXRQb3NpdGlvbihkb3duRXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgYm91bmRNb3VzZU1vdmVXaXRoRG93bkhhbmRsZXIgPSB0aGlzLl9wcml2YXRlX19tb3VzZU1vdmVXaXRoRG93bkhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kTW91c2VVcEhhbmRsZXIgPSB0aGlzLl9wcml2YXRlX19tb3VzZVVwSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgYm91bmRNb3VzZU1vdmVXaXRoRG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBib3VuZE1vdXNlVXBIYW5kbGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBib3VuZE1vdXNlTW92ZVdpdGhEb3duSGFuZGxlcik7XG4gICAgICAgICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgYm91bmRNb3VzZVVwSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ZpcmVzVG91Y2hFdmVudHMoZG93bkV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBhdEV2ZW50ID0gdGhpcy5fcHJpdmF0ZV9fbWFrZUNvbXBhdEV2ZW50KGRvd25FdmVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Byb2Nlc3NNb3VzZUV2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9tb3VzZURvd25FdmVudCk7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fY2xpY2tUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrQ291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3ByaXZhdGVfX3Jlc2V0Q2xpY2tUaW1lb3V0LmJpbmQodGhpcyksIDUwMCAvKiBEZWxheS5SZXNldENsaWNrICovKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrUG9zaXRpb24gPSBnZXRQb3NpdGlvbihkb3duRXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19pbml0KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMuX3ByaXZhdGVfX21vdXNlRW50ZXJIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBEbyBub3Qgc2hvdyBjb250ZXh0IG1lbnUgd2hlbiBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLl9wcml2YXRlX19jbGVhckxvbmdUYXBUaW1lb3V0LmJpbmQodGhpcykpO1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSB0aGlzLl9wcml2YXRlX190YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIGNvbnN0IG91dHNpZGVIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9tb3VzZURvd25PdXRzaWRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY29tcG9zZWQgJiYgdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LmNvbnRhaW5zKGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgJiYgdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9tb3VzZURvd25PdXRzaWRlRXZlbnQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU91dHNpZGVUb3VjaEV2ZW50cyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG91dHNpZGVIYW5kbGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU91dHNpZGVNb3VzZUV2ZW50cyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb3V0c2lkZUhhbmRsZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvdXRzaWRlSGFuZGxlcik7XG4gICAgICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG91dHNpZGVIYW5kbGVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSU9TKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW9iaWxlU2FmYXJpRXZlbnRzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMuX3ByaXZhdGVfX29uTW9iaWxlU2FmYXJpRG91YmxlQ2xpY2spO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMuX3ByaXZhdGVfX29uTW9iaWxlU2FmYXJpRG91YmxlQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5fcHJpdmF0ZV9fbW91c2VMZWF2ZUhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fcHJpdmF0ZV9fdG91Y2hTdGFydEhhbmRsZXIuYmluZCh0aGlzKSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBwcmV2ZW50U2Nyb2xsQnlXaGVlbENsaWNrKHRoaXMuX3ByaXZhdGVfX3RhcmdldCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9wcml2YXRlX19tb3VzZURvd25IYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbml0UGluY2goKTtcbiAgICAgICAgLy8gSGV5IG1vYmlsZSBTYWZhcmksIHdoYXQncyB1cD9cbiAgICAgICAgLy8gSWYgbW9iaWxlIFNhZmFyaSBkb2Vzbid0IGhhdmUgYW55IHRvdWNobW92ZSBoYW5kbGVyIHdpdGggcGFzc2l2ZT1mYWxzZVxuICAgICAgICAvLyBpdCB0cmVhdHMgYSB0b3VjaHN0YXJ0IGFuZCB0aGUgZm9sbG93aW5nIHRvdWNobW92ZSBldmVudHMgYXMgY2FuY2VsYWJsZT1mYWxzZSxcbiAgICAgICAgLy8gc28gd2UgY2FuJ3QgcHJldmVudCB0aGVtIChhcyBzb29uIHdlIHN1YnNjcmliZSBvbiB0b3VjaG1vdmUgaW5zaWRlIHRvdWNoc3RhcnQncyBoYW5kbGVyKS5cbiAgICAgICAgLy8gQW5kIHdlJ2xsIGdldCBzY3JvbGwgb2YgdGhlIHBhZ2UgYWxvbmcgd2l0aCBjaGFydCdzIG9uZSBpbnN0ZWFkIG9mIG9ubHkgY2hhcnQncyBzY3JvbGwuXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCAoKSA9PiB7IH0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19pbml0UGluY2goKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9waW5jaFN0YXJ0RXZlbnQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfcGluY2hFdmVudCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9waW5jaEVuZEV2ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX190YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIChldmVudCkgPT4gdGhpcy5fcHJpdmF0ZV9fY2hlY2tQaW5jaFN0YXRlKGV2ZW50LnRvdWNoZXMpLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCB0aGlzLl9wcml2YXRlX19zdGFydFBpbmNoTWlkZGxlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfcGluY2hFdmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudERpc3RhbmNlID0gZ2V0RGlzdGFuY2UoZXZlbnQudG91Y2hlc1swXSwgZXZlbnQudG91Y2hlc1sxXSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBjdXJyZW50RGlzdGFuY2UgLyB0aGlzLl9wcml2YXRlX19zdGFydFBpbmNoRGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfcGluY2hFdmVudCh0aGlzLl9wcml2YXRlX19zdGFydFBpbmNoTWlkZGxlUG9pbnQsIHNjYWxlKTtcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hlY2tQaW5jaFN0YXRlKGV2ZW50LnRvdWNoZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NoZWNrUGluY2hTdGF0ZSh0b3VjaGVzKSB7XG4gICAgICAgIGlmICh0b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGluY2hQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2hlcy5sZW5ndGggIT09IDIgfHwgdGhpcy5fcHJpdmF0ZV9fcGluY2hQcmV2ZW50ZWQgfHwgdGhpcy5fcHJpdmF0ZV9fbG9uZ1RhcEFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RvcFBpbmNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFBpbmNoKHRvdWNoZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19zdGFydFBpbmNoKHRvdWNoZXMpIHtcbiAgICAgICAgY29uc3QgYm94ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuX3ByaXZhdGVfX3RhcmdldCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0UGluY2hNaWRkbGVQb2ludCA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF94OiAoKHRvdWNoZXNbMF0uY2xpZW50WCAtIGJveC5sZWZ0KSArICh0b3VjaGVzWzFdLmNsaWVudFggLSBib3gubGVmdCkpIC8gMixcbiAgICAgICAgICAgIF9pbnRlcm5hbF95OiAoKHRvdWNoZXNbMF0uY2xpZW50WSAtIGJveC50b3ApICsgKHRvdWNoZXNbMV0uY2xpZW50WSAtIGJveC50b3ApKSAvIDIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0UGluY2hEaXN0YW5jZSA9IGdldERpc3RhbmNlKHRvdWNoZXNbMF0sIHRvdWNoZXNbMV0pO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfcGluY2hTdGFydEV2ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX3BpbmNoU3RhcnRFdmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsZWFyTG9uZ1RhcFRpbWVvdXQoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3N0b3BQaW5jaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXJ0UGluY2hNaWRkbGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0UGluY2hNaWRkbGVQb2ludCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9waW5jaEVuZEV2ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX3BpbmNoRW5kRXZlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VMZWF2ZUhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU1vdXNlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19maXJlc1RvdWNoRXZlbnRzKGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fYWNjZXB0TW91c2VMZWF2ZSkge1xuICAgICAgICAgICAgLy8gbW9iaWxlIFNhZmFyaSBzb21ldGltZXMgZW1pdHMgbW91c2UgbGVhdmUgZXZlbnQgZm9yIG5vIHJlYXNvbiwgdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSBpdCBpbiBvdGhlciB3YXlcbiAgICAgICAgICAgIC8vIGp1c3QgaWdub3JlIHRoaXMgZXZlbnQgaWYgdGhlcmUgd2FzIG5vIG1vdXNlIG1vdmUgb3IgbW91c2UgZW50ZXIgZXZlbnRzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcGF0RXZlbnQgPSB0aGlzLl9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQoZXZlbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzTW91c2VFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfbW91c2VMZWF2ZUV2ZW50KTtcbiAgICAgICAgLy8gYWNjZXB0IGFsbCBtb3VzZSBsZWF2ZSBldmVudHMgaWYgaXQncyBub3QgYW4gaU9TIGRldmljZVxuICAgICAgICB0aGlzLl9wcml2YXRlX19hY2NlcHRNb3VzZUxlYXZlID0gIWlzSU9TKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19sb25nVGFwSGFuZGxlcihldmVudCkge1xuICAgICAgICBjb25zdCB0b3VjaCA9IHRvdWNoV2l0aElkKGV2ZW50LnRvdWNoZXMsIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fYWN0aXZlVG91Y2hJZCkpO1xuICAgICAgICBpZiAodG91Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wYXRFdmVudCA9IHRoaXMuX3ByaXZhdGVfX21ha2VDb21wYXRFdmVudChldmVudCwgdG91Y2gpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzVG91Y2hFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfbG9uZ1RhcEV2ZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FuY2VsVGFwID0gdHJ1ZTtcbiAgICAgICAgLy8gbG9uZyB0YXAgaXMgYWN0aXZlIHVudGlsIHRvdWNoZW5kIGV2ZW50IHdpdGggMCB0b3VjaGVzIG9jY3VycmVkXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvbmdUYXBBY3RpdmUgPSB0cnVlO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZmlyZXNUb3VjaEV2ZW50cyhlKSB7XG4gICAgICAgIGlmIChlLnNvdXJjZUNhcGFiaWxpdGllcyAmJiBlLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudFRpbWVTdGFtcChlKSA8IHRoaXMuX3ByaXZhdGVfX2xhc3RUb3VjaEV2ZW50VGltZVN0YW1wICsgNTAwIC8qIERlbGF5LlByZXZlbnRGaXJlc1RvdWNoRXZlbnRzICovO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcHJvY2Vzc1RvdWNoRXZlbnQoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLl9wcml2YXRlX19oYW5kbGVyLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX3Byb2Nlc3NNb3VzZUV2ZW50KGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLl9wcml2YXRlX19oYW5kbGVyLCBldmVudCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQoZXZlbnQsIHRvdWNoKSB7XG4gICAgICAgIC8vIFRvdWNoRXZlbnQgaGFzIG5vIGNsaWVudFgvWSBjb29yZGluYXRlczpcbiAgICAgICAgLy8gV2UgaGF2ZSB0byB1c2UgdGhlIGxhc3QgVG91Y2ggaW5zdGVhZFxuICAgICAgICBjb25zdCBldmVudExpa2UgPSB0b3VjaCB8fCBldmVudDtcbiAgICAgICAgY29uc3QgYm94ID0gdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHx8IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnRYOiBldmVudExpa2UuY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50TGlrZS5jbGllbnRZLFxuICAgICAgICAgICAgcGFnZVg6IGV2ZW50TGlrZS5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBldmVudExpa2UucGFnZVksXG4gICAgICAgICAgICBzY3JlZW5YOiBldmVudExpa2Uuc2NyZWVuWCxcbiAgICAgICAgICAgIHNjcmVlblk6IGV2ZW50TGlrZS5zY3JlZW5ZLFxuICAgICAgICAgICAgbG9jYWxYOiAoZXZlbnRMaWtlLmNsaWVudFggLSBib3gubGVmdCksXG4gICAgICAgICAgICBsb2NhbFk6IChldmVudExpa2UuY2xpZW50WSAtIGJveC50b3ApLFxuICAgICAgICAgICAgY3RybEtleTogZXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgIGFsdEtleTogZXZlbnQuYWx0S2V5LFxuICAgICAgICAgICAgc2hpZnRLZXk6IGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgbWV0YUtleTogZXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pc1RvdWNoOiAhZXZlbnQudHlwZS5zdGFydHNXaXRoKCdtb3VzZScpICYmIGV2ZW50LnR5cGUgIT09ICdjb250ZXh0bWVudScgJiYgZXZlbnQudHlwZSAhPT0gJ2NsaWNrJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9zcmNUeXBlOiBldmVudC50eXBlLFxuICAgICAgICAgICAgX2ludGVybmFsX3RhcmdldDogZXZlbnRMaWtlLnRhcmdldCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aWV3OiBldmVudC52aWV3LFxuICAgICAgICAgICAgX2ludGVybmFsX3ByZXZlbnREZWZhdWx0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgIT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0b3VjaHN0YXJ0IGlzIHBhc3NpdmUgYW5kIGNhbm5vdCBiZSBwcmV2ZW50ZWRcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB8fCB7IGxlZnQ6IDAsIHRvcDogMCB9O1xufVxuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyKSB7XG4gICAgY29uc3QgeERpZmYgPSBwMS5jbGllbnRYIC0gcDIuY2xpZW50WDtcbiAgICBjb25zdCB5RGlmZiA9IHAxLmNsaWVudFkgLSBwMi5jbGllbnRZO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeERpZmYgKiB4RGlmZiArIHlEaWZmICogeURpZmYpO1xufVxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGV2ZW50TGlrZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9pbnRlcm5hbF94OiBldmVudExpa2UucGFnZVgsXG4gICAgICAgIF9pbnRlcm5hbF95OiBldmVudExpa2UucGFnZVksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV2ZW50VGltZVN0YW1wKGUpIHtcbiAgICAvLyBmb3Igc29tZSByZWFzb24gZS50aW1lc3RhbXAgaXMgYWx3YXlzIDAgb24gaVBhZCB3aXRoIG1hZ2ljIG1vdXNlLCBzbyB3ZSB1c2UgcGVyZm9ybWFuY2Uubm93KCkgYXMgYSBmYWxsYmFja1xuICAgIHJldHVybiBlLnRpbWVTdGFtcCB8fCBwZXJmb3JtYW5jZS5ub3coKTtcbn1cbmZ1bmN0aW9uIHRvdWNoV2l0aElkKHRvdWNoZXMsIGlkKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0b3VjaGVzW2ldLmlkZW50aWZpZXIgPT09IGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdG91Y2hlc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLy8gcmV0dXJucyB0cnVlIGlmIGl0ZW0gaXMgYWJvdmUgcmVmZXJlbmNlXG5mdW5jdGlvbiBjb21wYXJlUHJpbWl0aXZlWk9yZGVyKGl0ZW0sIHJlZmVyZW5jZSkge1xuICAgIHJldHVybiAoIXJlZmVyZW5jZSB8fFxuICAgICAgICAoaXRlbSA9PT0gJ3RvcCcgJiYgcmVmZXJlbmNlICE9PSAndG9wJykgfHxcbiAgICAgICAgKGl0ZW0gPT09ICdub3JtYWwnICYmIHJlZmVyZW5jZSA9PT0gJ2JvdHRvbScpKTtcbn1cbmZ1bmN0aW9uIGZpbmRCZXN0UHJpbWl0aXZlSGl0VGVzdChzb3VyY2VzLCB4LCB5KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgYmVzdFByaW1pdGl2ZUhpdDtcbiAgICBsZXQgYmVzdEhpdFNvdXJjZTtcbiAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZUhpdFJlc3VsdHMgPSAoX2IgPSAoX2EgPSBzb3VyY2UuX2ludGVybmFsX3ByaW1pdGl2ZUhpdFRlc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHNvdXJjZSwgeCwgeSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGhpdFJlc3VsdCBvZiBwcmltaXRpdmVIaXRSZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoY29tcGFyZVByaW1pdGl2ZVpPcmRlcihoaXRSZXN1bHQuek9yZGVyLCBiZXN0UHJpbWl0aXZlSGl0ID09PSBudWxsIHx8IGJlc3RQcmltaXRpdmVIaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJlc3RQcmltaXRpdmVIaXQuek9yZGVyKSkge1xuICAgICAgICAgICAgICAgIGJlc3RQcmltaXRpdmVIaXQgPSBoaXRSZXN1bHQ7XG4gICAgICAgICAgICAgICAgYmVzdEhpdFNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWJlc3RQcmltaXRpdmVIaXQgfHwgIWJlc3RIaXRTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIF9pbnRlcm5hbF9oaXQ6IGJlc3RQcmltaXRpdmVIaXQsXG4gICAgICAgIF9pbnRlcm5hbF9zb3VyY2U6IGJlc3RIaXRTb3VyY2UsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRQcmltaXRpdmVIaXRSZXN1bHQocHJpbWl0aXZlSGl0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2ludGVybmFsX3NvdXJjZTogcHJpbWl0aXZlSGl0Ll9pbnRlcm5hbF9zb3VyY2UsXG4gICAgICAgIF9pbnRlcm5hbF9vYmplY3Q6IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9leHRlcm5hbElkOiBwcmltaXRpdmVIaXQuX2ludGVybmFsX2hpdC5leHRlcm5hbElkLFxuICAgICAgICB9LFxuICAgICAgICBfaW50ZXJuYWxfY3Vyc29yU3R5bGU6IHByaW1pdGl2ZUhpdC5faW50ZXJuYWxfaGl0LmN1cnNvclN0eWxlLFxuICAgIH07XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgaGl0IHRlc3Qgb24gYSBjb2xsZWN0aW9uIG9mIHBhbmUgdmlld3MgdG8gZGV0ZXJtaW5lIHdoaWNoIHZpZXcgYW5kIG9iamVjdFxuICogaXMgbG9jYXRlZCBhdCBhIGdpdmVuIGNvb3JkaW5hdGUgKHgsIHkpIGFuZCByZXR1cm5zIHRoZSBtYXRjaGluZyBwYW5lIHZpZXcgYW5kXG4gKiBoaXQtdGVzdGVkIHJlc3VsdCBvYmplY3QsIG9yIG51bGwgaWYgbm8gbWF0Y2ggaXMgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGhpdFRlc3RQYW5lVmlldyhwYW5lVmlld3MsIHgsIHkpIHtcbiAgICBmb3IgKGNvbnN0IHBhbmVWaWV3IG9mIHBhbmVWaWV3cykge1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IHBhbmVWaWV3Ll9pbnRlcm5hbF9yZW5kZXJlcigpO1xuICAgICAgICBpZiAocmVuZGVyZXIgIT09IG51bGwgJiYgcmVuZGVyZXIuX2ludGVybmFsX2hpdFRlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlbmRlcmVyLl9pbnRlcm5hbF9oaXRUZXN0KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIF9pbnRlcm5hbF92aWV3OiBwYW5lVmlldyxcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX29iamVjdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBoaXRUZXN0UGFuZShwYW5lLCB4LCB5KSB7XG4gICAgY29uc3Qgc291cmNlcyA9IHBhbmUuX2ludGVybmFsX29yZGVyZWRTb3VyY2VzKCk7XG4gICAgY29uc3QgYmVzdFByaW1pdGl2ZUhpdCA9IGZpbmRCZXN0UHJpbWl0aXZlSGl0VGVzdChzb3VyY2VzLCB4LCB5KTtcbiAgICBpZiAoKGJlc3RQcmltaXRpdmVIaXQgPT09IG51bGwgfHwgYmVzdFByaW1pdGl2ZUhpdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmVzdFByaW1pdGl2ZUhpdC5faW50ZXJuYWxfaGl0LnpPcmRlcikgPT09ICd0b3AnKSB7XG4gICAgICAgIC8vIGEgcHJpbWl0aXZlIGhpdCBvbiB0aGUgJ3RvcCcgbGF5ZXIgd2lsbCBhbHdheXMgYmVhdCB0aGUgYnVpbHQtaW4gaGl0IHRlc3RzXG4gICAgICAgIC8vIChvbiBub3JtYWwgbGF5ZXIpIHNvIHdlIGNhbiByZXR1cm4gZWFybHkgaGVyZS5cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRQcmltaXRpdmVIaXRSZXN1bHQoYmVzdFByaW1pdGl2ZUhpdCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgaWYgKGJlc3RQcmltaXRpdmVIaXQgJiYgYmVzdFByaW1pdGl2ZUhpdC5faW50ZXJuYWxfc291cmNlID09PSBzb3VyY2UgJiYgYmVzdFByaW1pdGl2ZUhpdC5faW50ZXJuYWxfaGl0LnpPcmRlciAhPT0gJ2JvdHRvbScgJiYgIWJlc3RQcmltaXRpdmVIaXQuX2ludGVybmFsX2hpdC5pc0JhY2tncm91bmQpIHtcbiAgICAgICAgICAgIC8vIGEgcHJpbWl0aXZlIHdpbGwgYmUgZHJhd24gYWJvdmUgYSBidWlsdC1pbiBpdGVtIGxpa2UgYSBzZXJpZXMgbWFya2VyXG4gICAgICAgICAgICAvLyB0aGVyZWZvcmUgaXQgdGFrZXMgcHJlY2VkZW5jZSBoZXJlLlxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRQcmltaXRpdmVIaXRSZXN1bHQoYmVzdFByaW1pdGl2ZUhpdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlUmVzdWx0ID0gaGl0VGVzdFBhbmVWaWV3KHNvdXJjZS5faW50ZXJuYWxfcGFuZVZpZXdzKHBhbmUpLCB4LCB5KTtcbiAgICAgICAgaWYgKHNvdXJjZVJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3ZpZXc6IHNvdXJjZVJlc3VsdC5faW50ZXJuYWxfdmlldyxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfb2JqZWN0OiBzb3VyY2VSZXN1bHQuX2ludGVybmFsX29iamVjdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlc3RQcmltaXRpdmVIaXQgJiYgYmVzdFByaW1pdGl2ZUhpdC5faW50ZXJuYWxfc291cmNlID09PSBzb3VyY2UgJiYgYmVzdFByaW1pdGl2ZUhpdC5faW50ZXJuYWxfaGl0LnpPcmRlciAhPT0gJ2JvdHRvbScgJiYgYmVzdFByaW1pdGl2ZUhpdC5faW50ZXJuYWxfaGl0LmlzQmFja2dyb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRQcmltaXRpdmVIaXRSZXN1bHQoYmVzdFByaW1pdGl2ZUhpdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJlc3RQcmltaXRpdmVIaXQgPT09IG51bGwgfHwgYmVzdFByaW1pdGl2ZUhpdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmVzdFByaW1pdGl2ZUhpdC5faW50ZXJuYWxfaGl0KSB7XG4gICAgICAgIC8vIHJldHVybiBwcmltaXRpdmUgaGl0cyBmb3IgdGhlICdib3R0b20nIGxheWVyXG4gICAgICAgIHJldHVybiBjb252ZXJ0UHJpbWl0aXZlSGl0UmVzdWx0KGJlc3RQcmltaXRpdmVIaXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gYnVpbGRQcmljZUF4aXNWaWV3c0dldHRlcih6T3JkZXIsIHByaWNlU2NhbGVJZCkge1xuICAgIHJldHVybiAoc291cmNlKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgcHNJZCA9IChfYiA9IChfYSA9IHNvdXJjZS5faW50ZXJuYWxfcHJpY2VTY2FsZSgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX2ludGVybmFsX2lkKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgICAgICBpZiAocHNJZCAhPT0gcHJpY2VTY2FsZUlkKSB7XG4gICAgICAgICAgICAvLyBleGNsdWRlIGlmIHNvdXJjZSBpcyB1c2luZyBhIGRpZmZlcmVudCBwcmljZSBzY2FsZS5cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9kID0gKF9jID0gc291cmNlLl9pbnRlcm5hbF9wcmljZVBhbmVWaWV3cykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoc291cmNlLCB6T3JkZXIpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbXTtcbiAgICB9O1xufVxuY2xhc3MgUHJpY2VBeGlzV2lkZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcihwYW5lLCBvcHRpb25zLCByZW5kZXJlck9wdGlvbnNQcm92aWRlciwgc2lkZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX193aWR0aENhY2hlID0gbmV3IFRleHRXaWR0aENhY2hlKDIwMCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZvbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmV2T3B0aW1hbFdpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2NoYXJ0KCkuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc1NldHRpbmdTaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfY2hhcnQoKS5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZSA9IHBhbmU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sYXlvdXRPcHRpb25zID0gb3B0aW9ucy5sYXlvdXQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyID0gcmVuZGVyZXJPcHRpb25zUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzTGVmdCA9IHNpZGUgPT09ICdsZWZ0JztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc291cmNlUGFuZVZpZXdzID0gYnVpbGRQcmljZUF4aXNWaWV3c0dldHRlcignbm9ybWFsJywgc2lkZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NvdXJjZVRvcFBhbmVWaWV3cyA9IGJ1aWxkUHJpY2VBeGlzVmlld3NHZXR0ZXIoJ3RvcCcsIHNpZGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zb3VyY2VCb3R0b21QYW5lVmlld3MgPSBidWlsZFByaWNlQXhpc1ZpZXdzR2V0dGVyKCdib3R0b20nLCBzaWRlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLndpZHRoID0gJzI1cHgnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nID0gY3JlYXRlQm91bmRDYW52YXModGhpcy5fcHJpdmF0ZV9fY2VsbCwgc2l6ZSQxKHsgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2IH0pKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQ7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMSc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nID0gY3JlYXRlQm91bmRDYW52YXModGhpcy5fcHJpdmF0ZV9fY2VsbCwgc2l6ZSQxKHsgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2IH0pKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX190b3BDYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICBjb25zdCB0b3BDYW52YXMgPSB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQ7XG4gICAgICAgIHRvcENhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRvcENhbnZhcy5zdHlsZS56SW5kZXggPSAnMic7XG4gICAgICAgIHRvcENhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX21vdXNlRG93bkV2ZW50OiB0aGlzLl9wcml2YXRlX19tb3VzZURvd25FdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvdWNoU3RhcnRFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VEb3duRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wcmVzc2VkTW91c2VNb3ZlRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX3ByZXNzZWRNb3VzZU1vdmVFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvdWNoTW92ZUV2ZW50OiB0aGlzLl9wcml2YXRlX19wcmVzc2VkTW91c2VNb3ZlRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9tb3VzZURvd25PdXRzaWRlRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX21vdXNlRG93bk91dHNpZGVFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX21vdXNlVXBFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VVcEV2ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG91Y2hFbmRFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VVcEV2ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfbW91c2VEb3VibGVDbGlja0V2ZW50OiB0aGlzLl9wcml2YXRlX19tb3VzZURvdWJsZUNsaWNrRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9kb3VibGVUYXBFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VEb3VibGVDbGlja0V2ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfbW91c2VFbnRlckV2ZW50OiB0aGlzLl9wcml2YXRlX19tb3VzZUVudGVyRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9tb3VzZUxlYXZlRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX21vdXNlTGVhdmVFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZUV2ZW50SGFuZGxlciA9IG5ldyBNb3VzZUV2ZW50SGFuZGxlcih0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQsIGhhbmRsZXIsIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF90cmVhdFZlcnRUb3VjaERyYWdBc1BhZ2VTY3JvbGw6ICgpID0+ICF0aGlzLl9wcml2YXRlX19vcHRpb25zLmhhbmRsZVNjcm9sbC52ZXJ0VG91Y2hEcmFnLFxuICAgICAgICAgICAgX2ludGVybmFsX3RyZWF0SG9yelRvdWNoRHJhZ0FzUGFnZVNjcm9sbDogKCkgPT4gdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZUV2ZW50SGFuZGxlci5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLnVuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyKTtcbiAgICAgICAgcmVsZWFzZUNhbnZhcyh0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy51bnN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkKHRoaXMuX3ByaXZhdGVfX2NhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlcik7XG4gICAgICAgIHJlbGVhc2VDYW52YXModGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9vbk1hcmtzQ2hhbmdlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jZWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZm9udFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sYXlvdXRPcHRpb25zLmZvbnRTaXplO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVuZGVyZXJPcHRpb25zKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgaXNGb250Q2hhbmdlZCA9IHRoaXMuX3ByaXZhdGVfX2ZvbnQgIT09IG9wdGlvbnMuX2ludGVybmFsX2ZvbnQ7XG4gICAgICAgIGlmIChpc0ZvbnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX193aWR0aENhY2hlLl9pbnRlcm5hbF9yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9udCA9IG9wdGlvbnMuX2ludGVybmFsX2ZvbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcHRpbWFsV2lkdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGlja01hcmtNYXhXaWR0aCA9IDA7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IHRoaXMuX2ludGVybmFsX3JlbmRlcmVyT3B0aW9ucygpO1xuICAgICAgICBjb25zdCBjdHggPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudC5nZXRDb250ZXh0KCcyZCcpKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY29uc3QgdGlja01hcmtzID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfbWFya3MoKTtcbiAgICAgICAgY3R4LmZvbnQgPSB0aGlzLl9wcml2YXRlX19iYXNlRm9udCgpO1xuICAgICAgICBpZiAodGlja01hcmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRpY2tNYXJrTWF4V2lkdGggPSBNYXRoLm1heCh0aGlzLl9wcml2YXRlX193aWR0aENhY2hlLl9pbnRlcm5hbF9tZWFzdXJlVGV4dChjdHgsIHRpY2tNYXJrc1swXS5faW50ZXJuYWxfbGFiZWwpLCB0aGlzLl9wcml2YXRlX193aWR0aENhY2hlLl9pbnRlcm5hbF9tZWFzdXJlVGV4dChjdHgsIHRpY2tNYXJrc1t0aWNrTWFya3MubGVuZ3RoIC0gMV0uX2ludGVybmFsX2xhYmVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld3MgPSB0aGlzLl9wcml2YXRlX19iYWNrTGFiZWxzKCk7XG4gICAgICAgIGZvciAobGV0IGogPSB2aWV3cy5sZW5ndGg7IGotLTspIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fcHJpdmF0ZV9fd2lkdGhDYWNoZS5faW50ZXJuYWxfbWVhc3VyZVRleHQoY3R4LCB2aWV3c1tqXS5faW50ZXJuYWxfdGV4dCgpKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCA+IHRpY2tNYXJrTWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aWNrTWFya01heFdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgaWYgKGZpcnN0VmFsdWUgIT09IG51bGwgJiYgdGhpcy5fcHJpdmF0ZV9fc2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9wVmFsdWUgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9jb29yZGluYXRlVG9QcmljZSgxLCBmaXJzdFZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbVZhbHVlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfY29vcmRpbmF0ZVRvUHJpY2UodGhpcy5fcHJpdmF0ZV9fc2l6ZS5oZWlnaHQgLSAyLCBmaXJzdFZhbHVlKTtcbiAgICAgICAgICAgIHRpY2tNYXJrTWF4V2lkdGggPSBNYXRoLm1heCh0aWNrTWFya01heFdpZHRoLCB0aGlzLl9wcml2YXRlX193aWR0aENhY2hlLl9pbnRlcm5hbF9tZWFzdXJlVGV4dChjdHgsIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2Zvcm1hdFByaWNlKE1hdGguZmxvb3IoTWF0aC5taW4odG9wVmFsdWUsIGJvdHRvbVZhbHVlKSkgKyAwLjExMTExMTExMTExMTExLCBmaXJzdFZhbHVlKSksIHRoaXMuX3ByaXZhdGVfX3dpZHRoQ2FjaGUuX2ludGVybmFsX21lYXN1cmVUZXh0KGN0eCwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfZm9ybWF0UHJpY2UoTWF0aC5jZWlsKE1hdGgubWF4KHRvcFZhbHVlLCBib3R0b21WYWx1ZSkpIC0gMC4xMTExMTExMTExMTExMSwgZmlyc3RWYWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBjb25zdCByZXN1bHRUaWNrTWFya3NNYXhXaWR0aCA9IHRpY2tNYXJrTWF4V2lkdGggfHwgMzQgLyogQ29uc3RhbnRzLkRlZmF1bHRPcHRpbWFsV2lkdGggKi87XG4gICAgICAgIGNvbnN0IHJlcyA9IE1hdGguY2VpbChyZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2JvcmRlclNpemUgK1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoICtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0lubmVyICtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ091dGVyICtcbiAgICAgICAgICAgIDUgLyogQ29uc3RhbnRzLkxhYmVsT2Zmc2V0ICovICtcbiAgICAgICAgICAgIHJlc3VsdFRpY2tNYXJrc01heFdpZHRoKTtcbiAgICAgICAgLy8gbWFrZSBpdCBldmVuLCByZW1vdmUgdGhpcyBhZnRlciBtaWdyYXRpb24gdG8gcGVyZmVjdCBmYW5jeSBjYW52YXNcbiAgICAgICAgcmV0dXJuIHN1Z2dlc3RQcmljZVNjYWxlV2lkdGgocmVzKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFNpemUobmV3U2l6ZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2l6ZSA9PT0gbnVsbCB8fCAhZXF1YWxTaXplcyh0aGlzLl9wcml2YXRlX19zaXplLCBuZXdTaXplKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pc1NldHRpbmdTaXplID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcucmVzaXplQ2FudmFzRWxlbWVudChuZXdTaXplKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcucmVzaXplQ2FudmFzRWxlbWVudChuZXdTaXplKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUud2lkdGggPSBgJHtuZXdTaXplLndpZHRofXB4YDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUuaGVpZ2h0ID0gYCR7bmV3U2l6ZS5oZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fc2l6ZSkud2lkdGg7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRQcmljZVNjYWxlKHByaWNlU2NhbGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPT09IHByaWNlU2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfb25NYXJrc0NoYW5nZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9IHByaWNlU2NhbGU7XG4gICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX29uTWFya3NDaGFuZ2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19vbk1hcmtzQ2hhbmdlZC5iaW5kKHRoaXMpLCB0aGlzKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVzZXQoKSB7XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9zdGF0ZSgpO1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2NoYXJ0KCkuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIG1vZGVsLl9pbnRlcm5hbF9yZXNldFByaWNlU2NhbGUocGFuZSwgZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3BhaW50KHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3NpemUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSAhPT0gMSAvKiBJbnZhbGlkYXRpb25MZXZlbC5DdXJzb3IgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2FsaWduTGFiZWxzKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmFwcGx5U3VnZ2VzdGVkQml0bWFwU2l6ZSgpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdHJ5Q3JlYXRlQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQodGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZyk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSgoc2NvcGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0JhY2tncm91bmQoc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3Qm9yZGVyKHNjb3BlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9kcmF3QWRkaXRpb25hbFNvdXJjZXModGFyZ2V0LCB0aGlzLl9wcml2YXRlX19zb3VyY2VCb3R0b21QYW5lVmlld3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdUaWNrTWFya3ModGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9kcmF3QWRkaXRpb25hbFNvdXJjZXModGFyZ2V0LCB0aGlzLl9wcml2YXRlX19zb3VyY2VQYW5lVmlld3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdCYWNrTGFiZWxzKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5hcHBseVN1Z2dlc3RlZEJpdG1hcFNpemUoKTtcbiAgICAgICAgY29uc3QgdG9wVGFyZ2V0ID0gdHJ5Q3JlYXRlQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQodGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZyk7XG4gICAgICAgIGlmICh0b3BUYXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRvcFRhcmdldC51c2VCaXRtYXBDb29yZGluYXRlU3BhY2UoKHsgY29udGV4dDogY3R4LCBiaXRtYXBTaXplIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGJpdG1hcFNpemUud2lkdGgsIGJpdG1hcFNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0Nyb3NzaGFpckxhYmVsKHRvcFRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9kcmF3QWRkaXRpb25hbFNvdXJjZXModG9wVGFyZ2V0LCB0aGlzLl9wcml2YXRlX19zb3VyY2VUb3BQYW5lVmlld3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5iaXRtYXBTaXplO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZHJhd0JpdG1hcChjdHgsIHgsIHkpIHtcbiAgICAgICAgY29uc3QgYml0bWFwU2l6ZSA9IHRoaXMuX2ludGVybmFsX2dldEJpdG1hcFNpemUoKTtcbiAgICAgICAgaWYgKGJpdG1hcFNpemUud2lkdGggPiAwICYmIGJpdG1hcFNpemUuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQsIHgsIHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gdGhpcyBjYWxsIGhhcyBzaWRlLWVmZmVjdCAtIGl0IHJlZ2VuZXJhdGVzIG1hcmtzIG9uIHRoZSBwcmljZSBzY2FsZVxuICAgICAgICAoX2EgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX2ludGVybmFsX21hcmtzKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZURvd25FdmVudChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSB8fCAhdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5oYW5kbGVTY2FsZS5heGlzUHJlc3NlZE1vdXNlTW92ZS5wcmljZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfY2hhcnQoKS5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX3N0YXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlZG93biA9IHRydWU7XG4gICAgICAgIG1vZGVsLl9pbnRlcm5hbF9zdGFydFNjYWxlUHJpY2UocGFuZSwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSwgZS5sb2NhbFkpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcHJlc3NlZE1vdXNlTW92ZUV2ZW50KGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPT09IG51bGwgfHwgIXRoaXMuX3ByaXZhdGVfX29wdGlvbnMuaGFuZGxlU2NhbGUuYXhpc1ByZXNzZWRNb3VzZU1vdmUucHJpY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2NoYXJ0KCkuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9zdGF0ZSgpO1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZTtcbiAgICAgICAgbW9kZWwuX2ludGVybmFsX3NjYWxlUHJpY2VUbyhwYW5lLCBwcmljZVNjYWxlLCBlLmxvY2FsWSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZURvd25PdXRzaWRlRXZlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID09PSBudWxsIHx8ICF0aGlzLl9wcml2YXRlX19vcHRpb25zLmhhbmRsZVNjYWxlLmF4aXNQcmVzc2VkTW91c2VNb3ZlLnByaWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9jaGFydCgpLl9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfc3RhdGUoKTtcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGU7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19tb3VzZWRvd24pIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICAgICAgbW9kZWwuX2ludGVybmFsX2VuZFNjYWxlUHJpY2UocGFuZSwgcHJpY2VTY2FsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX21vdXNlVXBFdmVudChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID09PSBudWxsIHx8ICF0aGlzLl9wcml2YXRlX19vcHRpb25zLmhhbmRsZVNjYWxlLmF4aXNQcmVzc2VkTW91c2VNb3ZlLnByaWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9jaGFydCgpLl9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfc3RhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgIG1vZGVsLl9pbnRlcm5hbF9lbmRTY2FsZVByaWNlKHBhbmUsIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VEb3VibGVDbGlja0V2ZW50KGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuaGFuZGxlU2NhbGUuYXhpc0RvdWJsZUNsaWNrUmVzZXQucHJpY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3Jlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX21vdXNlRW50ZXJFdmVudChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9jaGFydCgpLl9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBpZiAobW9kZWwuX2ludGVybmFsX29wdGlvbnMoKS5oYW5kbGVTY2FsZS5heGlzUHJlc3NlZE1vdXNlTW92ZS5wcmljZSAmJiAhdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfaXNQZXJjZW50YWdlKCkgJiYgIXRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2lzSW5kZXhlZFRvMTAwKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldEN1cnNvcigxIC8qIEN1cnNvclR5cGUuTnNSZXNpemUgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZUxlYXZlRXZlbnQoZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDdXJzb3IoMCAvKiBDdXJzb3JUeXBlLkRlZmF1bHQgKi8pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fYmFja0xhYmVscygpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSAodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9PT0gbnVsbCkgPyB1bmRlZmluZWQgOiB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlO1xuICAgICAgICBjb25zdCBhZGRWaWV3c0ZvclNvdXJjZXMgPSAoc291cmNlcykgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gc291cmNlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cyA9IHNvdXJjZS5faW50ZXJuYWxfcHJpY2VBeGlzVmlld3ModGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfc3RhdGUoKSwgcHJpY2VTY2FsZSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2aWV3cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh2aWV3c1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBjYWxjdWxhdGUgbWF4IGFuZCBtaW4gY29vcmRpbmF0ZXMgZm9yIHZpZXdzIG9uIHNlbGVjdGlvblxuICAgICAgICAvLyBjcm9zc2hhaXIgaW5kaXZpZHVhbGx5XG4gICAgICAgIGFkZFZpZXdzRm9yU291cmNlcyh0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9zdGF0ZSgpLl9pbnRlcm5hbF9vcmRlcmVkU291cmNlcygpKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdCYWNrZ3JvdW5kKHsgY29udGV4dDogY3R4LCBiaXRtYXBTaXplIH0pIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBiaXRtYXBTaXplO1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX3N0YXRlKCkuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIGNvbnN0IHRvcENvbG9yID0gbW9kZWwuX2ludGVybmFsX2JhY2tncm91bmRUb3BDb2xvcigpO1xuICAgICAgICBjb25zdCBib3R0b21Db2xvciA9IG1vZGVsLl9pbnRlcm5hbF9iYWNrZ3JvdW5kQm90dG9tQ29sb3IoKTtcbiAgICAgICAgaWYgKHRvcENvbG9yID09PSBib3R0b21Db2xvcikge1xuICAgICAgICAgICAgY2xlYXJSZWN0KGN0eCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgdG9wQ29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJSZWN0V2l0aEdyYWRpZW50KGN0eCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgdG9wQ29sb3IsIGJvdHRvbUNvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0JvcmRlcih7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSwgaG9yaXpvbnRhbFBpeGVsUmF0aW8gfSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2l6ZSA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID09PSBudWxsIHx8ICF0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9vcHRpb25zKCkuYm9yZGVyVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9vcHRpb25zKCkuYm9yZGVyQ29sb3I7XG4gICAgICAgIGNvbnN0IGJvcmRlclNpemUgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHRoaXMuX2ludGVybmFsX3JlbmRlcmVyT3B0aW9ucygpLl9pbnRlcm5hbF9ib3JkZXJTaXplICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pKTtcbiAgICAgICAgbGV0IGxlZnQ7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc0xlZnQpIHtcbiAgICAgICAgICAgIGxlZnQgPSBiaXRtYXBTaXplLndpZHRoIC0gYm9yZGVyU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCAwLCBib3JkZXJTaXplLCBiaXRtYXBTaXplLmhlaWdodCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3VGlja01hcmtzKHRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2l6ZSA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGlja01hcmtzID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfbWFya3MoKTtcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZU9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IHRoaXMuX2ludGVybmFsX3JlbmRlcmVyT3B0aW9ucygpO1xuICAgICAgICBjb25zdCB0aWNrTWFya0xlZnRYID0gdGhpcy5fcHJpdmF0ZV9faXNMZWZ0ID9cbiAgICAgICAgICAgICh0aGlzLl9wcml2YXRlX19zaXplLndpZHRoIC0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoKSA6XG4gICAgICAgICAgICAwO1xuICAgICAgICBpZiAocHJpY2VTY2FsZU9wdGlvbnMuYm9yZGVyVmlzaWJsZSAmJiBwcmljZVNjYWxlT3B0aW9ucy50aWNrc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHRhcmdldC51c2VCaXRtYXBDb29yZGluYXRlU3BhY2UoKHsgY29udGV4dDogY3R4LCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gcHJpY2VTY2FsZU9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja0hlaWdodCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IodmVydGljYWxQaXhlbFJhdGlvKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja09mZnNldCA9IE1hdGguZmxvb3IodmVydGljYWxQaXhlbFJhdGlvICogMC41KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrTGVuZ3RoID0gTWF0aC5yb3VuZChyZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3RpY2tMZW5ndGggKiBob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGlja01hcmsgb2YgdGlja01hcmtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KE1hdGguZmxvb3IodGlja01hcmtMZWZ0WCAqIGhvcml6b250YWxQaXhlbFJhdGlvKSwgTWF0aC5yb3VuZCh0aWNrTWFyay5faW50ZXJuYWxfY29vcmQgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pIC0gdGlja09mZnNldCwgdGlja0xlbmd0aCwgdGlja0hlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQudXNlTWVkaWFDb29yZGluYXRlU3BhY2UoKHsgY29udGV4dDogY3R4IH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gdGhpcy5fcHJpdmF0ZV9fYmFzZUZvbnQoKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAoX2EgPSBwcmljZVNjYWxlT3B0aW9ucy50ZXh0Q29sb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuX3ByaXZhdGVfX2xheW91dE9wdGlvbnMudGV4dENvbG9yO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRoaXMuX3ByaXZhdGVfX2lzTGVmdCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBjb25zdCB0ZXh0TGVmdFggPSB0aGlzLl9wcml2YXRlX19pc0xlZnQgP1xuICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGlja01hcmtMZWZ0WCAtIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0lubmVyKSA6XG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCh0aWNrTWFya0xlZnRYICsgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoICsgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nSW5uZXIpO1xuICAgICAgICAgICAgY29uc3QgeU1pZENvcnJlY3Rpb25zID0gdGlja01hcmtzLm1hcCgobWFyaykgPT4gdGhpcy5fcHJpdmF0ZV9fd2lkdGhDYWNoZS5faW50ZXJuYWxfeU1pZENvcnJlY3Rpb24oY3R4LCBtYXJrLl9pbnRlcm5hbF9sYWJlbCkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRpY2tNYXJrcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrTWFyayA9IHRpY2tNYXJrc1tpXTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGlja01hcmsuX2ludGVybmFsX2xhYmVsLCB0ZXh0TGVmdFgsIHRpY2tNYXJrLl9pbnRlcm5hbF9jb29yZCArIHlNaWRDb3JyZWN0aW9uc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fYWxpZ25MYWJlbHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zaXplID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2VudGVyID0gdGhpcy5fcHJpdmF0ZV9fc2l6ZS5oZWlnaHQgLyAyO1xuICAgICAgICBjb25zdCB2aWV3cyA9IFtdO1xuICAgICAgICBjb25zdCBvcmRlcmVkU291cmNlcyA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX29yZGVyZWRTb3VyY2VzKCkuc2xpY2UoKTsgLy8gQ29weSBvZiBhcnJheVxuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZTtcbiAgICAgICAgY29uc3QgcGFuZVN0YXRlID0gcGFuZS5faW50ZXJuYWxfc3RhdGUoKTtcbiAgICAgICAgY29uc3QgcmVuZGVyZXJPcHRpb25zID0gdGhpcy5faW50ZXJuYWxfcmVuZGVyZXJPcHRpb25zKCk7XG4gICAgICAgIC8vIGlmIHdlIGFyZSBkZWZhdWx0IHByaWNlIHNjYWxlLCBhcHBlbmQgbGFiZWxzIGZyb20gbm8tc2NhbGVcbiAgICAgICAgY29uc3QgaXNEZWZhdWx0ID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9PT0gcGFuZVN0YXRlLl9pbnRlcm5hbF9kZWZhdWx0VmlzaWJsZVByaWNlU2NhbGUoKTtcbiAgICAgICAgaWYgKGlzRGVmYXVsdCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfc3RhdGUoKS5faW50ZXJuYWxfb3JkZXJlZFNvdXJjZXMoKS5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGFuZVN0YXRlLl9pbnRlcm5hbF9pc092ZXJsYXkoc291cmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBvcmRlcmVkU291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgY2FuIHVzZSBhbnksIGJ1dCBsZXQncyB1c2UgdGhlIGZpcnN0IHNvdXJjZSBhcyBcImNlbnRlclwiIG9uZVxuICAgICAgICBjb25zdCBjZW50ZXJTb3VyY2UgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9kYXRhU291cmNlcygpWzBdO1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZTtcbiAgICAgICAgY29uc3QgdXBkYXRlRm9yU291cmNlcyA9IChzb3VyY2VzKSA9PiB7XG4gICAgICAgICAgICBzb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZpZXdzID0gc291cmNlLl9pbnRlcm5hbF9wcmljZUF4aXNWaWV3cyhwYW5lU3RhdGUsIHByaWNlU2NhbGUpO1xuICAgICAgICAgICAgICAgIC8vIG5ldmVyIGFsaWduIHNlbGVjdGVkIHNvdXJjZXNcbiAgICAgICAgICAgICAgICBzb3VyY2VWaWV3cy5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuX2ludGVybmFsX3NldEZpeGVkQ29vcmRpbmF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXcuX2ludGVybmFsX2lzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbnRlclNvdXJjZSA9PT0gc291cmNlICYmIHNvdXJjZVZpZXdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyID0gc291cmNlVmlld3NbMF0uX2ludGVybmFsX2Nvb3JkaW5hdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gY3Jvc3NoYWlyIGluZGl2aWR1YWxseVxuICAgICAgICB1cGRhdGVGb3JTb3VyY2VzKG9yZGVyZWRTb3VyY2VzKTtcbiAgICAgICAgdmlld3MuZm9yRWFjaCgodmlldykgPT4gdmlldy5faW50ZXJuYWxfc2V0Rml4ZWRDb29yZGluYXRlKHZpZXcuX2ludGVybmFsX2Nvb3JkaW5hdGUoKSkpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYWxpZ25MYWJlbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19maXhMYWJlbE92ZXJsYXAodmlld3MsIHJlbmRlcmVyT3B0aW9ucywgY2VudGVyKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2ZpeExhYmVsT3ZlcmxhcCh2aWV3cywgcmVuZGVyZXJPcHRpb25zLCBjZW50ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3NpemUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGxpdCBpbnRvIHR3byBwYXJ0c1xuICAgICAgICBjb25zdCB0b3AgPSB2aWV3cy5maWx0ZXIoKHZpZXcpID0+IHZpZXcuX2ludGVybmFsX2Nvb3JkaW5hdGUoKSA8PSBjZW50ZXIpO1xuICAgICAgICBjb25zdCBib3R0b20gPSB2aWV3cy5maWx0ZXIoKHZpZXcpID0+IHZpZXcuX2ludGVybmFsX2Nvb3JkaW5hdGUoKSA+IGNlbnRlcik7XG4gICAgICAgIC8vIHNvcnQgdG9wIGZyb20gY2VudGVyIHRvIHRvcFxuICAgICAgICB0b3Auc29ydCgobCwgcikgPT4gci5faW50ZXJuYWxfY29vcmRpbmF0ZSgpIC0gbC5faW50ZXJuYWxfY29vcmRpbmF0ZSgpKTtcbiAgICAgICAgLy8gc2hhcmUgY2VudGVyIGxhYmVsXG4gICAgICAgIGlmICh0b3AubGVuZ3RoICYmIGJvdHRvbS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJvdHRvbS5wdXNoKHRvcFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgYm90dG9tLnNvcnQoKGwsIHIpID0+IGwuX2ludGVybmFsX2Nvb3JkaW5hdGUoKSAtIHIuX2ludGVybmFsX2Nvb3JkaW5hdGUoKSk7XG4gICAgICAgIGZvciAoY29uc3QgdmlldyBvZiB2aWV3cykge1xuICAgICAgICAgICAgY29uc3QgaGFsZkhlaWdodCA9IE1hdGguZmxvb3Iodmlldy5faW50ZXJuYWxfaGVpZ2h0KHJlbmRlcmVyT3B0aW9ucykgLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB2aWV3Ll9pbnRlcm5hbF9jb29yZGluYXRlKCk7XG4gICAgICAgICAgICBpZiAoY29vcmRpbmF0ZSA+IC1oYWxmSGVpZ2h0ICYmIGNvb3JkaW5hdGUgPCBoYWxmSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdmlldy5faW50ZXJuYWxfc2V0Rml4ZWRDb29yZGluYXRlKGhhbGZIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGUgPiAodGhpcy5fcHJpdmF0ZV9fc2l6ZS5oZWlnaHQgLSBoYWxmSGVpZ2h0KSAmJiBjb29yZGluYXRlIDwgdGhpcy5fcHJpdmF0ZV9fc2l6ZS5oZWlnaHQgKyBoYWxmSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdmlldy5faW50ZXJuYWxfc2V0Rml4ZWRDb29yZGluYXRlKHRoaXMuX3ByaXZhdGVfX3NpemUuaGVpZ2h0IC0gaGFsZkhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0b3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSB0b3BbaV07XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gdG9wW2kgLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHByZXYuX2ludGVybmFsX2hlaWdodChyZW5kZXJlck9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB2aWV3Ll9pbnRlcm5hbF9jb29yZGluYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBwcmV2Rml4ZWRDb29yZGluYXRlID0gcHJldi5faW50ZXJuYWxfZ2V0Rml4ZWRDb29yZGluYXRlKCk7XG4gICAgICAgICAgICBpZiAoY29vcmRpbmF0ZSA+IHByZXZGaXhlZENvb3JkaW5hdGUgLSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB2aWV3Ll9pbnRlcm5hbF9zZXRGaXhlZENvb3JkaW5hdGUocHJldkZpeGVkQ29vcmRpbmF0ZSAtIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBib3R0b20ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBib3R0b21bal07XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gYm90dG9tW2ogLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHByZXYuX2ludGVybmFsX2hlaWdodChyZW5kZXJlck9wdGlvbnMsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZSA9IHZpZXcuX2ludGVybmFsX2Nvb3JkaW5hdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZGaXhlZENvb3JkaW5hdGUgPSBwcmV2Ll9pbnRlcm5hbF9nZXRGaXhlZENvb3JkaW5hdGUoKTtcbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlIDwgcHJldkZpeGVkQ29vcmRpbmF0ZSArIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHZpZXcuX2ludGVybmFsX3NldEZpeGVkQ29vcmRpbmF0ZShwcmV2Rml4ZWRDb29yZGluYXRlICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0JhY2tMYWJlbHModGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zaXplID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld3MgPSB0aGlzLl9wcml2YXRlX19iYWNrTGFiZWxzKCk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IHRoaXMuX2ludGVybmFsX3JlbmRlcmVyT3B0aW9ucygpO1xuICAgICAgICBjb25zdCBhbGlnbiA9IHRoaXMuX3ByaXZhdGVfX2lzTGVmdCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgIHZpZXdzLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3Ll9pbnRlcm5hbF9pc0F4aXNMYWJlbFZpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdmlldy5faW50ZXJuYWxfcmVuZGVyZXIoZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlKSk7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuX2ludGVybmFsX2RyYXcodGFyZ2V0LCByZW5kZXJlck9wdGlvbnMsIHRoaXMuX3ByaXZhdGVfX3dpZHRoQ2FjaGUsIGFsaWduKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3Q3Jvc3NoYWlyTGFiZWwodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zaXplID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2NoYXJ0KCkuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIGNvbnN0IHZpZXdzID0gW107IC8vIGFycmF5IG9mIGFycmF5c1xuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfc3RhdGUoKTtcbiAgICAgICAgY29uc3QgdiA9IG1vZGVsLl9pbnRlcm5hbF9jcm9zc2hhaXJTb3VyY2UoKS5faW50ZXJuYWxfcHJpY2VBeGlzVmlld3MocGFuZSwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSk7XG4gICAgICAgIGlmICh2Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmlld3MucHVzaCh2KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBybyA9IHRoaXMuX2ludGVybmFsX3JlbmRlcmVyT3B0aW9ucygpO1xuICAgICAgICBjb25zdCBhbGlnbiA9IHRoaXMuX3ByaXZhdGVfX2lzTGVmdCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgIHZpZXdzLmZvckVhY2goKGFycikgPT4ge1xuICAgICAgICAgICAgYXJyLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgICAgICB2aWV3Ll9pbnRlcm5hbF9yZW5kZXJlcihlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUpKS5faW50ZXJuYWxfZHJhdyh0YXJnZXQsIHJvLCB0aGlzLl9wcml2YXRlX193aWR0aENhY2hlLCBhbGlnbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19zZXRDdXJzb3IodHlwZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLmN1cnNvciA9IHR5cGUgPT09IDEgLyogQ3Vyc29yVHlwZS5Oc1Jlc2l6ZSAqLyA/ICducy1yZXNpemUnIDogJ2RlZmF1bHQnO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fb25NYXJrc0NoYW5nZWQoKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5faW50ZXJuYWxfb3B0aW1hbFdpZHRoKCk7XG4gICAgICAgIC8vIGF2b2lkIHByaWNlIHNjYWxlIGlzIHNocnVua1xuICAgICAgICAvLyB1c2luZyA8IGluc3RlYWQgIT09IHRvIGF2b2lkIGluZmluaXRlIGNoYW5nZXNcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByZXZPcHRpbWFsV2lkdGggPCB3aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfY2hhcnQoKS5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByZXZPcHRpbWFsV2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Jhc2VGb250KCkge1xuICAgICAgICByZXR1cm4gbWFrZUZvbnQodGhpcy5fcHJpdmF0ZV9fbGF5b3V0T3B0aW9ucy5mb250U2l6ZSwgdGhpcy5fcHJpdmF0ZV9fbGF5b3V0T3B0aW9ucy5mb250RmFtaWx5KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNvdXJjZUJvdHRvbVBhbmVWaWV3cyQxKHNvdXJjZSwgcGFuZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHNvdXJjZS5faW50ZXJuYWxfYm90dG9tUGFuZVZpZXdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzb3VyY2UsIHBhbmUpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbn1cbmZ1bmN0aW9uIHNvdXJjZVBhbmVWaWV3cyQxKHNvdXJjZSwgcGFuZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHNvdXJjZS5faW50ZXJuYWxfcGFuZVZpZXdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzb3VyY2UsIHBhbmUpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbn1cbmZ1bmN0aW9uIHNvdXJjZUxhYmVsUGFuZVZpZXdzKHNvdXJjZSwgcGFuZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHNvdXJjZS5faW50ZXJuYWxfbGFiZWxQYW5lVmlld3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHNvdXJjZSwgcGFuZSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xufVxuZnVuY3Rpb24gc291cmNlVG9wUGFuZVZpZXdzJDEoc291cmNlLCBwYW5lKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gc291cmNlLl9pbnRlcm5hbF90b3BQYW5lVmlld3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHNvdXJjZSwgcGFuZSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xufVxuY2xhc3MgUGFuZVdpZGdldCB7XG4gICAgY29uc3RydWN0b3IoY2hhcnQsIHN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NpemUgPSBzaXplJDEoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFNjcm9sbGluZ1BvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmV2UGluY2hTY2FsZSA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvbmdUYXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZXhpdFRyYWNraW5nTW9kZU9uTmV4dFRyeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbml0Q3Jvc3NoYWlyUG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zY3JvbGxYQW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSB8fCB0aGlzLl9wcml2YXRlX19zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsKCkuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc1NldHRpbmdTaXplIHx8IHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnQgPSBjaGFydDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhdGUuX2ludGVybmFsX29uRGVzdHJveWVkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19vblN0YXRlRGVzdHJveWVkLmJpbmQodGhpcyksIHRoaXMsIHRydWUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lQ2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVDZWxsLnN0eWxlLnBhZGRpbmcgPSAnMCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVDZWxsLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgY29uc3QgcGFuZVdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcGFuZVdyYXBwZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHBhbmVXcmFwcGVyLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgcGFuZVdyYXBwZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICBwYW5lV3JhcHBlci5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0QXhpc0NlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0QXhpc0NlbGwuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRBeGlzQ2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0QXhpc0NlbGwuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZUNlbGwuYXBwZW5kQ2hpbGQocGFuZVdyYXBwZXIpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nID0gY3JlYXRlQm91bmRDYW52YXMocGFuZVdyYXBwZXIsIHNpemUkMSh7IHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiB9KSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fY2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyKTtcbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50O1xuICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzEnO1xuICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZyA9IGNyZWF0ZUJvdW5kQ2FudmFzKHBhbmVXcmFwcGVyLCBzaXplJDEoeyB3aWR0aDogMTYsIGhlaWdodDogMTYgfSkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLnN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlcik7XG4gICAgICAgIGNvbnN0IHRvcENhbnZhcyA9IHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudDtcbiAgICAgICAgdG9wQ2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdG9wQ2FudmFzLnN0eWxlLnpJbmRleCA9ICcyJztcbiAgICAgICAgdG9wQ2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIHRvcENhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jvd0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yb3dFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX2xlZnRBeGlzQ2VsbCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jvd0VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fcGFuZUNlbGwpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yb3dFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX3JpZ2h0QXhpc0NlbGwpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVQcmljZUF4aXNXaWRnZXRzU3RhdGVzKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlRXZlbnRIYW5kbGVyID0gbmV3IE1vdXNlRXZlbnRIYW5kbGVyKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudCwgdGhpcywge1xuICAgICAgICAgICAgX2ludGVybmFsX3RyZWF0VmVydFRvdWNoRHJhZ0FzUGFnZVNjcm9sbDogKCkgPT4gdGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50ID09PSBudWxsICYmICF0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpLmhhbmRsZVNjcm9sbC52ZXJ0VG91Y2hEcmFnLFxuICAgICAgICAgICAgX2ludGVybmFsX3RyZWF0SG9yelRvdWNoRHJhZ0FzUGFnZVNjcm9sbDogKCkgPT4gdGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50ID09PSBudWxsICYmICF0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpLmhhbmRsZVNjcm9sbC5ob3J6VG91Y2hEcmFnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Rlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcudW5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX190b3BDYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICByZWxlYXNlQ2FudmFzKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLnVuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fY2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyKTtcbiAgICAgICAgcmVsZWFzZUNhbnZhcyh0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfb25EZXN0cm95ZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VFdmVudEhhbmRsZXIuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXRlKCkge1xuICAgICAgICByZXR1cm4gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19zdGF0ZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRTdGF0ZShwYW5lKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhdGUuX2ludGVybmFsX29uRGVzdHJveWVkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXRlID0gcGFuZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfb25EZXN0cm95ZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKFBhbmVXaWRnZXQucHJvdG90eXBlLl9wcml2YXRlX19vblN0YXRlRGVzdHJveWVkLmJpbmQodGhpcyksIHRoaXMsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZVByaWNlQXhpc1dpZGdldHNTdGF0ZXMoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2NoYXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcm93RWxlbWVudDtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZVByaWNlQXhpc1dpZGdldHNTdGF0ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY3JlYXRlUHJpY2VBeGlzV2lkZ2V0cygpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfc2VyaWVzZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbGVmdFByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfbGVmdFByaWNlU2NhbGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX3NldFByaWNlU2NhbGUoZW5zdXJlTm90TnVsbChsZWZ0UHJpY2VTY2FsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcmlnaHRQcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fc3RhdGUuX2ludGVybmFsX3JpZ2h0UHJpY2VTY2FsZSgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX3NldFByaWNlU2NhbGUoZW5zdXJlTm90TnVsbChyaWdodFByaWNlU2NhbGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlUHJpY2VBeGlzV2lkZ2V0cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdHJldGNoRmFjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc3RhdGUgIT09IG51bGwgPyB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfc3RyZXRjaEZhY3RvcigpIDogMDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFN0cmV0Y2hGYWN0b3Ioc3RyZXRjaEZhY3Rvcikge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXRlLl9pbnRlcm5hbF9zZXRTdHJldGNoRmFjdG9yKHN0cmV0Y2hGYWN0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZUVudGVyRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19zdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uTW91c2VFdmVudCgpO1xuICAgICAgICBjb25zdCB4ID0gZXZlbnQubG9jYWxYO1xuICAgICAgICBjb25zdCB5ID0gZXZlbnQubG9jYWxZO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDcm9zc2hhaXJQb3NpdGlvbih4LCB5LCBldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZURvd25FdmVudChldmVudCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbk1vdXNlRXZlbnQoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VUb3VjaERvd25FdmVudCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDcm9zc2hhaXJQb3NpdGlvbihldmVudC5sb2NhbFgsIGV2ZW50LmxvY2FsWSwgZXZlbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VNb3ZlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3N0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25Nb3VzZUV2ZW50KCk7XG4gICAgICAgIGNvbnN0IHggPSBldmVudC5sb2NhbFg7XG4gICAgICAgIGNvbnN0IHkgPSBldmVudC5sb2NhbFk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldENyb3NzaGFpclBvc2l0aW9uKHgsIHksIGV2ZW50KTtcbiAgICAgICAgY29uc3QgaGl0VGVzdCA9IHRoaXMuX2ludGVybmFsX2hpdFRlc3QoeCwgeSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9zZXRDdXJzb3JTdHlsZSgoX2EgPSBoaXRUZXN0ID09PSBudWxsIHx8IGhpdFRlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhpdFRlc3QuX2ludGVybmFsX2N1cnNvclN0eWxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfc2V0SG92ZXJlZFNvdXJjZShoaXRUZXN0ICYmIHsgX2ludGVybmFsX3NvdXJjZTogaGl0VGVzdC5faW50ZXJuYWxfc291cmNlLCBfaW50ZXJuYWxfb2JqZWN0OiBoaXRUZXN0Ll9pbnRlcm5hbF9vYmplY3QgfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZUNsaWNrRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25Nb3VzZUV2ZW50KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZpcmVDbGlja2VkRGVsZWdhdGUoZXZlbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VEb3VibGVDbGlja0V2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZpcmVNb3VzZUNsaWNrRGVsZWdhdGUodGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZCwgZXZlbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZG91YmxlVGFwRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW91c2VEb3VibGVDbGlja0V2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByZXNzZWRNb3VzZU1vdmVFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbk1vdXNlRXZlbnQoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJlc3NlZE1vdXNlVG91Y2hNb3ZlRXZlbnQoZXZlbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDcm9zc2hhaXJQb3NpdGlvbihldmVudC5sb2NhbFgsIGV2ZW50LmxvY2FsWSwgZXZlbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VVcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uTW91c2VFdmVudCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb25nVGFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VuZFNjcm9sbChldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90YXBFdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19maXJlQ2xpY2tlZERlbGVnYXRlKGV2ZW50KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2xvbmdUYXBFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb25nVGFwID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXJ0VHJhY2tQb2ludCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB7IHg6IGV2ZW50LmxvY2FsWCwgeTogZXZlbnQubG9jYWxZIH07XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFRyYWNraW5nTW9kZShwb2ludCwgcG9pbnQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VMZWF2ZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uTW91c2VFdmVudCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfc2V0SG92ZXJlZFNvdXJjZShudWxsKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJDcm9zc2hhaXJQb3NpdGlvbigpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY2xpY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NsaWNrZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kYmxDbGlja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZDtcbiAgICB9XG4gICAgX2ludGVybmFsX3BpbmNoU3RhcnRFdmVudCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJldlBpbmNoU2NhbGUgPSAxO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCgpLl9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9waW5jaEV2ZW50KG1pZGRsZVBvaW50LCBzY2FsZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKCkuaGFuZGxlU2NhbGUucGluY2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB6b29tU2NhbGUgPSAoc2NhbGUgLSB0aGlzLl9wcml2YXRlX19wcmV2UGluY2hTY2FsZSkgKiA1O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmV2UGluY2hTY2FsZSA9IHNjYWxlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCgpLl9pbnRlcm5hbF96b29tVGltZShtaWRkbGVQb2ludC5faW50ZXJuYWxfeCwgem9vbVNjYWxlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3RvdWNoU3RhcnRFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb25nVGFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2V4aXRUcmFja2luZ01vZGVPbk5leHRUcnkgPSB0aGlzLl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQgIT09IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlVG91Y2hEb3duRXZlbnQoKTtcbiAgICAgICAgY29uc3QgY3Jvc3NoYWlyID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfY3Jvc3NoYWlyU291cmNlKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQgIT09IG51bGwgJiYgY3Jvc3NoYWlyLl9pbnRlcm5hbF92aXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2luaXRDcm9zc2hhaXJQb3NpdGlvbiA9IHsgeDogY3Jvc3NoYWlyLl9pbnRlcm5hbF9hcHBsaWVkWCgpLCB5OiBjcm9zc2hhaXIuX2ludGVybmFsX2FwcGxpZWRZKCkgfTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0VHJhY2tQb2ludCA9IHsgeDogZXZlbnQubG9jYWxYLCB5OiBldmVudC5sb2NhbFkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfdG91Y2hNb3ZlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeCA9IGV2ZW50LmxvY2FsWDtcbiAgICAgICAgY29uc3QgeSA9IGV2ZW50LmxvY2FsWTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXJ0VHJhY2tQb2ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gdHJhY2tpbmcgbW9kZTogbW92ZSBjcm9zc2hhaXJcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2V4aXRUcmFja2luZ01vZGVPbk5leHRUcnkgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdQb2ludCA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9faW5pdENyb3NzaGFpclBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ggPSBvcmlnUG9pbnQueCArICh4IC0gdGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50LngpO1xuICAgICAgICAgICAgY29uc3QgbmV3WSA9IG9yaWdQb2ludC55ICsgKHkgLSB0aGlzLl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQueSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDcm9zc2hhaXJQb3NpdGlvbihuZXdYLCBuZXdZLCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJlc3NlZE1vdXNlVG91Y2hNb3ZlRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdG91Y2hFbmRFdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfY2hhcnQoKS5faW50ZXJuYWxfb3B0aW9ucygpLnRyYWNraW5nTW9kZS5leGl0TW9kZSA9PT0gMCAvKiBUcmFja2luZ01vZGVFeGl0TW9kZS5PblRvdWNoRW5kICovKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19leGl0VHJhY2tpbmdNb2RlT25OZXh0VHJ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX190cnlFeGl0VHJhY2tpbmdNb2RlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VuZFNjcm9sbChldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9oaXRUZXN0KHgsIHkpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9wcml2YXRlX19zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGl0VGVzdFBhbmUoc3RhdGUsIHgsIHkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0UHJpY2VBeGlzU2l6ZSh3aWR0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgcHJpY2VBeGlzV2lkZ2V0ID0gcG9zaXRpb24gPT09ICdsZWZ0JyA/IHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQgOiB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldDtcbiAgICAgICAgZW5zdXJlTm90TnVsbChwcmljZUF4aXNXaWRnZXQpLl9pbnRlcm5hbF9zZXRTaXplKHNpemUkMSh7IHdpZHRoLCBoZWlnaHQ6IHRoaXMuX3ByaXZhdGVfX3NpemUuaGVpZ2h0IH0pKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zaXplO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0U2l6ZShuZXdTaXplKSB7XG4gICAgICAgIGlmIChlcXVhbFNpemVzKHRoaXMuX3ByaXZhdGVfX3NpemUsIG5ld1NpemUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLnJlc2l6ZUNhbnZhc0VsZW1lbnQobmV3U2l6ZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcucmVzaXplQ2FudmFzRWxlbWVudChuZXdTaXplKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lQ2VsbC5zdHlsZS53aWR0aCA9IG5ld1NpemUud2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lQ2VsbC5zdHlsZS5oZWlnaHQgPSBuZXdTaXplLmhlaWdodCArICdweCc7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZWNhbGN1bGF0ZVByaWNlU2NhbGVzKCkge1xuICAgICAgICBjb25zdCBwYW5lID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19zdGF0ZSk7XG4gICAgICAgIHBhbmUuX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VTY2FsZShwYW5lLl9pbnRlcm5hbF9sZWZ0UHJpY2VTY2FsZSgpKTtcbiAgICAgICAgcGFuZS5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVNjYWxlKHBhbmUuX2ludGVybmFsX3JpZ2h0UHJpY2VTY2FsZSgpKTtcbiAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2YgcGFuZS5faW50ZXJuYWxfZGF0YVNvdXJjZXMoKSkge1xuICAgICAgICAgICAgaWYgKHBhbmUuX2ludGVybmFsX2lzT3ZlcmxheShzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHNvdXJjZS5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmljZVNjYWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmUuX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VTY2FsZShwcmljZVNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZm9yIG92ZXJsYXkgZHJhd2luZ3MgcHJpY2Ugc2NhbGUgaXMgb3duZXIncyBwcmljZSBzY2FsZVxuICAgICAgICAgICAgICAgIC8vIGhvd2V2ZXIgb3duZXIncyBwcmljZSBzY2FsZSBjb3VsZCBub3QgY29udGFpbiBkc1xuICAgICAgICAgICAgICAgIHNvdXJjZS5faW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuYml0bWFwU2l6ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXdCaXRtYXAoY3R4LCB4LCB5KSB7XG4gICAgICAgIGNvbnN0IGJpdG1hcFNpemUgPSB0aGlzLl9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCk7XG4gICAgICAgIGlmIChiaXRtYXBTaXplLndpZHRoID4gMCAmJiBiaXRtYXBTaXplLmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50LCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFpbnQodHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gMCAvKiBJbnZhbGlkYXRpb25MZXZlbC5Ob25lICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPiAxIC8qIEludmFsaWRhdGlvbkxldmVsLkN1cnNvciAqLykge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVNjYWxlcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9wYWludCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9wYWludCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSAhPT0gMSAvKiBJbnZhbGlkYXRpb25MZXZlbC5DdXJzb3IgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuYXBwbHlTdWdnZXN0ZWRCaXRtYXBTaXplKCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0cnlDcmVhdGVDYW52YXNSZW5kZXJpbmdUYXJnZXQyRCh0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKChzY29wZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3QmFja2dyb3VuZChzY29wZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdTb3VyY2VzKHRhcmdldCwgc291cmNlQm90dG9tUGFuZVZpZXdzJDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3R3JpZCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3V2F0ZXJtYXJrKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdTb3VyY2VzKHRhcmdldCwgc291cmNlUGFuZVZpZXdzJDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3U291cmNlcyh0YXJnZXQsIHNvdXJjZUxhYmVsUGFuZVZpZXdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5hcHBseVN1Z2dlc3RlZEJpdG1hcFNpemUoKTtcbiAgICAgICAgY29uc3QgdG9wVGFyZ2V0ID0gdHJ5Q3JlYXRlQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQodGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZyk7XG4gICAgICAgIGlmICh0b3BUYXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRvcFRhcmdldC51c2VCaXRtYXBDb29yZGluYXRlU3BhY2UoKHsgY29udGV4dDogY3R4LCBiaXRtYXBTaXplIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGJpdG1hcFNpemUud2lkdGgsIGJpdG1hcFNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0Nyb3NzaGFpcih0b3BUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1NvdXJjZXModG9wVGFyZ2V0LCBzb3VyY2VUb3BQYW5lVmlld3MkMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX2xlZnRQcmljZUF4aXNXaWRnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmlnaHRQcmljZUF4aXNXaWRnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldDtcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXdBZGRpdGlvbmFsU291cmNlcyh0YXJnZXQsIHBhbmVWaWV3c0dldHRlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3U291cmNlcyh0YXJnZXQsIHBhbmVWaWV3c0dldHRlcik7XG4gICAgfVxuICAgIF9wcml2YXRlX19vblN0YXRlRGVzdHJveWVkKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXRlLl9pbnRlcm5hbF9vbkRlc3Ryb3llZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19maXJlQ2xpY2tlZERlbGVnYXRlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZpcmVNb3VzZUNsaWNrRGVsZWdhdGUodGhpcy5fcHJpdmF0ZV9fY2xpY2tlZCwgZXZlbnQpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZmlyZU1vdXNlQ2xpY2tEZWxlZ2F0ZShkZWxlZ2F0ZSwgZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeCA9IGV2ZW50LmxvY2FsWDtcbiAgICAgICAgY29uc3QgeSA9IGV2ZW50LmxvY2FsWTtcbiAgICAgICAgaWYgKGRlbGVnYXRlLl9pbnRlcm5hbF9oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgICAgICAgZGVsZWdhdGUuX2ludGVybmFsX2ZpcmUodGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2Nvb3JkaW5hdGVUb0luZGV4KHgpLCB7IHgsIHkgfSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3QmFja2dyb3VuZCh7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSB9KSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gYml0bWFwU2l6ZTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19tb2RlbCgpO1xuICAgICAgICBjb25zdCB0b3BDb2xvciA9IG1vZGVsLl9pbnRlcm5hbF9iYWNrZ3JvdW5kVG9wQ29sb3IoKTtcbiAgICAgICAgY29uc3QgYm90dG9tQ29sb3IgPSBtb2RlbC5faW50ZXJuYWxfYmFja2dyb3VuZEJvdHRvbUNvbG9yKCk7XG4gICAgICAgIGlmICh0b3BDb2xvciA9PT0gYm90dG9tQ29sb3IpIHtcbiAgICAgICAgICAgIGNsZWFyUmVjdChjdHgsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIGJvdHRvbUNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyUmVjdFdpdGhHcmFkaWVudChjdHgsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIHRvcENvbG9yLCBib3R0b21Db2xvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdHcmlkKHRhcmdldCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fc3RhdGUpO1xuICAgICAgICBjb25zdCBwYW5lVmlldyA9IHN0YXRlLl9pbnRlcm5hbF9ncmlkKCkuX2ludGVybmFsX3BhbmVWaWV3KCk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gcGFuZVZpZXcuX2ludGVybmFsX3JlbmRlcmVyKCk7XG4gICAgICAgIGlmIChyZW5kZXJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVuZGVyZXIuX2ludGVybmFsX2RyYXcodGFyZ2V0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdXYXRlcm1hcmsodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuX3ByaXZhdGVfX21vZGVsKCkuX2ludGVybmFsX3dhdGVybWFya1NvdXJjZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3U291cmNlSW1wbCh0YXJnZXQsIHNvdXJjZVBhbmVWaWV3cyQxLCBkcmF3QmFja2dyb3VuZCwgc291cmNlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1NvdXJjZUltcGwodGFyZ2V0LCBzb3VyY2VQYW5lVmlld3MkMSwgZHJhd0ZvcmVncm91bmQsIHNvdXJjZSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3Q3Jvc3NoYWlyKHRhcmdldCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3U291cmNlSW1wbCh0YXJnZXQsIHNvdXJjZVBhbmVWaWV3cyQxLCBkcmF3Rm9yZWdyb3VuZCwgdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfY3Jvc3NoYWlyU291cmNlKCkpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd1NvdXJjZXModGFyZ2V0LCBwYW5lVmlld3NHZXR0ZXIpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3N0YXRlKTtcbiAgICAgICAgY29uc3Qgc291cmNlcyA9IHN0YXRlLl9pbnRlcm5hbF9vcmRlcmVkU291cmNlcygpO1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3U291cmNlSW1wbCh0YXJnZXQsIHBhbmVWaWV3c0dldHRlciwgZHJhd0JhY2tncm91bmQsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1NvdXJjZUltcGwodGFyZ2V0LCBwYW5lVmlld3NHZXR0ZXIsIGRyYXdGb3JlZ3JvdW5kLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3U291cmNlSW1wbCh0YXJnZXQsIHBhbmVWaWV3c0dldHRlciwgZHJhd0ZuLCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3N0YXRlKTtcbiAgICAgICAgY29uc3QgaG92ZXJlZFNvdXJjZSA9IHN0YXRlLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9ob3ZlcmVkU291cmNlKCk7XG4gICAgICAgIGNvbnN0IGlzSG92ZXJlZCA9IGhvdmVyZWRTb3VyY2UgIT09IG51bGwgJiYgaG92ZXJlZFNvdXJjZS5faW50ZXJuYWxfc291cmNlID09PSBzb3VyY2U7XG4gICAgICAgIGNvbnN0IG9iamVjSWQgPSBob3ZlcmVkU291cmNlICE9PSBudWxsICYmIGlzSG92ZXJlZCAmJiBob3ZlcmVkU291cmNlLl9pbnRlcm5hbF9vYmplY3QgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBob3ZlcmVkU291cmNlLl9pbnRlcm5hbF9vYmplY3QuX2ludGVybmFsX2hpdFRlc3REYXRhXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZHJhd1JlbmRlcmVyRm4gPSAocmVuZGVyZXIpID0+IGRyYXdGbihyZW5kZXJlciwgdGFyZ2V0LCBpc0hvdmVyZWQsIG9iamVjSWQpO1xuICAgICAgICBkcmF3U291cmNlUGFuZVZpZXdzKHBhbmVWaWV3c0dldHRlciwgZHJhd1JlbmRlcmVyRm4sIHNvdXJjZSwgc3RhdGUpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcmVjcmVhdGVQcmljZUF4aXNXaWRnZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0O1xuICAgICAgICBjb25zdCBsZWZ0QXhpc1Zpc2libGUgPSB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfbGVmdFByaWNlU2NhbGUoKS5faW50ZXJuYWxfb3B0aW9ucygpLnZpc2libGU7XG4gICAgICAgIGNvbnN0IHJpZ2h0QXhpc1Zpc2libGUgPSB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfcmlnaHRQcmljZVNjYWxlKCkuX2ludGVybmFsX29wdGlvbnMoKS52aXNpYmxlO1xuICAgICAgICBpZiAoIWxlZnRBeGlzVmlzaWJsZSAmJiB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0QXhpc0NlbGwucmVtb3ZlQ2hpbGQodGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZGdldC5faW50ZXJuYWxfZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmlnaHRBeGlzVmlzaWJsZSAmJiB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRBeGlzQ2VsbC5yZW1vdmVDaGlsZCh0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldC5faW50ZXJuYWxfZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIgPSBjaGFydC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIoKTtcbiAgICAgICAgaWYgKGxlZnRBeGlzVmlzaWJsZSAmJiB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0ID0gbmV3IFByaWNlQXhpc1dpZGdldCh0aGlzLCBjaGFydC5faW50ZXJuYWxfb3B0aW9ucygpLCByZW5kZXJlck9wdGlvbnNQcm92aWRlciwgJ2xlZnQnKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRBeGlzQ2VsbC5hcHBlbmRDaGlsZCh0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9nZXRFbGVtZW50KCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodEF4aXNWaXNpYmxlICYmIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldCA9IG5ldyBQcmljZUF4aXNXaWRnZXQodGhpcywgY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKSwgcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIsICdyaWdodCcpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRBeGlzQ2VsbC5hcHBlbmRDaGlsZCh0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldC5faW50ZXJuYWxfZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fcHJldmVudFNjcm9sbChldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQuX2ludGVybmFsX2lzVG91Y2ggJiYgdGhpcy5fcHJpdmF0ZV9fbG9uZ1RhcCB8fCB0aGlzLl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQgIT09IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19jb3JyZWN0WENvb3JkKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHgsIHRoaXMuX3ByaXZhdGVfX3NpemUud2lkdGggLSAxKSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19jb3JyZWN0WUNvb3JkKHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHksIHRoaXMuX3ByaXZhdGVfX3NpemUuaGVpZ2h0IC0gMSkpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2V0Q3Jvc3NoYWlyUG9zaXRpb24oeCwgeSwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfc2V0QW5kU2F2ZUN1cnJlbnRQb3NpdGlvbih0aGlzLl9wcml2YXRlX19jb3JyZWN0WENvb3JkKHgpLCB0aGlzLl9wcml2YXRlX19jb3JyZWN0WUNvb3JkKHkpLCBldmVudCwgZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19zdGF0ZSkpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY2xlYXJDcm9zc2hhaXJQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfY2xlYXJDdXJyZW50UG9zaXRpb24oKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3RyeUV4aXRUcmFja2luZ01vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19leGl0VHJhY2tpbmdNb2RlT25OZXh0VHJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJDcm9zc2hhaXJQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19zdGFydFRyYWNraW5nTW9kZShzdGFydFRyYWNrUG9pbnQsIGNyb3NzSGFpclBvc2l0aW9uLCBldmVudCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQgPSBzdGFydFRyYWNrUG9pbnQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2V4aXRUcmFja2luZ01vZGVPbk5leHRUcnkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2V0Q3Jvc3NoYWlyUG9zaXRpb24oY3Jvc3NIYWlyUG9zaXRpb24ueCwgY3Jvc3NIYWlyUG9zaXRpb24ueSwgZXZlbnQpO1xuICAgICAgICBjb25zdCBjcm9zc2hhaXIgPSB0aGlzLl9wcml2YXRlX19tb2RlbCgpLl9pbnRlcm5hbF9jcm9zc2hhaXJTb3VyY2UoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5pdENyb3NzaGFpclBvc2l0aW9uID0geyB4OiBjcm9zc2hhaXIuX2ludGVybmFsX2FwcGxpZWRYKCksIHk6IGNyb3NzaGFpci5faW50ZXJuYWxfYXBwbGllZFkoKSB9O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW9kZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2VuZFNjcm9sbChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2lzU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19tb2RlbCgpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX2ludGVybmFsX3N0YXRlKCk7XG4gICAgICAgIG1vZGVsLl9pbnRlcm5hbF9lbmRTY3JvbGxQcmljZShzdGF0ZSwgc3RhdGUuX2ludGVybmFsX2RlZmF1bHRQcmljZVNjYWxlKCkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFNjcm9sbGluZ1BvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIG1vZGVsLl9pbnRlcm5hbF9lbmRTY3JvbGxUaW1lKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zY3JvbGxYQW5pbWF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydEFuaW1hdGlvblRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IG1vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Njcm9sbFhBbmltYXRpb24uX2ludGVybmFsX3N0YXJ0KHRpbWVTY2FsZS5faW50ZXJuYWxfcmlnaHRPZmZzZXQoKSwgc3RhcnRBbmltYXRpb25UaW1lKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsWEFuaW1hdGlvbi5faW50ZXJuYWxfZmluaXNoZWQoc3RhcnRBbmltYXRpb25UaW1lKSkge1xuICAgICAgICAgICAgICAgIG1vZGVsLl9pbnRlcm5hbF9zZXRUaW1lU2NhbGVBbmltYXRpb24odGhpcy5fcHJpdmF0ZV9fc2Nyb2xsWEFuaW1hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX29uTW91c2VFdmVudCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50ID0gbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21vdXNlVG91Y2hEb3duRXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCgpLl9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSWYgYW55IGZvY3VzYWJsZSBlbGVtZW50IGV4Y2VwdCB0aGUgcGFnZSBpdHNlbGYgaXMgZm9jdXNlZCwgcmVtb3ZlIHRoZSBmb2N1c1xuICAgICAgICAgICAgZW5zdXJlTm90TnVsbChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5ibHVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDbGVhciBzZWxlY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fc3RhdGUuX2ludGVybmFsX2RlZmF1bHRQcmljZVNjYWxlKCk7XG4gICAgICAgIGlmIChwcmljZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkgfHwgdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgX3ByaXZhdGVfX3ByZXNzZWRNb3VzZVRvdWNoTW92ZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKTtcbiAgICAgICAgY29uc3QgdGltZVNjYWxlID0gbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpO1xuICAgICAgICBpZiAodGltZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFydE9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICBjb25zdCBzY3JvbGxPcHRpb25zID0gY2hhcnRPcHRpb25zLmhhbmRsZVNjcm9sbDtcbiAgICAgICAgY29uc3Qga2luZXRpY1Njcm9sbE9wdGlvbnMgPSBjaGFydE9wdGlvbnMua2luZXRpY1Njcm9sbDtcbiAgICAgICAgaWYgKCghc2Nyb2xsT3B0aW9ucy5wcmVzc2VkTW91c2VNb3ZlIHx8IGV2ZW50Ll9pbnRlcm5hbF9pc1RvdWNoKSAmJlxuICAgICAgICAgICAgKCFzY3JvbGxPcHRpb25zLmhvcnpUb3VjaERyYWcgJiYgIXNjcm9sbE9wdGlvbnMudmVydFRvdWNoRHJhZyB8fCAhZXZlbnQuX2ludGVybmFsX2lzVG91Y2gpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3N0YXRlLl9pbnRlcm5hbF9kZWZhdWx0UHJpY2VTY2FsZSgpO1xuICAgICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXJ0U2Nyb2xsaW5nUG9zID09PSBudWxsICYmICF0aGlzLl9wcml2YXRlX19wcmV2ZW50U2Nyb2xsKGV2ZW50KSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRTY3JvbGxpbmdQb3MgPSB7XG4gICAgICAgICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90aW1lc3RhbXA6IG5vdyxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfbG9jYWxYOiBldmVudC5sb2NhbFgsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2xvY2FsWTogZXZlbnQubG9jYWxZLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhcnRTY3JvbGxpbmdQb3MgIT09IG51bGwgJiZcbiAgICAgICAgICAgICF0aGlzLl9wcml2YXRlX19pc1Njcm9sbGluZyAmJlxuICAgICAgICAgICAgKHRoaXMuX3ByaXZhdGVfX3N0YXJ0U2Nyb2xsaW5nUG9zLnggIT09IGV2ZW50LmNsaWVudFggfHwgdGhpcy5fcHJpdmF0ZV9fc3RhcnRTY3JvbGxpbmdQb3MueSAhPT0gZXZlbnQuY2xpZW50WSkpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5faW50ZXJuYWxfaXNUb3VjaCAmJiBraW5ldGljU2Nyb2xsT3B0aW9ucy50b3VjaCB8fCAhZXZlbnQuX2ludGVybmFsX2lzVG91Y2ggJiYga2luZXRpY1Njcm9sbE9wdGlvbnMubW91c2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXJTcGFjaW5nID0gdGltZVNjYWxlLl9pbnRlcm5hbF9iYXJTcGFjaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsWEFuaW1hdGlvbiA9IG5ldyBLaW5ldGljQW5pbWF0aW9uKDAuMiAvKiBLaW5ldGljU2Nyb2xsQ29uc3RhbnRzLk1pblNjcm9sbFNwZWVkICovIC8gYmFyU3BhY2luZywgNyAvKiBLaW5ldGljU2Nyb2xsQ29uc3RhbnRzLk1heFNjcm9sbFNwZWVkICovIC8gYmFyU3BhY2luZywgMC45OTcgLyogS2luZXRpY1Njcm9sbENvbnN0YW50cy5EdW1waW5nQ29lZmYgKi8sIDE1IC8qIEtpbmV0aWNTY3JvbGxDb25zdGFudHMuU2Nyb2xsTWluTW92ZSAqLyAvIGJhclNwYWNpbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Njcm9sbFhBbmltYXRpb24uX2ludGVybmFsX2FkZFBvc2l0aW9uKHRpbWVTY2FsZS5faW50ZXJuYWxfcmlnaHRPZmZzZXQoKSwgdGhpcy5fcHJpdmF0ZV9fc3RhcnRTY3JvbGxpbmdQb3MuX2ludGVybmFsX3RpbWVzdGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zY3JvbGxYQW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJpY2VTY2FsZS5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuX2ludGVybmFsX3N0YXJ0U2Nyb2xsUHJpY2UodGhpcy5fcHJpdmF0ZV9fc3RhdGUsIHByaWNlU2NhbGUsIGV2ZW50LmxvY2FsWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RlbC5faW50ZXJuYWxfc3RhcnRTY3JvbGxUaW1lKGV2ZW50LmxvY2FsWCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pc1Njcm9sbGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2lzU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGFsbG93cyBzY3JvbGxpbmcgbm90IGRlZmF1bHQgcHJpY2Ugc2NhbGVzXG4gICAgICAgICAgICBpZiAoIXByaWNlU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIG1vZGVsLl9pbnRlcm5hbF9zY3JvbGxQcmljZVRvKHRoaXMuX3ByaXZhdGVfX3N0YXRlLCBwcmljZVNjYWxlLCBldmVudC5sb2NhbFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kZWwuX2ludGVybmFsX3Njcm9sbFRpbWVUbyhldmVudC5sb2NhbFgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Njcm9sbFhBbmltYXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zY3JvbGxYQW5pbWF0aW9uLl9pbnRlcm5hbF9hZGRQb3NpdGlvbih0aW1lU2NhbGUuX2ludGVybmFsX3JpZ2h0T2Zmc2V0KCksIG5vdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFByaWNlQXhpc1N0dWIge1xuICAgIGNvbnN0cnVjdG9yKHNpZGUsIG9wdGlvbnMsIHBhcmFtcywgYm9yZGVyVmlzaWJsZSwgYm90dG9tQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplID0gc2l6ZSQxKHsgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyID0gKCkgPT4gdGhpcy5faW50ZXJuYWxfcGFpbnQoMyAvKiBJbnZhbGlkYXRpb25MZXZlbC5GdWxsICovKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNMZWZ0ID0gc2lkZSA9PT0gJ2xlZnQnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnNQcm92aWRlciA9IHBhcmFtcy5faW50ZXJuYWxfcmVuZGVyZXJPcHRpb25zUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ib3JkZXJWaXNpYmxlID0gYm9yZGVyVmlzaWJsZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYm90dG9tQ29sb3IgPSBib3R0b21Db2xvcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLndpZHRoID0gJzI1cHgnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nID0gY3JlYXRlQm91bmRDYW52YXModGhpcy5fcHJpdmF0ZV9fY2VsbCwgc2l6ZSQxKHsgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2IH0pKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy51bnN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkKHRoaXMuX3ByaXZhdGVfX2NhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlcik7XG4gICAgICAgIHJlbGVhc2VDYW52YXModGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5kaXNwb3NlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2VsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zaXplO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0U2l6ZShuZXdTaXplKSB7XG4gICAgICAgIGlmICghZXF1YWxTaXplcyh0aGlzLl9wcml2YXRlX19zaXplLCBuZXdTaXplKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLnJlc2l6ZUNhbnZhc0VsZW1lbnQobmV3U2l6ZSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLndpZHRoID0gYCR7bmV3U2l6ZS53aWR0aH1weGA7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLmhlaWdodCA9IGAke25ld1NpemUuaGVpZ2h0fXB4YDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFpbnQodHlwZSkge1xuICAgICAgICBpZiAodHlwZSA8IDMgLyogSW52YWxpZGF0aW9uTGV2ZWwuRnVsbCAqLyAmJiAhdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2l6ZS53aWR0aCA9PT0gMCB8fCB0aGlzLl9wcml2YXRlX19zaXplLmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuYXBwbHlTdWdnZXN0ZWRCaXRtYXBTaXplKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRyeUNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJEKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0YXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKChzY29wZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdCYWNrZ3JvdW5kKHNjb3BlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3Qm9yZGVyKHNjb3BlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5iaXRtYXBTaXplO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZHJhd0JpdG1hcChjdHgsIHgsIHkpIHtcbiAgICAgICAgY29uc3QgYml0bWFwU2l6ZSA9IHRoaXMuX2ludGVybmFsX2dldEJpdG1hcFNpemUoKTtcbiAgICAgICAgaWYgKGJpdG1hcFNpemUud2lkdGggPiAwICYmIGJpdG1hcFNpemUuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQsIHgsIHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3Qm9yZGVyKHsgY29udGV4dDogY3R4LCBiaXRtYXBTaXplLCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvIH0pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19ib3JkZXJWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy50aW1lU2NhbGUuYm9yZGVyQ29sb3I7XG4gICAgICAgIGNvbnN0IGhvcnpCb3JkZXJTaXplID0gTWF0aC5mbG9vcih0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnNQcm92aWRlci5faW50ZXJuYWxfb3B0aW9ucygpLl9pbnRlcm5hbF9ib3JkZXJTaXplICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICBjb25zdCB2ZXJ0Qm9yZGVyU2l6ZSA9IE1hdGguZmxvb3IodGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIuX2ludGVybmFsX29wdGlvbnMoKS5faW50ZXJuYWxfYm9yZGVyU2l6ZSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgIGNvbnN0IGxlZnQgPSAodGhpcy5fcHJpdmF0ZV9faXNMZWZ0KSA/IGJpdG1hcFNpemUud2lkdGggLSBob3J6Qm9yZGVyU2l6ZSA6IDA7XG4gICAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCAwLCBob3J6Qm9yZGVyU2l6ZSwgdmVydEJvcmRlclNpemUpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0JhY2tncm91bmQoeyBjb250ZXh0OiBjdHgsIGJpdG1hcFNpemUgfSkge1xuICAgICAgICBjbGVhclJlY3QoY3R4LCAwLCAwLCBiaXRtYXBTaXplLndpZHRoLCBiaXRtYXBTaXplLmhlaWdodCwgdGhpcy5fcHJpdmF0ZV9fYm90dG9tQ29sb3IoKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFRpbWVBeGlzVmlld3NHZXR0ZXIoek9yZGVyKSB7XG4gICAgcmV0dXJuIChzb3VyY2UpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHNvdXJjZS5faW50ZXJuYWxfdGltZVBhbmVWaWV3cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc291cmNlLCB6T3JkZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTsgfTtcbn1cbmNvbnN0IHNvdXJjZVBhbmVWaWV3cyA9IGJ1aWxkVGltZUF4aXNWaWV3c0dldHRlcignbm9ybWFsJyk7XG5jb25zdCBzb3VyY2VUb3BQYW5lVmlld3MgPSBidWlsZFRpbWVBeGlzVmlld3NHZXR0ZXIoJ3RvcCcpO1xuY29uc3Qgc291cmNlQm90dG9tUGFuZVZpZXdzID0gYnVpbGRUaW1lQXhpc1ZpZXdzR2V0dGVyKCdib3R0b20nKTtcbmNsYXNzIFRpbWVBeGlzV2lkZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcihjaGFydFdpZGdldCwgaG9yelNjYWxlQmVoYXZpb3IpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFN0dWIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZSA9IHNpemUkMSh7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NpemVDaGFuZ2VkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3dpZHRoQ2FjaGUgPSBuZXcgVGV4dFdpZHRoQ2FjaGUoNSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19pc1NldHRpbmdTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9saWdodFVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydCA9IGNoYXJ0V2lkZ2V0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvciA9IGhvcnpTY2FsZUJlaGF2aW9yO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gY2hhcnRXaWRnZXQuX2ludGVybmFsX29wdGlvbnMoKS5sYXlvdXQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0U3R1YkNlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0U3R1YkNlbGwuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViQ2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1YkNlbGwuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUuaGVpZ2h0ID0gJzI1cHgnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLnBhZGRpbmcgPSAnMCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2R2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2R2LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kdi5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2R2LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHYuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5hcHBlbmRDaGlsZCh0aGlzLl9wcml2YXRlX19kdik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcgPSBjcmVhdGVCb3VuZENhbnZhcyh0aGlzLl9wcml2YXRlX19kdiwgc2l6ZSQxKHsgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2IH0pKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQ7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMSc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nID0gY3JlYXRlQm91bmRDYW52YXModGhpcy5fcHJpdmF0ZV9fZHYsIHNpemUkMSh7IHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiB9KSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyKTtcbiAgICAgICAgY29uc3QgdG9wQ2FudmFzID0gdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50O1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUuekluZGV4ID0gJzInO1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgdG9wQ2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9wcml2YXRlX19sZWZ0U3R1YkNlbGwpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX2NlbGwpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1YkNlbGwpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNyZWF0ZVN0dWJzKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9wcmljZVNjYWxlc09wdGlvbnNDaGFuZ2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19yZWNyZWF0ZVN0dWJzLmJpbmQodGhpcyksIHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZUV2ZW50SGFuZGxlciA9IG5ldyBNb3VzZUV2ZW50SGFuZGxlcih0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQsIHRoaXMsIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF90cmVhdFZlcnRUb3VjaERyYWdBc1BhZ2VTY3JvbGw6ICgpID0+IHRydWUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdHJlYXRIb3J6VG91Y2hEcmFnQXNQYWdlU2Nyb2xsOiAoKSA9PiAhdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKS5oYW5kbGVTY3JvbGwuaG9yelRvdWNoRHJhZyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZUV2ZW50SGFuZGxlci5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy51bnN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlcik7XG4gICAgICAgIHJlbGVhc2VDYW52YXModGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcudW5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICByZWxlYXNlQ2FudmFzKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sZWZ0U3R1YigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmlnaHRTdHViKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VEb3duRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX21vdXNlRG93bikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIGlmIChtb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2lzRW1wdHkoKSB8fCAhdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKS5oYW5kbGVTY2FsZS5heGlzUHJlc3NlZE1vdXNlTW92ZS50aW1lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuX2ludGVybmFsX3N0YXJ0U2NhbGVUaW1lKGV2ZW50LmxvY2FsWCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90b3VjaFN0YXJ0RXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW91c2VEb3duRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VEb3duT3V0c2lkZUV2ZW50KCkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBpZiAoIW1vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfaXNFbXB0eSgpICYmIHRoaXMuX3ByaXZhdGVfX21vdXNlRG93bikge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKS5oYW5kbGVTY2FsZS5heGlzUHJlc3NlZE1vdXNlTW92ZS50aW1lKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuX2ludGVybmFsX2VuZFNjYWxlVGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmVzc2VkTW91c2VNb3ZlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICAgICAgaWYgKG1vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfaXNFbXB0eSgpIHx8ICF0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpLmhhbmRsZVNjYWxlLmF4aXNQcmVzc2VkTW91c2VNb3ZlLnRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5faW50ZXJuYWxfc2NhbGVUaW1lVG8oZXZlbnQubG9jYWxYKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3RvdWNoTW92ZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3ByZXNzZWRNb3VzZU1vdmVFdmVudChldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZVVwRXZlbnQoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBpZiAobW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9pc0VtcHR5KCkgJiYgIXRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKCkuaGFuZGxlU2NhbGUuYXhpc1ByZXNzZWRNb3VzZU1vdmUudGltZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLl9pbnRlcm5hbF9lbmRTY2FsZVRpbWUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3RvdWNoRW5kRXZlbnQoKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vdXNlVXBFdmVudCgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VEb3VibGVDbGlja0V2ZW50KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKS5oYW5kbGVTY2FsZS5heGlzRG91YmxlQ2xpY2tSZXNldC50aW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcmVzZXRUaW1lU2NhbGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfZG91YmxlVGFwRXZlbnQoKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vdXNlRG91YmxlQ2xpY2tFdmVudCgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VFbnRlckV2ZW50KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX29wdGlvbnMoKS5oYW5kbGVTY2FsZS5heGlzUHJlc3NlZE1vdXNlTW92ZS50aW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDdXJzb3IoMSAvKiBDdXJzb3JUeXBlLkV3UmVzaXplICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VMZWF2ZUV2ZW50KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDdXJzb3IoMCAvKiBDdXJzb3JUeXBlLkRlZmF1bHQgKi8pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3NpemU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zaXplQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3NpemVDaGFuZ2VkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0U2l6ZXModGltZUF4aXNTaXplLCBsZWZ0U3R1YldpZHRoLCByaWdodFN0dWJXaWR0aCkge1xuICAgICAgICBpZiAoIWVxdWFsU2l6ZXModGhpcy5fcHJpdmF0ZV9fc2l6ZSwgdGltZUF4aXNTaXplKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZSA9IHRpbWVBeGlzU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5yZXNpemVDYW52YXNFbGVtZW50KHRpbWVBeGlzU2l6ZSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLnJlc2l6ZUNhbnZhc0VsZW1lbnQodGltZUF4aXNTaXplKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUud2lkdGggPSBgJHt0aW1lQXhpc1NpemUud2lkdGh9cHhgO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5oZWlnaHQgPSBgJHt0aW1lQXhpc1NpemUuaGVpZ2h0fXB4YDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3NpemVDaGFuZ2VkLl9pbnRlcm5hbF9maXJlKHRpbWVBeGlzU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0U3R1Yi5faW50ZXJuYWxfc2V0U2l6ZShzaXplJDEoeyB3aWR0aDogbGVmdFN0dWJXaWR0aCwgaGVpZ2h0OiB0aW1lQXhpc1NpemUuaGVpZ2h0IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFN0dWIuX2ludGVybmFsX3NldFNpemUoc2l6ZSQxKHsgd2lkdGg6IHJpZ2h0U3R1YldpZHRoLCBoZWlnaHQ6IHRpbWVBeGlzU2l6ZS5oZWlnaHQgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcHRpbWFsSGVpZ2h0KCkge1xuICAgICAgICBjb25zdCByZW5kZXJlck9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19nZXRSZW5kZXJlck9wdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChcbiAgICAgICAgLy8gcmVuZGVyZXJPcHRpb25zLm9mZnNldFNpemUgK1xuICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2JvcmRlclNpemUgK1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoICtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udFNpemUgK1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nVG9wICtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0JvdHRvbSArXG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2xhYmVsQm90dG9tT2Zmc2V0KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSgpIHtcbiAgICAgICAgLy8gdGhpcyBjYWxsIGhhcyBzaWRlLWVmZmVjdCAtIGl0IHJlZ2VuZXJhdGVzIG1hcmtzIG9uIHRoZSB0aW1lIHNjYWxlXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfbWFya3MoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldEJpdG1hcFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmJpdG1hcFNpemU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3Qml0bWFwKGN0eCwgeCwgeSkge1xuICAgICAgICBjb25zdCBiaXRtYXBTaXplID0gdGhpcy5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpO1xuICAgICAgICBpZiAoYml0bWFwU2l6ZS53aWR0aCA+IDAgJiYgYml0bWFwU2l6ZS5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3BhaW50KHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IDAgLyogSW52YWxpZGF0aW9uTGV2ZWwuTm9uZSAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICE9PSAxIC8qIEludmFsaWRhdGlvbkxldmVsLkN1cnNvciAqLykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5hcHBseVN1Z2dlc3RlZEJpdG1hcFNpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRyeUNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJEKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC51c2VCaXRtYXBDb29yZGluYXRlU3BhY2UoKHNjb3BlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdCYWNrZ3JvdW5kKHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0JvcmRlcihzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdBZGRpdGlvbmFsU291cmNlcyh0YXJnZXQsIHNvdXJjZUJvdHRvbVBhbmVWaWV3cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1RpY2tNYXJrcyh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdBZGRpdGlvbmFsU291cmNlcyh0YXJnZXQsIHNvdXJjZVBhbmVWaWV3cyk7XG4gICAgICAgICAgICAgICAgLy8gYXRtIHdlIGRvbid0IGhhdmUgc291cmNlcyB0byBiZSBkcmF3biBvbiB0aW1lIGF4aXMgZXhjZXB0IGNyb3NzaGFpciB3aGljaCBpcyByZW5kZXJlZCBvbiB0b3AgbGV2ZWwgY2FudmFzXG4gICAgICAgICAgICAgICAgLy8gc28gbGV0J3MgZG9uJ3QgY2FsbCB0aGlzIGNvZGUgYXQgYWxsIGZvciBub3dcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9kcmF3TGFiZWxzKHRoaXMuX2NoYXJ0Lm1vZGVsKCkuZGF0YVNvdXJjZXMoKSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sZWZ0U3R1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViLl9pbnRlcm5hbF9wYWludCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19yaWdodFN0dWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFN0dWIuX2ludGVybmFsX3BhaW50KHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuYXBwbHlTdWdnZXN0ZWRCaXRtYXBTaXplKCk7XG4gICAgICAgIGNvbnN0IHRvcFRhcmdldCA9IHRyeUNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJEKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcpO1xuICAgICAgICBpZiAodG9wVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BUYXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKCh7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBiaXRtYXBTaXplLndpZHRoLCBiaXRtYXBTaXplLmhlaWdodCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdMYWJlbHMoWy4uLnRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9zZXJpZXNlcygpLCB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfY3Jvc3NoYWlyU291cmNlKCldLCB0b3BUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0FkZGl0aW9uYWxTb3VyY2VzKHRvcFRhcmdldCwgc291cmNlVG9wUGFuZVZpZXdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0FkZGl0aW9uYWxTb3VyY2VzKHRhcmdldCwgYXhpc1ZpZXdzR2V0dGVyKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfc2VyaWVzZXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICAgICAgZHJhd1NvdXJjZVBhbmVWaWV3cyhheGlzVmlld3NHZXR0ZXIsIChyZW5kZXJlcikgPT4gZHJhd0JhY2tncm91bmQocmVuZGVyZXIsIHRhcmdldCwgZmFsc2UsIHVuZGVmaW5lZCksIHNvdXJjZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgICAgICBkcmF3U291cmNlUGFuZVZpZXdzKGF4aXNWaWV3c0dldHRlciwgKHJlbmRlcmVyKSA9PiBkcmF3Rm9yZWdyb3VuZChyZW5kZXJlciwgdGFyZ2V0LCBmYWxzZSwgdW5kZWZpbmVkKSwgc291cmNlLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3QmFja2dyb3VuZCh7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSB9KSB7XG4gICAgICAgIGNsZWFyUmVjdChjdHgsIDAsIDAsIGJpdG1hcFNpemUud2lkdGgsIGJpdG1hcFNpemUuaGVpZ2h0LCB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfYmFja2dyb3VuZEJvdHRvbUNvbG9yKCkpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0JvcmRlcih7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSwgdmVydGljYWxQaXhlbFJhdGlvIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKCkudGltZVNjYWxlLmJvcmRlclZpc2libGUpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9wcml2YXRlX19saW5lQ29sb3IoKTtcbiAgICAgICAgICAgIGNvbnN0IGJvcmRlclNpemUgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHRoaXMuX3ByaXZhdGVfX2dldFJlbmRlcmVyT3B0aW9ucygpLl9pbnRlcm5hbF9ib3JkZXJTaXplICogdmVydGljYWxQaXhlbFJhdGlvKSk7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgYml0bWFwU2l6ZS53aWR0aCwgYm9yZGVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdUaWNrTWFya3ModGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF90aW1lU2NhbGUoKTtcbiAgICAgICAgY29uc3QgdGlja01hcmtzID0gdGltZVNjYWxlLl9pbnRlcm5hbF9tYXJrcygpO1xuICAgICAgICBpZiAoIXRpY2tNYXJrcyB8fCB0aWNrTWFya3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4V2VpZ2h0ID0gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IubWF4VGlja01hcmtXZWlnaHQodGlja01hcmtzKTtcbiAgICAgICAgY29uc3QgcmVuZGVyZXJPcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fZ2V0UmVuZGVyZXJPcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aW1lU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYm9yZGVyVmlzaWJsZSAmJiBvcHRpb25zLnRpY2tzVmlzaWJsZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSgoeyBjb250ZXh0OiBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuX3ByaXZhdGVfX2xpbmVDb2xvcigpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9wcml2YXRlX19saW5lQ29sb3IoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrV2lkdGggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGhvcml6b250YWxQaXhlbFJhdGlvKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja09mZnNldCA9IE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8gKiAwLjUpO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrTGVuID0gTWF0aC5yb3VuZChyZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3RpY2tMZW5ndGggKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gdGlja01hcmtzLmxlbmd0aDsgaW5kZXgtLTspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQodGlja01hcmtzW2luZGV4XS5jb29yZCAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoeCAtIHRpY2tPZmZzZXQsIDAsIHRpY2tXaWR0aCwgdGlja0xlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQudXNlTWVkaWFDb29yZGluYXRlU3BhY2UoKHsgY29udGV4dDogY3R4IH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHlUZXh0ID0gKHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfYm9yZGVyU2l6ZSArXG4gICAgICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoICtcbiAgICAgICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdUb3AgK1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udFNpemUgLyAyKTtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9wcml2YXRlX190ZXh0Q29sb3IoKTtcbiAgICAgICAgICAgIC8vIGRyYXcgYmFzZSBtYXJrc1xuICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLl9wcml2YXRlX19iYXNlRm9udCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0aWNrTWFyayBvZiB0aWNrTWFya3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodGlja01hcmsud2VpZ2h0IDwgbWF4V2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB0aWNrTWFyay5uZWVkQWxpZ25Db29yZGluYXRlID8gdGhpcy5fcHJpdmF0ZV9fYWxpZ25UaWNrTWFya0xhYmVsQ29vcmRpbmF0ZShjdHgsIHRpY2tNYXJrLmNvb3JkLCB0aWNrTWFyay5sYWJlbCkgOiB0aWNrTWFyay5jb29yZDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRpY2tNYXJrLmxhYmVsLCBjb29yZGluYXRlLCB5VGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLl9wcml2YXRlX19iYXNlQm9sZEZvbnQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGlja01hcmsgb2YgdGlja01hcmtzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpY2tNYXJrLndlaWdodCA+PSBtYXhXZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZSA9IHRpY2tNYXJrLm5lZWRBbGlnbkNvb3JkaW5hdGUgPyB0aGlzLl9wcml2YXRlX19hbGlnblRpY2tNYXJrTGFiZWxDb29yZGluYXRlKGN0eCwgdGlja01hcmsuY29vcmQsIHRpY2tNYXJrLmxhYmVsKSA6IHRpY2tNYXJrLmNvb3JkO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGlja01hcmsubGFiZWwsIGNvb3JkaW5hdGUsIHlUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fYWxpZ25UaWNrTWFya0xhYmVsQ29vcmRpbmF0ZShjdHgsIGNvb3JkaW5hdGUsIGxhYmVsVGV4dCkge1xuICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGhpcy5fcHJpdmF0ZV9fd2lkdGhDYWNoZS5faW50ZXJuYWxfbWVhc3VyZVRleHQoY3R4LCBsYWJlbFRleHQpO1xuICAgICAgICBjb25zdCBsYWJlbFdpZHRoSGFsZiA9IGxhYmVsV2lkdGggLyAyO1xuICAgICAgICBjb25zdCBsZWZ0VGV4dENvb3JkaW5hdGUgPSBNYXRoLmZsb29yKGNvb3JkaW5hdGUgLSBsYWJlbFdpZHRoSGFsZikgKyAwLjU7XG4gICAgICAgIGlmIChsZWZ0VGV4dENvb3JkaW5hdGUgPCAwKSB7XG4gICAgICAgICAgICBjb29yZGluYXRlID0gY29vcmRpbmF0ZSArIE1hdGguYWJzKDAgLSBsZWZ0VGV4dENvb3JkaW5hdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlZnRUZXh0Q29vcmRpbmF0ZSArIGxhYmVsV2lkdGggPiB0aGlzLl9wcml2YXRlX19zaXplLndpZHRoKSB7XG4gICAgICAgICAgICBjb29yZGluYXRlID0gY29vcmRpbmF0ZSAtIE1hdGguYWJzKHRoaXMuX3ByaXZhdGVfX3NpemUud2lkdGggLSAobGVmdFRleHRDb29yZGluYXRlICsgbGFiZWxXaWR0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0xhYmVscyhzb3VyY2VzLCB0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXJPcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fZ2V0UmVuZGVyZXJPcHRpb25zKCk7XG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmlldyBvZiBzb3VyY2UuX2ludGVybmFsX3RpbWVBeGlzVmlld3MoKSkge1xuICAgICAgICAgICAgICAgIHZpZXcuX2ludGVybmFsX3JlbmRlcmVyKCkuX2ludGVybmFsX2RyYXcodGFyZ2V0LCByZW5kZXJlck9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19saW5lQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpLnRpbWVTY2FsZS5ib3JkZXJDb2xvcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3RleHRDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudGV4dENvbG9yO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZm9udFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmZvbnRTaXplO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fYmFzZUZvbnQoKSB7XG4gICAgICAgIHJldHVybiBtYWtlRm9udCh0aGlzLl9wcml2YXRlX19mb250U2l6ZSgpLCB0aGlzLl9wcml2YXRlX19vcHRpb25zLmZvbnRGYW1pbHkpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fYmFzZUJvbGRGb250KCkge1xuICAgICAgICByZXR1cm4gbWFrZUZvbnQodGhpcy5fcHJpdmF0ZV9fZm9udFNpemUoKSwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5mb250RmFtaWx5LCAnYm9sZCcpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZ2V0UmVuZGVyZXJPcHRpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2JvcmRlclNpemU6IDEgLyogQ29uc3RhbnRzLkJvcmRlclNpemUgKi8sXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2Jhc2VsaW5lT2Zmc2V0OiBOYU4sXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3BhZGRpbmdUb3A6IE5hTixcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfcGFkZGluZ0JvdHRvbTogTmFOLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9wYWRkaW5nSG9yaXpvbnRhbDogTmFOLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90aWNrTGVuZ3RoOiA1IC8qIENvbnN0YW50cy5UaWNrTGVuZ3RoICovLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9mb250U2l6ZTogTmFOLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9mb250OiAnJyxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfd2lkdGhDYWNoZTogbmV3IFRleHRXaWR0aENhY2hlKCksXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2xhYmVsQm90dG9tT2Zmc2V0OiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW5kZXJlck9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG5ld0ZvbnQgPSB0aGlzLl9wcml2YXRlX19iYXNlRm9udCgpO1xuICAgICAgICBpZiAocmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250ICE9PSBuZXdGb250KSB7XG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuX3ByaXZhdGVfX2ZvbnRTaXplKCk7XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2ZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2ZvbnQgPSBuZXdGb250O1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nVG9wID0gMyAqIGZvbnRTaXplIC8gMTI7XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdCb3R0b20gPSAzICogZm9udFNpemUgLyAxMjtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0hvcml6b250YWwgPSA5ICogZm9udFNpemUgLyAxMjtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfYmFzZWxpbmVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9sYWJlbEJvdHRvbU9mZnNldCA9IDQgKiBmb250U2l6ZSAvIDEyO1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF93aWR0aENhY2hlLl9pbnRlcm5hbF9yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnM7XG4gICAgfVxuICAgIF9wcml2YXRlX19zZXRDdXJzb3IodHlwZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLmN1cnNvciA9IHR5cGUgPT09IDEgLyogQ3Vyc29yVHlwZS5Fd1Jlc2l6ZSAqLyA/ICdldy1yZXNpemUnIDogJ2RlZmF1bHQnO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcmVjcmVhdGVTdHVicygpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1vZGVsLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIGlmICghb3B0aW9ucy5sZWZ0UHJpY2VTY2FsZS52aXNpYmxlICYmIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0U3R1YkNlbGwucmVtb3ZlQ2hpbGQodGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWIuX2ludGVybmFsX2dldEVsZW1lbnQoKSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0U3R1Yi5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5yaWdodFByaWNlU2NhbGUudmlzaWJsZSAmJiB0aGlzLl9wcml2YXRlX19yaWdodFN0dWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1YkNlbGwucmVtb3ZlQ2hpbGQodGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViLl9pbnRlcm5hbF9nZXRFbGVtZW50KCkpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFN0dWIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyKCk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9yZW5kZXJlck9wdGlvbnNQcm92aWRlcjogcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJvcmRlclZpc2libGVHZXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5sZWZ0UHJpY2VTY2FsZS5ib3JkZXJWaXNpYmxlICYmIG1vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfb3B0aW9ucygpLmJvcmRlclZpc2libGU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJvdHRvbUNvbG9yR2V0dGVyID0gKCkgPT4gbW9kZWwuX2ludGVybmFsX2JhY2tncm91bmRCb3R0b21Db2xvcigpO1xuICAgICAgICBpZiAob3B0aW9ucy5sZWZ0UHJpY2VTY2FsZS52aXNpYmxlICYmIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0U3R1YiA9IG5ldyBQcmljZUF4aXNTdHViKCdsZWZ0Jywgb3B0aW9ucywgcGFyYW1zLCBib3JkZXJWaXNpYmxlR2V0dGVyLCBib3R0b21Db2xvckdldHRlcik7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0U3R1YkNlbGwuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWIuX2ludGVybmFsX2dldEVsZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucmlnaHRQcmljZVNjYWxlLnZpc2libGUgJiYgdGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFN0dWIgPSBuZXcgUHJpY2VBeGlzU3R1YigncmlnaHQnLCBvcHRpb25zLCBwYXJhbXMsIGJvcmRlclZpc2libGVHZXR0ZXIsIGJvdHRvbUNvbG9yR2V0dGVyKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1YkNlbGwuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViLl9pbnRlcm5hbF9nZXRFbGVtZW50KCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCB3aW5kb3dzQ2hyb21lID0gaXNDaHJvbWl1bUJhc2VkKCkgJiYgaXNXaW5kb3dzKCk7XG5jbGFzcyBDaGFydFdpZGdldCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBvcHRpb25zLCBob3J6U2NhbGVCZWhhdmlvcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3UmFmSWQgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX193aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzayA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdQbGFubmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vYnNlcnZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2N1cnNvclN0eWxlT3ZlcnJpZGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvciA9IGhvcnpTY2FsZUJlaGF2aW9yO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQuY2xhc3NMaXN0LmFkZCgndHYtbGlnaHR3ZWlnaHQtY2hhcnRzJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5zdHlsZS5kaXJlY3Rpb24gPSAnbHRyJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIGRpc2FibGVTZWxlY3Rpb24odGhpcy5fcHJpdmF0ZV9fZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NlbGxzcGFjaW5nJywgJzAnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9wcml2YXRlX190YWJsZUVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbldoZWVsQm91bmQgPSB0aGlzLl9wcml2YXRlX19vbk1vdXNld2hlZWwuYmluZCh0aGlzKTtcbiAgICAgICAgaWYgKHNob3VsZFN1YnNjcmliZU1vdXNlV2hlZWwodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldE1vdXNlV2hlZWxFdmVudExpc3RlbmVyKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsID0gbmV3IENoYXJ0TW9kZWwodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZUhhbmRsZXIuYmluZCh0aGlzKSwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucywgaG9yelNjYWxlQmVoYXZpb3IpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9jcm9zc2hhaXJNb3ZlZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUodGhpcy5fcHJpdmF0ZV9fb25QYW5lV2lkZ2V0Q3Jvc3NoYWlyTW92ZWQuYmluZCh0aGlzKSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0ID0gbmV3IFRpbWVBeGlzV2lkZ2V0KHRoaXMsIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFibGVFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9nZXRFbGVtZW50KCkpO1xuICAgICAgICBjb25zdCB1c2VkT2JzZXJ2ZXIgPSBvcHRpb25zLmF1dG9TaXplICYmIHRoaXMuX3ByaXZhdGVfX2luc3RhbGxPYnNlcnZlcigpO1xuICAgICAgICAvLyBvYnNlcnZlciBjb3VsZCBub3QgZmlyZSBldmVudCBpbW1lZGlhdGVseSBmb3Igc29tZSBjYXNlc1xuICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIHNldCBpbml0aWFsIHNpemUgbWFudWFsbHlcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy53aWR0aDtcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuaGVpZ2h0O1xuICAgICAgICAvLyBpZ25vcmUgd2lkdGgvaGVpZ2h0IG9wdGlvbnMgaWYgb2JzZXJ2ZXIgaGFzIGFjdHVhbGx5IGJlZW4gdXNlZFxuICAgICAgICAvLyBob3dldmVyIHJlc3BlY3Qgb3B0aW9ucyBpZiBpbnN0YWxsaW5nIHJlc2l6ZSBvYnNlcnZlciBmYWlsZWRcbiAgICAgICAgaWYgKHVzZWRPYnNlcnZlciB8fCB3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IGNvbnRhaW5lclJlY3Qud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgY29udGFpbmVyUmVjdC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQkVXQVJFOiByZXNpemUgbXVzdCBiZSBjYWxsZWQgQkVGT1JFIF9zeW5jR3VpV2l0aE1vZGVsIChpbiBjb25zdHJ1Y3RvciBvbmx5KVxuICAgICAgICAvLyBvciBhZnRlciBidXQgd2l0aCBhZGp1c3RTaXplIHRvIHByb3Blcmx5IHVwZGF0ZSB0aW1lIHNjYWxlXG4gICAgICAgIHRoaXMuX2ludGVybmFsX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3luY0d1aVdpdGhNb2RlbCgpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZVRpbWVBeGlzVmlzaWJpbGl0eSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX29wdGlvbnNBcHBsaWVkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfZnVsbFVwZGF0ZS5iaW5kKHRoaXMuX3ByaXZhdGVfX21vZGVsKSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9wcmljZVNjYWxlc09wdGlvbnNDaGFuZ2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfZnVsbFVwZGF0ZS5iaW5kKHRoaXMuX3ByaXZhdGVfX21vZGVsKSwgdGhpcyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb2RlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX21vZGVsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYW5lV2lkZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGltZUF4aXNXaWRnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldDtcbiAgICB9XG4gICAgX2ludGVybmFsX2Rlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldE1vdXNlV2hlZWxFdmVudExpc3RlbmVyKGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RyYXdSYWZJZCAhPT0gMCkge1xuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3ByaXZhdGVfX2RyYXdSYWZJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2Nyb3NzaGFpck1vdmVkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX29wdGlvbnNBcHBsaWVkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfcHJpY2VTY2FsZXNPcHRpb25zQ2hhbmdlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgZm9yIChjb25zdCBwYW5lV2lkZ2V0IG9mIHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190YWJsZUVsZW1lbnQucmVtb3ZlQ2hpbGQocGFuZVdpZGdldC5faW50ZXJuYWxfZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX2NsaWNrZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9kYmxDbGlja2VkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICAgICAgcGFuZVdpZGdldC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzID0gW107XG4gICAgICAgIC8vIGZvciAoY29uc3QgcGFuZVNlcGFyYXRvciBvZiB0aGlzLl9wYW5lU2VwYXJhdG9ycykge1xuICAgICAgICAvLyBcdHRoaXMuX2Rlc3Ryb3lTZXBhcmF0b3IocGFuZVNlcGFyYXRvcik7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gdGhpcy5fcGFuZVNlcGFyYXRvcnMgPSBbXTtcbiAgICAgICAgZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldCkuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQucGFyZW50RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrZWQuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191bmluc3RhbGxPYnNlcnZlcigpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVzaXplKHdpZHRoLCBoZWlnaHQsIGZvcmNlUmVwYWludCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19oZWlnaHQgPT09IGhlaWdodCAmJiB0aGlzLl9wcml2YXRlX193aWR0aCA9PT0gd2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplSGludCA9IHN1Z2dlc3RDaGFydFNpemUoc2l6ZSQxKHsgd2lkdGgsIGhlaWdodCB9KSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hlaWdodCA9IHNpemVIaW50LmhlaWdodDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fd2lkdGggPSBzaXplSGludC53aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0U3RyID0gdGhpcy5fcHJpdmF0ZV9faGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgY29uc3Qgd2lkdGhTdHIgPSB0aGlzLl9wcml2YXRlX193aWR0aCArICdweCc7XG4gICAgICAgIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fZWxlbWVudCkuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0U3RyO1xuICAgICAgICBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQpLnN0eWxlLndpZHRoID0gd2lkdGhTdHI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHRTdHI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoU3RyO1xuICAgICAgICBpZiAoZm9yY2VSZXBhaW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3SW1wbChJbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfZnVsbCgpLCBwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYWludChpbnZhbGlkYXRlTWFzaykge1xuICAgICAgICBpZiAoaW52YWxpZGF0ZU1hc2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW52YWxpZGF0ZU1hc2sgPSBJbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfZnVsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzW2ldLl9pbnRlcm5hbF9wYWludChpbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfaW52YWxpZGF0ZUZvclBhbmUoaSkuX2ludGVybmFsX2xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy50aW1lU2NhbGUudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX3BhaW50KGludmFsaWRhdGVNYXNrLl9pbnRlcm5hbF9mdWxsSW52YWxpZGF0aW9uKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBjdXJyZW50bHlIYXNNb3VzZVdoZWVsTGlzdGVuZXIgPSBzaG91bGRTdWJzY3JpYmVNb3VzZVdoZWVsKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMpO1xuICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIG1lcmdlIG9wdGlvbnMgaGVyZSBiZWNhdXNlIGl0J3MgZG9uZSBpbiBjaGFydCBtb2RlbFxuICAgICAgICAvLyBhbmQgc2luY2UgYm90aCBtb2RlbCBhbmQgd2lkZ2V0IHNoYXJlIHRoZSBzYW1lIG9iamVjdCBpdCB3aWxsIGJlIGRvbmUgYXV0b21hdGljYWxseSBmb3Igd2lkZ2V0IGFzIHdlbGxcbiAgICAgICAgLy8gbm90IGlkZWFsIHNvbHV0aW9uIGZvciBzdXJlLCBidXQgaXQgd29yaydzIGZvciBub3cgwq9cXF8o44OEKV8vwq9cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2FwcGx5T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc2hvdWxkSGF2ZU1vdXNlV2hlZWxMaXN0ZW5lciA9IHNob3VsZFN1YnNjcmliZU1vdXNlV2hlZWwodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyk7XG4gICAgICAgIGlmIChzaG91bGRIYXZlTW91c2VXaGVlbExpc3RlbmVyICE9PSBjdXJyZW50bHlIYXNNb3VzZVdoZWVsTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldE1vdXNlV2hlZWxFdmVudExpc3RlbmVyKHNob3VsZEhhdmVNb3VzZVdoZWVsTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZVRpbWVBeGlzVmlzaWJpbGl0eSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hcHBseUF1dG9TaXplT3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2NsaWNrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jbGlja2VkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGJsQ2xpY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2RibENsaWNrZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jcm9zc2hhaXJNb3ZlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGFrZVNjcmVlbnNob3QoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0ltcGwodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2ssIHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3JlZXNob3RCaXRtYXBTaXplID0gdGhpcy5fcHJpdmF0ZV9fdHJhdmVyc2VMYXlvdXQobnVsbCk7XG4gICAgICAgIGNvbnN0IHNjcmVlbnNob3RDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgc2NyZWVuc2hvdENhbnZhcy53aWR0aCA9IHNjcmVlc2hvdEJpdG1hcFNpemUud2lkdGg7XG4gICAgICAgIHNjcmVlbnNob3RDYW52YXMuaGVpZ2h0ID0gc2NyZWVzaG90Qml0bWFwU2l6ZS5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGN0eCA9IGVuc3VyZU5vdE51bGwoc2NyZWVuc2hvdENhbnZhcy5nZXRDb250ZXh0KCcyZCcpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdHJhdmVyc2VMYXlvdXQoY3R4KTtcbiAgICAgICAgcmV0dXJuIHNjcmVlbnNob3RDYW52YXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRQcmljZUF4aXNXaWR0aChwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyAmJiAhdGhpcy5fcHJpdmF0ZV9faXNMZWZ0QXhpc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnICYmICF0aGlzLl9wcml2YXRlX19pc1JpZ2h0QXhpc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBleGFjdGx5IHBhbmUgd2lkZ2V0IGhlcmVcbiAgICAgICAgLy8gYmVjYXVzZSBhbGwgcGFuZSB3aWRnZXRzIGhhdmUgdGhlIHNhbWUgd2lkdGggb2YgcHJpY2UgYXhpcyB3aWRnZXRcbiAgICAgICAgLy8gc2VlIF9hZGp1c3RTaXplSW1wbFxuICAgICAgICBjb25zdCBwcmljZUF4aXNXaWRnZXQgPSBwb3NpdGlvbiA9PT0gJ2xlZnQnXG4gICAgICAgICAgICA/IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzWzBdLl9pbnRlcm5hbF9sZWZ0UHJpY2VBeGlzV2lkZ2V0KClcbiAgICAgICAgICAgIDogdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHNbMF0uX2ludGVybmFsX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0KCk7XG4gICAgICAgIHJldHVybiBlbnN1cmVOb3ROdWxsKHByaWNlQXhpc1dpZGdldCkuX2ludGVybmFsX2dldFdpZHRoKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hdXRvU2l6ZUFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuYXV0b1NpemUgJiYgdGhpcy5fcHJpdmF0ZV9fb2JzZXJ2ZXIgIT09IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9lbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZWxlbWVudDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldEN1cnNvclN0eWxlKHN0eWxlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2N1cnNvclN0eWxlT3ZlcnJpZGUgPSBzdHlsZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2N1cnNvclN0eWxlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2VsZW1lbnQoKS5zdHlsZS5zZXRQcm9wZXJ0eSgnY3Vyc29yJywgc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfZWxlbWVudCgpLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdjdXJzb3InKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0Q3Vyc29yT3ZlcnJpZGVTdHlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2N1cnNvclN0eWxlT3ZlcnJpZGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYW5lU2l6ZSgpIHtcbiAgICAgICAgLy8gd2UgY3VycmVudGx5IG9ubHkgc3VwcG9ydCBhIHNpbmdsZSBwYW5lLlxuICAgICAgICByZXR1cm4gZW5zdXJlRGVmaW5lZCh0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0c1swXSkuX2ludGVybmFsX2dldFNpemUoKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBfcHJpdmF0ZV9fYXBwbHlBdXRvU2l6ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5hdXRvU2l6ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX3ByaXZhdGVfX29ic2VydmVyICYmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYFlvdSBzaG91bGQgdHVybiBhdXRvU2l6ZSBvZmYgZXhwbGljaXRseSBiZWZvcmUgc3BlY2lmeWluZyBzaXplczsgdHJ5IGFkZGluZyBvcHRpb25zLmF1dG9TaXplOiBmYWxzZSB0byBuZXcgb3B0aW9uc2ApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9TaXplICYmICF0aGlzLl9wcml2YXRlX19vYnNlcnZlcikge1xuICAgICAgICAgICAgLy8gaW5zdGFsbGluZyBvYnNlcnZlciB3aWxsIG92ZXJyaWRlIHJlc2l6ZSBpZiBzdWNjZXNzZnVsXG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnN0YWxsT2JzZXJ2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hdXRvU2l6ZSA9PT0gZmFsc2UgJiYgdGhpcy5fcHJpdmF0ZV9fb2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3VuaW5zdGFsbE9ic2VydmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLmF1dG9TaXplICYmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3Jlc2l6ZShvcHRpb25zLndpZHRoIHx8IHRoaXMuX3ByaXZhdGVfX3dpZHRoLCBvcHRpb25zLmhlaWdodCB8fCB0aGlzLl9wcml2YXRlX19oZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlcyB0aGUgd2lkZ2V0J3MgbGF5b3V0IChwYW5lIGFuZCBheGlzIGNoaWxkIHdpZGdldHMpLFxuICAgICAqIGRyYXdzIHRoZSBzY3JlZW5zaG90IChpZiByZW5kZXJpbmcgY29udGV4dCBpcyBwYXNzZWQpIGFuZCByZXR1cm5zIHRoZSBzY3JlZW5zaG90IGJpdG1hcCBzaXplXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3R4IC0gaWYgcGFzc2VkLCB1c2VkIHRvIGRyYXcgdGhlIHNjcmVlbnNob3Qgb2Ygd2lkZ2V0XG4gICAgICogQHJldHVybnMgc2NyZWVuc2hvdCBiaXRtYXAgc2l6ZVxuICAgICAqL1xuICAgIF9wcml2YXRlX190cmF2ZXJzZUxheW91dChjdHgpIHtcbiAgICAgICAgbGV0IHRvdGFsV2lkdGggPSAwO1xuICAgICAgICBsZXQgdG90YWxIZWlnaHQgPSAwO1xuICAgICAgICBjb25zdCBmaXJzdFBhbmUgPSB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0c1swXTtcbiAgICAgICAgY29uc3QgZHJhd1ByaWNlQXhpc2VzID0gKHBvc2l0aW9uLCB0YXJnZXRYKSA9PiB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0WSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBwYW5lSW5kZXggPSAwOyBwYW5lSW5kZXggPCB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cy5sZW5ndGg7IHBhbmVJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFuZVdpZGdldCA9IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzW3BhbmVJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpY2VBeGlzV2lkZ2V0ID0gZW5zdXJlTm90TnVsbChwb3NpdGlvbiA9PT0gJ2xlZnQnID8gcGFuZVdpZGdldC5faW50ZXJuYWxfbGVmdFByaWNlQXhpc1dpZGdldCgpIDogcGFuZVdpZGdldC5faW50ZXJuYWxfcmlnaHRQcmljZUF4aXNXaWRnZXQoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYml0bWFwU2l6ZSA9IHByaWNlQXhpc1dpZGdldC5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9kcmF3Qml0bWFwKGN0eCwgdGFyZ2V0WCwgdGFyZ2V0WSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldFkgKz0gYml0bWFwU2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy8gaWYgKHBhbmVJbmRleCA8IHRoaXMuX3BhbmVXaWRnZXRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAvLyBcdGNvbnN0IHNlcGFyYXRvciA9IHRoaXMuX3BhbmVTZXBhcmF0b3JzW3BhbmVJbmRleF07XG4gICAgICAgICAgICAgICAgLy8gXHRjb25zdCBzZXBhcmF0b3JCaXRtYXBTaXplID0gc2VwYXJhdG9yLmdldEJpdG1hcFNpemUoKTtcbiAgICAgICAgICAgICAgICAvLyBcdGlmIChjdHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBcdFx0c2VwYXJhdG9yLmRyYXdCaXRtYXAoY3R4LCB0YXJnZXRYLCB0YXJnZXRZKTtcbiAgICAgICAgICAgICAgICAvLyBcdH1cbiAgICAgICAgICAgICAgICAvLyBcdHRhcmdldFkgKz0gc2VwYXJhdG9yQml0bWFwU2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBkcmF3IGxlZnQgcHJpY2Ugc2NhbGUgaWYgZXhpc3RzXG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc0xlZnRBeGlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICBkcmF3UHJpY2VBeGlzZXMoJ2xlZnQnLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRBeGlzQml0bWFwV2lkdGggPSBlbnN1cmVOb3ROdWxsKGZpcnN0UGFuZS5faW50ZXJuYWxfbGVmdFByaWNlQXhpc1dpZGdldCgpKS5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpLndpZHRoO1xuICAgICAgICAgICAgdG90YWxXaWR0aCArPSBsZWZ0QXhpc0JpdG1hcFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHBhbmVJbmRleCA9IDA7IHBhbmVJbmRleCA8IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLmxlbmd0aDsgcGFuZUluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhbmVXaWRnZXQgPSB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0c1twYW5lSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgYml0bWFwU2l6ZSA9IHBhbmVXaWRnZXQuX2ludGVybmFsX2dldEJpdG1hcFNpemUoKTtcbiAgICAgICAgICAgIGlmIChjdHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9kcmF3Qml0bWFwKGN0eCwgdG90YWxXaWR0aCwgdG90YWxIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gYml0bWFwU2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBpZiAocGFuZUluZGV4IDwgdGhpcy5fcGFuZVdpZGdldHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgLy8gXHRjb25zdCBzZXBhcmF0b3IgPSB0aGlzLl9wYW5lU2VwYXJhdG9yc1twYW5lSW5kZXhdO1xuICAgICAgICAgICAgLy8gXHRjb25zdCBzZXBhcmF0b3JCaXRtYXBTaXplID0gc2VwYXJhdG9yLmdldEJpdG1hcFNpemUoKTtcbiAgICAgICAgICAgIC8vIFx0aWYgKGN0eCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gXHRcdHNlcGFyYXRvci5kcmF3Qml0bWFwKGN0eCwgdG90YWxXaWR0aCwgdG90YWxIZWlnaHQpO1xuICAgICAgICAgICAgLy8gXHR9XG4gICAgICAgICAgICAvLyBcdHRvdGFsSGVpZ2h0ICs9IHNlcGFyYXRvckJpdG1hcFNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0UGFuZUJpdG1hcFdpZHRoID0gZmlyc3RQYW5lLl9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCkud2lkdGg7XG4gICAgICAgIHRvdGFsV2lkdGggKz0gZmlyc3RQYW5lQml0bWFwV2lkdGg7XG4gICAgICAgIC8vIGRyYXcgcmlnaHQgcHJpY2Ugc2NhbGUgaWYgZXhpc3RzXG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc1JpZ2h0QXhpc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgZHJhd1ByaWNlQXhpc2VzKCdyaWdodCcsIHRvdGFsV2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgcmlnaHRBeGlzQml0bWFwV2lkdGggPSBlbnN1cmVOb3ROdWxsKGZpcnN0UGFuZS5faW50ZXJuYWxfcmlnaHRQcmljZUF4aXNXaWRnZXQoKSkuX2ludGVybmFsX2dldEJpdG1hcFNpemUoKS53aWR0aDtcbiAgICAgICAgICAgIHRvdGFsV2lkdGggKz0gcmlnaHRBeGlzQml0bWFwV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHJhd1N0dWIgPSAocG9zaXRpb24sIHRhcmdldFgsIHRhcmdldFkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0dWIgPSBlbnN1cmVOb3ROdWxsKHBvc2l0aW9uID09PSAnbGVmdCcgPyB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldC5faW50ZXJuYWxfbGVmdFN0dWIoKSA6IHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9yaWdodFN0dWIoKSk7XG4gICAgICAgICAgICBzdHViLl9pbnRlcm5hbF9kcmF3Qml0bWFwKGVuc3VyZU5vdE51bGwoY3R4KSwgdGFyZ2V0WCwgdGFyZ2V0WSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRyYXcgdGltZSBzY2FsZSBhbmQgc3R1YnNcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudGltZVNjYWxlLnZpc2libGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVBeGlzQml0bWFwU2l6ZSA9IHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCk7XG4gICAgICAgICAgICBpZiAoY3R4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldFggPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc0xlZnRBeGlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdTdHViKCdsZWZ0JywgdGFyZ2V0WCwgdG90YWxIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRYID0gZW5zdXJlTm90TnVsbChmaXJzdFBhbmUuX2ludGVybmFsX2xlZnRQcmljZUF4aXNXaWRnZXQoKSkuX2ludGVybmFsX2dldEJpdG1hcFNpemUoKS53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX2RyYXdCaXRtYXAoY3R4LCB0YXJnZXRYLCB0b3RhbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0WCArPSB0aW1lQXhpc0JpdG1hcFNpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2lzUmlnaHRBeGlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdTdHViKCdyaWdodCcsIHRhcmdldFgsIHRvdGFsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3RhbEhlaWdodCArPSB0aW1lQXhpc0JpdG1hcFNpemUuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplJDEoe1xuICAgICAgICAgICAgd2lkdGg6IHRvdGFsV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRvdGFsSGVpZ2h0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBfcHJpdmF0ZV9fYWRqdXN0U2l6ZUltcGwoKSB7XG4gICAgICAgIGxldCB0b3RhbFN0cmV0Y2ggPSAwO1xuICAgICAgICBsZXQgbGVmdFByaWNlQXhpc1dpZHRoID0gMDtcbiAgICAgICAgbGV0IHJpZ2h0UHJpY2VBeGlzV2lkdGggPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHBhbmVXaWRnZXQgb2YgdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc0xlZnRBeGlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgbGVmdFByaWNlQXhpc1dpZHRoID0gTWF0aC5tYXgobGVmdFByaWNlQXhpc1dpZHRoLCBlbnN1cmVOb3ROdWxsKHBhbmVXaWRnZXQuX2ludGVybmFsX2xlZnRQcmljZUF4aXNXaWRnZXQoKSkuX2ludGVybmFsX29wdGltYWxXaWR0aCgpLCB0aGlzLl9wcml2YXRlX19vcHRpb25zLmxlZnRQcmljZVNjYWxlLm1pbmltdW1XaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faXNSaWdodEF4aXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICByaWdodFByaWNlQXhpc1dpZHRoID0gTWF0aC5tYXgocmlnaHRQcmljZUF4aXNXaWR0aCwgZW5zdXJlTm90TnVsbChwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9yaWdodFByaWNlQXhpc1dpZGdldCgpKS5faW50ZXJuYWxfb3B0aW1hbFdpZHRoKCksIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucmlnaHRQcmljZVNjYWxlLm1pbmltdW1XaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3RhbFN0cmV0Y2ggKz0gcGFuZVdpZGdldC5faW50ZXJuYWxfc3RyZXRjaEZhY3RvcigpO1xuICAgICAgICB9XG4gICAgICAgIGxlZnRQcmljZUF4aXNXaWR0aCA9IHN1Z2dlc3RQcmljZVNjYWxlV2lkdGgobGVmdFByaWNlQXhpc1dpZHRoKTtcbiAgICAgICAgcmlnaHRQcmljZUF4aXNXaWR0aCA9IHN1Z2dlc3RQcmljZVNjYWxlV2lkdGgocmlnaHRQcmljZUF4aXNXaWR0aCk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fcHJpdmF0ZV9fd2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuX3ByaXZhdGVfX2hlaWdodDtcbiAgICAgICAgY29uc3QgcGFuZVdpZHRoID0gTWF0aC5tYXgod2lkdGggLSBsZWZ0UHJpY2VBeGlzV2lkdGggLSByaWdodFByaWNlQXhpc1dpZHRoLCAwKTtcbiAgICAgICAgLy8gY29uc3Qgc2VwYXJhdG9yQ291bnQgPSB0aGlzLl9wYW5lU2VwYXJhdG9ycy5sZW5ndGg7XG4gICAgICAgIC8vIGNvbnN0IHNlcGFyYXRvckhlaWdodCA9IFNFUEFSQVRPUl9IRUlHSFQ7XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvcnNIZWlnaHQgPSAwOyAvLyBzZXBhcmF0b3JIZWlnaHQgKiBzZXBhcmF0b3JDb3VudDtcbiAgICAgICAgY29uc3QgdGltZUF4aXNWaXNpYmxlID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy50aW1lU2NhbGUudmlzaWJsZTtcbiAgICAgICAgbGV0IHRpbWVBeGlzSGVpZ2h0ID0gdGltZUF4aXNWaXNpYmxlID8gTWF0aC5tYXgodGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX29wdGltYWxIZWlnaHQoKSwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy50aW1lU2NhbGUubWluaW11bUhlaWdodCkgOiAwO1xuICAgICAgICB0aW1lQXhpc0hlaWdodCA9IHN1Z2dlc3RUaW1lU2NhbGVIZWlnaHQodGltZUF4aXNIZWlnaHQpO1xuICAgICAgICBjb25zdCBvdGhlcldpZGdldEhlaWdodCA9IHNlcGFyYXRvcnNIZWlnaHQgKyB0aW1lQXhpc0hlaWdodDtcbiAgICAgICAgY29uc3QgdG90YWxQYW5lSGVpZ2h0ID0gaGVpZ2h0IDwgb3RoZXJXaWRnZXRIZWlnaHQgPyAwIDogaGVpZ2h0IC0gb3RoZXJXaWRnZXRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHN0cmV0Y2hQaXhlbHMgPSB0b3RhbFBhbmVIZWlnaHQgLyB0b3RhbFN0cmV0Y2g7XG4gICAgICAgIGxldCBhY2N1bXVsYXRlZEhlaWdodCA9IDA7XG4gICAgICAgIGZvciAobGV0IHBhbmVJbmRleCA9IDA7IHBhbmVJbmRleCA8IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLmxlbmd0aDsgKytwYW5lSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhbmVXaWRnZXQgPSB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0c1twYW5lSW5kZXhdO1xuICAgICAgICAgICAgcGFuZVdpZGdldC5faW50ZXJuYWxfc2V0U3RhdGUodGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3BhbmVzKClbcGFuZUluZGV4XSk7XG4gICAgICAgICAgICBsZXQgcGFuZUhlaWdodCA9IDA7XG4gICAgICAgICAgICBsZXQgY2FsY3VsYXRlUGFuZUhlaWdodCA9IDA7XG4gICAgICAgICAgICBpZiAocGFuZUluZGV4ID09PSB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlUGFuZUhlaWdodCA9IHRvdGFsUGFuZUhlaWdodCAtIGFjY3VtdWxhdGVkSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlUGFuZUhlaWdodCA9IE1hdGgucm91bmQocGFuZVdpZGdldC5faW50ZXJuYWxfc3RyZXRjaEZhY3RvcigpICogc3RyZXRjaFBpeGVscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYW5lSGVpZ2h0ID0gTWF0aC5tYXgoY2FsY3VsYXRlUGFuZUhlaWdodCwgMik7XG4gICAgICAgICAgICBhY2N1bXVsYXRlZEhlaWdodCArPSBwYW5lSGVpZ2h0O1xuICAgICAgICAgICAgcGFuZVdpZGdldC5faW50ZXJuYWxfc2V0U2l6ZShzaXplJDEoeyB3aWR0aDogcGFuZVdpZHRoLCBoZWlnaHQ6IHBhbmVIZWlnaHQgfSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2lzTGVmdEF4aXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9zZXRQcmljZUF4aXNTaXplKGxlZnRQcmljZUF4aXNXaWR0aCwgJ2xlZnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc1JpZ2h0QXhpc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX3NldFByaWNlQXhpc1NpemUocmlnaHRQcmljZUF4aXNXaWR0aCwgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFuZVdpZGdldC5faW50ZXJuYWxfc3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9zZXRQYW5lSGVpZ2h0KHBhbmVXaWRnZXQuX2ludGVybmFsX3N0YXRlKCksIHBhbmVIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9zZXRTaXplcyhzaXplJDEoeyB3aWR0aDogdGltZUF4aXNWaXNpYmxlID8gcGFuZVdpZHRoIDogMCwgaGVpZ2h0OiB0aW1lQXhpc0hlaWdodCB9KSwgdGltZUF4aXNWaXNpYmxlID8gbGVmdFByaWNlQXhpc1dpZHRoIDogMCwgdGltZUF4aXNWaXNpYmxlID8gcmlnaHRQcmljZUF4aXNXaWR0aCA6IDApO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2V0V2lkdGgocGFuZVdpZHRoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWR0aCAhPT0gbGVmdFByaWNlQXhpc1dpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkdGggPSBsZWZ0UHJpY2VBeGlzV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkdGggIT09IHJpZ2h0UHJpY2VBeGlzV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkdGggPSByaWdodFByaWNlQXhpc1dpZHRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19zZXRNb3VzZVdoZWVsRXZlbnRMaXN0ZW5lcihhZGQpIHtcbiAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX3ByaXZhdGVfX29uV2hlZWxCb3VuZCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5fcHJpdmF0ZV9fb25XaGVlbEJvdW5kKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2RldGVybWluZVdoZWVsU3BlZWRBZGp1c3RtZW50KGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQuZGVsdGFNb2RlKSB7XG4gICAgICAgICAgICBjYXNlIGV2ZW50LkRPTV9ERUxUQV9QQUdFOlxuICAgICAgICAgICAgICAgIC8vIG9uZSBzY3JlZW4gYXQgdGltZSBzY3JvbGwgbW9kZVxuICAgICAgICAgICAgICAgIHJldHVybiAxMjA7XG4gICAgICAgICAgICBjYXNlIGV2ZW50LkRPTV9ERUxUQV9MSU5FOlxuICAgICAgICAgICAgICAgIC8vIG9uZSBsaW5lIGF0IHRpbWUgc2Nyb2xsIG1vZGVcbiAgICAgICAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3aW5kb3dzQ2hyb21lKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaHJvbWl1bSBvbiBXaW5kb3dzIGhhcyBhIGJ1ZyB3aGVyZSB0aGUgc2Nyb2xsIHNwZWVkIGlzbid0IGNvcnJlY3RseVxuICAgICAgICAvLyBhZGp1c3RlZCBmb3IgaGlnaCBkZW5zaXR5IGRpc3BsYXlzLiBXZSBuZWVkIHRvIGNvcnJlY3QgZm9yIHRoaXMgc28gdGhhdFxuICAgICAgICAvLyBzY3JvbGwgc3BlZWQgaXMgY29uc2lzdGVudCBiZXR3ZWVuIGJyb3dzZXJzLlxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDAxNzM1XG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyMDczMDhcbiAgICAgICAgcmV0dXJuICgxIC8gd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fb25Nb3VzZXdoZWVsKGV2ZW50KSB7XG4gICAgICAgIGlmICgoZXZlbnQuZGVsdGFYID09PSAwIHx8ICF0aGlzLl9wcml2YXRlX19vcHRpb25zLmhhbmRsZVNjcm9sbC5tb3VzZVdoZWVsKSAmJlxuICAgICAgICAgICAgKGV2ZW50LmRlbHRhWSA9PT0gMCB8fCAhdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5oYW5kbGVTY2FsZS5tb3VzZVdoZWVsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjcm9sbFNwZWVkQWRqdXN0bWVudCA9IHRoaXMuX3ByaXZhdGVfX2RldGVybWluZVdoZWVsU3BlZWRBZGp1c3RtZW50KGV2ZW50KTtcbiAgICAgICAgY29uc3QgZGVsdGFYID0gc2Nyb2xsU3BlZWRBZGp1c3RtZW50ICogZXZlbnQuZGVsdGFYIC8gMTAwO1xuICAgICAgICBjb25zdCBkZWx0YVkgPSAtKHNjcm9sbFNwZWVkQWRqdXN0bWVudCAqIGV2ZW50LmRlbHRhWSAvIDEwMCk7XG4gICAgICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YVkgIT09IDAgJiYgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5oYW5kbGVTY2FsZS5tb3VzZVdoZWVsKSB7XG4gICAgICAgICAgICBjb25zdCB6b29tU2NhbGUgPSBNYXRoLnNpZ24oZGVsdGFZKSAqIE1hdGgubWluKDEsIE1hdGguYWJzKGRlbHRhWSkpO1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSBldmVudC5jbGllbnRYIC0gdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfem9vbVRpbWUoc2Nyb2xsUG9zaXRpb24sIHpvb21TY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbHRhWCAhPT0gMCAmJiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmhhbmRsZVNjcm9sbC5tb3VzZVdoZWVsKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9zY3JvbGxDaGFydChkZWx0YVggKiAtODApOyAvLyA4MCBpcyBhIG1hZGUgdXAgY29lZmZpY2llbnQsIGFuZCBtaW51cyBpcyBmb3IgdGhlIFwibmF0dXJhbFwiIHNjcm9sbFxuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3SW1wbChpbnZhbGlkYXRlTWFzaywgdGltZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGludmFsaWRhdGlvblR5cGUgPSBpbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfZnVsbEludmFsaWRhdGlvbigpO1xuICAgICAgICAvLyBhY3Rpb25zIGZvciBmdWxsIGludmFsaWRhdGlvbiBPTkxZIChub3Qgc2hhcmVkIHdpdGggbGlnaHQpXG4gICAgICAgIGlmIChpbnZhbGlkYXRpb25UeXBlID09PSAzIC8qIEludmFsaWRhdGlvbkxldmVsLkZ1bGwgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUd1aSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxpZ2h0IG9yIGZ1bGwgaW52YWxpZGF0ZSBhY3Rpb25zXG4gICAgICAgIGlmIChpbnZhbGlkYXRpb25UeXBlID09PSAzIC8qIEludmFsaWRhdGlvbkxldmVsLkZ1bGwgKi8gfHxcbiAgICAgICAgICAgIGludmFsaWRhdGlvblR5cGUgPT09IDIgLyogSW52YWxpZGF0aW9uTGV2ZWwuTGlnaHQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2FwcGx5TW9tZW50YXJ5QXV0b1NjYWxlKGludmFsaWRhdGVNYXNrKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2FwcGx5VGltZVNjYWxlSW52YWxpZGF0aW9ucyhpbnZhbGlkYXRlTWFzaywgdGltZSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldC5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cy5mb3JFYWNoKChwYW5lKSA9PiB7XG4gICAgICAgICAgICAgICAgcGFuZS5faW50ZXJuYWxfdXBkYXRlUHJpY2VBeGlzV2lkZ2V0cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBhIGZ1bGwgaW52YWxpZGF0aW9uIGhhcyBiZWVuIHBvc3Rwb25lZCBkdXJpbmcgdGhlIGRyYXcsIHJlYXBwbHlcbiAgICAgICAgICAgIC8vIHRoZSB0aW1lc2NhbGUgaW52YWxpZGF0aW9ucy4gQSBmdWxsIGludmFsaWRhdGlvbiB3b3VsZCBtZWFuIHRoZXJlIGlzIGEgY2hhbmdlXG4gICAgICAgICAgICAvLyBpbiB0aGUgdGltZXNjYWxlIHdpZHRoIChjYXVzZWQgYnkgcHJpY2Ugc2NhbGUgY2hhbmdlcykgdGhhdCBuZWVkcyB0byBiZSBkcmF3blxuICAgICAgICAgICAgLy8gcmlnaHQgYXdheSB0byBhdm9pZCBmbGlja2VyaW5nLlxuICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9pbnRlcm5hbF9mdWxsSW52YWxpZGF0aW9uKCkpID09PSAzIC8qIEludmFsaWRhdGlvbkxldmVsLkZ1bGwgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfbWVyZ2UoaW52YWxpZGF0ZU1hc2spO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUd1aSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2FwcGx5TW9tZW50YXJ5QXV0b1NjYWxlKHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hcHBseVRpbWVTY2FsZUludmFsaWRhdGlvbnModGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2ssIHRpbWUpO1xuICAgICAgICAgICAgICAgIGludmFsaWRhdGVNYXNrID0gdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2s7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2sgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3BhaW50KGludmFsaWRhdGVNYXNrKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2FwcGx5VGltZVNjYWxlSW52YWxpZGF0aW9ucyhpbnZhbGlkYXRlTWFzaywgdGltZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHRzSW52YWxpZGF0aW9uIG9mIGludmFsaWRhdGVNYXNrLl9pbnRlcm5hbF90aW1lU2NhbGVJbnZhbGlkYXRpb25zKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2FwcGx5VGltZVNjYWxlSW52YWxpZGF0aW9uKHRzSW52YWxpZGF0aW9uLCB0aW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fYXBwbHlNb21lbnRhcnlBdXRvU2NhbGUoaW52YWxpZGF0ZU1hc2spIHtcbiAgICAgICAgY29uc3QgcGFuZXMgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfcGFuZXMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGludmFsaWRhdGVNYXNrLl9pbnRlcm5hbF9pbnZhbGlkYXRlRm9yUGFuZShpKS5faW50ZXJuYWxfYXV0b1NjYWxlKSB7XG4gICAgICAgICAgICAgICAgcGFuZXNbaV0uX2ludGVybmFsX21vbWVudGFyeUF1dG9TY2FsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19hcHBseVRpbWVTY2FsZUludmFsaWRhdGlvbihpbnZhbGlkYXRpb24sIHRpbWUpIHtcbiAgICAgICAgY29uc3QgdGltZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpO1xuICAgICAgICBzd2l0Y2ggKGludmFsaWRhdGlvbi5faW50ZXJuYWxfdHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuRml0Q29udGVudCAqLzpcbiAgICAgICAgICAgICAgICB0aW1lU2NhbGUuX2ludGVybmFsX2ZpdENvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLkFwcGx5UmFuZ2UgKi86XG4gICAgICAgICAgICAgICAgdGltZVNjYWxlLl9pbnRlcm5hbF9zZXRMb2dpY2FsUmFuZ2UoaW52YWxpZGF0aW9uLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BcHBseUJhclNwYWNpbmcgKi86XG4gICAgICAgICAgICAgICAgdGltZVNjYWxlLl9pbnRlcm5hbF9zZXRCYXJTcGFjaW5nKGludmFsaWRhdGlvbi5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuQXBwbHlSaWdodE9mZnNldCAqLzpcbiAgICAgICAgICAgICAgICB0aW1lU2NhbGUuX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KGludmFsaWRhdGlvbi5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0IC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuUmVzZXQgKi86XG4gICAgICAgICAgICAgICAgdGltZVNjYWxlLl9pbnRlcm5hbF9yZXN0b3JlRGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1IC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuQW5pbWF0aW9uICovOlxuICAgICAgICAgICAgICAgIGlmICghaW52YWxpZGF0aW9uLl9pbnRlcm5hbF92YWx1ZS5faW50ZXJuYWxfZmluaXNoZWQodGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZVNjYWxlLl9pbnRlcm5hbF9zZXRSaWdodE9mZnNldChpbnZhbGlkYXRpb24uX2ludGVybmFsX3ZhbHVlLl9pbnRlcm5hbF9nZXRQb3NpdGlvbih0aW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19pbnZhbGlkYXRlSGFuZGxlcihpbnZhbGlkYXRlTWFzaykge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrLl9pbnRlcm5hbF9tZXJnZShpbnZhbGlkYXRlTWFzayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzayA9IGludmFsaWRhdGVNYXNrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fZHJhd1BsYW5uZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdQbGFubmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdSYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRpbWUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3UGxhbm5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdSYWZJZCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3SW1wbChtYXNrLCB0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0c0ludmFsaWRhdGlvbiBvZiBtYXNrLl9pbnRlcm5hbF90aW1lU2NhbGVJbnZhbGlkYXRpb25zKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0c0ludmFsaWRhdGlvbi5faW50ZXJuYWxfdHlwZSA9PT0gNSAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLkFuaW1hdGlvbiAqLyAmJiAhdHNJbnZhbGlkYXRpb24uX2ludGVybmFsX3ZhbHVlLl9pbnRlcm5hbF9maW5pc2hlZCh0aW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3NldFRpbWVTY2FsZUFuaW1hdGlvbih0c0ludmFsaWRhdGlvbi5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX3VwZGF0ZUd1aSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3luY0d1aVdpdGhNb2RlbCgpO1xuICAgIH1cbiAgICAvLyBwcml2YXRlIF9kZXN0cm95U2VwYXJhdG9yKHNlcGFyYXRvcjogUGFuZVNlcGFyYXRvcik6IHZvaWQge1xuICAgIC8vIFx0dGhpcy5fdGFibGVFbGVtZW50LnJlbW92ZUNoaWxkKHNlcGFyYXRvci5nZXRFbGVtZW50KCkpO1xuICAgIC8vIFx0c2VwYXJhdG9yLmRlc3Ryb3koKTtcbiAgICAvLyB9XG4gICAgX3ByaXZhdGVfX3N5bmNHdWlXaXRoTW9kZWwoKSB7XG4gICAgICAgIGNvbnN0IHBhbmVzID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3BhbmVzKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldFBhbmVXaWRnZXRzQ291bnQgPSBwYW5lcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGFjdHVhbFBhbmVXaWRnZXRzQ291bnQgPSB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cy5sZW5ndGg7XG4gICAgICAgIC8vIFJlbW92ZSAoaWYgbmVlZGVkKSBwYW5lIHdpZGdldHMgYW5kIHNlcGFyYXRvcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHRhcmdldFBhbmVXaWRnZXRzQ291bnQ7IGkgPCBhY3R1YWxQYW5lV2lkZ2V0c0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhbmVXaWRnZXQgPSBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLnBvcCgpKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudC5yZW1vdmVDaGlsZChwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9nZXRFbGVtZW50KCkpO1xuICAgICAgICAgICAgcGFuZVdpZGdldC5faW50ZXJuYWxfY2xpY2tlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX2RibENsaWNrZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgICAgICAvLyBjb25zdCBwYW5lU2VwYXJhdG9yID0gdGhpcy5fcGFuZVNlcGFyYXRvcnMucG9wKCk7XG4gICAgICAgICAgICAvLyBpZiAocGFuZVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBcdHRoaXMuX2Rlc3Ryb3lTZXBhcmF0b3IocGFuZVNlcGFyYXRvcik7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIChpZiBuZWVkZWQpIG5ldyBwYW5lIHdpZGdldHMgYW5kIHNlcGFyYXRvcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IGFjdHVhbFBhbmVXaWRnZXRzQ291bnQ7IGkgPCB0YXJnZXRQYW5lV2lkZ2V0c0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhbmVXaWRnZXQgPSBuZXcgUGFuZVdpZGdldCh0aGlzLCBwYW5lc1tpXSk7XG4gICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9jbGlja2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19vblBhbmVXaWRnZXRDbGlja2VkLmJpbmQodGhpcyksIHRoaXMpO1xuICAgICAgICAgICAgcGFuZVdpZGdldC5faW50ZXJuYWxfZGJsQ2xpY2tlZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUodGhpcy5fcHJpdmF0ZV9fb25QYW5lV2lkZ2V0RGJsQ2xpY2tlZC5iaW5kKHRoaXMpLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLnB1c2gocGFuZVdpZGdldCk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYW5kIGluc2VydCBzZXBhcmF0b3JcbiAgICAgICAgICAgIC8vIGlmIChpID4gMSkge1xuICAgICAgICAgICAgLy8gXHRjb25zdCBwYW5lU2VwYXJhdG9yID0gbmV3IFBhbmVTZXBhcmF0b3IodGhpcywgaSAtIDEsIGksIHRydWUpO1xuICAgICAgICAgICAgLy8gXHR0aGlzLl9wYW5lU2VwYXJhdG9ycy5wdXNoKHBhbmVTZXBhcmF0b3IpO1xuICAgICAgICAgICAgLy8gXHR0aGlzLl90YWJsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKHBhbmVTZXBhcmF0b3IuZ2V0RWxlbWVudCgpLCB0aGlzLl90aW1lQXhpc1dpZGdldC5nZXRFbGVtZW50KCkpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gaW5zZXJ0IHBhbmVXaWRnZXRcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudC5pbnNlcnRCZWZvcmUocGFuZVdpZGdldC5faW50ZXJuYWxfZ2V0RWxlbWVudCgpLCB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldC5faW50ZXJuYWxfZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldFBhbmVXaWRnZXRzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBwYW5lc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHBhbmVXaWRnZXQgPSB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0c1tpXTtcbiAgICAgICAgICAgIGlmIChwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9zdGF0ZSgpICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX3NldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX3VwZGF0ZVByaWNlQXhpc1dpZGdldHNTdGF0ZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVUaW1lQXhpc1Zpc2liaWxpdHkoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWRqdXN0U2l6ZUltcGwoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldE1vdXNlRXZlbnRQYXJhbXNJbXBsKGluZGV4LCBwb2ludCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBzZXJpZXNEYXRhID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc2VzID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3Nlcmllc2VzKCk7XG4gICAgICAgICAgICBzZXJpZXNlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIHNlYXJjaCBsZWZ0XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHMuX2ludGVybmFsX2JhcnMoKS5faW50ZXJuYWxfc2VhcmNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNEYXRhLnNldChzLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xpZW50VGltZTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lUG9pbnQgPSAoX2EgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2luZGV4VG9UaW1lU2NhbGVQb2ludChpbmRleCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcmlnaW5hbFRpbWU7XG4gICAgICAgICAgICBpZiAodGltZVBvaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjbGllbnRUaW1lID0gdGltZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvdmVyZWRTb3VyY2UgPSB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9ob3ZlcmVkU291cmNlKCk7XG4gICAgICAgIGNvbnN0IGhvdmVyZWRTZXJpZXMgPSBob3ZlcmVkU291cmNlICE9PSBudWxsICYmIGhvdmVyZWRTb3VyY2UuX2ludGVybmFsX3NvdXJjZSBpbnN0YW5jZW9mIFNlcmllc1xuICAgICAgICAgICAgPyBob3ZlcmVkU291cmNlLl9pbnRlcm5hbF9zb3VyY2VcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBob3ZlcmVkT2JqZWN0ID0gaG92ZXJlZFNvdXJjZSAhPT0gbnVsbCAmJiBob3ZlcmVkU291cmNlLl9pbnRlcm5hbF9vYmplY3QgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBob3ZlcmVkU291cmNlLl9pbnRlcm5hbF9vYmplY3QuX2ludGVybmFsX2V4dGVybmFsSWRcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX29yaWdpbmFsVGltZTogY2xpZW50VGltZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pbmRleDogaW5kZXggIT09IG51bGwgJiYgaW5kZXggIT09IHZvaWQgMCA/IGluZGV4IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX2ludGVybmFsX3BvaW50OiBwb2ludCAhPT0gbnVsbCAmJiBwb2ludCAhPT0gdm9pZCAwID8gcG9pbnQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfaW50ZXJuYWxfaG92ZXJlZFNlcmllczogaG92ZXJlZFNlcmllcyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9zZXJpZXNEYXRhOiBzZXJpZXNEYXRhLFxuICAgICAgICAgICAgX2ludGVybmFsX2hvdmVyZWRPYmplY3Q6IGhvdmVyZWRPYmplY3QsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG91Y2hNb3VzZUV2ZW50RGF0YTogZXZlbnQgIT09IG51bGwgJiYgZXZlbnQgIT09IHZvaWQgMCA/IGV2ZW50IDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fb25QYW5lV2lkZ2V0Q2xpY2tlZCh0aW1lLCBwb2ludCwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tlZC5faW50ZXJuYWxfZmlyZSgoKSA9PiB0aGlzLl9wcml2YXRlX19nZXRNb3VzZUV2ZW50UGFyYW1zSW1wbCh0aW1lLCBwb2ludCwgZXZlbnQpKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX29uUGFuZVdpZGdldERibENsaWNrZWQodGltZSwgcG9pbnQsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RibENsaWNrZWQuX2ludGVybmFsX2ZpcmUoKCkgPT4gdGhpcy5fcHJpdmF0ZV9fZ2V0TW91c2VFdmVudFBhcmFtc0ltcGwodGltZSwgcG9pbnQsIGV2ZW50KSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19vblBhbmVXaWRnZXRDcm9zc2hhaXJNb3ZlZCh0aW1lLCBwb2ludCwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyTW92ZWQuX2ludGVybmFsX2ZpcmUoKCkgPT4gdGhpcy5fcHJpdmF0ZV9fZ2V0TW91c2VFdmVudFBhcmFtc0ltcGwodGltZSwgcG9pbnQsIGV2ZW50KSk7XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVUaW1lQXhpc1Zpc2liaWxpdHkoKSB7XG4gICAgICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpbWVTY2FsZS52aXNpYmxlID8gJycgOiAnbm9uZSc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9nZXRFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gICAgfVxuICAgIF9wcml2YXRlX19pc0xlZnRBeGlzVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzWzBdLl9pbnRlcm5hbF9zdGF0ZSgpLl9pbnRlcm5hbF9sZWZ0UHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9vcHRpb25zKCkudmlzaWJsZTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2lzUmlnaHRBeGlzVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzWzBdLl9pbnRlcm5hbF9zdGF0ZSgpLl9pbnRlcm5hbF9yaWdodFByaWNlU2NhbGUoKS5faW50ZXJuYWxfb3B0aW9ucygpLnZpc2libGU7XG4gICAgfVxuICAgIF9wcml2YXRlX19pbnN0YWxsT2JzZXJ2ZXIoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBpZiAoISgnUmVzaXplT2JzZXJ2ZXInIGluIHdpbmRvdykpIHtcbiAgICAgICAgICAgIHdhcm4oJ09wdGlvbnMgY29udGFpbnMgXCJhdXRvU2l6ZVwiIGZsYWcsIGJ1dCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFJlc2l6ZU9ic2VydmVyIGZlYXR1cmUuIFBsZWFzZSBwcm92aWRlIHBvbHlmaWxsLicpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXJFbnRyeSA9IGVudHJpZXMuZmluZCgoZW50cnkpID0+IGVudHJ5LnRhcmdldCA9PT0gdGhpcy5fcHJpdmF0ZV9fY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lckVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVzaXplKGNvbnRhaW5lckVudHJ5LmNvbnRlbnRSZWN0LndpZHRoLCBjb250YWluZXJFbnRyeS5jb250ZW50UmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vYnNlcnZlci5vYnNlcnZlKHRoaXMuX3ByaXZhdGVfX2NvbnRhaW5lciwgeyBib3g6ICdib3JkZXItYm94JyB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX191bmluc3RhbGxPYnNlcnZlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX29ic2VydmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRpc2FibGVTZWxlY3Rpb24oZWxlbWVudCkge1xuICAgIGVsZW1lbnQuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgZWxlbWVudC5zdHlsZS5tc1VzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgZWxlbWVudC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgIGVsZW1lbnQuc3R5bGUud2Via2l0VGFwSGlnaGxpZ2h0Q29sb3IgPSAndHJhbnNwYXJlbnQnO1xufVxuZnVuY3Rpb24gc2hvdWxkU3Vic2NyaWJlTW91c2VXaGVlbChvcHRpb25zKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4ob3B0aW9ucy5oYW5kbGVTY3JvbGwubW91c2VXaGVlbCB8fCBvcHRpb25zLmhhbmRsZVNjYWxlLm1vdXNlV2hlZWwpO1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2VEYXRhKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5vcGVuID09PSB1bmRlZmluZWQgJiYgZGF0YS52YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNGdWxmaWxsZWREYXRhKGRhdGEpIHtcbiAgICByZXR1cm4gKGRhdGEub3BlbiAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGRhdGEudmFsdWUgIT09IHVuZGVmaW5lZCk7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxuXG5mdW5jdGlvbiBnZXRDb2xvcmVkTGluZUJhc2VkU2VyaWVzUGxvdFJvdyh0aW1lLCBpbmRleCwgaXRlbSwgb3JpZ2luYWxUaW1lKSB7XG4gICAgY29uc3QgdmFsID0gaXRlbS52YWx1ZTtcbiAgICBjb25zdCByZXMgPSB7IF9pbnRlcm5hbF9pbmRleDogaW5kZXgsIF9pbnRlcm5hbF90aW1lOiB0aW1lLCBfaW50ZXJuYWxfdmFsdWU6IFt2YWwsIHZhbCwgdmFsLCB2YWxdLCBfaW50ZXJuYWxfb3JpZ2luYWxUaW1lOiBvcmlnaW5hbFRpbWUgfTtcbiAgICBpZiAoaXRlbS5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcy5faW50ZXJuYWxfY29sb3IgPSBpdGVtLmNvbG9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2V0QXJlYVNlcmllc1Bsb3RSb3codGltZSwgaW5kZXgsIGl0ZW0sIG9yaWdpbmFsVGltZSkge1xuICAgIGNvbnN0IHZhbCA9IGl0ZW0udmFsdWU7XG4gICAgY29uc3QgcmVzID0geyBfaW50ZXJuYWxfaW5kZXg6IGluZGV4LCBfaW50ZXJuYWxfdGltZTogdGltZSwgX2ludGVybmFsX3ZhbHVlOiBbdmFsLCB2YWwsIHZhbCwgdmFsXSwgX2ludGVybmFsX29yaWdpbmFsVGltZTogb3JpZ2luYWxUaW1lIH07XG4gICAgaWYgKGl0ZW0ubGluZUNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzLl9pbnRlcm5hbF9saW5lQ29sb3IgPSBpdGVtLmxpbmVDb2xvcjtcbiAgICB9XG4gICAgaWYgKGl0ZW0udG9wQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMuX2ludGVybmFsX3RvcENvbG9yID0gaXRlbS50b3BDb2xvcjtcbiAgICB9XG4gICAgaWYgKGl0ZW0uYm90dG9tQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMuX2ludGVybmFsX2JvdHRvbUNvbG9yID0gaXRlbS5ib3R0b21Db2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldEJhc2VsaW5lU2VyaWVzUGxvdFJvdyh0aW1lLCBpbmRleCwgaXRlbSwgb3JpZ2luYWxUaW1lKSB7XG4gICAgY29uc3QgdmFsID0gaXRlbS52YWx1ZTtcbiAgICBjb25zdCByZXMgPSB7IF9pbnRlcm5hbF9pbmRleDogaW5kZXgsIF9pbnRlcm5hbF90aW1lOiB0aW1lLCBfaW50ZXJuYWxfdmFsdWU6IFt2YWwsIHZhbCwgdmFsLCB2YWxdLCBfaW50ZXJuYWxfb3JpZ2luYWxUaW1lOiBvcmlnaW5hbFRpbWUgfTtcbiAgICBpZiAoaXRlbS50b3BMaW5lQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMuX2ludGVybmFsX3RvcExpbmVDb2xvciA9IGl0ZW0udG9wTGluZUNvbG9yO1xuICAgIH1cbiAgICBpZiAoaXRlbS5ib3R0b21MaW5lQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMuX2ludGVybmFsX2JvdHRvbUxpbmVDb2xvciA9IGl0ZW0uYm90dG9tTGluZUNvbG9yO1xuICAgIH1cbiAgICBpZiAoaXRlbS50b3BGaWxsQ29sb3IxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzLl9pbnRlcm5hbF90b3BGaWxsQ29sb3IxID0gaXRlbS50b3BGaWxsQ29sb3IxO1xuICAgIH1cbiAgICBpZiAoaXRlbS50b3BGaWxsQ29sb3IyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzLl9pbnRlcm5hbF90b3BGaWxsQ29sb3IyID0gaXRlbS50b3BGaWxsQ29sb3IyO1xuICAgIH1cbiAgICBpZiAoaXRlbS5ib3R0b21GaWxsQ29sb3IxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzLl9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IxID0gaXRlbS5ib3R0b21GaWxsQ29sb3IxO1xuICAgIH1cbiAgICBpZiAoaXRlbS5ib3R0b21GaWxsQ29sb3IyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzLl9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IyID0gaXRlbS5ib3R0b21GaWxsQ29sb3IyO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2V0QmFyU2VyaWVzUGxvdFJvdyh0aW1lLCBpbmRleCwgaXRlbSwgb3JpZ2luYWxUaW1lKSB7XG4gICAgY29uc3QgcmVzID0geyBfaW50ZXJuYWxfaW5kZXg6IGluZGV4LCBfaW50ZXJuYWxfdGltZTogdGltZSwgX2ludGVybmFsX3ZhbHVlOiBbaXRlbS5vcGVuLCBpdGVtLmhpZ2gsIGl0ZW0ubG93LCBpdGVtLmNsb3NlXSwgX2ludGVybmFsX29yaWdpbmFsVGltZTogb3JpZ2luYWxUaW1lIH07XG4gICAgaWYgKGl0ZW0uY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMuX2ludGVybmFsX2NvbG9yID0gaXRlbS5jb2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldENhbmRsZXN0aWNrU2VyaWVzUGxvdFJvdyh0aW1lLCBpbmRleCwgaXRlbSwgb3JpZ2luYWxUaW1lKSB7XG4gICAgY29uc3QgcmVzID0geyBfaW50ZXJuYWxfaW5kZXg6IGluZGV4LCBfaW50ZXJuYWxfdGltZTogdGltZSwgX2ludGVybmFsX3ZhbHVlOiBbaXRlbS5vcGVuLCBpdGVtLmhpZ2gsIGl0ZW0ubG93LCBpdGVtLmNsb3NlXSwgX2ludGVybmFsX29yaWdpbmFsVGltZTogb3JpZ2luYWxUaW1lIH07XG4gICAgaWYgKGl0ZW0uY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMuX2ludGVybmFsX2NvbG9yID0gaXRlbS5jb2xvcjtcbiAgICB9XG4gICAgaWYgKGl0ZW0uYm9yZGVyQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMuX2ludGVybmFsX2JvcmRlckNvbG9yID0gaXRlbS5ib3JkZXJDb2xvcjtcbiAgICB9XG4gICAgaWYgKGl0ZW0ud2lja0NvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzLl9pbnRlcm5hbF93aWNrQ29sb3IgPSBpdGVtLndpY2tDb2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldEN1c3RvbVNlcmllc1Bsb3RSb3codGltZSwgaW5kZXgsIGl0ZW0sIG9yaWdpbmFsVGltZSwgZGF0YVRvUGxvdFJvdykge1xuICAgIGNvbnN0IHZhbHVlcyA9IGVuc3VyZURlZmluZWQoZGF0YVRvUGxvdFJvdykoaXRlbSk7XG4gICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoLi4udmFsdWVzKTtcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi52YWx1ZXMpO1xuICAgIGNvbnN0IGxhc3QgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHZhbHVlID0gW2xhc3QsIG1heCwgbWluLCBsYXN0XTtcbiAgICBjb25zdCBfYSA9IGl0ZW0sIHsgdGltZTogZXhjbHVkZWRUaW1lLCBjb2xvciB9ID0gX2EsIGRhdGEgPSBfX3Jlc3QoX2EsIFtcInRpbWVcIiwgXCJjb2xvclwiXSk7XG4gICAgcmV0dXJuIHsgX2ludGVybmFsX2luZGV4OiBpbmRleCwgX2ludGVybmFsX3RpbWU6IHRpbWUsIF9pbnRlcm5hbF92YWx1ZTogdmFsdWUsIF9pbnRlcm5hbF9vcmlnaW5hbFRpbWU6IG9yaWdpbmFsVGltZSwgX2ludGVybmFsX2RhdGE6IGRhdGEsIF9pbnRlcm5hbF9jb2xvcjogY29sb3IgfTtcbn1cbmZ1bmN0aW9uIGlzU2VyaWVzUGxvdFJvdyhyb3cpIHtcbiAgICByZXR1cm4gcm93Ll9pbnRlcm5hbF92YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gd3JhcEN1c3RvbVZhbHVlcyhwbG90Um93LCBiYXIpIHtcbiAgICBpZiAoYmFyLmN1c3RvbVZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBsb3RSb3cuX2ludGVybmFsX2N1c3RvbVZhbHVlcyA9IGJhci5jdXN0b21WYWx1ZXM7XG4gICAgfVxuICAgIHJldHVybiBwbG90Um93O1xufVxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlRGF0YVdpdGhDdXN0b21DaGVjayhiYXIsIGN1c3RvbUlzV2hpdGVzcGFjZSkge1xuICAgIGlmIChjdXN0b21Jc1doaXRlc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIGN1c3RvbUlzV2hpdGVzcGFjZShiYXIpO1xuICAgIH1cbiAgICByZXR1cm4gaXNXaGl0ZXNwYWNlRGF0YShiYXIpO1xufVxuZnVuY3Rpb24gd3JhcFdoaXRlc3BhY2VEYXRhKGNyZWF0ZVBsb3RSb3dGbikge1xuICAgIHJldHVybiAodGltZSwgaW5kZXgsIGJhciwgb3JpZ2luYWxUaW1lLCBkYXRhVG9QbG90Um93LCBjdXN0b21Jc1doaXRlc3BhY2UpID0+IHtcbiAgICAgICAgaWYgKGlzV2hpdGVzcGFjZURhdGFXaXRoQ3VzdG9tQ2hlY2soYmFyLCBjdXN0b21Jc1doaXRlc3BhY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcEN1c3RvbVZhbHVlcyh7IF9pbnRlcm5hbF90aW1lOiB0aW1lLCBfaW50ZXJuYWxfaW5kZXg6IGluZGV4LCBfaW50ZXJuYWxfb3JpZ2luYWxUaW1lOiBvcmlnaW5hbFRpbWUgfSwgYmFyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JhcEN1c3RvbVZhbHVlcyhjcmVhdGVQbG90Um93Rm4odGltZSwgaW5kZXgsIGJhciwgb3JpZ2luYWxUaW1lLCBkYXRhVG9QbG90Um93KSwgYmFyKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VyaWVzUGxvdFJvd0NyZWF0b3Ioc2VyaWVzVHlwZSkge1xuICAgIGNvbnN0IHNlcmllc1Bsb3RSb3dGbk1hcCA9IHtcbiAgICAgICAgQ2FuZGxlc3RpY2s6IHdyYXBXaGl0ZXNwYWNlRGF0YShnZXRDYW5kbGVzdGlja1Nlcmllc1Bsb3RSb3cpLFxuICAgICAgICBCYXI6IHdyYXBXaGl0ZXNwYWNlRGF0YShnZXRCYXJTZXJpZXNQbG90Um93KSxcbiAgICAgICAgQXJlYTogd3JhcFdoaXRlc3BhY2VEYXRhKGdldEFyZWFTZXJpZXNQbG90Um93KSxcbiAgICAgICAgQmFzZWxpbmU6IHdyYXBXaGl0ZXNwYWNlRGF0YShnZXRCYXNlbGluZVNlcmllc1Bsb3RSb3cpLFxuICAgICAgICBIaXN0b2dyYW06IHdyYXBXaGl0ZXNwYWNlRGF0YShnZXRDb2xvcmVkTGluZUJhc2VkU2VyaWVzUGxvdFJvdyksXG4gICAgICAgIExpbmU6IHdyYXBXaGl0ZXNwYWNlRGF0YShnZXRDb2xvcmVkTGluZUJhc2VkU2VyaWVzUGxvdFJvdyksXG4gICAgICAgIEN1c3RvbTogd3JhcFdoaXRlc3BhY2VEYXRhKGdldEN1c3RvbVNlcmllc1Bsb3RSb3cpLFxuICAgIH07XG4gICAgcmV0dXJuIHNlcmllc1Bsb3RSb3dGbk1hcFtzZXJpZXNUeXBlXTtcbn1cblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJfYnVpbGQtdGltZS1jb25zdGFudHNcIiAvPlxuZnVuY3Rpb24gY3JlYXRlRW1wdHlUaW1lUG9pbnREYXRhKHRpbWVQb2ludCkge1xuICAgIHJldHVybiB7IF9pbnRlcm5hbF9pbmRleDogMCwgX2ludGVybmFsX21hcHBpbmc6IG5ldyBNYXAoKSwgX2ludGVybmFsX3RpbWVQb2ludDogdGltZVBvaW50IH07XG59XG5mdW5jdGlvbiBzZXJpZXNSb3dzRmlyc3RBbmRMYXN0VGltZShzZXJpZXNSb3dzLCBiaCkge1xuICAgIGlmIChzZXJpZXNSb3dzID09PSB1bmRlZmluZWQgfHwgc2VyaWVzUm93cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2ludGVybmFsX2ZpcnN0VGltZTogYmgua2V5KHNlcmllc1Jvd3NbMF0uX2ludGVybmFsX3RpbWUpLFxuICAgICAgICBfaW50ZXJuYWxfbGFzdFRpbWU6IGJoLmtleShzZXJpZXNSb3dzW3Nlcmllc1Jvd3MubGVuZ3RoIC0gMV0uX2ludGVybmFsX3RpbWUpLFxuICAgIH07XG59XG5mdW5jdGlvbiBzZXJpZXNVcGRhdGVJbmZvKHNlcmllc1Jvd3MsIHByZXZTZXJpZXNSb3dzLCBiaCkge1xuICAgIGNvbnN0IGZpcnN0QW5kTGFzdFRpbWUgPSBzZXJpZXNSb3dzRmlyc3RBbmRMYXN0VGltZShzZXJpZXNSb3dzLCBiaCk7XG4gICAgY29uc3QgcHJldkZpcnN0QW5kTGFzdFRpbWUgPSBzZXJpZXNSb3dzRmlyc3RBbmRMYXN0VGltZShwcmV2U2VyaWVzUm93cywgYmgpO1xuICAgIGlmIChmaXJzdEFuZExhc3RUaW1lICE9PSB1bmRlZmluZWQgJiYgcHJldkZpcnN0QW5kTGFzdFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX2xhc3RCYXJVcGRhdGVkT3JOZXdCYXJzQWRkZWRUb1RoZVJpZ2h0OiBmaXJzdEFuZExhc3RUaW1lLl9pbnRlcm5hbF9sYXN0VGltZSA+PSBwcmV2Rmlyc3RBbmRMYXN0VGltZS5faW50ZXJuYWxfbGFzdFRpbWUgJiZcbiAgICAgICAgICAgICAgICBmaXJzdEFuZExhc3RUaW1lLl9pbnRlcm5hbF9maXJzdFRpbWUgPj0gcHJldkZpcnN0QW5kTGFzdFRpbWUuX2ludGVybmFsX2ZpcnN0VGltZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHRpbWVTY2FsZVBvaW50VGltZShtZXJnZWRQb2ludERhdGEpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIG1lcmdlZFBvaW50RGF0YS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdi5faW50ZXJuYWxfb3JpZ2luYWxUaW1lO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGVuc3VyZURlZmluZWQocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIHNhdmVPcmlnaW5hbFRpbWUoZGF0YSkge1xuICAgIGlmIChkYXRhLl9pbnRlcm5hbF9vcmlnaW5hbFRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9vcmlnaW5hbFRpbWUgPSBkYXRhLnRpbWU7XG4gICAgfVxufVxuY2xhc3MgRGF0YUxheWVyIHtcbiAgICBjb25zdHJ1Y3Rvcihob3J6U2NhbGVCZWhhdmlvcikge1xuICAgICAgICAvLyBub3RlIHRoYXQgX3BvaW50RGF0YUJ5VGltZVBvaW50IGFuZCBfc2VyaWVzUm93c0J5U2VyaWVzIHNoYXJlcyBUSEUgU0FNRSBvYmplY3RzIGluIHRoZWlyIHZhbHVlcyBiZXR3ZWVuIGVhY2ggb3RoZXJcbiAgICAgICAgLy8gaXQncyBqdXN0IGRpZmZlcmVudCBraW5kIG9mIG1hcHMgdG8gbWFrZSB1c2FnZXMvcGVyZiBiZXR0ZXJcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9pbnREYXRhQnlUaW1lUG9pbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc1Jvd3NCeVNlcmllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTGFzdFRpbWVQb2ludCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gdGhpcyBpcyBraW5kIG9mIFwiZGVzdFwiIHZhbHVlcyAoaW4gb3Bwb3NpdGUgdG8gXCJzb3VyY2VcIiBvbmVzKSAtIHdlIGRvbid0IG5lZWQgdG8gbW9kaWZ5IGl0IG1hbnVhbGx5LCB0aGUgb25seSBieSBjYWxsaW5nIF91cGRhdGVUaW1lU2NhbGVQb2ludHMgb3IgdXBkYXRlU2VyaWVzRGF0YSBtZXRob2RzXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NvcnRlZFRpbWVQb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IgPSBob3J6U2NhbGVCZWhhdmlvcjtcbiAgICB9XG4gICAgX2ludGVybmFsX2Rlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BvaW50RGF0YUJ5VGltZVBvaW50LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc1Jvd3NCeVNlcmllcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNMYXN0VGltZVBvaW50LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NvcnRlZFRpbWVQb2ludHMgPSBbXTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFNlcmllc0RhdGEoc2VyaWVzLCBkYXRhKSB7XG4gICAgICAgIGxldCBuZWVkQ2xlYW51cFBvaW50cyA9IHRoaXMuX3ByaXZhdGVfX3BvaW50RGF0YUJ5VGltZVBvaW50LnNpemUgIT09IDA7XG4gICAgICAgIGxldCBpc1RpbWVTY2FsZUFmZmVjdGVkID0gZmFsc2U7XG4gICAgICAgIC8vIHNhdmUgcHJldmlvdXMgc2VyaWVzIHJvd3MgZGF0YSBiZWZvcmUgaXQncyByZXBsYWNlZCBpbnNpZGUgdGhpcy5fc2V0Um93c1RvU2VyaWVzXG4gICAgICAgIGNvbnN0IHByZXZTZXJpZXNSb3dzID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLmdldChzZXJpZXMpO1xuICAgICAgICBpZiAocHJldlNlcmllc1Jvd3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Nlcmllc1Jvd3NCeVNlcmllcy5zaXplID09PSAxKSB7XG4gICAgICAgICAgICAgICAgbmVlZENsZWFudXBQb2ludHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc1RpbWVTY2FsZUFmZmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBwZXJmIG9wdGltaXphdGlvbiAtIGlmIHRoZXJlIGlzIG9ubHkgMSBzZXJpZXMsIHRoZW4gd2UgY2FuIGp1c3QgY2xlYXIgYW5kIGZpbGwgZXZlcnl0aGluZyBmcm9tIHNjcmF0Y2hcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wb2ludERhdGFCeVRpbWVQb2ludC5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcGVyZiBvcHRpbWl6YXRpb24gLSBhY3R1YWxseSB3ZSBoYXZlIHRvIHVzZSB0aGlzLl9wb2ludERhdGFCeVRpbWVQb2ludCBmb3IgZ29pbmcgdGhyb3VnaCBoZXJlXG4gICAgICAgICAgICAgICAgLy8gYnV0IGFzIHNvb24gYXMgdGhpcy5fc29ydGVkVGltZVBvaW50cyBpcyBqdXN0IGEgZGlmZmVyZW50IGZvcm0gb2YgX3BvaW50RGF0YUJ5VGltZVBvaW50IHdlIGNhbiB1c2UgaXQgYXMgd2VsbFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgdGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQucG9pbnREYXRhLl9pbnRlcm5hbF9tYXBwaW5nLmRlbGV0ZShzZXJpZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RpbWVTY2FsZUFmZmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VyaWVzUm93cyA9IFtdO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsVGltZXMgPSBkYXRhLm1hcCgoZCkgPT4gZC50aW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVDb252ZXJ0ZXIgPSB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5jcmVhdGVDb252ZXJ0ZXJUb0ludGVybmFsT2JqKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlUGxvdFJvdyA9IGdldFNlcmllc1Bsb3RSb3dDcmVhdG9yKHNlcmllcy5faW50ZXJuYWxfc2VyaWVzVHlwZSgpKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFUb1Bsb3RSb3cgPSBzZXJpZXMuX2ludGVybmFsX2N1c3RvbVNlcmllc1Bsb3RWYWx1ZXNCdWlsZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBjdXN0b21XaGl0ZXNwYWNlQ2hlY2tlciA9IHNlcmllcy5faW50ZXJuYWxfY3VzdG9tU2VyaWVzV2hpdGVzcGFjZUNoZWNrKCk7XG4gICAgICAgICAgICBzZXJpZXNSb3dzID0gZGF0YS5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZSA9IHRpbWVDb252ZXJ0ZXIoaXRlbS50aW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBob3J6SXRlbUtleSA9IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleSh0aW1lKTtcbiAgICAgICAgICAgICAgICBsZXQgdGltZVBvaW50RGF0YSA9IHRoaXMuX3ByaXZhdGVfX3BvaW50RGF0YUJ5VGltZVBvaW50LmdldChob3J6SXRlbUtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVQb2ludERhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaW5kZXhlcyB3aWxsIGJlIHN5bmMgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgdGltZVBvaW50RGF0YSA9IGNyZWF0ZUVtcHR5VGltZVBvaW50RGF0YSh0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9pbnREYXRhQnlUaW1lUG9pbnQuc2V0KGhvcnpJdGVtS2V5LCB0aW1lUG9pbnREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaXNUaW1lU2NhbGVBZmZlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGNyZWF0ZVBsb3RSb3codGltZSwgdGltZVBvaW50RGF0YS5faW50ZXJuYWxfaW5kZXgsIGl0ZW0sIG9yaWdpbmFsVGltZXNbaW5kZXhdLCBkYXRhVG9QbG90Um93LCBjdXN0b21XaGl0ZXNwYWNlQ2hlY2tlcik7XG4gICAgICAgICAgICAgICAgdGltZVBvaW50RGF0YS5faW50ZXJuYWxfbWFwcGluZy5zZXQoc2VyaWVzLCByb3cpO1xuICAgICAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZENsZWFudXBQb2ludHMpIHtcbiAgICAgICAgICAgIC8vIHdlIGRlbGV0ZWQgdGhlIG9sZCBkYXRhIGZyb20gbWFwcGluZyBhbmQgYWRkZWQgdGhlIG5ldyBvbmVzXG4gICAgICAgICAgICAvLyBzbyB0aGVyZSBtaWdodCBiZSBlbXB0eSBwb2ludHMgbm93LCBsZXQncyByZW1vdmUgdGhlbSBmaXJzdFxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYW51cFBvaW50c0RhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRSb3dzVG9TZXJpZXMoc2VyaWVzLCBzZXJpZXNSb3dzKTtcbiAgICAgICAgbGV0IGZpcnN0Q2hhbmdlZFBvaW50SW5kZXggPSAtMTtcbiAgICAgICAgaWYgKGlzVGltZVNjYWxlQWZmZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIHRoZW4gZ2VuZXJhdGUgdGhlIHRpbWUgc2NhbGUgcG9pbnRzXG4gICAgICAgICAgICAvLyB0aW1lV2VpZ2h0IHdpbGwgYmUgdXBkYXRlcyBpbiBfdXBkYXRlVGltZVNjYWxlUG9pbnRzIGxhdGVyXG4gICAgICAgICAgICBjb25zdCBuZXdUaW1lU2NhbGVQb2ludHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BvaW50RGF0YUJ5VGltZVBvaW50LmZvckVhY2goKHBvaW50RGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIG5ld1RpbWVTY2FsZVBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGltZVdlaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgdGltZTogcG9pbnREYXRhLl9pbnRlcm5hbF90aW1lUG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxUaW1lOiB0aW1lU2NhbGVQb2ludFRpbWUocG9pbnREYXRhLl9pbnRlcm5hbF9tYXBwaW5nKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3VGltZVNjYWxlUG9pbnRzLnNvcnQoKHQxLCB0MikgPT4gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KHQxLnRpbWUpIC0gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KHQyLnRpbWUpKTtcbiAgICAgICAgICAgIGZpcnN0Q2hhbmdlZFBvaW50SW5kZXggPSB0aGlzLl9wcml2YXRlX19yZXBsYWNlVGltZVNjYWxlUG9pbnRzKG5ld1RpbWVTY2FsZVBvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2dldFVwZGF0ZVJlc3BvbnNlKHNlcmllcywgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCwgc2VyaWVzVXBkYXRlSW5mbyh0aGlzLl9wcml2YXRlX19zZXJpZXNSb3dzQnlTZXJpZXMuZ2V0KHNlcmllcyksIHByZXZTZXJpZXNSb3dzLCB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvcikpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVtb3ZlU2VyaWVzKHNlcmllcykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfc2V0U2VyaWVzRGF0YShzZXJpZXMsIFtdKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZVNlcmllc0RhdGEoc2VyaWVzLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuZGVkRGF0YSA9IGRhdGE7XG4gICAgICAgIHNhdmVPcmlnaW5hbFRpbWUoZXh0ZW5kZWREYXRhKTtcbiAgICAgICAgLy8gY29udmVydFN0cmluZ1RvQnVzaW5lc3NEYXkoZGF0YSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLnByZXByb2Nlc3NEYXRhKGRhdGEpO1xuICAgICAgICBjb25zdCB0aW1lQ29udmVydGVyID0gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IuY3JlYXRlQ29udmVydGVyVG9JbnRlcm5hbE9iaihbZGF0YV0pO1xuICAgICAgICBjb25zdCB0aW1lID0gdGltZUNvbnZlcnRlcihkYXRhLnRpbWUpO1xuICAgICAgICBjb25zdCBsYXN0U2VyaWVzVGltZSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllc0xhc3RUaW1lUG9pbnQuZ2V0KHNlcmllcyk7XG4gICAgICAgIGlmIChsYXN0U2VyaWVzVGltZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleSh0aW1lKSA8IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleShsYXN0U2VyaWVzVGltZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHVwZGF0ZSBvbGRlc3QgZGF0YSwgbGFzdCB0aW1lPSR7bGFzdFNlcmllc1RpbWV9LCBuZXcgdGltZT0ke3RpbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvaW50RGF0YUF0VGltZSA9IHRoaXMuX3ByaXZhdGVfX3BvaW50RGF0YUJ5VGltZVBvaW50LmdldCh0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkodGltZSkpO1xuICAgICAgICAvLyBpZiBubyBwb2ludCBkYXRhIGZvdW5kIGZvciB0aGUgbmV3IGRhdGEgaXRlbVxuICAgICAgICAvLyB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB1cGRhdGUgc2NhbGVcbiAgICAgICAgY29uc3QgYWZmZWN0c1RpbWVTY2FsZSA9IHBvaW50RGF0YUF0VGltZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocG9pbnREYXRhQXRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBpbmRleGVzIHdpbGwgYmUgc3luYyBsYXRlclxuICAgICAgICAgICAgcG9pbnREYXRhQXRUaW1lID0gY3JlYXRlRW1wdHlUaW1lUG9pbnREYXRhKHRpbWUpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9pbnREYXRhQnlUaW1lUG9pbnQuc2V0KHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleSh0aW1lKSwgcG9pbnREYXRhQXRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdGVQbG90Um93ID0gZ2V0U2VyaWVzUGxvdFJvd0NyZWF0b3Ioc2VyaWVzLl9pbnRlcm5hbF9zZXJpZXNUeXBlKCkpO1xuICAgICAgICBjb25zdCBkYXRhVG9QbG90Um93ID0gc2VyaWVzLl9pbnRlcm5hbF9jdXN0b21TZXJpZXNQbG90VmFsdWVzQnVpbGRlcigpO1xuICAgICAgICBjb25zdCBjdXN0b21XaGl0ZXNwYWNlQ2hlY2tlciA9IHNlcmllcy5faW50ZXJuYWxfY3VzdG9tU2VyaWVzV2hpdGVzcGFjZUNoZWNrKCk7XG4gICAgICAgIGNvbnN0IHBsb3RSb3cgPSBjcmVhdGVQbG90Um93KHRpbWUsIHBvaW50RGF0YUF0VGltZS5faW50ZXJuYWxfaW5kZXgsIGRhdGEsIGV4dGVuZGVkRGF0YS5faW50ZXJuYWxfb3JpZ2luYWxUaW1lLCBkYXRhVG9QbG90Um93LCBjdXN0b21XaGl0ZXNwYWNlQ2hlY2tlcik7XG4gICAgICAgIHBvaW50RGF0YUF0VGltZS5faW50ZXJuYWxfbWFwcGluZy5zZXQoc2VyaWVzLCBwbG90Um93KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlTGFzdFNlcmllc1JvdyhzZXJpZXMsIHBsb3RSb3cpO1xuICAgICAgICBjb25zdCBpbmZvID0geyBfaW50ZXJuYWxfbGFzdEJhclVwZGF0ZWRPck5ld0JhcnNBZGRlZFRvVGhlUmlnaHQ6IGlzU2VyaWVzUGxvdFJvdyhwbG90Um93KSB9O1xuICAgICAgICAvLyBpZiBwb2ludCBhbHJlYWR5IGV4aXN0IG9uIHRoZSB0aW1lIHNjYWxlIC0gd2UgZG9uJ3QgbmVlZCB0byBtYWtlIGEgZnVsbCB1cGRhdGUgYW5kIGp1c3QgbWFrZSBhbiBpbmNyZW1lbnRhbCBvbmVcbiAgICAgICAgaWYgKCFhZmZlY3RzVGltZVNjYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZ2V0VXBkYXRlUmVzcG9uc2Uoc2VyaWVzLCAtMSwgaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3UG9pbnQgPSB7XG4gICAgICAgICAgICB0aW1lV2VpZ2h0OiAwLFxuICAgICAgICAgICAgdGltZTogcG9pbnREYXRhQXRUaW1lLl9pbnRlcm5hbF90aW1lUG9pbnQsXG4gICAgICAgICAgICBwb2ludERhdGE6IHBvaW50RGF0YUF0VGltZSxcbiAgICAgICAgICAgIG9yaWdpbmFsVGltZTogdGltZVNjYWxlUG9pbnRUaW1lKHBvaW50RGF0YUF0VGltZS5faW50ZXJuYWxfbWFwcGluZyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGluc2VydEluZGV4ID0gbG93ZXJCb3VuZCh0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzLCB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkobmV3UG9pbnQudGltZSksIChhLCBiKSA9PiB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkoYS50aW1lKSA8IGIpO1xuICAgICAgICAvLyB5ZXMsIEkga25vdyB0aGF0IHRoaXMgYXJyYXkgaXMgcmVhZG9ubHkgYW5kIHRoaXMgY2hhbmdlIGlzIGludGVuZGVkIHRvIG1ha2UgaXQgcGVyZm9ybWF0aXZlXG4gICAgICAgIC8vIHdlIG1hcmtlZCBfc29ydGVkVGltZVBvaW50cyBhcnJheSBhcyByZWFkb25seSB0byBhdm9pZCBtb2RpZnlpbmcgdGhpcyBhcnJheSBhbnl3aGVyZSBlbHNlXG4gICAgICAgIC8vIGJ1dCB0aGlzIHBsYWNlIGlzIGV4Y2VwdGlvbmFsIGNhc2UgZHVlIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHNvcnJ5XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NvcnRlZFRpbWVQb2ludHMuc3BsaWNlKGluc2VydEluZGV4LCAwLCBuZXdQb2ludCk7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gaW5zZXJ0SW5kZXg7IGluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGFzc2lnbkluZGV4VG9Qb2ludERhdGEodGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50c1tpbmRleF0ucG9pbnREYXRhLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IuZmlsbFdlaWdodHNGb3JQb2ludHModGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cywgaW5zZXJ0SW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZ2V0VXBkYXRlUmVzcG9uc2Uoc2VyaWVzLCBpbnNlcnRJbmRleCwgaW5mbyk7XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVMYXN0U2VyaWVzUm93KHNlcmllcywgcGxvdFJvdykge1xuICAgICAgICBsZXQgc2VyaWVzRGF0YSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllc1Jvd3NCeVNlcmllcy5nZXQoc2VyaWVzKTtcbiAgICAgICAgaWYgKHNlcmllc0RhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2VyaWVzRGF0YSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLnNldChzZXJpZXMsIHNlcmllc0RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3RTZXJpZXNSb3cgPSBzZXJpZXNEYXRhLmxlbmd0aCAhPT0gMCA/IHNlcmllc0RhdGFbc2VyaWVzRGF0YS5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgIGlmIChsYXN0U2VyaWVzUm93ID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleShwbG90Um93Ll9pbnRlcm5hbF90aW1lKSA+IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleShsYXN0U2VyaWVzUm93Ll9pbnRlcm5hbF90aW1lKSkge1xuICAgICAgICAgICAgaWYgKGlzU2VyaWVzUGxvdFJvdyhwbG90Um93KSkge1xuICAgICAgICAgICAgICAgIHNlcmllc0RhdGEucHVzaChwbG90Um93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1Nlcmllc1Bsb3RSb3cocGxvdFJvdykpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNEYXRhW3Nlcmllc0RhdGEubGVuZ3RoIC0gMV0gPSBwbG90Um93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzRGF0YS5zcGxpY2UoLTEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc0xhc3RUaW1lUG9pbnQuc2V0KHNlcmllcywgcGxvdFJvdy5faW50ZXJuYWxfdGltZSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19zZXRSb3dzVG9TZXJpZXMoc2VyaWVzLCBzZXJpZXNSb3dzKSB7XG4gICAgICAgIGlmIChzZXJpZXNSb3dzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLnNldChzZXJpZXMsIHNlcmllc1Jvd3MuZmlsdGVyKGlzU2VyaWVzUGxvdFJvdykpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTGFzdFRpbWVQb2ludC5zZXQoc2VyaWVzLCBzZXJpZXNSb3dzW3Nlcmllc1Jvd3MubGVuZ3RoIC0gMV0uX2ludGVybmFsX3RpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLmRlbGV0ZShzZXJpZXMpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTGFzdFRpbWVQb2ludC5kZWxldGUoc2VyaWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fY2xlYW51cFBvaW50c0RhdGEoKSB7XG4gICAgICAgIC8vIGxldCdzIHRyZWF0IGFsbCBjdXJyZW50IHBvaW50cyBhcyBcInBvdGVudGlhbGx5IHJlbW92ZWRcIlxuICAgICAgICAvLyB3ZSBjb3VsZCBjcmVhdGUgYW4gYXJyYXkgd2l0aCBhY3R1YWxseSBwb3RlbnRpYWxseSByZW1vdmVkIHBvaW50c1xuICAgICAgICAvLyBidXQgbW9zdCBsaWtlbHkgdGhpcyBhcnJheSB3aWxsIGJlIHNpbWlsYXIgdG8gX3NvcnRlZFRpbWVQb2ludHMgc28gbGV0J3MgYXZvaWQgdXNpbmcgYWRkaXRpb25hbCBtZW1vcnlcbiAgICAgICAgLy8gbm90ZSB0aGF0IHdlIGNhbiB1c2UgX3NvcnRlZFRpbWVQb2ludHMgaGVyZSBzaW5jZSBhIHBvaW50IG1pZ2h0IGJlIHJlbW92ZWQgb25seSBpdCB3YXMgaGVyZSBwcmV2aW91c2x5XG4gICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgdGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cykge1xuICAgICAgICAgICAgaWYgKHBvaW50LnBvaW50RGF0YS5faW50ZXJuYWxfbWFwcGluZy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9pbnREYXRhQnlUaW1lUG9pbnQuZGVsZXRlKHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleShwb2ludC50aW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBuZXcgdGltZSBzY2FsZSBhbmQgbWFrZSBpbmRleGVzIHZhbGlkIGZvciBhbGwgc2VyaWVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYW5nZWQgcG9pbnQgb3IgYC0xYCBpZiB0aGVyZSBpcyBubyBjaGFuZ2UuXG4gICAgICovXG4gICAgX3ByaXZhdGVfX3JlcGxhY2VUaW1lU2NhbGVQb2ludHMobmV3VGltZVBvaW50cykge1xuICAgICAgICBsZXQgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCA9IC0xO1xuICAgICAgICAvLyBzZWFyY2ggdGhlIGZpcnN0IGRpZmZlcmVudCBwb2ludCBhbmQgXCJzeW5jaW5nXCIgdGltZSB3ZWlnaHQgYnkgdGhlIHdheVxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cy5sZW5ndGggJiYgaW5kZXggPCBuZXdUaW1lUG9pbnRzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgY29uc3Qgb2xkUG9pbnQgPSB0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1BvaW50ID0gbmV3VGltZVBvaW50c1tpbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KG9sZFBvaW50LnRpbWUpICE9PSB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkobmV3UG9pbnQudGltZSkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdENoYW5nZWRQb2ludEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZS1hc3NpZ24gcG9pbnQncyB0aW1lIHdlaWdodCBmb3IgcG9pbnRzIGlmIHRpbWUgaXMgdGhlIHNhbWUgKGFuZCBhbGwgcHJpb3IgdGltZXMgd2FzIHRoZSBzYW1lKVxuICAgICAgICAgICAgbmV3UG9pbnQudGltZVdlaWdodCA9IG9sZFBvaW50LnRpbWVXZWlnaHQ7XG4gICAgICAgICAgICBhc3NpZ25JbmRleFRvUG9pbnREYXRhKG5ld1BvaW50LnBvaW50RGF0YSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdENoYW5nZWRQb2ludEluZGV4ID09PSAtMSAmJiB0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzLmxlbmd0aCAhPT0gbmV3VGltZVBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHRoZSBjb21tb24gcGFydCBvZiB0aGUgcHJldiBhbmQgdGhlIG5ldyBwb2ludHMgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyBzbyB0aGUgZmlyc3QgY2hhbmdlZCBwb2ludCBpcyB0aGUgbmV4dCBhZnRlciB0aGUgY29tbW9uIHBhcnRcbiAgICAgICAgICAgIGZpcnN0Q2hhbmdlZFBvaW50SW5kZXggPSBNYXRoLm1pbih0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzLmxlbmd0aCwgbmV3VGltZVBvaW50cy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdENoYW5nZWRQb2ludEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gaWYgbm8gdGltZSBzY2FsZSBjaGFuZ2VkLCB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aW1lIHNjYWxlIHBvaW50cyBhcmUgY2hhbmdlZCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBtYWtlIGZ1bGwgdXBkYXRlIHRvIGFsbCBzZXJpZXMgKHdpdGggY2xlYXJpbmcgcG9pbnRzKVxuICAgICAgICAvLyBidXQgZmlyc3Qgd2UgbmVlZCB0byBzeW5jaHJvbml6ZSBpbmRleGVzIGFuZCByZS1maWxsIHRpbWUgd2VpZ2h0c1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IGZpcnN0Q2hhbmdlZFBvaW50SW5kZXg7IGluZGV4IDwgbmV3VGltZVBvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGFzc2lnbkluZGV4VG9Qb2ludERhdGEobmV3VGltZVBvaW50c1tpbmRleF0ucG9pbnREYXRhLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmUtZmlsbCB0aW1lIHdlaWdodHMgZm9yIHBvaW50IGFmdGVyIHRoZSBmaXJzdCBjaGFuZ2VkIG9uZVxuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5maWxsV2VpZ2h0c0ZvclBvaW50cyhuZXdUaW1lUG9pbnRzLCBmaXJzdENoYW5nZWRQb2ludEluZGV4KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cyA9IG5ld1RpbWVQb2ludHM7XG4gICAgICAgIHJldHVybiBmaXJzdENoYW5nZWRQb2ludEluZGV4O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZ2V0QmFzZUluZGV4KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbm8gZGF0YSB0aGVuICdyZXNldCcgdGhlIGJhc2UgaW5kZXggdG8gbnVsbFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJhc2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc1Jvd3NCeVNlcmllcy5mb3JFYWNoKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBiYXNlSW5kZXggPSBNYXRoLm1heChiYXNlSW5kZXgsIGRhdGFbZGF0YS5sZW5ndGggLSAxXS5faW50ZXJuYWxfaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJhc2VJbmRleDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldFVwZGF0ZVJlc3BvbnNlKHVwZGF0ZWRTZXJpZXMsIGZpcnN0Q2hhbmdlZFBvaW50SW5kZXgsIGluZm8pIHtcbiAgICAgICAgY29uc3QgZGF0YVVwZGF0ZVJlc3BvbnNlID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX3NlcmllczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgX2ludGVybmFsX3RpbWVTY2FsZToge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlSW5kZXg6IHRoaXMuX3ByaXZhdGVfX2dldEJhc2VJbmRleCgpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZpcnN0Q2hhbmdlZFBvaW50SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpdCdzIHBvc3NpYmxlIHRvIG1ha2UgcGVyZiBpbXByb3ZlbWVudHMgYnkgY2hlY2tpbmcgd2hhdCBzZXJpZXMgaGFzIGRhdGEgYWZ0ZXIgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleFxuICAgICAgICAgICAgLy8gYnV0IGxldCdzIHNraXAgZm9yIG5vd1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLmZvckVhY2goKGRhdGEsIHMpID0+IHtcbiAgICAgICAgICAgICAgICBkYXRhVXBkYXRlUmVzcG9uc2UuX2ludGVybmFsX3Nlcmllcy5zZXQocywge1xuICAgICAgICAgICAgICAgICAgICBfaW50ZXJuYWxfZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX2luZm86IHMgPT09IHVwZGF0ZWRTZXJpZXMgPyBpbmZvIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBpZiB0aGUgc2VyaWVzIGRhdGEgd2FzIHNldCB0byBbXSBpdCB3aWxsIGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZnJvbSBfc2VyaWVzUm93QnlTZXJpZXNcbiAgICAgICAgICAgIC8vIG1lYW5pbmcgdGhlIGZvckVhY2ggYWJvdmUgd29uJ3QgYWRkIHRoZSBzZXJpZXMgdG8gdGhlIGRhdGEgdXBkYXRlIHJlc3BvbnNlXG4gICAgICAgICAgICAvLyBzbyB3ZSBoYW5kbGUgdGhhdCBjYXNlIGhlcmVcbiAgICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLmhhcyh1cGRhdGVkU2VyaWVzKSkge1xuICAgICAgICAgICAgICAgIGRhdGFVcGRhdGVSZXNwb25zZS5faW50ZXJuYWxfc2VyaWVzLnNldCh1cGRhdGVkU2VyaWVzLCB7IF9pbnRlcm5hbF9kYXRhOiBbXSwgX2ludGVybmFsX2luZm86IGluZm8gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhVXBkYXRlUmVzcG9uc2UuX2ludGVybmFsX3RpbWVTY2FsZS5faW50ZXJuYWxfcG9pbnRzID0gdGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cztcbiAgICAgICAgICAgIGRhdGFVcGRhdGVSZXNwb25zZS5faW50ZXJuYWxfdGltZVNjYWxlLl9pbnRlcm5hbF9maXJzdENoYW5nZWRQb2ludEluZGV4ID0gZmlyc3RDaGFuZ2VkUG9pbnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc0RhdGEgPSB0aGlzLl9wcml2YXRlX19zZXJpZXNSb3dzQnlTZXJpZXMuZ2V0KHVwZGF0ZWRTZXJpZXMpO1xuICAgICAgICAgICAgLy8gaWYgbm8gc2VyaWVzRGF0YSBmb3VuZCB0aGF0IG1lYW5zIHRoYXQgd2UganVzdCByZW1vdmVkIHRoZSBzZXJpZXNcbiAgICAgICAgICAgIGRhdGFVcGRhdGVSZXNwb25zZS5faW50ZXJuYWxfc2VyaWVzLnNldCh1cGRhdGVkU2VyaWVzLCB7IF9pbnRlcm5hbF9kYXRhOiBzZXJpZXNEYXRhIHx8IFtdLCBfaW50ZXJuYWxfaW5mbzogaW5mbyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVVwZGF0ZVJlc3BvbnNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2lnbkluZGV4VG9Qb2ludERhdGEocG9pbnREYXRhLCBpbmRleCkge1xuICAgIC8vIGZpcnN0LCBuZXZlcnRoZWxlc3MgdXBkYXRlIGluZGV4IG9mIHBvaW50IGRhdGEgKFwibWFrZSBpdCB2YWxpZFwiKVxuICAgIHBvaW50RGF0YS5faW50ZXJuYWxfaW5kZXggPSBpbmRleDtcbiAgICAvLyBhbmQgdGhlbiB3ZSBuZWVkIHRvIHN5bmMgaW5kZXhlcyBmb3IgYWxsIHNlcmllc1xuICAgIHBvaW50RGF0YS5faW50ZXJuYWxfbWFwcGluZy5mb3JFYWNoKChzZXJpZXNSb3cpID0+IHtcbiAgICAgICAgc2VyaWVzUm93Ll9pbnRlcm5hbF9pbmRleCA9IGluZGV4O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzaW5nbGVWYWx1ZURhdGEocGxvdFJvdykge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIHZhbHVlOiBwbG90Um93Ll9pbnRlcm5hbF92YWx1ZVszIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkNsb3NlICovXSxcbiAgICAgICAgdGltZTogcGxvdFJvdy5faW50ZXJuYWxfb3JpZ2luYWxUaW1lLFxuICAgIH07XG4gICAgaWYgKHBsb3RSb3cuX2ludGVybmFsX2N1c3RvbVZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGEuY3VzdG9tVmFsdWVzID0gcGxvdFJvdy5faW50ZXJuYWxfY3VzdG9tVmFsdWVzO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGxpbmVEYXRhKHBsb3RSb3cpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzaW5nbGVWYWx1ZURhdGEocGxvdFJvdyk7XG4gICAgaWYgKHBsb3RSb3cuX2ludGVybmFsX2NvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LmNvbG9yID0gcGxvdFJvdy5faW50ZXJuYWxfY29sb3I7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhcmVhRGF0YShwbG90Um93KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc2luZ2xlVmFsdWVEYXRhKHBsb3RSb3cpO1xuICAgIGlmIChwbG90Um93Ll9pbnRlcm5hbF9saW5lQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQubGluZUNvbG9yID0gcGxvdFJvdy5faW50ZXJuYWxfbGluZUNvbG9yO1xuICAgIH1cbiAgICBpZiAocGxvdFJvdy5faW50ZXJuYWxfdG9wQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQudG9wQ29sb3IgPSBwbG90Um93Ll9pbnRlcm5hbF90b3BDb2xvcjtcbiAgICB9XG4gICAgaWYgKHBsb3RSb3cuX2ludGVybmFsX2JvdHRvbUNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LmJvdHRvbUNvbG9yID0gcGxvdFJvdy5faW50ZXJuYWxfYm90dG9tQ29sb3I7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBiYXNlbGluZURhdGEocGxvdFJvdykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHNpbmdsZVZhbHVlRGF0YShwbG90Um93KTtcbiAgICBpZiAocGxvdFJvdy5faW50ZXJuYWxfdG9wTGluZUNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LnRvcExpbmVDb2xvciA9IHBsb3RSb3cuX2ludGVybmFsX3RvcExpbmVDb2xvcjtcbiAgICB9XG4gICAgaWYgKHBsb3RSb3cuX2ludGVybmFsX2JvdHRvbUxpbmVDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC5ib3R0b21MaW5lQ29sb3IgPSBwbG90Um93Ll9pbnRlcm5hbF9ib3R0b21MaW5lQ29sb3I7XG4gICAgfVxuICAgIGlmIChwbG90Um93Ll9pbnRlcm5hbF90b3BGaWxsQ29sb3IxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LnRvcEZpbGxDb2xvcjEgPSBwbG90Um93Ll9pbnRlcm5hbF90b3BGaWxsQ29sb3IxO1xuICAgIH1cbiAgICBpZiAocGxvdFJvdy5faW50ZXJuYWxfdG9wRmlsbENvbG9yMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC50b3BGaWxsQ29sb3IyID0gcGxvdFJvdy5faW50ZXJuYWxfdG9wRmlsbENvbG9yMjtcbiAgICB9XG4gICAgaWYgKHBsb3RSb3cuX2ludGVybmFsX2JvdHRvbUZpbGxDb2xvcjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQuYm90dG9tRmlsbENvbG9yMSA9IHBsb3RSb3cuX2ludGVybmFsX2JvdHRvbUZpbGxDb2xvcjE7XG4gICAgfVxuICAgIGlmIChwbG90Um93Ll9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LmJvdHRvbUZpbGxDb2xvcjIgPSBwbG90Um93Ll9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IyO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gb2hsY0RhdGEocGxvdFJvdykge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIG9wZW46IHBsb3RSb3cuX2ludGVybmFsX3ZhbHVlWzAgLyogUGxvdFJvd1ZhbHVlSW5kZXguT3BlbiAqL10sXG4gICAgICAgIGhpZ2g6IHBsb3RSb3cuX2ludGVybmFsX3ZhbHVlWzEgLyogUGxvdFJvd1ZhbHVlSW5kZXguSGlnaCAqL10sXG4gICAgICAgIGxvdzogcGxvdFJvdy5faW50ZXJuYWxfdmFsdWVbMiAvKiBQbG90Um93VmFsdWVJbmRleC5Mb3cgKi9dLFxuICAgICAgICBjbG9zZTogcGxvdFJvdy5faW50ZXJuYWxfdmFsdWVbMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqL10sXG4gICAgICAgIHRpbWU6IHBsb3RSb3cuX2ludGVybmFsX29yaWdpbmFsVGltZSxcbiAgICB9O1xuICAgIGlmIChwbG90Um93Ll9pbnRlcm5hbF9jdXN0b21WYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkYXRhLmN1c3RvbVZhbHVlcyA9IHBsb3RSb3cuX2ludGVybmFsX2N1c3RvbVZhbHVlcztcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBiYXJEYXRhKHBsb3RSb3cpIHtcbiAgICBjb25zdCByZXN1bHQgPSBvaGxjRGF0YShwbG90Um93KTtcbiAgICBpZiAocGxvdFJvdy5faW50ZXJuYWxfY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQuY29sb3IgPSBwbG90Um93Ll9pbnRlcm5hbF9jb2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNhbmRsZXN0aWNrRGF0YShwbG90Um93KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gb2hsY0RhdGEocGxvdFJvdyk7XG4gICAgY29uc3QgeyBfaW50ZXJuYWxfY29sb3I6IGNvbG9yLCBfaW50ZXJuYWxfYm9yZGVyQ29sb3I6IGJvcmRlckNvbG9yLCBfaW50ZXJuYWxfd2lja0NvbG9yOiB3aWNrQ29sb3IgfSA9IHBsb3RSb3c7XG4gICAgaWYgKGNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LmNvbG9yID0gY29sb3I7XG4gICAgfVxuICAgIGlmIChib3JkZXJDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC5ib3JkZXJDb2xvciA9IGJvcmRlckNvbG9yO1xuICAgIH1cbiAgICBpZiAod2lja0NvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LndpY2tDb2xvciA9IHdpY2tDb2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFNlcmllc0RhdGFDcmVhdG9yKHNlcmllc1R5cGUpIHtcbiAgICBjb25zdCBzZXJpZXNQbG90Um93VG9EYXRhTWFwID0ge1xuICAgICAgICBBcmVhOiAoYXJlYURhdGEpLFxuICAgICAgICBMaW5lOiAobGluZURhdGEpLFxuICAgICAgICBCYXNlbGluZTogKGJhc2VsaW5lRGF0YSksXG4gICAgICAgIEhpc3RvZ3JhbTogKGxpbmVEYXRhKSxcbiAgICAgICAgQmFyOiAoYmFyRGF0YSksXG4gICAgICAgIENhbmRsZXN0aWNrOiAoY2FuZGxlc3RpY2tEYXRhKSxcbiAgICAgICAgQ3VzdG9tOiAoY3VzdG9tRGF0YSksXG4gICAgfTtcbiAgICByZXR1cm4gc2VyaWVzUGxvdFJvd1RvRGF0YU1hcFtzZXJpZXNUeXBlXTtcbn1cbmZ1bmN0aW9uIGN1c3RvbURhdGEocGxvdFJvdykge1xuICAgIGNvbnN0IHRpbWUgPSBwbG90Um93Ll9pbnRlcm5hbF9vcmlnaW5hbFRpbWU7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGxvdFJvdy5faW50ZXJuYWxfZGF0YSksIHsgdGltZSB9KTtcbn1cblxuY29uc3QgY3Jvc3NoYWlyT3B0aW9uc0RlZmF1bHRzID0ge1xuICAgIHZlcnRMaW5lOiB7XG4gICAgICAgIGNvbG9yOiAnIzk1OThBMScsXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBzdHlsZTogMyAvKiBMaW5lU3R5bGUuTGFyZ2VEYXNoZWQgKi8sXG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIGxhYmVsVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgbGFiZWxCYWNrZ3JvdW5kQ29sb3I6ICcjMTMxNzIyJyxcbiAgICB9LFxuICAgIGhvcnpMaW5lOiB7XG4gICAgICAgIGNvbG9yOiAnIzk1OThBMScsXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBzdHlsZTogMyAvKiBMaW5lU3R5bGUuTGFyZ2VEYXNoZWQgKi8sXG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIGxhYmVsVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgbGFiZWxCYWNrZ3JvdW5kQ29sb3I6ICcjMTMxNzIyJyxcbiAgICB9LFxuICAgIG1vZGU6IDEgLyogQ3Jvc3NoYWlyTW9kZS5NYWduZXQgKi8sXG59O1xuXG5jb25zdCBncmlkT3B0aW9uc0RlZmF1bHRzID0ge1xuICAgIHZlcnRMaW5lczoge1xuICAgICAgICBjb2xvcjogJyNENkRDREUnLFxuICAgICAgICBzdHlsZTogMCAvKiBMaW5lU3R5bGUuU29saWQgKi8sXG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgfSxcbiAgICBob3J6TGluZXM6IHtcbiAgICAgICAgY29sb3I6ICcjRDZEQ0RFJyxcbiAgICAgICAgc3R5bGU6IDAgLyogTGluZVN0eWxlLlNvbGlkICovLFxuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgIH0sXG59O1xuXG5jb25zdCBsYXlvdXRPcHRpb25zRGVmYXVsdHMgPSB7XG4gICAgYmFja2dyb3VuZDoge1xuICAgICAgICB0eXBlOiBcInNvbGlkXCIgLyogQ29sb3JUeXBlLlNvbGlkICovLFxuICAgICAgICBjb2xvcjogJyNGRkZGRkYnLFxuICAgIH0sXG4gICAgdGV4dENvbG9yOiAnIzE5MTkxOScsXG4gICAgZm9udFNpemU6IDEyLFxuICAgIGZvbnRGYW1pbHk6IGRlZmF1bHRGb250RmFtaWx5LFxufTtcblxuY29uc3QgcHJpY2VTY2FsZU9wdGlvbnNEZWZhdWx0cyA9IHtcbiAgICBhdXRvU2NhbGU6IHRydWUsXG4gICAgbW9kZTogMCAvKiBQcmljZVNjYWxlTW9kZS5Ob3JtYWwgKi8sXG4gICAgaW52ZXJ0U2NhbGU6IGZhbHNlLFxuICAgIGFsaWduTGFiZWxzOiB0cnVlLFxuICAgIGJvcmRlclZpc2libGU6IHRydWUsXG4gICAgYm9yZGVyQ29sb3I6ICcjMkIyQjQzJyxcbiAgICBlbnRpcmVUZXh0T25seTogZmFsc2UsXG4gICAgdmlzaWJsZTogZmFsc2UsXG4gICAgdGlja3NWaXNpYmxlOiBmYWxzZSxcbiAgICBzY2FsZU1hcmdpbnM6IHtcbiAgICAgICAgYm90dG9tOiAwLjEsXG4gICAgICAgIHRvcDogMC4yLFxuICAgIH0sXG4gICAgbWluaW11bVdpZHRoOiAwLFxufTtcblxuY29uc3QgdGltZVNjYWxlT3B0aW9uc0RlZmF1bHRzID0ge1xuICAgIHJpZ2h0T2Zmc2V0OiAwLFxuICAgIGJhclNwYWNpbmc6IDYsXG4gICAgbWluQmFyU3BhY2luZzogMC41LFxuICAgIGZpeExlZnRFZGdlOiBmYWxzZSxcbiAgICBmaXhSaWdodEVkZ2U6IGZhbHNlLFxuICAgIGxvY2tWaXNpYmxlVGltZVJhbmdlT25SZXNpemU6IGZhbHNlLFxuICAgIHJpZ2h0QmFyU3RheXNPblNjcm9sbDogZmFsc2UsXG4gICAgYm9yZGVyVmlzaWJsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxuICAgIHZpc2libGU6IHRydWUsXG4gICAgdGltZVZpc2libGU6IGZhbHNlLFxuICAgIHNlY29uZHNWaXNpYmxlOiB0cnVlLFxuICAgIHNoaWZ0VmlzaWJsZVJhbmdlT25OZXdCYXI6IHRydWUsXG4gICAgYWxsb3dTaGlmdFZpc2libGVSYW5nZU9uV2hpdGVzcGFjZVJlcGxhY2VtZW50OiBmYWxzZSxcbiAgICB0aWNrc1Zpc2libGU6IGZhbHNlLFxuICAgIHVuaWZvcm1EaXN0cmlidXRpb246IGZhbHNlLFxuICAgIG1pbmltdW1IZWlnaHQ6IDAsXG59O1xuXG5jb25zdCB3YXRlcm1hcmtPcHRpb25zRGVmYXVsdHMgPSB7XG4gICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDApJyxcbiAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICBmb250U2l6ZTogNDgsXG4gICAgZm9udEZhbWlseTogZGVmYXVsdEZvbnRGYW1pbHksXG4gICAgZm9udFN0eWxlOiAnJyxcbiAgICB0ZXh0OiAnJyxcbiAgICBob3J6QWxpZ246ICdjZW50ZXInLFxuICAgIHZlcnRBbGlnbjogJ2NlbnRlcicsXG59O1xuXG5mdW5jdGlvbiBjaGFydE9wdGlvbnNEZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBhdXRvU2l6ZTogZmFsc2UsXG4gICAgICAgIGxheW91dDogbGF5b3V0T3B0aW9uc0RlZmF1bHRzLFxuICAgICAgICBjcm9zc2hhaXI6IGNyb3NzaGFpck9wdGlvbnNEZWZhdWx0cyxcbiAgICAgICAgZ3JpZDogZ3JpZE9wdGlvbnNEZWZhdWx0cyxcbiAgICAgICAgb3ZlcmxheVByaWNlU2NhbGVzOiBPYmplY3QuYXNzaWduKHt9LCBwcmljZVNjYWxlT3B0aW9uc0RlZmF1bHRzKSxcbiAgICAgICAgbGVmdFByaWNlU2NhbGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJpY2VTY2FsZU9wdGlvbnNEZWZhdWx0cyksIHsgdmlzaWJsZTogZmFsc2UgfSksXG4gICAgICAgIHJpZ2h0UHJpY2VTY2FsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmljZVNjYWxlT3B0aW9uc0RlZmF1bHRzKSwgeyB2aXNpYmxlOiB0cnVlIH0pLFxuICAgICAgICB0aW1lU2NhbGU6IHRpbWVTY2FsZU9wdGlvbnNEZWZhdWx0cyxcbiAgICAgICAgd2F0ZXJtYXJrOiB3YXRlcm1hcmtPcHRpb25zRGVmYXVsdHMsXG4gICAgICAgIGxvY2FsaXphdGlvbjoge1xuICAgICAgICAgICAgbG9jYWxlOiBpc1J1bm5pbmdPbkNsaWVudFNpZGUgPyBuYXZpZ2F0b3IubGFuZ3VhZ2UgOiAnJyxcbiAgICAgICAgICAgIGRhdGVGb3JtYXQ6ICdkZCBNTU0gXFwneXknLFxuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVTY3JvbGw6IHtcbiAgICAgICAgICAgIG1vdXNlV2hlZWw6IHRydWUsXG4gICAgICAgICAgICBwcmVzc2VkTW91c2VNb3ZlOiB0cnVlLFxuICAgICAgICAgICAgaG9yelRvdWNoRHJhZzogdHJ1ZSxcbiAgICAgICAgICAgIHZlcnRUb3VjaERyYWc6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZVNjYWxlOiB7XG4gICAgICAgICAgICBheGlzUHJlc3NlZE1vdXNlTW92ZToge1xuICAgICAgICAgICAgICAgIHRpbWU6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJpY2U6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXhpc0RvdWJsZUNsaWNrUmVzZXQ6IHtcbiAgICAgICAgICAgICAgICB0aW1lOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByaWNlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlV2hlZWw6IHRydWUsXG4gICAgICAgICAgICBwaW5jaDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAga2luZXRpY1Njcm9sbDoge1xuICAgICAgICAgICAgbW91c2U6IGZhbHNlLFxuICAgICAgICAgICAgdG91Y2g6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRyYWNraW5nTW9kZToge1xuICAgICAgICAgICAgZXhpdE1vZGU6IDEgLyogVHJhY2tpbmdNb2RlRXhpdE1vZGUuT25OZXh0VGFwICovLFxuICAgICAgICB9LFxuICAgIH07XG59XG5cbmNsYXNzIFByaWNlU2NhbGVBcGkge1xuICAgIGNvbnN0cnVjdG9yKGNoYXJ0V2lkZ2V0LCBwcmljZVNjYWxlSWQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQgPSBjaGFydFdpZGdldDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZUlkID0gcHJpY2VTY2FsZUlkO1xuICAgIH1cbiAgICBhcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfYXBwbHlQcmljZVNjYWxlT3B0aW9ucyh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgfVxuICAgIHdpZHRoKCkge1xuICAgICAgICBpZiAoIWlzRGVmYXVsdFByaWNlU2NhbGUodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZUlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9nZXRQcmljZUF4aXNXaWR0aCh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlSWQpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcHJpY2VTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2ZpbmRQcmljZVNjYWxlKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGVJZCkpLl9pbnRlcm5hbF9wcmljZVNjYWxlO1xuICAgIH1cbn1cblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJfYnVpbGQtdGltZS1jb25zdGFudHNcIiAvPlxuZnVuY3Rpb24gY2hlY2tQcmljZUxpbmVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3RzbGludC9jb25maWdcbiAgICBhc3NlcnQodHlwZW9mIG9wdGlvbnMucHJpY2UgPT09ICdudW1iZXInLCBgdGhlIHR5cGUgb2YgJ3ByaWNlJyBwcmljZSBsaW5lJ3MgcHJvcGVydHkgbXVzdCBiZSBhIG51bWJlciwgZ290ICcke3R5cGVvZiBvcHRpb25zLnByaWNlfSdgKTtcbn1cbmZ1bmN0aW9uIGNoZWNrSXRlbXNBcmVPcmRlcmVkKGRhdGEsIGJoLCBhbGxvd0R1cGxpY2F0ZXMgPSBmYWxzZSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwcmV2VGltZSA9IGJoLmtleShkYXRhWzBdLnRpbWUpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IGJoLmtleShkYXRhW2ldLnRpbWUpO1xuICAgICAgICBjb25zdCBjaGVja1Jlc3VsdCA9IGFsbG93RHVwbGljYXRlcyA/IHByZXZUaW1lIDw9IGN1cnJlbnRUaW1lIDogcHJldlRpbWUgPCBjdXJyZW50VGltZTtcbiAgICAgICAgYXNzZXJ0KGNoZWNrUmVzdWx0LCBgZGF0YSBtdXN0IGJlIGFzYyBvcmRlcmVkIGJ5IHRpbWUsIGluZGV4PSR7aX0sIHRpbWU9JHtjdXJyZW50VGltZX0sIHByZXYgdGltZT0ke3ByZXZUaW1lfWApO1xuICAgICAgICBwcmV2VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2VyaWVzVmFsdWVzVHlwZSh0eXBlLCBkYXRhKSB7XG4gICAgZGF0YS5mb3JFYWNoKGdldENoZWNrZXIodHlwZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q2hlY2tlcih0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ0Jhcic6XG4gICAgICAgIGNhc2UgJ0NhbmRsZXN0aWNrJzpcbiAgICAgICAgICAgIHJldHVybiBjaGVja0Jhckl0ZW0uYmluZChudWxsLCB0eXBlKTtcbiAgICAgICAgY2FzZSAnQXJlYSc6XG4gICAgICAgIGNhc2UgJ0Jhc2VsaW5lJzpcbiAgICAgICAgY2FzZSAnTGluZSc6XG4gICAgICAgIGNhc2UgJ0hpc3RvZ3JhbSc6XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tMaW5lSXRlbS5iaW5kKG51bGwsIHR5cGUpO1xuICAgICAgICBjYXNlICdDdXN0b20nOlxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrQ3VzdG9tSXRlbS5iaW5kKG51bGwsIHR5cGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQmFySXRlbSh0eXBlLCBiYXJJdGVtKSB7XG4gICAgaWYgKCFpc0Z1bGZpbGxlZERhdGEoYmFySXRlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3NlcnQoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC90c2xpbnQvY29uZmlnXG4gICAgdHlwZW9mIGJhckl0ZW0ub3BlbiA9PT0gJ251bWJlcicsIGAke3R5cGV9IHNlcmllcyBpdGVtIGRhdGEgdmFsdWUgb2Ygb3BlbiBtdXN0IGJlIGEgbnVtYmVyLCBnb3Q9JHt0eXBlb2YgYmFySXRlbS5vcGVufSwgdmFsdWU9JHtiYXJJdGVtLm9wZW59YCk7XG4gICAgYXNzZXJ0KFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdHNsaW50L2NvbmZpZ1xuICAgIHR5cGVvZiBiYXJJdGVtLmhpZ2ggPT09ICdudW1iZXInLCBgJHt0eXBlfSBzZXJpZXMgaXRlbSBkYXRhIHZhbHVlIG9mIGhpZ2ggbXVzdCBiZSBhIG51bWJlciwgZ290PSR7dHlwZW9mIGJhckl0ZW0uaGlnaH0sIHZhbHVlPSR7YmFySXRlbS5oaWdofWApO1xuICAgIGFzc2VydChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3RzbGludC9jb25maWdcbiAgICB0eXBlb2YgYmFySXRlbS5sb3cgPT09ICdudW1iZXInLCBgJHt0eXBlfSBzZXJpZXMgaXRlbSBkYXRhIHZhbHVlIG9mIGxvdyBtdXN0IGJlIGEgbnVtYmVyLCBnb3Q9JHt0eXBlb2YgYmFySXRlbS5sb3d9LCB2YWx1ZT0ke2Jhckl0ZW0ubG93fWApO1xuICAgIGFzc2VydChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3RzbGludC9jb25maWdcbiAgICB0eXBlb2YgYmFySXRlbS5jbG9zZSA9PT0gJ251bWJlcicsIGAke3R5cGV9IHNlcmllcyBpdGVtIGRhdGEgdmFsdWUgb2YgY2xvc2UgbXVzdCBiZSBhIG51bWJlciwgZ290PSR7dHlwZW9mIGJhckl0ZW0uY2xvc2V9LCB2YWx1ZT0ke2Jhckl0ZW0uY2xvc2V9YCk7XG59XG5mdW5jdGlvbiBjaGVja0xpbmVJdGVtKHR5cGUsIGxpbmVJdGVtKSB7XG4gICAgaWYgKCFpc0Z1bGZpbGxlZERhdGEobGluZUl0ZW0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXNzZXJ0KFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdHNsaW50L2NvbmZpZ1xuICAgIHR5cGVvZiBsaW5lSXRlbS52YWx1ZSA9PT0gJ251bWJlcicsIGAke3R5cGV9IHNlcmllcyBpdGVtIGRhdGEgdmFsdWUgbXVzdCBiZSBhIG51bWJlciwgZ290PSR7dHlwZW9mIGxpbmVJdGVtLnZhbHVlfSwgdmFsdWU9JHtsaW5lSXRlbS52YWx1ZX1gKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQ3VzdG9tSXRlbShcbi8vIHR5cGU6ICdDdXN0b20nLFxuLy8gY3VzdG9tSXRlbTogU2VyaWVzRGF0YUl0ZW1UeXBlTWFwW3R5cGVvZiB0eXBlXVxuKSB7XG4gICAgLy8gTm90aGluZyB0byBjaGVjayB5ZXQuLi5cbiAgICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRTZXJpZXNNYXJrZXIoc20sIG5ld1RpbWUsIG9yaWdpbmFsVGltZSkge1xuICAgIGNvbnN0IHZhbHVlcyA9IF9fcmVzdChzbSwgW1widGltZVwiLCBcIm9yaWdpbmFsVGltZVwiXSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1hc3NlcnRpb25zICovXG4gICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbih7IHRpbWU6IG5ld1RpbWUgfSwgdmFsdWVzKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtYXNzZXJ0aW9ucyAqL1xuICAgIGlmIChvcmlnaW5hbFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMub3JpZ2luYWxUaW1lID0gb3JpZ2luYWxUaW1lO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5jb25zdCBwcmljZUxpbmVPcHRpb25zRGVmYXVsdHMgPSB7XG4gICAgY29sb3I6ICcjRkYwMDAwJyxcbiAgICBwcmljZTogMCxcbiAgICBsaW5lU3R5bGU6IDIgLyogTGluZVN0eWxlLkRhc2hlZCAqLyxcbiAgICBsaW5lV2lkdGg6IDEsXG4gICAgbGluZVZpc2libGU6IHRydWUsXG4gICAgYXhpc0xhYmVsVmlzaWJsZTogdHJ1ZSxcbiAgICB0aXRsZTogJycsXG4gICAgYXhpc0xhYmVsQ29sb3I6ICcnLFxuICAgIGF4aXNMYWJlbFRleHRDb2xvcjogJycsXG59O1xuXG5jbGFzcyBQcmljZUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKHByaWNlTGluZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUxpbmUgPSBwcmljZUxpbmU7XG4gICAgfVxuICAgIGFwcGx5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZS5faW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZUxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmljZUxpbmU7XG4gICAgfVxufVxuXG5jbGFzcyBTZXJpZXNBcGkge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgZGF0YVVwZGF0ZXNDb25zdW1lciwgcHJpY2VTY2FsZUFwaVByb3ZpZGVyLCBjaGFydEFwaSwgaG9yelNjYWxlQmVoYXZpb3IpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YUNoYW5nZWREZWxlZ2F0ZSA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzID0gc2VyaWVzO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZGF0YVVwZGF0ZXNDb25zdW1lciA9IGRhdGFVcGRhdGVzQ29uc3VtZXI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGVBcGlQcm92aWRlciA9IHByaWNlU2NhbGVBcGlQcm92aWRlcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IgPSBob3J6U2NhbGVCZWhhdmlvcjtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2NoYXJ0QXBpID0gY2hhcnRBcGk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhQ2hhbmdlZERlbGVnYXRlLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgfVxuICAgIHByaWNlRm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfZm9ybWF0dGVyKCk7XG4gICAgfVxuICAgIHByaWNlVG9Db29yZGluYXRlKHByaWNlKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZShwcmljZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpO1xuICAgIH1cbiAgICBjb29yZGluYXRlVG9QcmljZShjb29yZGluYXRlKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9jb29yZGluYXRlVG9QcmljZShjb29yZGluYXRlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgfVxuICAgIGJhcnNJbkxvZ2ljYWxSYW5nZShyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIHVzZSBUaW1lU2NhbGVWaXNpYmxlUmFuZ2UgaGVyZSB0byBjb252ZXJ0IExvZ2ljYWxSYW5nZSB0byBzdHJpY3QgcmFuZ2UgcHJvcGVybHlcbiAgICAgICAgY29uc3QgY29ycmVjdGVkUmFuZ2UgPSBuZXcgVGltZVNjYWxlVmlzaWJsZVJhbmdlKG5ldyBSYW5nZUltcGwocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKS5faW50ZXJuYWxfc3RyaWN0UmFuZ2UoKTtcbiAgICAgICAgY29uc3QgYmFycyA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2JhcnMoKTtcbiAgICAgICAgaWYgKGJhcnMuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YUZpcnN0QmFySW5SYW5nZSA9IGJhcnMuX2ludGVybmFsX3NlYXJjaChjb3JyZWN0ZWRSYW5nZS5faW50ZXJuYWxfbGVmdCgpLCAxIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5lYXJlc3RSaWdodCAqLyk7XG4gICAgICAgIGNvbnN0IGRhdGFMYXN0QmFySW5SYW5nZSA9IGJhcnMuX2ludGVybmFsX3NlYXJjaChjb3JyZWN0ZWRSYW5nZS5faW50ZXJuYWxfcmlnaHQoKSwgLTEgLyogTWlzbWF0Y2hEaXJlY3Rpb24uTmVhcmVzdExlZnQgKi8pO1xuICAgICAgICBjb25zdCBkYXRhRmlyc3RJbmRleCA9IGVuc3VyZU5vdE51bGwoYmFycy5faW50ZXJuYWxfZmlyc3RJbmRleCgpKTtcbiAgICAgICAgY29uc3QgZGF0YUxhc3RJbmRleCA9IGVuc3VyZU5vdE51bGwoYmFycy5faW50ZXJuYWxfbGFzdEluZGV4KCkpO1xuICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgd2UgcmVxdWVzdCBkYXRhIGluIHRoZSBkYXRhIGdhcFxuICAgICAgICAvLyBlLmcuIGxldCdzIHNheSB3ZSBoYXZlIHNlcmllcyB3aXRoIGRhdGEgWzAuLjEwLCAzMC4uNjBdXG4gICAgICAgIC8vIGFuZCB3ZSByZXF1ZXN0IGJhcnMgaW5mbyBpbiByYW5nZSBbMTUsIDI1XVxuICAgICAgICAvLyB0aHVzLCBkYXRhRmlyc3RCYXJJblJhbmdlIHdpbGwgYmUgd2l0aCBpbmRleCAzMCBhbmQgZGF0YUxhc3RCYXJJblJhbmdlIHdpdGggMTBcbiAgICAgICAgaWYgKGRhdGFGaXJzdEJhckluUmFuZ2UgIT09IG51bGwgJiYgZGF0YUxhc3RCYXJJblJhbmdlICE9PSBudWxsICYmIGRhdGFGaXJzdEJhckluUmFuZ2UuX2ludGVybmFsX2luZGV4ID4gZGF0YUxhc3RCYXJJblJhbmdlLl9pbnRlcm5hbF9pbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiYXJzQmVmb3JlOiByYW5nZS5mcm9tIC0gZGF0YUZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgYmFyc0FmdGVyOiBkYXRhTGFzdEluZGV4IC0gcmFuZ2UudG8sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhcnNCZWZvcmUgPSAoZGF0YUZpcnN0QmFySW5SYW5nZSA9PT0gbnVsbCB8fCBkYXRhRmlyc3RCYXJJblJhbmdlLl9pbnRlcm5hbF9pbmRleCA9PT0gZGF0YUZpcnN0SW5kZXgpXG4gICAgICAgICAgICA/IHJhbmdlLmZyb20gLSBkYXRhRmlyc3RJbmRleFxuICAgICAgICAgICAgOiBkYXRhRmlyc3RCYXJJblJhbmdlLl9pbnRlcm5hbF9pbmRleCAtIGRhdGFGaXJzdEluZGV4O1xuICAgICAgICBjb25zdCBiYXJzQWZ0ZXIgPSAoZGF0YUxhc3RCYXJJblJhbmdlID09PSBudWxsIHx8IGRhdGFMYXN0QmFySW5SYW5nZS5faW50ZXJuYWxfaW5kZXggPT09IGRhdGFMYXN0SW5kZXgpXG4gICAgICAgICAgICA/IGRhdGFMYXN0SW5kZXggLSByYW5nZS50b1xuICAgICAgICAgICAgOiBkYXRhTGFzdEluZGV4IC0gZGF0YUxhc3RCYXJJblJhbmdlLl9pbnRlcm5hbF9pbmRleDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBiYXJzQmVmb3JlLCBiYXJzQWZ0ZXIgfTtcbiAgICAgICAgLy8gYWN0dWFsbHkgdGhleSBjYW4ndCBleGlzdCBzZXBhcmF0ZWx5XG4gICAgICAgIGlmIChkYXRhRmlyc3RCYXJJblJhbmdlICE9PSBudWxsICYmIGRhdGFMYXN0QmFySW5SYW5nZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmZyb20gPSBkYXRhRmlyc3RCYXJJblJhbmdlLl9pbnRlcm5hbF9vcmlnaW5hbFRpbWU7XG4gICAgICAgICAgICByZXN1bHQudG8gPSBkYXRhTGFzdEJhckluUmFuZ2UuX2ludGVybmFsX29yaWdpbmFsVGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZXREYXRhKGRhdGEpIHtcbiAgICAgICAgY2hlY2tJdGVtc0FyZU9yZGVyZWQoZGF0YSwgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IpO1xuICAgICAgICBjaGVja1Nlcmllc1ZhbHVlc1R5cGUodGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfc2VyaWVzVHlwZSgpLCBkYXRhKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2RhdGFVcGRhdGVzQ29uc3VtZXIuX2ludGVybmFsX2FwcGx5TmV3RGF0YSh0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLCBkYXRhKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25EYXRhQ2hhbmdlZCgnZnVsbCcpO1xuICAgIH1cbiAgICB1cGRhdGUoYmFyKSB7XG4gICAgICAgIGNoZWNrU2VyaWVzVmFsdWVzVHlwZSh0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9zZXJpZXNUeXBlKCksIFtiYXJdKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2RhdGFVcGRhdGVzQ29uc3VtZXIuX2ludGVybmFsX3VwZGF0ZURhdGEodGhpcy5faW50ZXJuYWxfX3NlcmllcywgYmFyKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25EYXRhQ2hhbmdlZCgndXBkYXRlJyk7XG4gICAgfVxuICAgIGRhdGFCeUluZGV4KGxvZ2ljYWxJbmRleCwgbWlzbWF0Y2hEaXJlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2JhcnMoKS5faW50ZXJuYWxfc2VhcmNoKGxvZ2ljYWxJbmRleCwgbWlzbWF0Y2hEaXJlY3Rpb24pO1xuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gYWN0dWFsbHkgaXQgY2FuIGJlIGEgd2hpdGVzcGFjZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRvciA9IGdldFNlcmllc0RhdGFDcmVhdG9yKHRoaXMuc2VyaWVzVHlwZSgpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0b3IoZGF0YSk7XG4gICAgfVxuICAgIGRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHNlcmllc0NyZWF0b3IgPSBnZXRTZXJpZXNEYXRhQ3JlYXRvcih0aGlzLnNlcmllc1R5cGUoKSk7XG4gICAgICAgIGNvbnN0IHJvd3MgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9iYXJzKCkuX2ludGVybmFsX3Jvd3MoKTtcbiAgICAgICAgcmV0dXJuIHJvd3MubWFwKChyb3cpID0+IHNlcmllc0NyZWF0b3Iocm93KSk7XG4gICAgfVxuICAgIHN1YnNjcmliZURhdGFDaGFuZ2VkKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YUNoYW5nZWREZWxlZ2F0ZS5faW50ZXJuYWxfc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZURhdGFDaGFuZ2VkKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YUNoYW5nZWREZWxlZ2F0ZS5faW50ZXJuYWxfdW5zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgfVxuICAgIHNldE1hcmtlcnMoZGF0YSkge1xuICAgICAgICBjaGVja0l0ZW1zQXJlT3JkZXJlZChkYXRhLCB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvciwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZE1hcmtlcnMgPSBkYXRhLm1hcCgobWFya2VyKSA9PiBjb252ZXJ0U2VyaWVzTWFya2VyKG1hcmtlciwgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IuY29udmVydEhvcnpJdGVtVG9JbnRlcm5hbChtYXJrZXIudGltZSksIG1hcmtlci50aW1lKSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX3NldE1hcmtlcnMoY29udmVydGVkTWFya2Vycyk7XG4gICAgfVxuICAgIG1hcmtlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9tYXJrZXJzKCkubWFwKChpbnRlcm5hbEl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0U2VyaWVzTWFya2VyKGludGVybmFsSXRlbSwgaW50ZXJuYWxJdGVtLm9yaWdpbmFsVGltZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFwcGx5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2FwcGx5T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gICAgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lKHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKSk7XG4gICAgfVxuICAgIHByaWNlU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlQXBpUHJvdmlkZXIucHJpY2VTY2FsZSh0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX2lkKCkpO1xuICAgIH1cbiAgICBjcmVhdGVQcmljZUxpbmUob3B0aW9ucykge1xuICAgICAgICBjaGVja1ByaWNlTGluZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHN0cmljdE9wdGlvbnMgPSBtZXJnZShjbG9uZShwcmljZUxpbmVPcHRpb25zRGVmYXVsdHMpLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcHJpY2VMaW5lID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfY3JlYXRlUHJpY2VMaW5lKHN0cmljdE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IFByaWNlTGluZShwcmljZUxpbmUpO1xuICAgIH1cbiAgICByZW1vdmVQcmljZUxpbmUobGluZSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9yZW1vdmVQcmljZUxpbmUobGluZS5faW50ZXJuYWxfcHJpY2VMaW5lKCkpO1xuICAgIH1cbiAgICBzZXJpZXNUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfc2VyaWVzVHlwZSgpO1xuICAgIH1cbiAgICBhdHRhY2hQcmltaXRpdmUocHJpbWl0aXZlKSB7XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgd2UgY2FzdCB0aGUgZ2VuZXJpYyB0byB1bmtub3duIGJlY2F1c2Ugd2VcbiAgICAgICAgLy8gZG9uJ3Qgd2FudCB0aGUgbW9kZWwgdG8ga25vdyB0aGUgdHlwZXMgb2YgdGhlIEFQSSAo4peRX+KXkSlcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYXR0YWNoUHJpbWl0aXZlKHByaW1pdGl2ZSk7XG4gICAgICAgIGlmIChwcmltaXRpdmUuYXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHByaW1pdGl2ZS5hdHRhY2hlZCh7XG4gICAgICAgICAgICAgICAgY2hhcnQ6IHRoaXMuX2ludGVybmFsX19jaGFydEFwaSxcbiAgICAgICAgICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdFVwZGF0ZTogKCkgPT4gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGV0YWNoUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9kZXRhY2hQcmltaXRpdmUocHJpbWl0aXZlKTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5kZXRhY2hlZCkge1xuICAgICAgICAgICAgcHJpbWl0aXZlLmRldGFjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX29uRGF0YUNoYW5nZWQoc2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGFDaGFuZ2VkRGVsZWdhdGUuX2ludGVybmFsX2hhc0xpc3RlbmVycygpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhQ2hhbmdlZERlbGVnYXRlLl9pbnRlcm5hbF9maXJlKHNjb3BlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgVGltZVNjYWxlQXBpIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCwgdGltZUF4aXNXaWRnZXQsIGhvcnpTY2FsZUJlaGF2aW9yKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVSYW5nZUNoYW5nZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlQ2hhbmdlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplQ2hhbmdlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUgPSBtb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0ID0gdGltZUF4aXNXaWRnZXQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfdmlzaWJsZUJhcnNDaGFuZ2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19vblZpc2libGVCYXJzQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9sb2dpY2FsUmFuZ2VDaGFuZ2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19vblZpc2libGVMb2dpY2FsUmFuZ2VDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldC5faW50ZXJuYWxfc2l6ZUNoYW5nZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKHRoaXMuX3ByaXZhdGVfX29uU2l6ZUNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yID0gaG9yelNjYWxlQmVoYXZpb3I7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3Zpc2libGVCYXJzQ2hhbmdlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9sb2dpY2FsUmFuZ2VDaGFuZ2VkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldC5faW50ZXJuYWxfc2l6ZUNoYW5nZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVSYW5nZUNoYW5nZWQuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlQ2hhbmdlZC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplQ2hhbmdlZC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgIH1cbiAgICBzY3JvbGxQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfcmlnaHRPZmZzZXQoKTtcbiAgICB9XG4gICAgc2Nyb2xsVG9Qb3NpdGlvbihwb3NpdGlvbiwgYW5pbWF0ZWQpIHtcbiAgICAgICAgaWYgKCFhbmltYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3Njcm9sbFRvT2Zmc2V0QW5pbWF0ZWQocG9zaXRpb24sIDEwMDAgLyogQ29uc3RhbnRzLkFuaW1hdGlvbkR1cmF0aW9uTXMgKi8pO1xuICAgIH1cbiAgICBzY3JvbGxUb1JlYWxUaW1lKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3Njcm9sbFRvUmVhbFRpbWUoKTtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZVJhbmdlKCkge1xuICAgICAgICBjb25zdCB0aW1lUmFuZ2UgPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3Zpc2libGVUaW1lUmFuZ2UoKTtcbiAgICAgICAgaWYgKHRpbWVSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IHRpbWVSYW5nZS5mcm9tLm9yaWdpbmFsVGltZSxcbiAgICAgICAgICAgIHRvOiB0aW1lUmFuZ2UudG8ub3JpZ2luYWxUaW1lLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRWaXNpYmxlUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgY29uc3QgY29udmVydGVkUmFuZ2UgPSB7XG4gICAgICAgICAgICBmcm9tOiB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5jb252ZXJ0SG9yekl0ZW1Ub0ludGVybmFsKHJhbmdlLmZyb20pLFxuICAgICAgICAgICAgdG86IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmNvbnZlcnRIb3J6SXRlbVRvSW50ZXJuYWwocmFuZ2UudG8pLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsb2dpY2FsUmFuZ2UgPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2xvZ2ljYWxSYW5nZUZvclRpbWVSYW5nZShjb252ZXJ0ZWRSYW5nZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9zZXRUYXJnZXRMb2dpY2FsUmFuZ2UobG9naWNhbFJhbmdlKTtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZUxvZ2ljYWxSYW5nZSgpIHtcbiAgICAgICAgY29uc3QgbG9naWNhbFJhbmdlID0gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF92aXNpYmxlTG9naWNhbFJhbmdlKCk7XG4gICAgICAgIGlmIChsb2dpY2FsUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiBsb2dpY2FsUmFuZ2UuX2ludGVybmFsX2xlZnQoKSxcbiAgICAgICAgICAgIHRvOiBsb2dpY2FsUmFuZ2UuX2ludGVybmFsX3JpZ2h0KCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldFZpc2libGVMb2dpY2FsUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgYXNzZXJ0KHJhbmdlLmZyb20gPD0gcmFuZ2UudG8sICdUaGUgZnJvbSBpbmRleCBjYW5ub3QgYmUgYWZ0ZXIgdGhlIHRvIGluZGV4LicpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2V0VGFyZ2V0TG9naWNhbFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gICAgcmVzZXRUaW1lU2NhbGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9yZXNldFRpbWVTY2FsZSgpO1xuICAgIH1cbiAgICBmaXRDb250ZW50KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfZml0Q29udGVudCgpO1xuICAgIH1cbiAgICBsb2dpY2FsVG9Db29yZGluYXRlKGxvZ2ljYWwpIHtcbiAgICAgICAgY29uc3QgdGltZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpO1xuICAgICAgICBpZiAodGltZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhUb0Nvb3JkaW5hdGUobG9naWNhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29vcmRpbmF0ZVRvTG9naWNhbCh4KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9jb29yZGluYXRlVG9JbmRleCh4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aW1lVG9Db29yZGluYXRlKHRpbWUpIHtcbiAgICAgICAgY29uc3QgdGltZVBvaW50ID0gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IuY29udmVydEhvcnpJdGVtVG9JbnRlcm5hbCh0aW1lKTtcbiAgICAgICAgY29uc3QgdGltZVBvaW50SW5kZXggPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3RpbWVUb0luZGV4KHRpbWVQb2ludCwgZmFsc2UpO1xuICAgICAgICBpZiAodGltZVBvaW50SW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2luZGV4VG9Db29yZGluYXRlKHRpbWVQb2ludEluZGV4KTtcbiAgICB9XG4gICAgY29vcmRpbmF0ZVRvVGltZSh4KSB7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKTtcbiAgICAgICAgY29uc3QgdGltZVBvaW50SW5kZXggPSB0aW1lU2NhbGUuX2ludGVybmFsX2Nvb3JkaW5hdGVUb0luZGV4KHgpO1xuICAgICAgICBjb25zdCB0aW1lUG9pbnQgPSB0aW1lU2NhbGUuX2ludGVybmFsX2luZGV4VG9UaW1lU2NhbGVQb2ludCh0aW1lUG9pbnRJbmRleCk7XG4gICAgICAgIGlmICh0aW1lUG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lUG9pbnQub3JpZ2luYWxUaW1lO1xuICAgIH1cbiAgICB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9nZXRTaXplKCkud2lkdGg7XG4gICAgfVxuICAgIGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9nZXRTaXplKCkuaGVpZ2h0O1xuICAgIH1cbiAgICBzdWJzY3JpYmVWaXNpYmxlVGltZVJhbmdlQ2hhbmdlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVJhbmdlQ2hhbmdlZC5faW50ZXJuYWxfc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZVZpc2libGVUaW1lUmFuZ2VDaGFuZ2UoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lUmFuZ2VDaGFuZ2VkLl9pbnRlcm5hbF91bnN1YnNjcmliZShoYW5kbGVyKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlVmlzaWJsZUxvZ2ljYWxSYW5nZUNoYW5nZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxSYW5nZUNoYW5nZWQuX2ludGVybmFsX3N1YnNjcmliZShoYW5kbGVyKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVWaXNpYmxlTG9naWNhbFJhbmdlQ2hhbmdlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlQ2hhbmdlZC5faW50ZXJuYWxfdW5zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgfVxuICAgIHN1YnNjcmliZVNpemVDaGFuZ2UoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplQ2hhbmdlZC5faW50ZXJuYWxfc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZVNpemVDaGFuZ2UoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplQ2hhbmdlZC5faW50ZXJuYWxfdW5zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgfVxuICAgIGFwcGx5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjbG9uZSh0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKSkpLCB7IGJhclNwYWNpbmc6IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfYmFyU3BhY2luZygpIH0pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fb25WaXNpYmxlQmFyc0NoYW5nZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX190aW1lUmFuZ2VDaGFuZ2VkLl9pbnRlcm5hbF9oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVJhbmdlQ2hhbmdlZC5faW50ZXJuYWxfZmlyZSh0aGlzLmdldFZpc2libGVSYW5nZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fb25WaXNpYmxlTG9naWNhbFJhbmdlQ2hhbmdlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxSYW5nZUNoYW5nZWQuX2ludGVybmFsX2hhc0xpc3RlbmVycygpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sb2dpY2FsUmFuZ2VDaGFuZ2VkLl9pbnRlcm5hbF9maXJlKHRoaXMuZ2V0VmlzaWJsZUxvZ2ljYWxSYW5nZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fb25TaXplQ2hhbmdlZChzaXplKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NpemVDaGFuZ2VkLl9pbnRlcm5hbF9maXJlKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhdGNoUHJpY2VGb3JtYXQocHJpY2VGb3JtYXQpIHtcbiAgICBpZiAocHJpY2VGb3JtYXQgPT09IHVuZGVmaW5lZCB8fCBwcmljZUZvcm1hdC50eXBlID09PSAnY3VzdG9tJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByaWNlRm9ybWF0QnVpbHRJbiA9IHByaWNlRm9ybWF0O1xuICAgIGlmIChwcmljZUZvcm1hdEJ1aWx0SW4ubWluTW92ZSAhPT0gdW5kZWZpbmVkICYmIHByaWNlRm9ybWF0QnVpbHRJbi5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcmljZUZvcm1hdEJ1aWx0SW4ucHJlY2lzaW9uID0gcHJlY2lzaW9uQnlNaW5Nb3ZlKHByaWNlRm9ybWF0QnVpbHRJbi5taW5Nb3ZlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtaWdyYXRlSGFuZGxlU2NhbGVTY3JvbGxPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoaXNCb29sZWFuKG9wdGlvbnMuaGFuZGxlU2NhbGUpKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZVNjYWxlID0gb3B0aW9ucy5oYW5kbGVTY2FsZTtcbiAgICAgICAgb3B0aW9ucy5oYW5kbGVTY2FsZSA9IHtcbiAgICAgICAgICAgIGF4aXNEb3VibGVDbGlja1Jlc2V0OiB7XG4gICAgICAgICAgICAgICAgdGltZTogaGFuZGxlU2NhbGUsXG4gICAgICAgICAgICAgICAgcHJpY2U6IGhhbmRsZVNjYWxlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF4aXNQcmVzc2VkTW91c2VNb3ZlOiB7XG4gICAgICAgICAgICAgICAgdGltZTogaGFuZGxlU2NhbGUsXG4gICAgICAgICAgICAgICAgcHJpY2U6IGhhbmRsZVNjYWxlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlV2hlZWw6IGhhbmRsZVNjYWxlLFxuICAgICAgICAgICAgcGluY2g6IGhhbmRsZVNjYWxlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLmhhbmRsZVNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgeyBheGlzUHJlc3NlZE1vdXNlTW92ZSwgYXhpc0RvdWJsZUNsaWNrUmVzZXQgfSA9IG9wdGlvbnMuaGFuZGxlU2NhbGU7XG4gICAgICAgIGlmIChpc0Jvb2xlYW4oYXhpc1ByZXNzZWRNb3VzZU1vdmUpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmhhbmRsZVNjYWxlLmF4aXNQcmVzc2VkTW91c2VNb3ZlID0ge1xuICAgICAgICAgICAgICAgIHRpbWU6IGF4aXNQcmVzc2VkTW91c2VNb3ZlLFxuICAgICAgICAgICAgICAgIHByaWNlOiBheGlzUHJlc3NlZE1vdXNlTW92ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQm9vbGVhbihheGlzRG91YmxlQ2xpY2tSZXNldCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGFuZGxlU2NhbGUuYXhpc0RvdWJsZUNsaWNrUmVzZXQgPSB7XG4gICAgICAgICAgICAgICAgdGltZTogYXhpc0RvdWJsZUNsaWNrUmVzZXQsXG4gICAgICAgICAgICAgICAgcHJpY2U6IGF4aXNEb3VibGVDbGlja1Jlc2V0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoYW5kbGVTY3JvbGwgPSBvcHRpb25zLmhhbmRsZVNjcm9sbDtcbiAgICBpZiAoaXNCb29sZWFuKGhhbmRsZVNjcm9sbCkpIHtcbiAgICAgICAgb3B0aW9ucy5oYW5kbGVTY3JvbGwgPSB7XG4gICAgICAgICAgICBob3J6VG91Y2hEcmFnOiBoYW5kbGVTY3JvbGwsXG4gICAgICAgICAgICB2ZXJ0VG91Y2hEcmFnOiBoYW5kbGVTY3JvbGwsXG4gICAgICAgICAgICBtb3VzZVdoZWVsOiBoYW5kbGVTY3JvbGwsXG4gICAgICAgICAgICBwcmVzc2VkTW91c2VNb3ZlOiBoYW5kbGVTY3JvbGwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gdG9JbnRlcm5hbE9wdGlvbnMob3B0aW9ucykge1xuICAgIG1pZ3JhdGVIYW5kbGVTY2FsZVNjcm9sbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5jbGFzcyBDaGFydEFwaSB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBob3J6U2NhbGVCZWhhdmlvciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc01hcFJldmVyc2VkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja2VkRGVsZWdhdGUgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZERlbGVnYXRlID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkRGVsZWdhdGUgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YUxheWVyID0gbmV3IERhdGFMYXllcihob3J6U2NhbGVCZWhhdmlvcik7XG4gICAgICAgIGNvbnN0IGludGVybmFsT3B0aW9ucyA9IChvcHRpb25zID09PSB1bmRlZmluZWQpID9cbiAgICAgICAgICAgIGNsb25lKGNoYXJ0T3B0aW9uc0RlZmF1bHRzKCkpIDpcbiAgICAgICAgICAgIG1lcmdlKGNsb25lKGNoYXJ0T3B0aW9uc0RlZmF1bHRzKCkpLCB0b0ludGVybmFsT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yID0gaG9yelNjYWxlQmVoYXZpb3I7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0ID0gbmV3IENoYXJ0V2lkZ2V0KGNvbnRhaW5lciwgaW50ZXJuYWxPcHRpb25zLCBob3J6U2NhbGVCZWhhdmlvcik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9jbGlja2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSgocGFyYW1TdXBwbGllcikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NsaWNrZWREZWxlZ2F0ZS5faW50ZXJuYWxfaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja2VkRGVsZWdhdGUuX2ludGVybmFsX2ZpcmUodGhpcy5fcHJpdmF0ZV9fY29udmVydE1vdXNlUGFyYW1zKHBhcmFtU3VwcGxpZXIoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX2RibENsaWNrZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKChwYXJhbVN1cHBsaWVyKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZERlbGVnYXRlLl9pbnRlcm5hbF9oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RibENsaWNrZWREZWxlZ2F0ZS5faW50ZXJuYWxfZmlyZSh0aGlzLl9wcml2YXRlX19jb252ZXJ0TW91c2VQYXJhbXMocGFyYW1TdXBwbGllcigpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfY3Jvc3NoYWlyTW92ZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKChwYXJhbVN1cHBsaWVyKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyTW92ZWREZWxlZ2F0ZS5faW50ZXJuYWxfaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZERlbGVnYXRlLl9pbnRlcm5hbF9maXJlKHRoaXMuX3ByaXZhdGVfX2NvbnZlcnRNb3VzZVBhcmFtcyhwYXJhbVN1cHBsaWVyKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZUFwaSA9IG5ldyBUaW1lU2NhbGVBcGkobW9kZWwsIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF90aW1lQXhpc1dpZGdldCgpLCB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvcik7XG4gICAgfVxuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX2NsaWNrZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9kYmxDbGlja2VkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfY3Jvc3NoYWlyTW92ZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZUFwaS5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNNYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTWFwUmV2ZXJzZWQuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tlZERlbGVnYXRlLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RibENsaWNrZWREZWxlZ2F0ZS5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZERlbGVnYXRlLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFMYXllci5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgIH1cbiAgICByZXNpemUod2lkdGgsIGhlaWdodCwgZm9yY2VSZXBhaW50KSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9TaXplQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIC8vIFdlIHJldHVybiBlYXJseSBoZXJlIGluc3RlYWQgb2YgY2hlY2tpbmcgdGhpcyB3aXRoaW4gdGhlIGFjdHVhbCBfY2hhcnRXaWRnZXQucmVzaXplIG1ldGhvZFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGlzIHNob3VsZCBvbmx5IGFwcGx5IHRvIGV4dGVybmFsIHJlc2l6ZSByZXF1ZXN0cy5cbiAgICAgICAgICAgIHdhcm4oYEhlaWdodCBhbmQgd2lkdGggdmFsdWVzIGlnbm9yZWQgYmVjYXVzZSAnYXV0b1NpemUnIG9wdGlvbiBpcyBlbmFibGVkLmApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9yZXNpemUod2lkdGgsIGhlaWdodCwgZm9yY2VSZXBhaW50KTtcbiAgICB9XG4gICAgYWRkQ3VzdG9tU2VyaWVzKGN1c3RvbVBhbmVWaWV3LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhbmVWaWV3ID0gZW5zdXJlKGN1c3RvbVBhbmVWaWV3KTtcbiAgICAgICAgY29uc3QgZGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGN1c3RvbVN0eWxlRGVmYXVsdHMpLCBwYW5lVmlldy5kZWZhdWx0T3B0aW9ucygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2FkZFNlcmllc0ltcGwoJ0N1c3RvbScsIGRlZmF1bHRzLCBvcHRpb25zLCBwYW5lVmlldyk7XG4gICAgfVxuICAgIGFkZEFyZWFTZXJpZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYWRkU2VyaWVzSW1wbCgnQXJlYScsIGFyZWFTdHlsZURlZmF1bHRzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYWRkQmFzZWxpbmVTZXJpZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYWRkU2VyaWVzSW1wbCgnQmFzZWxpbmUnLCBiYXNlbGluZVN0eWxlRGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhZGRCYXJTZXJpZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYWRkU2VyaWVzSW1wbCgnQmFyJywgYmFyU3R5bGVEZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFkZENhbmRsZXN0aWNrU2VyaWVzKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBmaWxsVXBEb3duQ2FuZGxlc3RpY2tzQ29sb3JzKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYWRkU2VyaWVzSW1wbCgnQ2FuZGxlc3RpY2snLCBjYW5kbGVzdGlja1N0eWxlRGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhZGRIaXN0b2dyYW1TZXJpZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYWRkU2VyaWVzSW1wbCgnSGlzdG9ncmFtJywgaGlzdG9ncmFtU3R5bGVEZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFkZExpbmVTZXJpZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYWRkU2VyaWVzSW1wbCgnTGluZScsIGxpbmVTdHlsZURlZmF1bHRzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmVtb3ZlU2VyaWVzKHNlcmllc0FwaSkge1xuICAgICAgICBjb25zdCBzZXJpZXMgPSBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX3Nlcmllc01hcC5nZXQoc2VyaWVzQXBpKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZSA9IHRoaXMuX3ByaXZhdGVfX2RhdGFMYXllci5faW50ZXJuYWxfcmVtb3ZlU2VyaWVzKHNlcmllcyk7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIG1vZGVsLl9pbnRlcm5hbF9yZW1vdmVTZXJpZXMoc2VyaWVzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VuZFVwZGF0ZVRvQ2hhcnQodXBkYXRlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTWFwLmRlbGV0ZShzZXJpZXNBcGkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNNYXBSZXZlcnNlZC5kZWxldGUoc2VyaWVzKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2FwcGx5TmV3RGF0YShzZXJpZXMsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VuZFVwZGF0ZVRvQ2hhcnQodGhpcy5fcHJpdmF0ZV9fZGF0YUxheWVyLl9pbnRlcm5hbF9zZXRTZXJpZXNEYXRhKHNlcmllcywgZGF0YSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlRGF0YShzZXJpZXMsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VuZFVwZGF0ZVRvQ2hhcnQodGhpcy5fcHJpdmF0ZV9fZGF0YUxheWVyLl9pbnRlcm5hbF91cGRhdGVTZXJpZXNEYXRhKHNlcmllcywgZGF0YSkpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVDbGljayhoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrZWREZWxlZ2F0ZS5faW50ZXJuYWxfc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZUNsaWNrKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tlZERlbGVnYXRlLl9pbnRlcm5hbF91bnN1YnNjcmliZShoYW5kbGVyKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlQ3Jvc3NoYWlyTW92ZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkRGVsZWdhdGUuX2ludGVybmFsX3N1YnNjcmliZShoYW5kbGVyKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVDcm9zc2hhaXJNb3ZlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyTW92ZWREZWxlZ2F0ZS5faW50ZXJuYWxfdW5zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgfVxuICAgIHN1YnNjcmliZURibENsaWNrKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZERlbGVnYXRlLl9pbnRlcm5hbF9zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlRGJsQ2xpY2soaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYmxDbGlja2VkRGVsZWdhdGUuX2ludGVybmFsX3Vuc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIH1cbiAgICBwcmljZVNjYWxlKHByaWNlU2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gbmV3IFByaWNlU2NhbGVBcGkodGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQsIHByaWNlU2NhbGVJZCk7XG4gICAgfVxuICAgIHRpbWVTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZUFwaTtcbiAgICB9XG4gICAgYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX2FwcGx5T3B0aW9ucyh0b0ludGVybmFsT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgfVxuICAgIG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgIH1cbiAgICB0YWtlU2NyZWVuc2hvdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF90YWtlU2NyZWVuc2hvdCgpO1xuICAgIH1cbiAgICBhdXRvU2l6ZUFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9hdXRvU2l6ZUFjdGl2ZSgpO1xuICAgIH1cbiAgICBjaGFydEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfZWxlbWVudCgpO1xuICAgIH1cbiAgICBwYW5lU2l6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9wYW5lU2l6ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRDcm9zc2hhaXJQb3NpdGlvbihwcmljZSwgaG9yaXpvbnRhbFBvc2l0aW9uLCBzZXJpZXNBcGkpIHtcbiAgICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTWFwLmdldChzZXJpZXNBcGkpO1xuICAgICAgICBpZiAoc2VyaWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3BhbmVGb3JTb3VyY2Uoc2VyaWVzKTtcbiAgICAgICAgaWYgKHBhbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfc2V0QW5kU2F2ZVN5bnRoZXRpY1Bvc2l0aW9uKHByaWNlLCBob3Jpem9udGFsUG9zaXRpb24sIHBhbmUpO1xuICAgIH1cbiAgICBjbGVhckNyb3NzaGFpclBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfY2xlYXJDdXJyZW50UG9zaXRpb24odHJ1ZSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19hZGRTZXJpZXNJbXBsKHR5cGUsIHN0eWxlRGVmYXVsdHMsIG9wdGlvbnMgPSB7fSwgY3VzdG9tUGFuZVZpZXcpIHtcbiAgICAgICAgcGF0Y2hQcmljZUZvcm1hdChvcHRpb25zLnByaWNlRm9ybWF0KTtcbiAgICAgICAgY29uc3Qgc3RyaWN0T3B0aW9ucyA9IG1lcmdlKGNsb25lKHNlcmllc09wdGlvbnNEZWZhdWx0cyksIGNsb25lKHN0eWxlRGVmYXVsdHMpLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2NyZWF0ZVNlcmllcyh0eXBlLCBzdHJpY3RPcHRpb25zLCBjdXN0b21QYW5lVmlldyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBTZXJpZXNBcGkoc2VyaWVzLCB0aGlzLCB0aGlzLCB0aGlzLCB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvcik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc01hcC5zZXQocmVzLCBzZXJpZXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNNYXBSZXZlcnNlZC5zZXQoc2VyaWVzLCByZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2VuZFVwZGF0ZVRvQ2hhcnQodXBkYXRlKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIG1vZGVsLl9pbnRlcm5hbF91cGRhdGVUaW1lU2NhbGUodXBkYXRlLl9pbnRlcm5hbF90aW1lU2NhbGUuX2ludGVybmFsX2Jhc2VJbmRleCwgdXBkYXRlLl9pbnRlcm5hbF90aW1lU2NhbGUuX2ludGVybmFsX3BvaW50cywgdXBkYXRlLl9pbnRlcm5hbF90aW1lU2NhbGUuX2ludGVybmFsX2ZpcnN0Q2hhbmdlZFBvaW50SW5kZXgpO1xuICAgICAgICB1cGRhdGUuX2ludGVybmFsX3Nlcmllcy5mb3JFYWNoKCh2YWx1ZSwgc2VyaWVzKSA9PiBzZXJpZXMuX2ludGVybmFsX3NldERhdGEodmFsdWUuX2ludGVybmFsX2RhdGEsIHZhbHVlLl9pbnRlcm5hbF9pbmZvKSk7XG4gICAgICAgIG1vZGVsLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZUFsbFBhbmVzKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19tYXBTZXJpZXNUb0FwaShzZXJpZXMpIHtcbiAgICAgICAgcmV0dXJuIGVuc3VyZURlZmluZWQodGhpcy5fcHJpdmF0ZV9fc2VyaWVzTWFwUmV2ZXJzZWQuZ2V0KHNlcmllcykpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY29udmVydE1vdXNlUGFyYW1zKHBhcmFtKSB7XG4gICAgICAgIGNvbnN0IHNlcmllc0RhdGEgPSBuZXcgTWFwKCk7XG4gICAgICAgIHBhcmFtLl9pbnRlcm5hbF9zZXJpZXNEYXRhLmZvckVhY2goKHBsb3RSb3csIHNlcmllcykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWVzVHlwZSA9IHNlcmllcy5faW50ZXJuYWxfc2VyaWVzVHlwZSgpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGdldFNlcmllc0RhdGFDcmVhdG9yKHNlcmllc1R5cGUpKHBsb3RSb3cpO1xuICAgICAgICAgICAgaWYgKHNlcmllc1R5cGUgIT09ICdDdXN0b20nKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGlzRnVsZmlsbGVkRGF0YShkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXN0b21XaGl0ZXNwYWNlQ2hlY2tlciA9IHNlcmllcy5faW50ZXJuYWxfY3VzdG9tU2VyaWVzV2hpdGVzcGFjZUNoZWNrKCk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KCFjdXN0b21XaGl0ZXNwYWNlQ2hlY2tlciB8fCBjdXN0b21XaGl0ZXNwYWNlQ2hlY2tlcihkYXRhKSA9PT0gZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VyaWVzRGF0YS5zZXQodGhpcy5fcHJpdmF0ZV9fbWFwU2VyaWVzVG9BcGkoc2VyaWVzKSwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBob3ZlcmVkU2VyaWVzID0gcGFyYW0uX2ludGVybmFsX2hvdmVyZWRTZXJpZXMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaXMuX3ByaXZhdGVfX21hcFNlcmllc1RvQXBpKHBhcmFtLl9pbnRlcm5hbF9ob3ZlcmVkU2VyaWVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWU6IHBhcmFtLl9pbnRlcm5hbF9vcmlnaW5hbFRpbWUsXG4gICAgICAgICAgICBsb2dpY2FsOiBwYXJhbS5faW50ZXJuYWxfaW5kZXgsXG4gICAgICAgICAgICBwb2ludDogcGFyYW0uX2ludGVybmFsX3BvaW50LFxuICAgICAgICAgICAgaG92ZXJlZFNlcmllcyxcbiAgICAgICAgICAgIGhvdmVyZWRPYmplY3RJZDogcGFyYW0uX2ludGVybmFsX2hvdmVyZWRPYmplY3QsXG4gICAgICAgICAgICBzZXJpZXNEYXRhLFxuICAgICAgICAgICAgc291cmNlRXZlbnQ6IHBhcmFtLl9pbnRlcm5hbF90b3VjaE1vdXNlRXZlbnREYXRhLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHRoZSBtYWluIGVudHJ5IHBvaW50IG9mIHRoZSBMaWdodHdlaWdodCBDaGFydGluZyBMaWJyYXJ5LiBJZiB5b3UgYXJlIHVzaW5nIHRpbWUgdmFsdWVzXG4gKiBmb3IgdGhlIGhvcml6b250YWwgc2NhbGUgdGhlbiBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdSByYXRoZXIgdXNlIHRoZSB7QGxpbmsgY3JlYXRlQ2hhcnR9IGZ1bmN0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBIb3J6U2NhbGVJdGVtIC0gdHlwZSBvZiBwb2ludHMgb24gdGhlIGhvcml6b250YWwgc2NhbGVcbiAqIEB0ZW1wbGF0ZSBUSG9yelNjYWxlQmVoYXZpb3IgLSB0eXBlIG9mIGhvcml6b250YWwgYXhpcyBzdHJhdGVneSB0aGF0IGVuY2Fwc3VsYXRlIGFsbCB0aGUgc3BlY2lmaWMgYmVoYXZpb3JzIG9mIHRoZSBob3Jpem9udGFsIHNjYWxlIHR5cGVcbiAqXG4gKiBAcGFyYW0gY29udGFpbmVyIC0gSUQgb2YgSFRNTCBlbGVtZW50IG9yIGVsZW1lbnQgaXRzZWxmXG4gKiBAcGFyYW0gaG9yelNjYWxlQmVoYXZpb3IgLSBIb3Jpem9udGFsIHNjYWxlIGJlaGF2aW9yXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFueSBzdWJzZXQgb2Ygb3B0aW9ucyB0byBiZSBhcHBsaWVkIGF0IHN0YXJ0LlxuICogQHJldHVybnMgQW4gaW50ZXJmYWNlIHRvIHRoZSBjcmVhdGVkIGNoYXJ0XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYXJ0RXgoY29udGFpbmVyLCBob3J6U2NhbGVCZWhhdmlvciwgb3B0aW9ucykge1xuICAgIGxldCBodG1sRWxlbWVudDtcbiAgICBpZiAoaXNTdHJpbmcoY29udGFpbmVyKSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGFpbmVyKTtcbiAgICAgICAgYXNzZXJ0KGVsZW1lbnQgIT09IG51bGwsIGBDYW5ub3QgZmluZCBlbGVtZW50IGluIERPTSB3aXRoIGlkPSR7Y29udGFpbmVyfWApO1xuICAgICAgICBodG1sRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBodG1sRWxlbWVudCA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IENoYXJ0QXBpKGh0bWxFbGVtZW50LCBob3J6U2NhbGVCZWhhdmlvciwgb3B0aW9ucyk7XG4gICAgaG9yelNjYWxlQmVoYXZpb3Iuc2V0T3B0aW9ucyhyZXMub3B0aW9ucygpKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHRoZSBzaW1wbGlmaWVkIG1haW4gZW50cnkgcG9pbnQgb2YgdGhlIExpZ2h0d2VpZ2h0IENoYXJ0aW5nIExpYnJhcnkgd2l0aCB0aW1lIHBvaW50cyBmb3IgdGhlIGhvcml6b250YWwgc2NhbGUuXG4gKlxuICogQHBhcmFtIGNvbnRhaW5lciAtIElEIG9mIEhUTUwgZWxlbWVudCBvciBlbGVtZW50IGl0c2VsZlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbnkgc3Vic2V0IG9mIG9wdGlvbnMgdG8gYmUgYXBwbGllZCBhdCBzdGFydC5cbiAqIEByZXR1cm5zIEFuIGludGVyZmFjZSB0byB0aGUgY3JlYXRlZCBjaGFydFxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFydChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhcnRFeChjb250YWluZXIsIG5ldyBIb3J6U2NhbGVCZWhhdmlvclRpbWUoKSwgSG9yelNjYWxlQmVoYXZpb3JUaW1lLl9pbnRlcm5hbF9hcHBseURlZmF1bHRzKG9wdGlvbnMpKTtcbn1cblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJfYnVpbGQtdGltZS1jb25zdGFudHNcIiAvPlxuY29uc3QgY3VzdG9tU2VyaWVzRGVmYXVsdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlcmllc09wdGlvbnNEZWZhdWx0cyksIGN1c3RvbVN0eWxlRGVmYXVsdHMpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZlcnNpb24gYXMgYSBzdHJpbmcuIEZvciBleGFtcGxlIGAnMy4zLjAnYC5cbiAqL1xuZnVuY3Rpb24gdmVyc2lvbigpIHtcbiAgICByZXR1cm4gXCI0LjEuMlwiO1xufVxuXG5leHBvcnQgeyBDb2xvclR5cGUsIENyb3NzaGFpck1vZGUsIExhc3RQcmljZUFuaW1hdGlvbk1vZGUsIExpbmVTdHlsZSwgTGluZVR5cGUsIE1pc21hdGNoRGlyZWN0aW9uLCBQcmljZUxpbmVTb3VyY2UsIFByaWNlU2NhbGVNb2RlLCBUaWNrTWFya1R5cGUsIFRyYWNraW5nTW9kZUV4aXRNb2RlLCBjcmVhdGVDaGFydCwgY3JlYXRlQ2hhcnRFeCwgY3VzdG9tU2VyaWVzRGVmYXVsdE9wdGlvbnMsIGlzQnVzaW5lc3NEYXksIGlzVVRDVGltZXN0YW1wLCB2ZXJzaW9uIH07XG4iXSwibmFtZXMiOlsic2l6ZSIsInNpemUkMSIsImJpbmRDYW52YXNFbGVtZW50Qml0bWFwU2l6ZVRvIiwiZXF1YWxTaXplcyIsInRyeUNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJEIiwiY2FuZGxlc3RpY2tTdHlsZURlZmF1bHRzIiwidXBDb2xvciIsImRvd25Db2xvciIsIndpY2tWaXNpYmxlIiwiYm9yZGVyVmlzaWJsZSIsImJvcmRlckNvbG9yIiwiYm9yZGVyVXBDb2xvciIsImJvcmRlckRvd25Db2xvciIsIndpY2tDb2xvciIsIndpY2tVcENvbG9yIiwid2lja0Rvd25Db2xvciIsImJhclN0eWxlRGVmYXVsdHMiLCJvcGVuVmlzaWJsZSIsInRoaW5CYXJzIiwibGluZVN0eWxlRGVmYXVsdHMiLCJjb2xvciIsImxpbmVTdHlsZSIsImxpbmVXaWR0aCIsImxpbmVUeXBlIiwibGluZVZpc2libGUiLCJjcm9zc2hhaXJNYXJrZXJWaXNpYmxlIiwiY3Jvc3NoYWlyTWFya2VyUmFkaXVzIiwiY3Jvc3NoYWlyTWFya2VyQm9yZGVyQ29sb3IiLCJjcm9zc2hhaXJNYXJrZXJCb3JkZXJXaWR0aCIsImNyb3NzaGFpck1hcmtlckJhY2tncm91bmRDb2xvciIsImxhc3RQcmljZUFuaW1hdGlvbiIsInBvaW50TWFya2Vyc1Zpc2libGUiLCJhcmVhU3R5bGVEZWZhdWx0cyIsInRvcENvbG9yIiwiYm90dG9tQ29sb3IiLCJpbnZlcnRGaWxsZWRBcmVhIiwibGluZUNvbG9yIiwiYmFzZWxpbmVTdHlsZURlZmF1bHRzIiwiYmFzZVZhbHVlIiwidHlwZSIsInByaWNlIiwidG9wRmlsbENvbG9yMSIsInRvcEZpbGxDb2xvcjIiLCJ0b3BMaW5lQ29sb3IiLCJib3R0b21GaWxsQ29sb3IxIiwiYm90dG9tRmlsbENvbG9yMiIsImJvdHRvbUxpbmVDb2xvciIsImhpc3RvZ3JhbVN0eWxlRGVmYXVsdHMiLCJiYXNlIiwiY3VzdG9tU3R5bGVEZWZhdWx0cyIsInNlcmllc09wdGlvbnNEZWZhdWx0cyIsInRpdGxlIiwidmlzaWJsZSIsImxhc3RWYWx1ZVZpc2libGUiLCJwcmljZUxpbmVWaXNpYmxlIiwicHJpY2VMaW5lU291cmNlIiwicHJpY2VMaW5lV2lkdGgiLCJwcmljZUxpbmVDb2xvciIsInByaWNlTGluZVN0eWxlIiwiYmFzZUxpbmVWaXNpYmxlIiwiYmFzZUxpbmVXaWR0aCIsImJhc2VMaW5lQ29sb3IiLCJiYXNlTGluZVN0eWxlIiwicHJpY2VGb3JtYXQiLCJwcmVjaXNpb24iLCJtaW5Nb3ZlIiwiTGluZVR5cGUiLCJMaW5lU3R5bGUiLCJzZXRMaW5lU3R5bGUiLCJjdHgiLCJzdHlsZSIsImRhc2hQYXR0ZXJucyIsImRhc2hQYXR0ZXJuIiwic2V0TGluZURhc2giLCJkcmF3SG9yaXpvbnRhbExpbmUiLCJ5IiwibGVmdCIsInJpZ2h0IiwiYmVnaW5QYXRoIiwiY29ycmVjdGlvbiIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZSIsImRyYXdWZXJ0aWNhbExpbmUiLCJ4IiwidG9wIiwiYm90dG9tIiwic3Ryb2tlSW5QaXhlbCIsImRyYXdGdW5jdGlvbiIsInNhdmUiLCJ0cmFuc2xhdGUiLCJyZXN0b3JlIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsIkVycm9yIiwiZW5zdXJlRGVmaW5lZCIsInZhbHVlIiwidW5kZWZpbmVkIiwiZW5zdXJlTm90TnVsbCIsImVuc3VyZSIsImVuc3VyZU5ldmVyIiwibmFtZWRDb2xvclJnYkhleFN0cmluZ3MiLCJraGFraSIsImF6dXJlIiwiYWxpY2VibHVlIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJnYWluc2Jvcm8iLCJncmF5IiwiZ3JlZW4iLCJob25leWRldyIsImZsb3JhbHdoaXRlIiwibGlnaHRibHVlIiwibGlnaHRjb3JhbCIsImxlbW9uY2hpZmZvbiIsImhvdHBpbmsiLCJsaWdodHllbGxvdyIsImdyZWVueWVsbG93IiwibGlnaHRnb2xkZW5yb2R5ZWxsb3ciLCJsaW1lZ3JlZW4iLCJsaW5lbiIsImxpZ2h0Y3lhbiIsIm1hZ2VudGEiLCJtYXJvb24iLCJvbGl2ZSIsIm9yYW5nZSIsIm9sZGxhY2UiLCJtZWRpdW1ibHVlIiwidHJhbnNwYXJlbnQiLCJsaW1lIiwibGlnaHRwaW5rIiwibWlzdHlyb3NlIiwibW9jY2FzaW4iLCJtaWRuaWdodGJsdWUiLCJvcmNoaWQiLCJtZWRpdW1vcmNoaWQiLCJtZWRpdW10dXJxdW9pc2UiLCJvcmFuZ2VyZWQiLCJyb3lhbGJsdWUiLCJwb3dkZXJibHVlIiwicmVkIiwiY29yYWwiLCJ0dXJxdW9pc2UiLCJ3aGl0ZSIsIndoaXRlc21va2UiLCJ3aGVhdCIsInRlYWwiLCJzdGVlbGJsdWUiLCJiaXNxdWUiLCJhcXVhbWFyaW5lIiwiYXF1YSIsInNpZW5uYSIsInNpbHZlciIsInNwcmluZ2dyZWVuIiwiYW50aXF1ZXdoaXRlIiwiYnVybHl3b29kIiwiYnJvd24iLCJiZWlnZSIsImNob2NvbGF0ZSIsImNoYXJ0cmV1c2UiLCJjb3JuZmxvd2VyYmx1ZSIsImNvcm5zaWxrIiwiY3JpbXNvbiIsImNhZGV0Ymx1ZSIsInRvbWF0byIsImZ1Y2hzaWEiLCJibHVlIiwic2FsbW9uIiwiYmxhbmNoZWRhbG1vbmQiLCJzbGF0ZWJsdWUiLCJzbGF0ZWdyYXkiLCJ0aGlzdGxlIiwidGFuIiwiY3lhbiIsImRhcmtibHVlIiwiZGFya2N5YW4iLCJkYXJrZ29sZGVucm9kIiwiZGFya2dyYXkiLCJibHVldmlvbGV0IiwiYmxhY2siLCJkYXJrbWFnZW50YSIsImRhcmtzbGF0ZWJsdWUiLCJkYXJra2hha2kiLCJkYXJrb3JjaGlkIiwiZGFya29yYW5nZSIsImRhcmtncmVlbiIsImRhcmtyZWQiLCJkb2RnZXJibHVlIiwiZGFya3NsYXRlZ3JheSIsImRpbWdyYXkiLCJkZWVwc2t5Ymx1ZSIsImZpcmVicmljayIsImZvcmVzdGdyZWVuIiwiaW5kaWdvIiwiaXZvcnkiLCJsYXZlbmRlcmJsdXNoIiwiZmVsZHNwYXIiLCJpbmRpYW5yZWQiLCJsaWdodGdyZWVuIiwibGlnaHRncmV5IiwibGlnaHRza3libHVlIiwibGlnaHRzbGF0ZWdyYXkiLCJsaWdodHNsYXRlYmx1ZSIsInNub3ciLCJsaWdodHNlYWdyZWVuIiwibGlnaHRzYWxtb24iLCJkYXJrc2FsbW9uIiwiZGFya3Zpb2xldCIsIm1lZGl1bXB1cnBsZSIsIm1lZGl1bWFxdWFtYXJpbmUiLCJza3libHVlIiwibGF2ZW5kZXIiLCJsaWdodHN0ZWVsYmx1ZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pbnRjcmVhbSIsIm5hdmFqb3doaXRlIiwibmF2eSIsIm9saXZlZHJhYiIsInBhbGV2aW9sZXRyZWQiLCJ2aW9sZXRyZWQiLCJ5ZWxsb3ciLCJ5ZWxsb3dncmVlbiIsImxhd25ncmVlbiIsInBpbmsiLCJwYWxldHVycXVvaXNlIiwicGFsZWdvbGRlbnJvZCIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya3NlYWdyZWVuIiwiZGFya3R1cnF1b2lzZSIsInBlYWNocHVmZiIsImRlZXBwaW5rIiwidmlvbGV0IiwicGFsZWdyZWVuIiwibWVkaXVtc2VhZ3JlZW4iLCJwZXJ1Iiwic2FkZGxlYnJvd24iLCJzYW5keWJyb3duIiwicm9zeWJyb3duIiwicHVycGxlIiwic2VhZ3JlZW4iLCJzZWFzaGVsbCIsInBhcGF5YXdoaXAiLCJtZWRpdW1zbGF0ZWJsdWUiLCJwbHVtIiwibWVkaXVtc3ByaW5nZ3JlZW4iLCJub3JtYWxpemVSZ2JDb21wb25lbnQiLCJjb21wb25lbnQiLCJNYXRoIiwicm91bmQiLCJub3JtYWxpemVBbHBoYUNvbXBvbmVudCIsInNob3J0SGV4UmUiLCJoZXhSZSIsInJnYlJlIiwicmdiYVJlIiwiY29sb3JTdHJpbmdUb1JnYmEiLCJjb2xvclN0cmluZyIsInRvTG93ZXJDYXNlIiwibWF0Y2hlcyIsImV4ZWMiLCJwYXJzZUludCIsImxlbmd0aCIsInBhcnNlRmxvYXQiLCJyZ2JhVG9HcmF5c2NhbGUiLCJyZ2JWYWx1ZSIsInJlZENvbXBvbmVudEdyYXlzY2FsZVdlaWdodCIsImdyZWVuQ29tcG9uZW50R3JheXNjYWxlV2VpZ2h0IiwiYmx1ZUNvbXBvbmVudEdyYXlzY2FsZVdlaWdodCIsImFwcGx5QWxwaGEiLCJhbHBoYSIsIm9yaWdpblJnYmEiLCJvcmlnaW5BbHBoYSIsImdlbmVyYXRlQ29udHJhc3RDb2xvcnMiLCJiYWNrZ3JvdW5kQ29sb3IiLCJyZ2IiLCJfaW50ZXJuYWxfYmFja2dyb3VuZCIsIl9pbnRlcm5hbF9mb3JlZ3JvdW5kIiwiZ3JhZGllbnRDb2xvckF0UGVyY2VudCIsInBlcmNlbnQiLCJ0b3BSIiwidG9wRyIsInRvcEIiLCJ0b3BBIiwiYm90dG9tUiIsImJvdHRvbUciLCJib3R0b21CIiwiYm90dG9tQSIsInJlc3VsdFJnYmEiLCJEZWxlZ2F0ZSIsIl9pbnRlcm5hbF9zdWJzY3JpYmUiLCJjYWxsYmFjayIsImxpbmtlZE9iamVjdCIsInNpbmdsZXNob3QiLCJsaXN0ZW5lciIsIl9pbnRlcm5hbF9jYWxsYmFjayIsIl9pbnRlcm5hbF9saW5rZWRPYmplY3QiLCJfaW50ZXJuYWxfc2luZ2xlc2hvdCIsIl9wcml2YXRlX19saXN0ZW5lcnMiLCJwdXNoIiwiX2ludGVybmFsX3Vuc3Vic2NyaWJlIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJfaW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwiLCJmaWx0ZXIiLCJfaW50ZXJuYWxfZmlyZSIsInBhcmFtMSIsInBhcmFtMiIsInBhcmFtMyIsImxpc3RlbmVyc1NuYXBzaG90IiwiZm9yRWFjaCIsIl9pbnRlcm5hbF9oYXNMaXN0ZW5lcnMiLCJfaW50ZXJuYWxfZGVzdHJveSIsImNvbnN0cnVjdG9yIiwibWVyZ2UiLCJkc3QiLCJzb3VyY2VzIiwic3JjIiwiaSIsIkFycmF5IiwiaXNBcnJheSIsImlzTnVtYmVyIiwiaXNGaW5pdGUiLCJpc0ludGVnZXIiLCJpc1N0cmluZyIsImlzQm9vbGVhbiIsImNsb25lIiwib2JqZWN0IiwibyIsImMiLCJwIiwidiIsImhhc093blByb3BlcnR5Iiwibm90TnVsbCIsInQiLCJ1bmRlZmluZWRJZk51bGwiLCJkZWZhdWx0Rm9udEZhbWlseSIsIm1ha2VGb250IiwiZmFtaWx5IiwiUHJpY2VBeGlzUmVuZGVyZXJPcHRpb25zUHJvdmlkZXIiLCJfaW50ZXJuYWxfb3B0aW9ucyIsInJlbmRlcmVyT3B0aW9ucyIsIl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMiLCJjdXJyZW50Rm9udFNpemUiLCJfcHJpdmF0ZV9fZm9udFNpemUiLCJjdXJyZW50Rm9udEZhbWlseSIsIl9wcml2YXRlX19mb250RmFtaWx5IiwiX2ludGVybmFsX2ZvbnRTaXplIiwiX2ludGVybmFsX2ZvbnRGYW1pbHkiLCJfaW50ZXJuYWxfZm9udCIsIl9pbnRlcm5hbF9wYWRkaW5nVG9wIiwiX2ludGVybmFsX3BhZGRpbmdCb3R0b20iLCJfaW50ZXJuYWxfcGFkZGluZ0lubmVyIiwiX2ludGVybmFsX3RpY2tMZW5ndGgiLCJfaW50ZXJuYWxfcGFkZGluZ091dGVyIiwiX2ludGVybmFsX2Jhc2VsaW5lT2Zmc2V0IiwiX2ludGVybmFsX2NvbG9yIiwiX3ByaXZhdGVfX3RleHRDb2xvciIsIl9pbnRlcm5hbF9wYW5lQmFja2dyb3VuZENvbG9yIiwiX3ByaXZhdGVfX3BhbmVCYWNrZ3JvdW5kQ29sb3IiLCJfcHJpdmF0ZV9fY2hhcnRNb2RlbCIsImxheW91dCIsInRleHRDb2xvciIsIl9pbnRlcm5hbF9iYWNrZ3JvdW5kVG9wQ29sb3IiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJjaGFydE1vZGVsIiwiX2ludGVybmFsX2JvcmRlclNpemUiLCJOYU4iLCJDb21wb3NpdGVSZW5kZXJlciIsIl9pbnRlcm5hbF9zZXRSZW5kZXJlcnMiLCJyZW5kZXJlcnMiLCJfcHJpdmF0ZV9fcmVuZGVyZXJzIiwiX2ludGVybmFsX2RyYXciLCJ0YXJnZXQiLCJpc0hvdmVyZWQiLCJoaXRUZXN0RGF0YSIsInIiLCJNZWRpYUNvb3JkaW5hdGVzUGFuZVJlbmRlcmVyIiwidXNlTWVkaWFDb29yZGluYXRlU3BhY2UiLCJzY29wZSIsIl9pbnRlcm5hbF9fZHJhd0ltcGwiLCJfaW50ZXJuYWxfZHJhd0JhY2tncm91bmQiLCJfaW50ZXJuYWxfX2RyYXdCYWNrZ3JvdW5kSW1wbCIsInJlbmRlcmluZ1Njb3BlIiwiUGFuZVJlbmRlcmVyTWFya3MiLCJfaW50ZXJuYWxfc2V0RGF0YSIsImRhdGEiLCJfaW50ZXJuYWxfX2RhdGEiLCJjb250ZXh0IiwiX2ludGVybmFsX3Zpc2libGVSYW5nZSIsInZpc2libGVSYW5nZSIsImRyYXciLCJyYWRpdXMiLCJ0byIsImZyb20iLCJwb2ludCIsIl9pbnRlcm5hbF9pdGVtcyIsIl9pbnRlcm5hbF94IiwiX2ludGVybmFsX3kiLCJhcmMiLCJQSSIsImZpbGwiLCJfaW50ZXJuYWxfbGluZVdpZHRoIiwiZmlsbFN0eWxlIiwiX2ludGVybmFsX2JhY2tDb2xvciIsIl9pbnRlcm5hbF9yYWRpdXMiLCJfaW50ZXJuYWxfbGluZUNvbG9yIiwiYXJndW1lbnRzIiwiY3JlYXRlRW1wdHlNYXJrZXJEYXRhIiwiX2ludGVybmFsX3RpbWUiLCJfaW50ZXJuYWxfcHJpY2UiLCJyYW5nZUZvclNpbmdsZVBvaW50IiwiQ3Jvc3NoYWlyTWFya3NQYW5lVmlldyIsIl9pbnRlcm5hbF91cGRhdGUiLCJ1cGRhdGVUeXBlIiwic2VyaWVzZXMiLCJfaW50ZXJuYWxfc2VyaWVzZXMiLCJfcHJpdmF0ZV9fbWFya2Vyc1JlbmRlcmVycyIsIl9wcml2YXRlX19tYXJrZXJzRGF0YSIsIm1hcCIsInJlcyIsIl9wcml2YXRlX19jb21wb3NpdGVSZW5kZXJlciIsIl9wcml2YXRlX19pbnZhbGlkYXRlZCIsIl9pbnRlcm5hbF9yZW5kZXJlciIsIl9wcml2YXRlX191cGRhdGVJbXBsIiwiZm9yY2VIaWRkZW4iLCJfcHJpdmF0ZV9fY3Jvc3NoYWlyIiwibW9kZSIsInRpbWVQb2ludEluZGV4IiwiX2ludGVybmFsX2FwcGxpZWRJbmRleCIsInRpbWVTY2FsZSIsIl9pbnRlcm5hbF90aW1lU2NhbGUiLCJzIiwiX2EiLCJzZXJpZXNEYXRhIiwiX2ludGVybmFsX21hcmtlckRhdGFBdEluZGV4IiwiX2ludGVybmFsX3Zpc2libGUiLCJmaXJzdFZhbHVlIiwiX2ludGVybmFsX2ZpcnN0VmFsdWUiLCJfaW50ZXJuYWxfYmFja2dyb3VuZENvbG9yIiwiX2ludGVybmFsX2JvcmRlcldpZHRoIiwiX2ludGVybmFsX3ByaWNlU2NhbGUiLCJfaW50ZXJuYWxfcHJpY2VUb0Nvb3JkaW5hdGUiLCJfaW50ZXJuYWxfdmFsdWUiLCJfaW50ZXJuYWxfYm9yZGVyQ29sb3IiLCJfaW50ZXJuYWxfYmFja2dyb3VuZENvbG9yQXRZUGVyY2VudEZyb21Ub3AiLCJfaW50ZXJuYWxfaGVpZ2h0IiwiX2ludGVybmFsX2luZGV4VG9Db29yZGluYXRlIiwiY3Jvc3NoYWlyIiwiQml0bWFwQ29vcmRpbmF0ZXNQYW5lUmVuZGVyZXIiLCJ1c2VCaXRtYXBDb29yZGluYXRlU3BhY2UiLCJDcm9zc2hhaXJSZW5kZXJlciIsImJpdG1hcFNpemUiLCJob3Jpem9udGFsUGl4ZWxSYXRpbyIsInZlcnRpY2FsUGl4ZWxSYXRpbyIsIl9wcml2YXRlX19kYXRhIiwidmVydExpbmVzVmlzaWJsZSIsIl9pbnRlcm5hbF92ZXJ0TGluZSIsImhvcnpMaW5lc1Zpc2libGUiLCJfaW50ZXJuYWxfaG9yekxpbmUiLCJsaW5lQ2FwIiwiZmxvb3IiLCJzdHJva2VTdHlsZSIsIl9pbnRlcm5hbF9saW5lU3R5bGUiLCJoZWlnaHQiLCJ3aWR0aCIsIkNyb3NzaGFpclBhbmVWaWV3IiwiX3ByaXZhdGVfX3JlbmRlcmVyIiwiX3ByaXZhdGVfX3NvdXJjZSIsInBhbmUiLCJfaW50ZXJuYWxfcGFuZSIsImNyb3NzaGFpck9wdGlvbnMiLCJfaW50ZXJuYWxfbW9kZWwiLCJfcHJpdmF0ZV9fcmVuZGVyZXJEYXRhIiwiX2ludGVybmFsX2hvcnpMaW5lVmlzaWJsZSIsIl9pbnRlcm5hbF92ZXJ0TGluZVZpc2libGUiLCJob3J6TGluZSIsInZlcnRMaW5lIiwiX2ludGVybmFsX2FwcGxpZWRYIiwiX2ludGVybmFsX2FwcGxpZWRZIiwic291cmNlIiwiZmlsbFJlY3RJbm5lckJvcmRlciIsImJvcmRlcldpZHRoIiwiZmlsbFJlY3QiLCJjbGVhclJlY3QiLCJ3IiwiaCIsImNsZWFyQ29sb3IiLCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24iLCJjaGFuZ2VCb3JkZXJSYWRpdXMiLCJib3JkZXJSYWRpdXMiLCJvZmZzZXQiLCJkcmF3Um91bmRSZWN0IiwicmFkaWkiLCJhcmNUbyIsImRyYXdSb3VuZFJlY3RXaXRoSW5uZXJCb3JkZXIiLCJoYWxmQm9yZGVyV2lkdGgiLCJpbm5lclJhZGlpIiwib3V0ZXJSYWRpaSIsImNsb3NlUGF0aCIsImNsZWFyUmVjdFdpdGhHcmFkaWVudCIsImdyYWRpZW50IiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJhZGRDb2xvclN0b3AiLCJQcmljZUF4aXNWaWV3UmVuZGVyZXIiLCJjb21tb25EYXRhIiwiX3ByaXZhdGVfX2NvbW1vbkRhdGEiLCJ1c2VTZWNvbmRMaW5lIiwidGV4dFdpZHRoQ2FjaGUiLCJhbGlnbiIsIl9pbnRlcm5hbF90ZXh0IiwiZ2VvbWV0cnkiLCJmb250IiwiZ2VvbSIsIl9wcml2YXRlX19jYWxjdWxhdGVHZW9tZXRyeSIsImdiIiwiX2ludGVybmFsX2JpdG1hcCIsImRyYXdMYWJlbEJvZHkiLCJsYWJlbEJhY2tncm91bmRDb2xvciIsImxhYmVsQm9yZGVyQ29sb3IiLCJfaW50ZXJuYWxfYWxpZ25SaWdodCIsIl9pbnRlcm5hbF94T3V0c2lkZSIsIl9pbnRlcm5hbF95VG9wIiwiX2ludGVybmFsX3RvdGFsV2lkdGgiLCJfaW50ZXJuYWxfdG90YWxIZWlnaHQiLCJfaW50ZXJuYWxfaG9yekJvcmRlciIsIl9pbnRlcm5hbF94SW5zaWRlIiwiX2ludGVybmFsX3RpY2tWaXNpYmxlIiwiX2ludGVybmFsX3lNaWQiLCJfaW50ZXJuYWxfeFRpY2siLCJfaW50ZXJuYWxfdGlja0hlaWdodCIsIl9pbnRlcm5hbF9ib3JkZXJWaXNpYmxlIiwiX2ludGVybmFsX3JpZ2h0IiwiX2ludGVybmFsX3lCb3R0b20iLCJnbSIsIl9pbnRlcm5hbF9tZWRpYSIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0IiwiX2ludGVybmFsX3hUZXh0IiwiX2ludGVybmFsX3RleHRNaWRDb3JyZWN0aW9uIiwibWVkaWFTaXplIiwidGlja1NpemUiLCJfaW50ZXJuYWxfbW92ZVRleHRUb0ludmlzaWJsZVRpY2siLCJob3J6Qm9yZGVyIiwiX2ludGVybmFsX3NlcGFyYXRvclZpc2libGUiLCJwYWRkaW5nVG9wIiwiX2ludGVybmFsX2FkZGl0aW9uYWxQYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsIl9pbnRlcm5hbF9hZGRpdGlvbmFsUGFkZGluZ0JvdHRvbSIsInBhZGRpbmdJbm5lciIsInBhZGRpbmdPdXRlciIsInRleHQiLCJhY3R1YWxUZXh0SGVpZ2h0IiwidGV4dE1pZENvcnJlY3Rpb24iLCJfaW50ZXJuYWxfeU1pZENvcnJlY3Rpb24iLCJ0ZXh0V2lkdGgiLCJjZWlsIiwiX2ludGVybmFsX21lYXN1cmVUZXh0IiwidG90YWxIZWlnaHQiLCJ0b3RhbFdpZHRoIiwidGlja0hlaWdodEJpdG1hcCIsIm1heCIsInRvdGFsSGVpZ2h0Qml0bWFwIiwiaG9yekJvcmRlckJpdG1hcCIsInRvdGFsV2lkdGhCaXRtYXAiLCJ0aWNrU2l6ZUJpdG1hcCIsInlNaWQiLCJfaW50ZXJuYWxfZml4ZWRDb29yZGluYXRlIiwiX2ludGVybmFsX2Nvb3JkaW5hdGUiLCJ5TWlkQml0bWFwIiwieVRvcEJpdG1hcCIsInlCb3R0b21CaXRtYXAiLCJhbGlnblJpZ2h0IiwieEluc2lkZSIsInhJbnNpZGVCaXRtYXAiLCJ4T3V0c2lkZUJpdG1hcCIsInhUaWNrQml0bWFwIiwieFRleHQiLCJQcmljZUF4aXNWaWV3IiwiX3ByaXZhdGVfX3VwZGF0ZVJlbmRlcmVyRGF0YUlmTmVlZGVkIiwiX3ByaXZhdGVfX2F4aXNSZW5kZXJlckRhdGEiLCJfcHJpdmF0ZV9fY29tbW9uUmVuZGVyZXJEYXRhIiwiX3ByaXZhdGVfX2F4aXNSZW5kZXJlciIsIl9wcml2YXRlX19wYW5lUmVuZGVyZXIiLCJfaW50ZXJuYWxfZ2V0Rml4ZWRDb29yZGluYXRlIiwiX2ludGVybmFsX3NldEZpeGVkQ29vcmRpbmF0ZSIsIl9pbnRlcm5hbF9pc1Zpc2libGUiLCJfcHJpdmF0ZV9fcGFuZVJlbmRlcmVyRGF0YSIsIl9pbnRlcm5hbF9pc0F4aXNMYWJlbFZpc2libGUiLCJwcmljZVNjYWxlIiwidGlja3NWaXNpYmxlIiwiX2ludGVybmFsX3BhbmVSZW5kZXJlciIsIl9pbnRlcm5hbF9fdXBkYXRlUmVuZGVyZXJEYXRhIiwiY3RvciIsIkNyb3NzaGFpclByaWNlQXhpc1ZpZXciLCJheGlzUmVuZGVyZXJEYXRhIiwicGFuZVJlbmRlcmVyRGF0YSIsImNvbW1vblJlbmRlcmVyRGF0YSIsIm9wdGlvbnMiLCJsYWJlbFZpc2libGUiLCJfcHJpdmF0ZV9fcHJpY2VTY2FsZSIsIl9pbnRlcm5hbF9pc0VtcHR5IiwiY29sb3JzIiwiYWRkaXRpb25hbFBhZGRpbmciLCJfcHJpdmF0ZV9fdmFsdWVQcm92aWRlciIsIl9pbnRlcm5hbF9mb3JtYXRQcmljZSIsInZhbHVlUHJvdmlkZXIiLCJvcHRpbWl6YXRpb25SZXBsYWNlbWVudFJlIiwicmFkaXVzJDEiLCJUaW1lQXhpc1ZpZXdSZW5kZXJlciIsIl9pbnRlcm5hbF93aWR0aENhY2hlIiwiaG9yek1hcmdpbiIsIl9pbnRlcm5hbF9wYWRkaW5nSG9yaXpvbnRhbCIsImxhYmVsV2lkdGgiLCJsYWJlbFdpZHRoSGFsZiIsInRpbWVTY2FsZVdpZHRoIiwiX2ludGVybmFsX3dpZHRoIiwiY29vcmRpbmF0ZSIsIngxIiwiYWJzIiwieDIiLCJ5MSIsInkyIiwieDFzY2FsZWQiLCJ5MXNjYWxlZCIsIngyc2NhbGVkIiwieTJzY2FsZWQiLCJyYWRpdXNTY2FsZWQiLCJ0aWNrWCIsInRpY2tUb3AiLCJ0aWNrQm90dG9tIiwidGlja1dpZHRoIiwidGlja09mZnNldCIsInlUZXh0IiwidGV4dFlDb3JyZWN0aW9uIiwiQ3Jvc3NoYWlyVGltZUF4aXNWaWV3IiwiX3ByaXZhdGVfX21vZGVsIiwiY3VycmVudFRpbWUiLCJfaW50ZXJuYWxfaW5kZXhUb1RpbWVTY2FsZVBvaW50IiwiX2ludGVybmFsX2Zvcm1hdERhdGVUaW1lIiwibW9kZWwiLCJEYXRhU291cmNlIiwiX2ludGVybmFsX3pvcmRlciIsIl9wcml2YXRlX196b3JkZXIiLCJfaW50ZXJuYWxfc2V0Wm9yZGVyIiwiem9yZGVyIiwiX2ludGVybmFsX19wcmljZVNjYWxlIiwiX2ludGVybmFsX3NldFByaWNlU2NhbGUiLCJfaW50ZXJuYWxfbGFiZWxQYW5lVmlld3MiLCJfaW50ZXJuYWxfdGltZUF4aXNWaWV3cyIsIkNyb3NzaGFpck1vZGUiLCJDcm9zc2hhaXIiLCJfcHJpdmF0ZV9fb3B0aW9ucyIsIl9pbnRlcm5hbF9zYXZlT3JpZ2luQ29vcmQiLCJfcHJpdmF0ZV9fb3JpZ2luWCIsIl9wcml2YXRlX19vcmlnaW5ZIiwiX2ludGVybmFsX2NsZWFyT3JpZ2luQ29vcmQiLCJfaW50ZXJuYWxfb3JpZ2luQ29vcmRYIiwiX2ludGVybmFsX29yaWdpbkNvb3JkWSIsIl9pbnRlcm5hbF9zZXRQb3NpdGlvbiIsIl9wcml2YXRlX19zdWJzY3JpYmVkIiwiX3ByaXZhdGVfX3Zpc2libGUiLCJfcHJpdmF0ZV9fdHJ5VG9VcGRhdGVWaWV3cyIsIl9wcml2YXRlX19pbmRleCIsIl9wcml2YXRlX194IiwiX3ByaXZhdGVfX3kiLCJfaW50ZXJuYWxfY2xlYXJQb3NpdGlvbiIsIl9wcml2YXRlX19zZXRJbmRleFRvTGFzdFNlcmllc0JhckluZGV4IiwiX3ByaXZhdGVfX3ByaWNlIiwiX3ByaXZhdGVfX3BhbmUiLCJfaW50ZXJuYWxfcGFuZVZpZXdzIiwiX3ByaXZhdGVfX3BhbmVWaWV3IiwiX3ByaXZhdGVfX21hcmtlcnNQYW5lVmlldyIsIl9pbnRlcm5hbF9wcmljZUF4aXNWaWV3cyIsIl9wcml2YXRlX19wcmljZUF4aXNWaWV3cyIsImNsZWFyIiwidmlld3MiLCJfcHJpdmF0ZV9fY3JlYXRlUHJpY2VBeGlzVmlld09uRGVtYW5kIiwiX3ByaXZhdGVfX2N1cnJlbnRQb3NQcmljZVByb3ZpZGVyIiwiX3ByaXZhdGVfX3RpbWVBeGlzVmlldyIsIl9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cyIsIl9wcml2YXRlX19wcmljZVNjYWxlQnlQYW5lIiwiX2ludGVybmFsX2RlZmF1bHRQcmljZVNjYWxlIiwiX3ByaXZhdGVfX3RyeVRvVXBkYXRlRGF0YSIsIm5ld0luZGV4IiwibmV3UHJpY2UiLCJuZXdQYW5lIiwib2xkWCIsIm9sZFkiLCJvbGRQcmljZSIsIm9sZEluZGV4Iiwib2xkUGFuZSIsImlzTmFOIiwibGFzdEluZGV4ZXMiLCJfaW50ZXJuYWxfYmFycyIsIl9pbnRlcm5hbF9sYXN0SW5kZXgiLCJsYXN0QmFySW5kZXgiLCJ2aWV3IiwiZ2V0Iiwic2V0IiwiTWFwIiwidmFsdWVQcmljZVByb3ZpZGVyIiwicmF3UHJpY2VQcm92aWRlciIsInJhd0Nvb3JkaW5hdGVQcm92aWRlciIsInJhd1ByaWNlIiwiX2ludGVybmFsX2Nvb3JkaW5hdGVUb1ByaWNlIiwidmFsdWVUaW1lUHJvdmlkZXIiLCJyYXdJbmRleFByb3ZpZGVyIiwidGltZSIsIl9pbnRlcm5hbF9pbmRleFRvVGltZSIsIk51bWJlciIsImN1cnJlbnRQb3NUaW1lUHJvdmlkZXIiLCJpc0RlZmF1bHRQcmljZVNjYWxlIiwicHJpY2VTY2FsZUlkIiwibWVyZ2VQYW5lSW52YWxpZGF0aW9uIiwiYmVmb3JlVmFsdWUiLCJuZXdWYWx1ZSIsImxldmVsIiwiX2ludGVybmFsX2xldmVsIiwiYXV0b1NjYWxlIiwiX2ludGVybmFsX2F1dG9TY2FsZSIsIkludmFsaWRhdGVNYXNrIiwiX2ludGVybmFsX2ludmFsaWRhdGVQYW5lIiwicGFuZUluZGV4IiwiaW52YWxpZGF0aW9uIiwicHJldlZhbHVlIiwiX3ByaXZhdGVfX2ludmFsaWRhdGVkUGFuZXMiLCJfaW50ZXJuYWxfZnVsbEludmFsaWRhdGlvbiIsIl9wcml2YXRlX19nbG9iYWxMZXZlbCIsIl9pbnRlcm5hbF9pbnZhbGlkYXRlRm9yUGFuZSIsInBhbmVJbnZhbGlkYXRpb24iLCJfaW50ZXJuYWxfc2V0Rml0Q29udGVudCIsIl9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uIiwiX3ByaXZhdGVfX3RpbWVTY2FsZUludmFsaWRhdGlvbnMiLCJfaW50ZXJuYWxfdHlwZSIsIl9pbnRlcm5hbF9hcHBseVJhbmdlIiwicmFuZ2UiLCJfaW50ZXJuYWxfc2V0VGltZVNjYWxlQW5pbWF0aW9uIiwiYW5pbWF0aW9uIiwiX3ByaXZhdGVfX3JlbW92ZVRpbWVTY2FsZUFuaW1hdGlvbiIsIl9pbnRlcm5hbF9yZXNldFRpbWVTY2FsZSIsIl9pbnRlcm5hbF9zZXRCYXJTcGFjaW5nIiwiYmFyU3BhY2luZyIsIl9pbnRlcm5hbF9zZXRSaWdodE9mZnNldCIsIl9pbnRlcm5hbF90aW1lU2NhbGVJbnZhbGlkYXRpb25zIiwiX2ludGVybmFsX21lcmdlIiwib3RoZXIiLCJ0c0ludmFsaWRhdGlvbiIsIl9wcml2YXRlX19hcHBseVRpbWVTY2FsZUludmFsaWRhdGlvbiIsIl9pbnRlcm5hbF9saWdodCIsIl9pbnRlcm5hbF9mdWxsIiwiaW52IiwiZ2xvYmFsTGV2ZWwiLCJmb3JtYXR0ZXJPcHRpb25zIiwiX2ludGVybmFsX2RlY2ltYWxTaWduIiwiX2ludGVybmFsX2RlY2ltYWxTaWduRnJhY3Rpb25hbCIsIm51bWJlclRvU3RyaW5nV2l0aExlYWRpbmdaZXJvIiwiVHlwZUVycm9yIiwidG9TdHJpbmciLCJkdW1teVN0cmluZyIsInNsaWNlIiwiUHJpY2VGb3JtYXR0ZXIiLCJmb3JtYXQiLCJzaWduIiwiX3ByaXZhdGVfX2Zvcm1hdEFzRGVjaW1hbCIsIl9wcml2YXRlX19jYWxjdWxhdGVEZWNpbWFsIiwiX2ludGVybmFsX19mcmFjdGlvbmFsTGVuZ3RoIiwiX3ByaXZhdGVfX21pbk1vdmUiLCJpbnRQYXJ0IiwiZnJhY1N0cmluZyIsImZyYWNMZW5ndGgiLCJmcmFjUGFydCIsInRvRml4ZWQiLCJQZXJjZW50YWdlRm9ybWF0dGVyIiwiVm9sdW1lRm9ybWF0dGVyIiwidm9sIiwiX3ByaXZhdGVfX2Zvcm1hdE51bWJlciIsInBvdyIsIl9wcml2YXRlX19wcmVjaXNpb24iLCJyZXBsYWNlIiwiU3RyaW5nIiwiZSIsInAxIiwid2Fsa0xpbmUiLCJpdGVtcyIsImJhcldpZHRoIiwic3R5bGVHZXR0ZXIiLCJmaW5pc2hTdHlsZWRBcmVhIiwiZmlyc3RJdGVtIiwiY3VycmVudFN0eWxlIiwiY3VycmVudFN0eWxlRmlyc3RJdGVtIiwiaGFsZkJhcldpZHRoIiwiaXRlbTEiLCJpdGVtMiIsImNoYW5nZVN0eWxlIiwibmV3U3R5bGUiLCJjdXJyZW50SXRlbSIsIml0ZW1TdHlsZSIsImNwMSIsImNwMiIsImdldENvbnRyb2xQb2ludHMiLCJiZXppZXJDdXJ2ZVRvIiwiY3VydmVUZW5zaW9uIiwic3VidHJhY3QiLCJwMiIsImFkZCIsImRpdmlkZSIsIm4iLCJwb2ludHMiLCJmcm9tUG9pbnRJbmRleCIsInRvUG9pbnRJbmRleCIsImJlZm9yZUZyb21Qb2ludEluZGV4IiwiYWZ0ZXJUb1BvaW50SW5kZXgiLCJtaW4iLCJmaW5pc2hTdHlsZWRBcmVhJDEiLCJiYXNlTGV2ZWxDb29yZGluYXRlIiwiYXJlYUZpcnN0SXRlbSIsIm5ld0FyZWFGaXJzdEl0ZW0iLCJQYW5lUmVuZGVyZXJBcmVhQmFzZSIsIl9pbnRlcm5hbF9iYXJXaWR0aCIsIl9pbnRlcm5hbF9saW5lVHlwZSIsIl9pbnRlcm5hbF9iYXNlTGV2ZWxDb29yZGluYXRlIiwiX2ludGVybmFsX2ludmVydEZpbGxlZEFyZWEiLCJsaW5lSm9pbiIsIl9pbnRlcm5hbF9fZmlsbFN0eWxlIiwiYmluZCIsImNsYW1wIiwibWluVmFsIiwibWF4VmFsIiwiaXNCYXNlRGVjaW1hbCIsImN1cnJlbnQiLCJncmVhdGVyT3JFcXVhbCIsImVwc2lsb24iLCJlcXVhbCIsImFyciIsImNlaWxlZEV2ZW4iLCJjZWlsZWQiLCJjZWlsZWRPZGQiLCJHcmFkaWVudFN0eWxlQ2FjaGUiLCJfaW50ZXJuYWxfZ2V0IiwicGFyYW1zIiwiY2FjaGVkUGFyYW1zIiwiX3ByaXZhdGVfX3BhcmFtcyIsIl9pbnRlcm5hbF90b3BDb2xvcjEiLCJ0b3BDb2xvcjEiLCJfaW50ZXJuYWxfdG9wQ29sb3IyIiwidG9wQ29sb3IyIiwiX2ludGVybmFsX2JvdHRvbUNvbG9yMSIsImJvdHRvbUNvbG9yMSIsIl9pbnRlcm5hbF9ib3R0b21Db2xvcjIiLCJib3R0b21Db2xvcjIiLCJfaW50ZXJuYWxfYm90dG9tIiwiX3ByaXZhdGVfX2NhY2hlZFZhbHVlIiwiYmFzZWxpbmVQZXJjZW50IiwiUGFuZVJlbmRlcmVyQXJlYSIsIml0ZW0iLCJfcHJpdmF0ZV9fZmlsbENhY2hlIiwiX2ludGVybmFsX3RvcENvbG9yIiwiX2ludGVybmFsX2JvdHRvbUNvbG9yIiwiZHJhd1Nlcmllc1BvaW50TWFya2VycyIsInBvaW50TWFya2Vyc1JhZGl1cyIsInByZXZTdHlsZSIsImNlbnRlclgiLCJjZW50ZXJZIiwiUGFuZVJlbmRlcmVyTGluZUJhc2UiLCJfaW50ZXJuYWxfcG9pbnRNYXJrZXJzUmFkaXVzIiwiX2ludGVybmFsX19zdHJva2VTdHlsZSIsIlBhbmVSZW5kZXJlckxpbmUiLCJib3VuZENvbXBhcmUiLCJsb3dlciIsImNvbXBhcmUiLCJzdGFydCIsImNvdW50IiwiY291bnQyIiwibWlkIiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJsb3dlckJvdW5kSXRlbXNDb21wYXJlIiwidXBwZXJCb3VuZEl0ZW1zQ29tcGFyZSIsInZpc2libGVUaW1lZFZhbHVlcyIsImV4dGVuZGVkUmFuZ2UiLCJmaXJzdEJhciIsIl9pbnRlcm5hbF9sZWZ0IiwibGFzdEJhciIsImV4dGVuZGVkRnJvbSIsImV4dGVuZGVkVG8iLCJTZXJpZXNQYW5lVmlld0Jhc2UiLCJfaW50ZXJuYWxfX2ludmFsaWRhdGVkIiwiX2ludGVybmFsX19kYXRhSW52YWxpZGF0ZWQiLCJfaW50ZXJuYWxfX29wdGlvbnNJbnZhbGlkYXRlZCIsIl9pbnRlcm5hbF9fc2VyaWVzIiwiX3ByaXZhdGVfX21ha2VWYWxpZCIsIl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UiLCJfaW50ZXJuYWxfX3JlbmRlcmVyIiwiX2ludGVybmFsX191cGRhdGVPcHRpb25zIiwiX2ludGVybmFsX19pdGVtcyIsIk9iamVjdCIsImFzc2lnbiIsIl9pbnRlcm5hbF9iYXJDb2xvcmVyIiwiX2ludGVybmFsX2JhclN0eWxlIiwiX2ludGVybmFsX19jbGVhclZpc2libGVSYW5nZSIsIl9pbnRlcm5hbF9fZmlsbFJhd1BvaW50cyIsIl9wcml2YXRlX19tYWtlVmFsaWRJbXBsIiwiX2ludGVybmFsX19tb2RlbCIsInZpc2libGVCYXJzIiwiX2ludGVybmFsX3Zpc2libGVTdHJpY3RSYW5nZSIsIl9pbnRlcm5hbF9zaXplIiwiX3ByaXZhdGVfX2V4dGVuZGVkVmlzaWJsZVJhbmdlIiwiX2ludGVybmFsX19jb252ZXJ0VG9Db29yZGluYXRlcyIsIl9pbnRlcm5hbF9fcHJlcGFyZVJlbmRlcmVyRGF0YSIsInNlcmllcyIsImV4dGVuZGVkVmlzaWJsZVJhbmdlIiwiTGluZVBhbmVWaWV3QmFzZSIsIl9pbnRlcm5hbF9pbmRleGVzVG9Db29yZGluYXRlcyIsIl9pbnRlcm5hbF9wb2ludHNBcnJheVRvQ29vcmRpbmF0ZXMiLCJfaW50ZXJuYWxfX2NyZWF0ZVJhd0l0ZW1CYXNlIiwiY29sb3JlciIsIl9pbnRlcm5hbF9yb3dzIiwicm93IiwiX2ludGVybmFsX19jcmVhdGVSYXdJdGVtIiwiX2ludGVybmFsX2luZGV4IiwiU2VyaWVzQXJlYVBhbmVWaWV3IiwiX3ByaXZhdGVfX2FyZWFSZW5kZXJlciIsIl9pbnRlcm5hbF9iYXJTcGFjaW5nIiwiX3ByaXZhdGVfX2xpbmVSZW5kZXJlciIsIm9wdGltYWxCYXJXaWR0aCIsInBpeGVsUmF0aW8iLCJvcHRpbWFsQ2FuZGxlc3RpY2tXaWR0aCIsImJhclNwYWNpbmdTcGVjaWFsQ2FzZUZyb20iLCJiYXJTcGFjaW5nU3BlY2lhbENhc2VUbyIsImJhclNwYWNpbmdTcGVjaWFsQ2FzZUNvZWZmIiwiYmFyU3BhY2luZ1JlZHVjaW5nQ29lZmYiLCJjb2VmZiIsImF0YW4iLCJzY2FsZWRCYXJTcGFjaW5nIiwib3B0aW1hbCIsIlBhbmVSZW5kZXJlckJhcnMiLCJfcHJpdmF0ZV9fYmFyV2lkdGgiLCJfcHJpdmF0ZV9fY2FsY0JhcldpZHRoIiwiX3ByaXZhdGVfX2JhckxpbmVXaWR0aCIsIl9pbnRlcm5hbF90aGluQmFycyIsInByZXZDb2xvciIsImRyYXdPcGVuQ2xvc2UiLCJiYXIiLCJfaW50ZXJuYWxfYmFyQ29sb3IiLCJib2R5V2lkdGhIYWxmIiwiYm9keUNlbnRlciIsImJvZHlMZWZ0IiwiYm9keVdpZHRoIiwiYm9keVJpZ2h0IiwiaGlnaCIsIl9pbnRlcm5hbF9oaWdoWSIsIl9pbnRlcm5hbF9sb3dZIiwibG93IiwiYm9keVRvcCIsImJvZHlCb3R0b20iLCJib2R5SGVpZ2h0Iiwic2lkZVdpZHRoIiwiX2ludGVybmFsX29wZW5WaXNpYmxlIiwib3BlbkxlZnQiLCJvcGVuVG9wIiwiX2ludGVybmFsX29wZW5ZIiwib3BlbkJvdHRvbSIsImNsb3NlUmlnaHQiLCJjbG9zZVRvcCIsIl9pbnRlcm5hbF9jbG9zZVkiLCJjbG9zZUJvdHRvbSIsImxpbWl0IiwiQmFyc1BhbmVWaWV3QmFzZSIsIl9pbnRlcm5hbF9iYXJQcmljZXNUb0Nvb3JkaW5hdGVzIiwiX2ludGVybmFsX19jcmVhdGVEZWZhdWx0SXRlbSIsIl9pbnRlcm5hbF9vcGVuIiwiX2ludGVybmFsX2hpZ2giLCJfaW50ZXJuYWxfbG93IiwiX2ludGVybmFsX2Nsb3NlIiwiU2VyaWVzQmFyc1BhbmVWaWV3IiwiYmFyU3R5bGVQcm9wcyIsIlBhbmVSZW5kZXJlckJhc2VsaW5lQXJlYSIsIl9pbnRlcm5hbF90b3BGaWxsQ29sb3IxIiwiX2ludGVybmFsX3RvcEZpbGxDb2xvcjIiLCJfaW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMSIsIl9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IyIiwiUGFuZVJlbmRlcmVyQmFzZWxpbmVMaW5lIiwiX3ByaXZhdGVfX3N0cm9rZUNhY2hlIiwiX2ludGVybmFsX3RvcExpbmVDb2xvciIsIl9pbnRlcm5hbF9ib3R0b21MaW5lQ29sb3IiLCJTZXJpZXNCYXNlbGluZVBhbmVWaWV3IiwiX3ByaXZhdGVfX2Jhc2VsaW5lQXJlYVJlbmRlcmVyIiwiX3ByaXZhdGVfX2Jhc2VsaW5lTGluZVJlbmRlcmVyIiwiUGFuZVJlbmRlcmVyQ2FuZGxlc3RpY2tzIiwid2lja1dpZHRoIiwiYmFycyIsIl9pbnRlcm5hbF93aWNrVmlzaWJsZSIsIl9wcml2YXRlX19kcmF3V2lja3MiLCJfcHJpdmF0ZV9fZHJhd0JvcmRlciIsIl9wcml2YXRlX19jYWxjdWxhdGVCb3JkZXJXaWR0aCIsIl9wcml2YXRlX19kcmF3Q2FuZGxlcyIsInByZXZXaWNrQ29sb3IiLCJ3aWNrT2Zmc2V0IiwicHJldkVkZ2UiLCJfaW50ZXJuYWxfYmFyV2lja0NvbG9yIiwic2NhbGVkWCIsInByZXZCb3JkZXJDb2xvciIsIl9pbnRlcm5hbF9iYXJCb3JkZXJDb2xvciIsInByZXZCYXJDb2xvciIsImJhckNvbG9yIiwiU2VyaWVzQ2FuZGxlc3RpY2tzUGFuZVZpZXciLCJjYW5kbGVzdGlja1N0eWxlUHJvcHMiLCJDdXN0b21TZXJpZXNQYW5lUmVuZGVyZXJXcmFwcGVyIiwiX3ByaXZhdGVfX3NvdXJjZVJlbmRlcmVyIiwic291cmNlUmVuZGVyZXIiLCJTZXJpZXNDdXN0b21QYW5lVmlldyIsIl9pbnRlcm5hbF9wcmljZVZhbHVlQnVpbGRlciIsInBsb3RSb3ciLCJwcmljZVZhbHVlQnVpbGRlciIsIl9pbnRlcm5hbF9pc1doaXRlc3BhY2UiLCJpc1doaXRlc3BhY2UiLCJfaW50ZXJuYWxfb3JpZ2luYWxEYXRhIiwiX2ludGVybmFsX2RhdGEiLCJ1cGRhdGUiLCJ1bndyYXBJdGVtRGF0YSIsInBhbmVWaWV3IiwicmVuZGVyZXIiLCJvcmlnaW5hbERhdGEiLCJzaG93U3BhY2luZ01pbmltYWxCYXJXaWR0aCIsImFsaWduVG9NaW5pbWFsV2lkdGhMaW1pdCIsIlBhbmVSZW5kZXJlckhpc3RvZ3JhbSIsIl9wcml2YXRlX19wcmVjYWxjdWxhdGVkQ2FjaGUiLCJfcHJpdmF0ZV9fZmlsbFByZWNhbGN1bGF0ZWRDYWNoZSIsImhpc3RvZ3JhbUJhc2UiLCJfaW50ZXJuYWxfaGlzdG9ncmFtQmFzZSIsInRvcEhpc3RvZ3JhbUJhc2UiLCJib3R0b21IaXN0b2dyYW1CYXNlIiwic3BhY2luZyIsImNvbHVtbldpZHRoIiwiaGFsZldpZHRoIiwiX2ludGVybmFsX3JvdW5kZWRDZW50ZXIiLCJfaW50ZXJuYWxfY2VudGVyIiwicHJldiIsIm1pbldpZHRoIiwiU2VyaWVzSGlzdG9ncmFtUGFuZVZpZXciLCJTZXJpZXNMaW5lUGFuZVZpZXciLCJkZWZhdWx0UmVwbGFjZW1lbnRSZSIsIlRleHRXaWR0aENhY2hlIiwiX2ludGVybmFsX3Jlc2V0IiwiX3ByaXZhdGVfX2FjdHVhbFNpemUiLCJfcHJpdmF0ZV9fY2FjaGUiLCJfcHJpdmF0ZV9fdXNhZ2VUaWNrIiwiX3ByaXZhdGVfX29sZGVzdFRpY2siLCJfcHJpdmF0ZV9fdGljazJMYWJlbHMiLCJfcHJpdmF0ZV9fZ2V0TWV0cmljcyIsIm1ldHJpY3MiLCJhY3R1YWxCb3VuZGluZ0JveEFzY2VudCIsImFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCIsInJlIiwiY2FjaGVTdHJpbmciLCJoYXMiLCJfaW50ZXJuYWxfbWV0cmljcyIsIl9wcml2YXRlX19tYXhTaXplIiwib2xkZXN0VmFsdWUiLCJkZWxldGUiLCJtZWFzdXJlVGV4dCIsIl9pbnRlcm5hbF90aWNrIiwiUGFuZVByaWNlQXhpc1ZpZXdSZW5kZXJlciIsIl9pbnRlcm5hbF9zZXRQYXJhbXMiLCJwcmljZUF4aXNWaWV3UmVuZGVyZXIiLCJfcHJpdmF0ZV9fcHJpY2VBeGlzVmlld1JlbmRlcmVyIiwiX3ByaXZhdGVfX2FsaWduIiwiX3ByaXZhdGVfX3RleHRXaWR0aENhY2hlIiwiUGFuZVByaWNlQXhpc1ZpZXciLCJfaW50ZXJuYWxfcGFuZUZvclNvdXJjZSIsIl9wcml2YXRlX19kYXRhU291cmNlIiwiX2ludGVybmFsX2lzT3ZlcmxheSIsIl9pbnRlcm5hbF9kZWZhdWx0VmlzaWJsZVByaWNlU2NhbGUiLCJwb3NpdGlvbiIsIl9pbnRlcm5hbF9wcmljZVNjYWxlUG9zaXRpb24iLCJfaW50ZXJuYWxfcHJpY2VBeGlzUmVuZGVyZXJPcHRpb25zIiwiX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXciLCJwcmljZUF4aXNWaWV3IiwiZGF0YVNvdXJjZSIsIkhvcml6b250YWxMaW5lUmVuZGVyZXIiLCJfaW50ZXJuYWxfaGl0VGVzdCIsIml0ZW1ZIiwiX2ludGVybmFsX2V4dGVybmFsSWQiLCJleHRlcm5hbElkIiwiX2ludGVybmFsX2hpdFRlc3REYXRhIiwiU2VyaWVzSG9yaXpvbnRhbExpbmVQYW5lVmlldyIsIl9pbnRlcm5hbF9fdXBkYXRlSW1wbCIsIl9pbnRlcm5hbF9fbGluZVJlbmRlcmVyIiwiX2ludGVybmFsX19saW5lUmVuZGVyZXJEYXRhIiwiU2VyaWVzSG9yaXpvbnRhbEJhc2VMaW5lUGFuZVZpZXciLCJfaW50ZXJuYWxfbW9kZSIsInNlcmllc09wdGlvbnMiLCJTZXJpZXNMYXN0UHJpY2VBbmltYXRpb25SZW5kZXJlciIsIl9pbnRlcm5hbF9zZXJpZXNMaW5lQ29sb3IiLCJjZW50ZXJQb2ludFJhZGl1cyIsIl9pbnRlcm5hbF9zZXJpZXNMaW5lV2lkdGgiLCJfaW50ZXJuYWxfZmlsbENvbG9yIiwiX2ludGVybmFsX3N0cm9rZUNvbG9yIiwiYW5pbWF0aW9uU3RhZ2VzRGF0YSIsIl9pbnRlcm5hbF9zdGFydCIsIl9pbnRlcm5hbF9lbmQiLCJfaW50ZXJuYWxfc3RhcnRSYWRpdXMiLCJfaW50ZXJuYWxfZW5kUmFkaXVzIiwiX2ludGVybmFsX3N0YXJ0RmlsbEFscGhhIiwiX2ludGVybmFsX2VuZEZpbGxBbHBoYSIsIl9pbnRlcm5hbF9zdGFydFN0cm9rZUFscGhhIiwiX2ludGVybmFsX2VuZFN0cm9rZUFscGhhIiwic2VyaWVzTGluZUNvbG9yIiwic3RhZ2UiLCJzdGFydEFscGhhIiwiZW5kQWxwaGEiLCJzdGFydFJhZGl1cyIsImVuZFJhZGl1cyIsImFuaW1hdGlvbkRhdGEiLCJkdXJhdGlvblNpbmNlU3RhcnQiLCJnbG9iYWxTdGFnZSIsImN1cnJlbnRTdGFnZURhdGEiLCJzdGFnZURhdGEiLCJzdWJTdGFnZSIsIlNlcmllc0xhc3RQcmljZUFuaW1hdGlvblBhbmVWaWV3IiwiX2ludGVybmFsX29uRGF0YUNsZWFyZWQiLCJfcHJpdmF0ZV9fZW5kVGltZSIsIl9wcml2YXRlX19zdGFydFRpbWUiLCJfaW50ZXJuYWxfb25OZXdSZWFsdGltZURhdGFSZWNlaXZlZCIsIl9wcml2YXRlX19zZXJpZXMiLCJub3ciLCJwZXJmb3JtYW5jZSIsInRpbWVUb0FuaW1hdGlvbkVuZCIsIl9pbnRlcm5hbF9pbnZhbGlkYXRlU3RhZ2UiLCJfcHJpdmF0ZV9fc3RhZ2VJbnZhbGlkYXRlZCIsIl9pbnRlcm5hbF9hbmltYXRpb25BY3RpdmUiLCJfcHJpdmF0ZV9fdXBkYXRlUmVuZGVyZXJEYXRhU3RhZ2UiLCJsYXN0VmFsdWUiLCJfaW50ZXJuYWxfbGFzdFZhbHVlRGF0YSIsIl9pbnRlcm5hbF9ub0RhdGEiLCJfaW50ZXJuYWxfY29udGFpbnMiLCJsYXN0VmFsdWVQb2ludCIsInNlcmllc0xpbmVXaWR0aCIsIl9wcml2YXRlX19kdXJhdGlvbiIsInJlbmRlcmVyRGF0YSIsInJlc3VsdCIsInNoYXBlU2l6ZSIsInNoYXBlIiwib3JpZ2luYWxTaXplIiwiY2FsY3VsYXRlU2hhcGVIZWlnaHQiLCJzaGFwZU1hcmdpbiIsImRyYXdTcXVhcmUiLCJzcXVhcmVTaXplIiwiaGFsZlNpemUiLCJoaXRUZXN0U3F1YXJlIiwiZHJhd0Fycm93IiwidXAiLCJhcnJvd1NpemUiLCJoYWxmQXJyb3dTaXplIiwiYmFzZVNpemUiLCJoYWxmQmFzZVNpemUiLCJoaXRUZXN0QXJyb3ciLCJkcmF3Q2lyY2xlIiwiY2lyY2xlU2l6ZSIsImhpdFRlc3RDaXJjbGUiLCJ0b2xlcmFuY2UiLCJ4T2Zmc2V0IiwieU9mZnNldCIsImRpc3QiLCJzcXJ0IiwiZHJhd1RleHQiLCJoaXRUZXN0VGV4dCIsInRleHRYIiwidGV4dFkiLCJ0ZXh0SGVpZ2h0IiwiaGFsZkhlaWdodCIsIlNlcmllc01hcmtlcnNSZW5kZXJlciIsIl9wcml2YXRlX19mb250IiwiaGl0VGVzdEl0ZW0iLCJfaW50ZXJuYWxfaW50ZXJuYWxJZCIsIl9pbnRlcm5hbF9jb250ZW50IiwiZHJhd0l0ZW0iLCJkcmF3U2hhcGUiLCJfaW50ZXJuYWxfc2hhcGUiLCJoaXRUZXN0U2hhcGUiLCJmaWxsU2l6ZUFuZFkiLCJyZW5kZXJlckl0ZW0iLCJtYXJrZXIiLCJvZmZzZXRzIiwiaW5CYXJQcmljZSIsImhpZ2hQcmljZSIsImxvd1ByaWNlIiwic2l6ZU11bHRpcGxpZXIiLCJfaW50ZXJuYWxfYWJvdmVCYXIiLCJfaW50ZXJuYWxfYmVsb3dCYXIiLCJTZXJpZXNNYXJrZXJzUGFuZVZpZXciLCJfcHJpdmF0ZV9fYXV0b1NjYWxlTWFyZ2luc0ludmFsaWRhdGVkIiwiX3ByaXZhdGVfX2RhdGFJbnZhbGlkYXRlZCIsImFkZEFuY2hvcnMiLCJfaW50ZXJuYWxfX21ha2VWYWxpZCIsIl9pbnRlcm5hbF9hdXRvU2NhbGVNYXJnaW5zIiwiX2ludGVybmFsX2luZGV4ZWRNYXJrZXJzIiwic2hhcGVNYXJnaW4kMSIsIm1hcmdpbnNBYm92ZUFuZEJlbG93IiwiX3ByaXZhdGVfX2F1dG9TY2FsZU1hcmdpbnMiLCJhYm92ZSIsImJlbG93Iiwic2VyaWVzTWFya2VycyIsImlkIiwibGF5b3V0T3B0aW9ucyIsInByZXZUaW1lSW5kZXgiLCJkYXRhQXQiLCJfaW50ZXJuYWxfZGF0YUF0IiwiU2VyaWVzUHJpY2VMaW5lUGFuZVZpZXciLCJsYXN0VmFsdWVEYXRhIiwiX2ludGVybmFsX3ByaWNlTGluZUNvbG9yIiwiU2VyaWVzUHJpY2VBeGlzVmlldyIsInNob3dTZXJpZXNMYXN0VmFsdWUiLCJzaG93U3ltYm9sTGFiZWwiLCJfaW50ZXJuYWxfdGl0bGUiLCJzaG93UHJpY2VBbmRQZXJjZW50YWdlIiwic2VyaWVzTGFzdFZhbHVlTW9kZSIsIl9pbnRlcm5hbF9fYXhpc1RleHQiLCJfaW50ZXJuYWxfX3BhbmVUZXh0IiwibGFzdFZhbHVlQ29sb3IiLCJfaW50ZXJuYWxfaXNQZXJjZW50YWdlIiwiX2ludGVybmFsX2Zvcm1hdHRlZFByaWNlQWJzb2x1dGUiLCJfaW50ZXJuYWxfZm9ybWF0dGVkUHJpY2VQZXJjZW50YWdlIiwidHJpbSIsImNvbXB1dGVGaW5pdGVSZXN1bHQiLCJtZXRob2QiLCJ2YWx1ZU9uZSIsInZhbHVlVHdvIiwiZmFsbGJhY2siLCJmaXJzdEZpbml0ZSIsInNlY29uZEZpbml0ZSIsIlByaWNlUmFuZ2VJbXBsIiwiX2ludGVybmFsX2VxdWFscyIsInByIiwiX3ByaXZhdGVfX21pblZhbHVlIiwiX3ByaXZhdGVfX21heFZhbHVlIiwiX2ludGVybmFsX2Nsb25lIiwiX2ludGVybmFsX21pblZhbHVlIiwiX2ludGVybmFsX21heFZhbHVlIiwiX2ludGVybmFsX2xlbmd0aCIsImFub3RoZXJSYW5nZSIsIkluZmluaXR5IiwiX2ludGVybmFsX3NjYWxlQXJvdW5kQ2VudGVyIiwiZGVsdGEiLCJjZW50ZXIiLCJtYXhEZWx0YSIsIm1pbkRlbHRhIiwiX2ludGVybmFsX3NoaWZ0IiwiX2ludGVybmFsX3RvUmF3IiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsIl9pbnRlcm5hbF9mcm9tUmF3IiwicmF3IiwiQXV0b3NjYWxlSW5mb0ltcGwiLCJfaW50ZXJuYWxfcHJpY2VSYW5nZSIsIl9wcml2YXRlX19wcmljZVJhbmdlIiwiX2ludGVybmFsX21hcmdpbnMiLCJfcHJpdmF0ZV9fbWFyZ2lucyIsInByaWNlUmFuZ2UiLCJtYXJnaW5zIiwiQ3VzdG9tUHJpY2VMaW5lUGFuZVZpZXciLCJsaW5lT3B0aW9ucyIsIl9wcml2YXRlX19wcmljZUxpbmUiLCJfaW50ZXJuYWxfeUNvb3JkIiwicHJpY2VMaW5lIiwiQ3VzdG9tUHJpY2VMaW5lUHJpY2VBeGlzVmlldyIsImF4aXNMYWJlbFZpc2libGUiLCJzaG93UGFuZUxhYmVsIiwiX3ByaXZhdGVfX2Zvcm1hdFByaWNlIiwiYXhpc0xhYmVsQ29sb3IiLCJheGlzTGFiZWxUZXh0Q29sb3IiLCJDdXN0b21QcmljZUxpbmUiLCJfaW50ZXJuYWxfYXBwbHlPcHRpb25zIiwiX2ludGVybmFsX2xpZ2h0VXBkYXRlIiwiX2ludGVybmFsX3BhbmVWaWV3IiwiX3ByaXZhdGVfX3ByaWNlTGluZVZpZXciLCJfaW50ZXJuYWxfbGFiZWxQYW5lVmlldyIsIl9wcml2YXRlX19wYW5lUHJpY2VBeGlzVmlldyIsIl9pbnRlcm5hbF9wcmljZUF4aXNWaWV3IiwiUHJpY2VEYXRhU291cmNlIiwiYmFyU3R5bGVGbk1hcCIsIkJhciIsImZpbmRCYXIiLCJiYXJTdHlsZSIsImJhckluZGV4IiwicHJlY29tcHV0ZWRCYXJzIiwiY3VycmVudEJhciIsImlzVXAiLCJDYW5kbGVzdGljayIsImNhbmRsZXN0aWNrU3R5bGUiLCJfYiIsIl9jIiwiX2ludGVybmFsX3dpY2tDb2xvciIsIkN1c3RvbSIsImN1c3RvbVN0eWxlIiwiQXJlYSIsImFyZWFTdHlsZSIsIl9kIiwiQmFzZWxpbmUiLCJiYXNlbGluZVN0eWxlIiwiX2UiLCJfZiIsImlzQWJvdmVCYXNlbGluZSIsIkxpbmUiLCJIaXN0b2dyYW0iLCJoaXN0b2dyYW1TdHlsZSIsIlNlcmllc0JhckNvbG9yZXIiLCJfcHJpdmF0ZV9fc3R5bGVHZXR0ZXIiLCJfcHJpdmF0ZV9fZmluZEJhciIsIl9pbnRlcm5hbF92YWx1ZUF0IiwiX2ludGVybmFsX3Nlcmllc1R5cGUiLCJNaXNtYXRjaERpcmVjdGlvbiIsIkNIVU5LX1NJWkUiLCJQbG90TGlzdCIsIl9pbnRlcm5hbF9sYXN0IiwiX3ByaXZhdGVfX2l0ZW1zIiwiX2ludGVybmFsX2ZpcnN0SW5kZXgiLCJfcHJpdmF0ZV9faW5kZXhBdCIsIl9wcml2YXRlX19zZWFyY2giLCJfaW50ZXJuYWxfc2VhcmNoIiwic2VhcmNoTW9kZSIsInBvcyIsIl9wcml2YXRlX192YWx1ZUF0IiwiX2ludGVybmFsX21pbk1heE9uUmFuZ2VDYWNoZWQiLCJlbmQiLCJwbG90cyIsInBsb3QiLCJwbG90TWluTWF4IiwiX3ByaXZhdGVfX21pbk1heE9uUmFuZ2VDYWNoZWRJbXBsIiwibWVyZ2VNaW5NYXgiLCJwbG90Um93cyIsIl9wcml2YXRlX19yb3dTZWFyY2hDYWNoZSIsIl9wcml2YXRlX19taW5NYXhDYWNoZSIsImV4YWN0UG9zIiwiX3ByaXZhdGVfX2JzZWFyY2giLCJfcHJpdmF0ZV9fc2VhcmNoTmVhcmVzdExlZnQiLCJfcHJpdmF0ZV9fc2VhcmNoTmVhcmVzdFJpZ2h0IiwibmVhcmVzdExlZnRQb3MiLCJfcHJpdmF0ZV9fbG93ZXJib3VuZCIsIm5lYXJlc3RSaWdodFBvcyIsIl9wcml2YXRlX191cHBlcmJvdW5kIiwiYSIsImIiLCJfcHJpdmF0ZV9fcGxvdE1pbk1heCIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleEV4Y2x1c2l2ZSIsInBsb3RJbmRleCIsInZhbHVlcyIsIl9pbnRlcm5hbF9taW4iLCJfaW50ZXJuYWxfbWF4IiwiZmlyc3RJbmRleCIsImxhc3RJbmRleCIsImNhY2hlZExvdyIsImNhY2hlZEhpZ2giLCJlbmRJbmRleCIsIm1pbk1heENhY2hlIiwiY2h1bmtJbmRleCIsImNodW5rTWluTWF4IiwiY2h1bmtTdGFydCIsImNodW5rRW5kIiwiZmlyc3QiLCJzZWNvbmQiLCJjcmVhdGVTZXJpZXNQbG90TGlzdCIsIlNlcmllc1ByaW1pdGl2ZVJlbmRlcmVyV3JhcHBlciIsIl9wcml2YXRlX19iYXNlUmVuZGVyZXIiLCJkcmF3QmFja2dyb3VuZCIsImNhbGwiLCJiYXNlUmVuZGVyZXIiLCJTZXJpZXNQcmltaXRpdmVQYW5lVmlld1dyYXBwZXIiLCJfaW50ZXJuYWxfYmFzZSIsIl9pbnRlcm5hbF93cmFwcGVyIiwid3JhcHBlciIsIl9pbnRlcm5hbF96T3JkZXIiLCJ6T3JkZXIiLCJnZXRBeGlzVmlld0RhdGEiLCJiYXNlVmlldyIsImZpeGVkQ29vcmRpbmF0ZSIsImJhY2tDb2xvciIsInRpY2tWaXNpYmxlIiwiU2VyaWVzUHJpbWl0aXZlVGltZUF4aXNWaWV3V3JhcHBlciIsIl9wcml2YXRlX190aW1lU2NhbGUiLCJfcHJpdmF0ZV9fYmFzZVZpZXciLCJTZXJpZXNQcmltaXRpdmVQcmljZUF4aXNWaWV3V3JhcHBlciIsIlNlcmllc1ByaW1pdGl2ZVdyYXBwZXIiLCJfaW50ZXJuYWxfcHJpbWl0aXZlIiwiX3ByaXZhdGVfX3ByaW1pdGl2ZSIsInVwZGF0ZUFsbFZpZXdzIiwicGFuZVZpZXdzIiwiX3ByaXZhdGVfX3BhbmVWaWV3c0NhY2hlIiwicHciLCJ0aW1lQXhpc1ZpZXdzIiwiX3ByaXZhdGVfX3RpbWVBeGlzVmlld3NDYWNoZSIsImF3IiwicHJpY2VBeGlzVmlld3MiLCJfcHJpdmF0ZV9fcHJpY2VBeGlzVmlld3NDYWNoZSIsIl9pbnRlcm5hbF9wcmljZUF4aXNQYW5lVmlld3MiLCJwcmljZUF4aXNQYW5lVmlld3MiLCJfcHJpdmF0ZV9fcHJpY2VBeGlzUGFuZVZpZXdzQ2FjaGUiLCJfaW50ZXJuYWxfdGltZUF4aXNQYW5lVmlld3MiLCJ0aW1lQXhpc1BhbmVWaWV3cyIsIl9wcml2YXRlX190aW1lQXhpc1BhbmVWaWV3c0NhY2hlIiwiX2ludGVybmFsX2F1dG9zY2FsZUluZm8iLCJzdGFydFRpbWVQb2ludCIsImVuZFRpbWVQb2ludCIsImF1dG9zY2FsZUluZm8iLCJoaXRUZXN0IiwicHJpbWl0aXZlIiwiZXh0cmFjdFByaW1pdGl2ZVBhbmVWaWV3cyIsInByaW1pdGl2ZXMiLCJleHRyYWN0b3IiLCJkZXN0aW5hdGlvbiIsInByaW1pdGl2ZVBhbmVWaWV3c0V4dHJhY3RvciIsInByaW1pdGl2ZVByaWNlUGFuZVZpZXdzRXh0cmFjdG9yIiwicHJpbWl0aXZlVGltZVBhbmVWaWV3c0V4dHJhY3RvciIsIlNlcmllcyIsIl9wcml2YXRlX19hbmltYXRpb25UaW1lb3V0SWQiLCJjbGVhclRpbWVvdXQiLCJsYXN0QmFyQ29sb3IiLCJnbG9iYWxMYXN0Iiwibm9EYXRhUmVzIiwiZW5kQmFyIiwiYmFyQ29sb3JlciIsIl9pbnRlcm5hbF9mb3JtYXRQcmljZUFic29sdXRlIiwiX2ludGVybmFsX2Zvcm1hdFByaWNlUGVyY2VudGFnZSIsIl9wcml2YXRlX19iYXJDb2xvcmVyQ2FjaGUiLCJ0YXJnZXRQcmljZVNjYWxlSWQiLCJfaW50ZXJuYWxfbW92ZVNlcmllc1RvU2NhbGUiLCJfcHJpdmF0ZV9fcmVjcmVhdGVGb3JtYXR0ZXIiLCJfaW50ZXJuYWxfZnVsbFVwZGF0ZSIsIl9pbnRlcm5hbF91cGRhdGVTb3VyY2UiLCJfaW50ZXJuYWxfdXBkYXRlQ3Jvc3NoYWlyIiwidXBkYXRlSW5mbyIsIl9wcml2YXRlX19yZWNhbGN1bGF0ZU1hcmtlcnMiLCJfcHJpdmF0ZV9fbGFzdFByaWNlQW5pbWF0aW9uUGFuZVZpZXciLCJfaW50ZXJuYWxfbGFzdEJhclVwZGF0ZWRPck5ld0JhcnNBZGRlZFRvVGhlUmlnaHQiLCJzb3VyY2VQYW5lIiwiX2ludGVybmFsX3JlY2FsY3VsYXRlUGFuZSIsIl9pbnRlcm5hbF9zZXRNYXJrZXJzIiwiX3ByaXZhdGVfX21hcmtlcnMiLCJfaW50ZXJuYWxfbWFya2VycyIsIl9wcml2YXRlX19pbmRleGVkTWFya2VycyIsIl9pbnRlcm5hbF9jcmVhdGVQcmljZUxpbmUiLCJfcHJpdmF0ZV9fY3VzdG9tUHJpY2VMaW5lcyIsIl9pbnRlcm5hbF9yZW1vdmVQcmljZUxpbmUiLCJsaW5lIiwiaW5kZXhPZiIsIl9wcml2YXRlX19zZXJpZXNUeXBlIiwiX2ludGVybmFsX2ZpcnN0QmFyIiwiX2ludGVybmFsX3RpbWVQb2ludCIsInByaWNlcyIsIl9pbnRlcm5hbF90b3BQYW5lVmlld3MiLCJfcHJpdmF0ZV9fcHJpbWl0aXZlcyIsImFuaW1hdGlvblBhbmVWaWV3Iiwic2V0VGltZW91dCIsIl9pbnRlcm5hbF9jdXJzb3JVcGRhdGUiLCJfcHJpdmF0ZV9faXNPdmVybGF5IiwiX3ByaXZhdGVfX2Jhc2VIb3Jpem9udGFsTGluZVZpZXciLCJwcmljZUxpbmVWaWV3cyIsIl9pbnRlcm5hbF9ib3R0b21QYW5lVmlld3MiLCJfcHJpdmF0ZV9fZXh0cmFjdFBhbmVWaWV3cyIsIl9pbnRlcm5hbF9wcmljZVBhbmVWaWV3cyIsIl9pbnRlcm5hbF90aW1lUGFuZVZpZXdzIiwiX2ludGVybmFsX3ByaW1pdGl2ZUhpdFRlc3QiLCJjdXN0b21QcmljZUxpbmUiLCJhdXRvc2NhbGVJbmZvUHJvdmlkZXIiLCJfcHJpdmF0ZV9fYXV0b3NjYWxlSW5mb0ltcGwiLCJfaW50ZXJuYWxfbWluTW92ZSIsIl9pbnRlcm5hbF9mb3JtYXR0ZXIiLCJfcHJpdmF0ZV9fZm9ybWF0dGVyIiwiZ2V0VmFsdWUiLCJfcHJpdmF0ZV9fbWFya2VyUmFkaXVzIiwiX3ByaXZhdGVfX21hcmtlckJvcmRlckNvbG9yIiwiX3ByaXZhdGVfX21hcmtlckJvcmRlcldpZHRoIiwiX3ByaXZhdGVfX21hcmtlckJhY2tncm91bmRDb2xvciIsIl9pbnRlcm5hbF9hdHRhY2hQcmltaXRpdmUiLCJfaW50ZXJuYWxfZGV0YWNoUHJpbWl0aXZlIiwiX2ludGVybmFsX2N1c3RvbVNlcmllc1Bsb3RWYWx1ZXNCdWlsZGVyIiwiX2ludGVybmFsX2N1c3RvbVNlcmllc1doaXRlc3BhY2VDaGVjayIsIl9pbnRlcm5hbF9pZCIsImJhcnNNaW5NYXgiLCJyYW5nZVdpdGhCYXNlIiwicHJpbWl0aXZlQXV0b3NjYWxlIiwicHJpbWl0aXZlUmFuZ2UiLCJtZXJnZU1hcmdpbnMiLCJmb3JtYXR0ZXIiLCJfaW50ZXJuYWxfdXBkYXRlRm9ybWF0dGVyIiwiX2ludGVybmFsX2hhc1BvaW50cyIsImZpcnN0RGF0YUluZGV4IiwiX2ludGVybmFsX3RpbWVUb0luZGV4Iiwic2VyaWVzRGF0YUluZGV4Iiwib3JpZ2luYWxUaW1lIiwiX3ByaXZhdGVfX3JlY3JlYXRlUGFuZVZpZXdzIiwiY3VzdG9tUGFuZVZpZXciLCJzZXJpZXNUeXBlIiwiYWRkaXRpb25hbE1hcmdpbiIsIk1hZ25ldCIsIl9pbnRlcm5hbF9hbGlnbiIsImRlZmF1bHRQcmljZVNjYWxlIiwiX2ludGVybmFsX2RhdGFTb3VyY2VzIiwiZHMiLCJjYW5kaWRhdGVzIiwicmVkdWNlIiwiYWNjIiwicHMiLCJmaXJzdFByaWNlIiwiY29uY2F0Iiwic29ydCIsIm5lYXJlc3QiLCJHcmlkUmVuZGVyZXIiLCJfaW50ZXJuYWxfdmVydExpbmVzVmlzaWJsZSIsIl9pbnRlcm5hbF92ZXJ0TGluZXNDb2xvciIsIl9pbnRlcm5hbF92ZXJ0TGluZVN0eWxlIiwidGltZU1hcmsiLCJfaW50ZXJuYWxfdGltZU1hcmtzIiwiX2ludGVybmFsX2Nvb3JkIiwiX2ludGVybmFsX2hvcnpMaW5lc1Zpc2libGUiLCJfaW50ZXJuYWxfaG9yekxpbmVzQ29sb3IiLCJfaW50ZXJuYWxfaG9yekxpbmVTdHlsZSIsInByaWNlTWFyayIsIl9pbnRlcm5hbF9wcmljZU1hcmtzIiwiR3JpZFBhbmVWaWV3IiwiZ3JpZE9wdGlvbnMiLCJncmlkIiwiaG9yekxpbmVzIiwidmVydExpbmVzIiwiX2ludGVybmFsX21hcmtzIiwidG0iLCJjb29yZCIsIkdyaWQiLCJkZWZMb2dGb3JtdWxhIiwiX2ludGVybmFsX2xvZ2ljYWxPZmZzZXQiLCJfaW50ZXJuYWxfY29vcmRPZmZzZXQiLCJmcm9tUGVyY2VudCIsInRvUGVyY2VudCIsInRvUGVyY2VudFJhbmdlIiwibWluUGVyY2VudCIsIm1heFBlcmNlbnQiLCJmcm9tSW5kZXhlZFRvMTAwIiwidG9JbmRleGVkVG8xMDAiLCJ0b0luZGV4ZWRUbzEwMFJhbmdlIiwidG9Mb2ciLCJsb2dGb3JtdWxhIiwibSIsImxvZzEwIiwiZnJvbUxvZyIsImxvZ2ljYWwiLCJjb252ZXJ0UHJpY2VSYW5nZVRvTG9nIiwiY2FuQ29udmVydFByaWNlUmFuZ2VGcm9tTG9nIiwiY29udmVydFByaWNlUmFuZ2VGcm9tTG9nIiwibG9nRm9ybXVsYUZvclByaWNlUmFuZ2UiLCJkaWZmIiwiZGlnaXRzIiwibG9naWNhbE9mZnNldCIsImNvb3JkT2Zmc2V0IiwibG9nRm9ybXVsYXNBcmVTYW1lIiwiZjEiLCJmMiIsIlByaWNlVGlja1NwYW5DYWxjdWxhdG9yIiwiX2ludGVybmFsX3RpY2tTcGFuIiwibWF4VGlja1NwYW4iLCJtaW5Nb3ZlbWVudCIsIl9wcml2YXRlX19iYXNlIiwicmVzdWx0VGlja1NwYW4iLCJfcHJpdmF0ZV9faW50ZWdyYWxEaXZpZGVycyIsInJlc3VsdFRpY2tTcGFuTGFyZ2VyTWluTW92ZW1lbnQiLCJyZXN1bHRUaWNrU3Bhbkxhcmdlck1heFRpY2tTcGFuIiwicmVzdWx0VGlja1NwYW5MYXJnZXIxIiwiaGF2ZVRvQ29udGludWUiLCJfcHJpdmF0ZV9fZnJhY3Rpb25hbERpdmlkZXJzIiwiaW50ZWdyYWxEaXZpZGVycyIsImJhc2VSZXN0IiwiVElDS19ERU5TSVRZIiwiUHJpY2VUaWNrTWFya0J1aWxkZXIiLCJzY2FsZUhlaWdodCIsIm1hcmtIZWlnaHQiLCJfcHJpdmF0ZV9fdGlja01hcmtIZWlnaHQiLCJzcGFuQ2FsY3VsYXRvcjEiLCJzcGFuQ2FsY3VsYXRvcjIiLCJzcGFuQ2FsY3VsYXRvcjMiLCJzcGFucyIsIl9pbnRlcm5hbF9yZWJ1aWxkVGlja01hcmtzIiwiX3ByaXZhdGVfX21hcmtzIiwiX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0xvZ2ljYWxGdW5jIiwiZXh0cmFUb3BCb3R0b21NYXJnaW4iLCJlbnRpcmVUZXh0T25seSIsIl9wcml2YXRlX19mb250SGVpZ2h0IiwibWluQ29vcmQiLCJtYXhDb29yZCIsInNwYW4iLCJtb2QiLCJwcmV2Q29vcmQiLCJ0YXJnZXRJbmRleCIsIl9wcml2YXRlX19sb2dpY2FsVG9Db29yZGluYXRlRnVuYyIsIl9pbnRlcm5hbF9sYWJlbCIsIl9pbnRlcm5hbF9mb3JtYXRMb2dpY2FsIiwiX2ludGVybmFsX2lzTG9nIiwiY29vcmRpbmF0ZVRvTG9naWNhbEZ1bmMiLCJsb2dpY2FsVG9Db29yZGluYXRlRnVuYyIsInNvcnRTb3VyY2VzIiwiczEiLCJzMiIsIlByaWNlU2NhbGVNb2RlIiwicGVyY2VudGFnZUZvcm1hdHRlciIsImRlZmF1bHRQcmljZUZvcm1hdHRlciIsIlByaWNlU2NhbGUiLCJfcHJpdmF0ZV9faWQiLCJfaW50ZXJuYWxfc2V0TW9kZSIsInNjYWxlTWFyZ2lucyIsIl9wcml2YXRlX19pbnZhbGlkYXRlSW50ZXJuYWxIZWlnaHRDYWNoZSIsIl9wcml2YXRlX19tYXJrc0NhY2hlIiwiX2ludGVybmFsX2lzQXV0b1NjYWxlIiwiX2ludGVybmFsX2lzSW5kZXhlZFRvMTAwIiwiX2ludGVybmFsX2lzSW52ZXJ0ZWQiLCJpbnZlcnRTY2FsZSIsIm5ld01vZGUiLCJvbGRNb2RlIiwiX3ByaXZhdGVfX2ludmFsaWRhdGVkRm9yUmFuZ2UiLCJfaW50ZXJuYWxfaXNWYWxpZCIsIl9wcml2YXRlX19sb2dGb3JtdWxhIiwiX2ludGVybmFsX3NldFByaWNlUmFuZ2UiLCJtb2RlQ2hhbmdlZCIsIl9wcml2YXRlX19vbklzSW52ZXJ0ZWRDaGFuZ2VkIiwiX3ByaXZhdGVfX21vZGVDaGFuZ2VkIiwiX2ludGVybmFsX21vZGVDaGFuZ2VkIiwiX3ByaXZhdGVfX2xheW91dE9wdGlvbnMiLCJfcHJpdmF0ZV9faGVpZ2h0IiwiX2ludGVybmFsX3NldEhlaWdodCIsIl9pbnRlcm5hbF9pbnRlcm5hbEhlaWdodCIsIl9wcml2YXRlX19pbnRlcm5hbEhlaWdodENhY2hlIiwiX3ByaXZhdGVfX3RvcE1hcmdpblB4IiwiX3ByaXZhdGVfX2JvdHRvbU1hcmdpblB4IiwiX3ByaXZhdGVfX21ha2VTdXJlSXRJc1ZhbGlkIiwibmV3UHJpY2VSYW5nZSIsImlzRm9yY2VTZXRWYWx1ZSIsIm9sZFByaWNlUmFuZ2UiLCJfaW50ZXJuYWxfaW52ZXJ0ZWRDb29yZGluYXRlIiwiX3ByaXZhdGVfX2xvZ2ljYWxUb0Nvb3JkaW5hdGUiLCJiaCIsImloIiwiaXNJbnZlcnRlZCIsImhtbSIsImZyb21JbmRleCIsInRvSW5kZXgiLCJ0cmFuc2Zvcm1GbiIsIl9wcml2YXRlX19nZXRDb29yZGluYXRlVHJhbnNmb3JtZXIiLCJpbnZDb29yZGluYXRlIiwicHJpY2VzTGlzdCIsIm9wZW5Mb2dpY2FsIiwiaGlnaExvZ2ljYWwiLCJsb3dMb2dpY2FsIiwiY2xvc2VMb2dpY2FsIiwiX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0xvZ2ljYWwiLCJfaW50ZXJuYWxfbG9naWNhbFRvUHJpY2UiLCJfcHJpdmF0ZV9fZGF0YVNvdXJjZXMiLCJfaW50ZXJuYWxfb3JkZXJlZFNvdXJjZXMiLCJfcHJpdmF0ZV9fY2FjaGVkT3JkZXJlZFNvdXJjZXMiLCJfaW50ZXJuYWxfYWRkRGF0YVNvdXJjZSIsIl9pbnRlcm5hbF9pbnZhbGlkYXRlU291cmNlc0NhY2hlIiwiX2ludGVybmFsX3JlbW92ZURhdGFTb3VyY2UiLCJmaXJzdFZhbHVlSXNOdWxsIiwiX2ludGVybmFsX2ZpcnN0VmFsdWVJc051bGwiLCJfcHJpdmF0ZV9fbWFya0J1aWxkZXIiLCJtYXJrcyIsIl9wcml2YXRlX19vbk1hcmtzQ2hhbmdlZCIsIl9pbnRlcm5hbF9vbk1hcmtzQ2hhbmdlZCIsIl9pbnRlcm5hbF9zdGFydFNjYWxlIiwiX3ByaXZhdGVfX3NjYWxlU3RhcnRQb2ludCIsIl9wcml2YXRlX19wcmljZVJhbmdlU25hcHNob3QiLCJfaW50ZXJuYWxfc2NhbGVUbyIsInNjYWxlQ29lZmYiLCJfaW50ZXJuYWxfZW5kU2NhbGUiLCJfaW50ZXJuYWxfc3RhcnRTY3JvbGwiLCJfcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCIsIl9pbnRlcm5hbF9zY3JvbGxUbyIsInByaWNlVW5pdHNQZXJQaXhlbCIsInBpeGVsRGVsdGEiLCJwcmljZURlbHRhIiwiX2ludGVybmFsX2VuZFNjcm9sbCIsIl9wcml2YXRlX19mb3JtYXRQZXJjZW50YWdlIiwiX3ByaXZhdGVfX2Zvcm1hdHRlclNvdXJjZSIsIl9pbnRlcm5hbF9zb3VyY2VzRm9yQXV0b1NjYWxlIiwiX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VSYW5nZSIsIl9pbnRlcm5hbF92aXNpYmxlQmFycyIsImZvcm1hdHRlclNvdXJjZSIsIl9wcml2YXRlX19tYXJnaW5CZWxvdyIsIl9wcml2YXRlX19tYXJnaW5BYm92ZSIsIl9wcml2YXRlX19yZWNhbGN1bGF0ZVByaWNlUmFuZ2VJbXBsIiwibWFyZ2luQWJvdmUiLCJtYXJnaW5CZWxvdyIsImF1dG9TY2FsZUluZm8iLCJzb3VyY2VSYW5nZSIsImV4dGVuZFZhbHVlIiwicmF3UmFuZ2UiLCJuZXdMb2dGb3JtdWxhIiwicmF3U25hcHNob3QiLCJfcHJpdmF0ZV9fZm9ybWF0VmFsdWUiLCJmYWxsYmFja0Zvcm1hdHRlciIsIl9wcml2YXRlX19sb2NhbGl6YXRpb25PcHRpb25zIiwicHJpY2VGb3JtYXR0ZXIiLCJwZXJjZW50YWdlIiwibG9jYWxpemF0aW9uT3B0aW9ucyIsIkRFRkFVTFRfU1RSRVRDSF9GQUNUT1IiLCJQYW5lIiwiX2ludGVybmFsX2FwcGx5U2NhbGVPcHRpb25zIiwibGVmdFByaWNlU2NhbGUiLCJfcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGUiLCJyaWdodFByaWNlU2NhbGUiLCJfcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlIiwibG9jYWxpemF0aW9uIiwib3ZlcmxheVByaWNlU2NhbGVzIiwic291cmNlQXJyYXlzIiwiX3ByaXZhdGVfX292ZXJsYXlTb3VyY2VzQnlTY2FsZUlkIiwiX2ludGVybmFsX3ByaWNlU2NhbGVCeUlkIiwiX2ludGVybmFsX3ByaWNlU2NhbGVzT3B0aW9uc0NoYW5nZWQiLCJfcHJpdmF0ZV9fZGVzdHJveWVkIiwiX2ludGVybmFsX3N0cmV0Y2hGYWN0b3IiLCJfcHJpdmF0ZV9fc3RyZXRjaEZhY3RvciIsIl9pbnRlcm5hbF9zZXRTdHJldGNoRmFjdG9yIiwiZmFjdG9yIiwiX3ByaXZhdGVfX3dpZHRoIiwiX2ludGVybmFsX3NldFdpZHRoIiwiX2ludGVybmFsX3VwZGF0ZUFsbFNvdXJjZXMiLCJ0YXJnZXRTY2FsZUlkIiwidGFyZ2V0Wk9yZGVyIiwiX3ByaXZhdGVfX2dldFpPcmRlck1pbk1heCIsIl9pbnRlcm5hbF9tYXhaT3JkZXIiLCJfcHJpdmF0ZV9faW5zZXJ0RGF0YVNvdXJjZSIsIm92ZXJsYXlTb3VyY2VzIiwib3ZlcmxheUluZGV4IiwiX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VTY2FsZSIsIl9pbnRlcm5hbF9sZWZ0UHJpY2VTY2FsZSIsIl9pbnRlcm5hbF9yaWdodFByaWNlU2NhbGUiLCJfaW50ZXJuYWxfc3RhcnRTY2FsZVByaWNlIiwiX2ludGVybmFsX3NjYWxlUHJpY2VUbyIsIl9pbnRlcm5hbF9lbmRTY2FsZVByaWNlIiwiX2ludGVybmFsX3N0YXJ0U2Nyb2xsUHJpY2UiLCJfaW50ZXJuYWxfc2Nyb2xsUHJpY2VUbyIsIl9pbnRlcm5hbF9lbmRTY3JvbGxQcmljZSIsIl9wcml2YXRlX19yZWNhbGN1bGF0ZVByaWNlU2NhbGVJbXBsIiwiX2ludGVybmFsX3Jlc2V0UHJpY2VTY2FsZSIsIl9pbnRlcm5hbF9tb21lbnRhcnlBdXRvU2NhbGUiLCJfaW50ZXJuYWxfcmVjYWxjdWxhdGUiLCJfaW50ZXJuYWxfb25EZXN0cm95ZWQiLCJfaW50ZXJuYWxfZ3JpZCIsIl9wcml2YXRlX19ncmlkIiwic291cmNlRm9yQXV0b1NjYWxlIiwiX2ludGVybmFsX21pblpPcmRlciIsIm1pblpPcmRlciIsIm1heFpPcmRlciIsImoiLCJfcHJpdmF0ZV9fY3JlYXRlUHJpY2VTY2FsZSIsIl9wcml2YXRlX19vblByaWNlU2NhbGVNb2RlQ2hhbmdlZCIsImFjdHVhbE9wdGlvbnMiLCJGb3JtYXR0ZWRMYWJlbHNDYWNoZSIsIl9pbnRlcm5hbF9mb3JtYXQiLCJ0aWNrTWFyayIsImNhY2hlS2V5IiwiX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yIiwidGljayIsIl9pbnRlcm5hbF9zdHJpbmciLCJzdHIiLCJfcHJpdmF0ZV9fZm9ybWF0IiwiaG9yelNjYWxlQmVoYXZpb3IiLCJSYW5nZUltcGwiLCJfcHJpdmF0ZV9fbGVmdCIsIl9wcml2YXRlX19yaWdodCIsIl9pbnRlcm5hbF9jb3VudCIsImFyZVJhbmdlc0VxdWFsIiwiVGlja01hcmtzIiwiX2ludGVybmFsX3NldFVuaWZvcm1EaXN0cmlidXRpb24iLCJ2YWwiLCJfcHJpdmF0ZV9fdW5pZm9ybURpc3RyaWJ1dGlvbiIsIl9pbnRlcm5hbF9zZXRUaW1lU2NhbGVQb2ludHMiLCJuZXdQb2ludHMiLCJmaXJzdENoYW5nZWRQb2ludEluZGV4IiwiX3ByaXZhdGVfX3JlbW92ZU1hcmtzU2luY2VJbmRleCIsIm1hcmtzRm9yV2VpZ2h0IiwiX3ByaXZhdGVfX21hcmtzQnlXZWlnaHQiLCJ0aW1lV2VpZ2h0Iiwid2VpZ2h0IiwiX2ludGVybmFsX2J1aWxkIiwibWF4V2lkdGgiLCJtYXhJbmRleGVzUGVyTWFyayIsIl9pbnRlcm5hbF9tYXhJbmRleGVzUGVyTWFyayIsIl9wcml2YXRlX19idWlsZE1hcmtzSW1wbCIsInNpbmNlSW5kZXgiLCJ3ZWlnaHRzVG9DbGVhciIsImtleXMiLCJwcmV2TWFya3MiLCJwcmV2TWFya3NMZW5ndGgiLCJwcmV2TWFya3NQb2ludGVyIiwiY3VycmVudFdlaWdodCIsImN1cnJlbnRXZWlnaHRMZW5ndGgiLCJyaWdodEluZGV4IiwibGVmdEluZGV4IiwibWFyayIsImN1cnJlbnRJbmRleCIsImxhc3RNYXJrIiwiVGltZVNjYWxlVmlzaWJsZVJhbmdlIiwiX2ludGVybmFsX3N0cmljdFJhbmdlIiwiX3ByaXZhdGVfX2xvZ2ljYWxSYW5nZSIsIl9pbnRlcm5hbF9sb2dpY2FsUmFuZ2UiLCJfaW50ZXJuYWxfaW52YWxpZCIsImxvZ2ljYWxSYW5nZSIsImRlZmF1bHRUaWNrTWFya01heENoYXJhY3Rlckxlbmd0aCIsIm1hcmtXaXRoR3JlYXRlcldlaWdodCIsIlRpbWVTY2FsZSIsIl9pbnRlcm5hbF9hcHBseUxvY2FsaXphdGlvbk9wdGlvbnMiLCJfcHJpdmF0ZV9faW52YWxpZGF0ZVRpY2tNYXJrcyIsIl9wcml2YXRlX191cGRhdGVEYXRlVGltZUZvcm1hdHRlciIsImZpeExlZnRFZGdlIiwiX3ByaXZhdGVfX2RvRml4TGVmdEVkZ2UiLCJmaXhSaWdodEVkZ2UiLCJfcHJpdmF0ZV9fZG9GaXhSaWdodEVkZ2UiLCJyaWdodE9mZnNldCIsIm1pbkJhclNwYWNpbmciLCJfcHJpdmF0ZV9fYmFyU3BhY2luZyIsIl9wcml2YXRlX19vcHRpb25zQXBwbGllZCIsIl9wcml2YXRlX19wb2ludHMiLCJmaW5kTmVhcmVzdCIsImtleSIsIl9wcml2YXRlX19iYXNlSW5kZXhPck51bGwiLCJfcHJpdmF0ZV9fdXBkYXRlVmlzaWJsZVJhbmdlIiwiX3ByaXZhdGVfX3Zpc2libGVSYW5nZSIsIl9pbnRlcm5hbF92aXNpYmxlTG9naWNhbFJhbmdlIiwiX2ludGVybmFsX3Zpc2libGVUaW1lUmFuZ2UiLCJfaW50ZXJuYWxfdGltZVJhbmdlRm9yTG9naWNhbFJhbmdlIiwiX3ByaXZhdGVfX2ZpcnN0SW5kZXgiLCJfcHJpdmF0ZV9fbGFzdEluZGV4IiwiX2ludGVybmFsX2xvZ2ljYWxSYW5nZUZvclRpbWVSYW5nZSIsIm5ld1dpZHRoIiwicHJldmlvdXNWaXNpYmxlUmFuZ2UiLCJvbGRXaWR0aCIsIl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCIsImxvY2tWaXNpYmxlVGltZVJhbmdlT25SZXNpemUiLCJuZXdCYXJTcGFjaW5nIiwiX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0IiwiX3ByaXZhdGVfX2NvcnJlY3RCYXJTcGFjaW5nIiwiX3ByaXZhdGVfX2NvcnJlY3RPZmZzZXQiLCJiYXNlSW5kZXgiLCJfaW50ZXJuYWxfYmFzZUluZGV4IiwiZGVsdGFGcm9tUmlnaHQiLCJpbmRleEZyb20iLCJpbmRleFRvIiwiX2ludGVybmFsX2Nvb3JkaW5hdGVUb0luZGV4IiwiX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0Zsb2F0SW5kZXgiLCJfaW50ZXJuYWxfcmVjYWxjdWxhdGVBbGxQYW5lcyIsIl9wcml2YXRlX19zZXRCYXJTcGFjaW5nIiwiX2ludGVybmFsX3JpZ2h0T2Zmc2V0IiwiX3ByaXZhdGVfX3RpbWVNYXJrc0NhY2hlIiwicGl4ZWxzUGVyOENoYXJhY3RlcnMiLCJwaXhlbHNQZXJDaGFyYWN0ZXIiLCJtYXhMYWJlbFdpZHRoIiwidGlja01hcmtNYXhDaGFyYWN0ZXJMZW5ndGgiLCJpbmRleFBlckxhYmVsIiwiX3ByaXZhdGVfX3RpY2tNYXJrcyIsImVhcmxpZXN0SW5kZXhPZlNlY29uZExhYmVsIiwiaW5kZXhPZlNlY29uZExhc3RMYWJlbCIsImlzQWxsU2NhbGluZ0FuZFNjcm9sbGluZ0Rpc2FibGVkIiwiX3ByaXZhdGVfX2lzQWxsU2NhbGluZ0FuZFNjcm9sbGluZ0Rpc2FibGVkIiwiaXNMZWZ0RWRnZUZpeGVkIiwiaXNSaWdodEVkZ2VGaXhlZCIsImxhYmVsIiwiX3ByaXZhdGVfX2xhYmVscyIsIl9wcml2YXRlX19mb3JtYXRMYWJlbCIsIm5lZWRBbGlnbkNvb3JkaW5hdGUiLCJfaW50ZXJuYWxfcmVzdG9yZURlZmF1bHQiLCJfaW50ZXJuYWxfc2V0QmFzZUluZGV4IiwiX2ludGVybmFsX3pvb20iLCJ6b29tUG9pbnQiLCJzY2FsZSIsImZsb2F0SW5kZXhBdFpvb21Qb2ludCIsInJpZ2h0QmFyU3RheXNPblNjcm9sbCIsIl9wcml2YXRlX19jb21tb25UcmFuc2l0aW9uU3RhcnRTdGF0ZSIsIl9wcml2YXRlX19zYXZlQ29tbW9uVHJhbnNpdGlvbnNTdGFydFN0YXRlIiwic3RhcnRMZW5ndGhGcm9tUmlnaHQiLCJjdXJyZW50TGVuZ3RoRnJvbVJpZ2h0IiwiX3ByaXZhdGVfX2NsZWFyQ29tbW9uVHJhbnNpdGlvbnNTdGFydFN0YXRlIiwic2hpZnRJbkxvZ2ljYWwiLCJfaW50ZXJuYWxfc2Nyb2xsVG9SZWFsVGltZSIsIl9pbnRlcm5hbF9zY3JvbGxUb09mZnNldEFuaW1hdGVkIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJSYW5nZUVycm9yIiwiYW5pbWF0aW9uU3RhcnQiLCJfaW50ZXJuYWxfZmluaXNoZWQiLCJfaW50ZXJuYWxfZ2V0UG9zaXRpb24iLCJhbmltYXRpb25Qcm9ncmVzcyIsImZpbmlzaEFuaW1hdGlvbiIsIl9pbnRlcm5hbF92aXNpYmxlQmFyc0NoYW5nZWQiLCJfcHJpdmF0ZV9fdmlzaWJsZUJhcnNDaGFuZ2VkIiwiX2ludGVybmFsX2xvZ2ljYWxSYW5nZUNoYW5nZWQiLCJfcHJpdmF0ZV9fbG9naWNhbFJhbmdlQ2hhbmdlZCIsIl9pbnRlcm5hbF9vcHRpb25zQXBwbGllZCIsIl9pbnRlcm5hbF9zZXRWaXNpYmxlUmFuZ2UiLCJfaW50ZXJuYWxfZml0Q29udGVudCIsImxhc3QiLCJfaW50ZXJuYWxfc2V0TG9naWNhbFJhbmdlIiwiYmFyUmFuZ2UiLCJ0aW1lU2NhbGVQb2ludCIsInRpbWVGb3JtYXR0ZXIiLCJmb3JtYXRIb3J6SXRlbSIsImhhbmRsZVNjcm9sbCIsImhhbmRsZVNjYWxlIiwiaG9yelRvdWNoRHJhZyIsIm1vdXNlV2hlZWwiLCJwcmVzc2VkTW91c2VNb3ZlIiwidmVydFRvdWNoRHJhZyIsImF4aXNEb3VibGVDbGlja1Jlc2V0IiwiYXhpc1ByZXNzZWRNb3VzZU1vdmUiLCJwaW5jaCIsIl9wcml2YXRlX19yaWdodE9mZnNldEZvckNvb3JkaW5hdGUiLCJvbGRCYXJTcGFjaW5nIiwiX3ByaXZhdGVfX3Jlc2V0VGltZU1hcmtzQ2FjaGUiLCJfcHJpdmF0ZV9fc2V0VmlzaWJsZVJhbmdlIiwibmV3QmFyc0xlbmd0aCIsInJpZ2h0Qm9yZGVyIiwibGVmdEJvcmRlciIsIl9wcml2YXRlX19taW5CYXJTcGFjaW5nIiwibWF4QmFyU3BhY2luZyIsIm1heFJpZ2h0T2Zmc2V0IiwiX3ByaXZhdGVfX21heFJpZ2h0T2Zmc2V0IiwibWluUmlnaHRPZmZzZXQiLCJfcHJpdmF0ZV9fbWluUmlnaHRPZmZzZXQiLCJiYXJzRXN0aW1hdGlvbiIsIl9wcml2YXRlX19mb3JtYXR0ZWRCeVdlaWdodCIsIl9wcml2YXRlX19mb3JtYXRMYWJlbEltcGwiLCJmb3JtYXRUaWNrbWFyayIsIm5ld1Zpc2libGVSYW5nZSIsIm9sZFZpc2libGVSYW5nZSIsInVwZGF0ZUZvcm1hdHRlciIsImxlZnRFZGdlT2Zmc2V0IiwidW5pZm9ybURpc3RyaWJ1dGlvbiIsIldhdGVybWFya1JlbmRlcmVyIiwiX2ludGVybmFsX2xpbmVzIiwiX3ByaXZhdGVfX21ldHJpY3MiLCJfaW50ZXJuYWxfbGluZUhlaWdodCIsInZlcnRPZmZzZXQiLCJfaW50ZXJuYWxfdmVydEFsaWduIiwiaG9yek9mZnNldCIsIl9pbnRlcm5hbF9ob3J6QWxpZ24iLCJfaW50ZXJuYWxfdmVydE9mZnNldCIsImZvbnRDYWNoZSIsIl9wcml2YXRlX19mb250Q2FjaGUiLCJfcHJpdmF0ZV9fbWV0cmljc0NhY2hlIiwiV2F0ZXJtYXJrUGFuZVZpZXciLCJob3J6QWxpZ24iLCJ2ZXJ0QWxpZ24iLCJmb250U3R5bGUiLCJXYXRlcm1hcmsiLCJUcmFja2luZ01vZGVFeGl0TW9kZSIsIkNoYXJ0TW9kZWwiLCJfcHJpdmF0ZV9faW52YWxpZGF0ZSIsIl9wcml2YXRlX19pbnZhbGlkYXRpb25NYXNrRm9yU291cmNlIiwiX2ludGVybmFsX2hvdmVyZWRTb3VyY2UiLCJfcHJpdmF0ZV9faG92ZXJlZFNvdXJjZSIsIl9pbnRlcm5hbF9zZXRIb3ZlcmVkU291cmNlIiwicHJldlNvdXJjZSIsIl9pbnRlcm5hbF9zb3VyY2UiLCJfcHJpdmF0ZV9fcGFuZXMiLCJfcHJpdmF0ZV9fcHJpY2VTY2FsZXNPcHRpb25zQ2hhbmdlZCIsIl9wcml2YXRlX19iYWNrZ3JvdW5kVG9wQ29sb3IiLCJfcHJpdmF0ZV9fZ2V0QmFja2dyb3VuZENvbG9yIiwiX3ByaXZhdGVfX2JhY2tncm91bmRCb3R0b21Db2xvciIsIl9pbnRlcm5hbF9hcHBseVByaWNlU2NhbGVPcHRpb25zIiwiX2ludGVybmFsX2ZpbmRQcmljZVNjYWxlIiwiX2ludGVybmFsX3BhbmVzIiwiX2ludGVybmFsX3dhdGVybWFya1NvdXJjZSIsIl9wcml2YXRlX193YXRlcm1hcmsiLCJfaW50ZXJuYWxfY3Jvc3NoYWlyU291cmNlIiwiX2ludGVybmFsX2Nyb3NzaGFpck1vdmVkIiwiX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkIiwiX2ludGVybmFsX3NldFBhbmVIZWlnaHQiLCJfaW50ZXJuYWxfY3JlYXRlUGFuZSIsImFjdHVhbEluZGV4IiwibWFzayIsIl9wcml2YXRlX19wYW5lSW52YWxpZGF0aW9uTWFzayIsIl9pbnRlcm5hbF9zdGFydFNjYWxlVGltZSIsIl9pbnRlcm5hbF96b29tVGltZSIsInBvaW50WCIsIl9pbnRlcm5hbF9zY3JvbGxDaGFydCIsIl9pbnRlcm5hbF9zdGFydFNjcm9sbFRpbWUiLCJfaW50ZXJuYWxfc2Nyb2xsVGltZVRvIiwiX2ludGVybmFsX2VuZFNjcm9sbFRpbWUiLCJfaW50ZXJuYWxfc2NhbGVUaW1lVG8iLCJfaW50ZXJuYWxfZW5kU2NhbGVUaW1lIiwiX3ByaXZhdGVfX3Nlcmllc2VzIiwiX2ludGVybmFsX3NldEFuZFNhdmVDdXJyZW50UG9zaXRpb24iLCJldmVudCIsInNraXBFdmVudCIsIl9wcml2YXRlX19tYWduZXQiLCJfaW50ZXJuYWxfc2V0QW5kU2F2ZVN5bnRoZXRpY1Bvc2l0aW9uIiwiaG9yaXpvbnRhbFBvc2l0aW9uIiwiX2ludGVybmFsX2NsZWFyQ3VycmVudFBvc2l0aW9uIiwiX2ludGVybmFsX3VwZGF0ZVRpbWVTY2FsZSIsIm5ld0Jhc2VJbmRleCIsIm9sZEZpcnN0VGltZSIsIm5ld0ZpcnN0VGltZSIsImN1cnJlbnRCYXNlSW5kZXgiLCJpc0xhc3RTZXJpZXNCYXJWaXNpYmxlIiwiaXNMZWZ0QmFyU2hpZnRUb0xlZnQiLCJpc1Nlcmllc1BvaW50c0FkZGVkIiwiaXNTZXJpZXNQb2ludHNBZGRlZFRvUmlnaHQiLCJhbGxvd1NoaWZ0V2hlblJlcGxhY2luZ1doaXRlc3BhY2UiLCJhbGxvd1NoaWZ0VmlzaWJsZVJhbmdlT25XaGl0ZXNwYWNlUmVwbGFjZW1lbnQiLCJyZXBsYWNlZEV4aXN0aW5nV2hpdGVzcGFjZSIsIm5lZWRTaGlmdFZpc2libGVSYW5nZU9uTmV3QmFyIiwic2hpZnRWaXNpYmxlUmFuZ2VPbk5ld0JhciIsImNvbXBlbnNhdGlvblNoaWZ0IiwiZmluZCIsImluY2x1ZGVzIiwiX2ludGVybmFsX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyIiwiX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyIiwiX2ludGVybmFsX2NyZWF0ZVNlcmllcyIsIl9wcml2YXRlX19jcmVhdGVTZXJpZXMiLCJfaW50ZXJuYWxfcmVtb3ZlU2VyaWVzIiwic2VyaWVzSW5kZXgiLCJfaW50ZXJuYWxfc2V0VGFyZ2V0TG9naWNhbFJhbmdlIiwiX2ludGVybmFsX2RlZmF1bHRWaXNpYmxlUHJpY2VTY2FsZUlkIiwiX2ludGVybmFsX2JhY2tncm91bmRCb3R0b21Db2xvciIsIl9wcml2YXRlX19ncmFkaWVudENvbG9yc0NhY2hlIiwiX2ludGVybmFsX2NvbG9ycyIsImNhY2hlZFZhbHVlIiwiaW52YWxpZGF0ZVR5cGUiLCJfcHJpdmF0ZV9faW52YWxpZGF0ZUhhbmRsZXIiLCJzaWRlIiwiYmFja2dyb3VuZCIsImludmFsaWRhdGVIYW5kbGVyIiwid2F0ZXJtYXJrIiwiZmlsbFVwRG93bkNhbmRsZXN0aWNrc0NvbG9ycyIsIkxhc3RQcmljZUFuaW1hdGlvbk1vZGUiLCJwcmVjaXNpb25CeU1pbk1vdmUiLCJmcmFjdFBhcnQiLCJQcmljZUxpbmVTb3VyY2UiLCJDb2xvclR5cGUiLCJpc0J1c2luZXNzRGF5IiwiaXNVVENUaW1lc3RhbXAiLCJUaWNrTWFya1R5cGUiLCJnZXRNb250aCIsImRhdGUiLCJnZXRVVENNb250aCIsImdldERheSIsImdldFVUQ0RhdGUiLCJnZXRZZWFyIiwiZ2V0VVRDRnVsbFllYXIiLCJkZCIsIk1NTU0iLCJsb2NhbGUiLCJEYXRlIiwidG9Mb2NhbGVTdHJpbmciLCJtb250aCIsIk1NTSIsIk1NIiwieXkiLCJ5eXl5IiwiZm9ybWF0RGF0ZSIsIkRhdGVGb3JtYXR0ZXIiLCJfcHJpdmF0ZV9fZGF0ZUZvcm1hdCIsIl9wcml2YXRlX19sb2NhbGUiLCJkYXRlRm9ybWF0IiwiVGltZUZvcm1hdHRlciIsIl9wcml2YXRlX19mb3JtYXRTdHIiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwiZGVmYXVsdFBhcmFtcyIsIl9pbnRlcm5hbF9kYXRlRm9ybWF0IiwiX2ludGVybmFsX3RpbWVGb3JtYXQiLCJfaW50ZXJuYWxfZGF0ZVRpbWVTZXBhcmF0b3IiLCJfaW50ZXJuYWxfbG9jYWxlIiwiRGF0ZVRpbWVGb3JtYXR0ZXIiLCJkYXRlVGltZSIsIl9wcml2YXRlX19kYXRlRm9ybWF0dGVyIiwiX3ByaXZhdGVfX3NlcGFyYXRvciIsIl9wcml2YXRlX190aW1lRm9ybWF0dGVyIiwiZm9ybWF0dGVyUGFyYW1zIiwiZGVmYXVsdFRpY2tNYXJrRm9ybWF0dGVyIiwidGltZVBvaW50IiwidGlja01hcmtUeXBlIiwiZm9ybWF0T3B0aW9ucyIsInllYXIiLCJkYXkiLCJob3VyMTIiLCJob3VyIiwibWludXRlIiwiX2ludGVybmFsX2J1c2luZXNzRGF5IiwiX2ludGVybmFsX3RpbWVzdGFtcCIsIlVUQyIsImxvY2FsRGF0ZUZyb21VdGMiLCJnZXRVVENNaWxsaXNlY29uZHMiLCJob3VycyIsIm1pbnV0ZXMiLCJzZWNvbmRzIiwiaW50cmFkYXlXZWlnaHREaXZpc29ycyIsIl9pbnRlcm5hbF9kaXZpc29yIiwiX2ludGVybmFsX3dlaWdodCIsIndlaWdodEJ5VGltZSIsImN1cnJlbnREYXRlIiwicHJldkRhdGUiLCJnZXRUaW1lIiwiY2FzdCIsImZpbGxXZWlnaHRzRm9yUG9pbnRzIiwic29ydGVkVGltZVBvaW50cyIsInByZXZUaW1lIiwidG90YWxUaW1lRGlmZiIsImN1cnJlbnRQb2ludCIsImF2ZXJhZ2VUaW1lRGlmZiIsImFwcHJveFByZXZEYXRlIiwiYnVzaW5lc3NEYXlDb252ZXJ0ZXIiLCJidXNpbmVzc0RheSIsInN0cmluZ1RvQnVzaW5lc3NEYXkiLCJ0aW1lc3RhbXBDb252ZXJ0ZXIiLCJzZWxlY3RUaW1lQ29udmVydGVyIiwidmFsaWREYXRlUmVnZXgiLCJjb252ZXJ0VGltZSIsInRlc3QiLCJkIiwiY29udmVydFN0cmluZ1RvQnVzaW5lc3NEYXkiLCJjb252ZXJ0U3RyaW5nc1RvQnVzaW5lc3NEYXlzIiwid2VpZ2h0VG9UaWNrTWFya1R5cGUiLCJ0aW1lVmlzaWJsZSIsInNlY29uZHNWaXNpYmxlIiwiSG9yelNjYWxlQmVoYXZpb3JUaW1lIiwic2V0T3B0aW9ucyIsInByZXByb2Nlc3NEYXRhIiwiY3JlYXRlQ29udmVydGVyVG9JbnRlcm5hbE9iaiIsImNvbnZlcnRIb3J6SXRlbVRvSW50ZXJuYWwiLCJfcHJpdmF0ZV9fZGF0ZVRpbWVGb3JtYXR0ZXIiLCJ0cCIsInRpY2tNYXJrRm9ybWF0dGVyIiwidGlja01hcmtTdHJpbmciLCJtYXhUaWNrTWFya1dlaWdodCIsInRpY2tNYXJrcyIsIm1heFdlaWdodCIsIl9pbnRlcm5hbF9hcHBseURlZmF1bHRzIiwiaXNSdW5uaW5nT25DbGllbnRTaWRlIiwiaXNGRiIsIndpbmRvdyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzSU9TIiwicGxhdGZvcm0iLCJpc0Nocm9tZSIsImNocm9tZSIsImlzV2luZG93cyIsInVzZXJBZ2VudERhdGEiLCJpc0Nocm9taXVtQmFzZWQiLCJicmFuZHMiLCJzb21lIiwiYnJhbmQiLCJ3YXJuIiwibXNnIiwiY29uc29sZSIsInN1Z2dlc3RDaGFydFNpemUiLCJpbnRlZ2VyV2lkdGgiLCJpbnRlZ2VySGVpZ2h0Iiwic3VnZ2VzdFRpbWVTY2FsZUhlaWdodCIsIm9yaWdpbmFsSGVpZ2h0Iiwic3VnZ2VzdFByaWNlU2NhbGVXaWR0aCIsIm9yaWdpbmFsV2lkdGgiLCJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCJwb3MxIiwicG9zMiIsIl9pbnRlcm5hbF9wb3NpdGlvbiIsInNwZWVkUHhQZXJNU2VjIiwibWF4U3BlZWQiLCJzcGVlZCIsImR1cmF0aW9uTVNlYyIsImR1bXBpbmdDb2VmZiIsImxuRHVtcGluZ0NvZWZmIiwibG9nIiwiS2luZXRpY0FuaW1hdGlvbiIsIl9pbnRlcm5hbF9hZGRQb3NpdGlvbiIsIl9wcml2YXRlX19wb3NpdGlvbjEiLCJfcHJpdmF0ZV9fcG9zaXRpb240IiwiX3ByaXZhdGVfX3Bvc2l0aW9uMyIsIl9wcml2YXRlX19wb3NpdGlvbjIiLCJ0b3RhbERpc3RhbmNlIiwic3BlZWQxIiwiX3ByaXZhdGVfX21heFNwZWVkIiwiZGlzdGFuY2UxIiwic3BlZWRJdGVtcyIsImRpc3RhbmNlSXRlbXMiLCJzcGVlZDIiLCJkaXN0YW5jZTIiLCJzcGVlZDMiLCJkaXN0YW5jZTMiLCJyZXN1bHRTcGVlZCIsIl9wcml2YXRlX19taW5TcGVlZCIsIl9wcml2YXRlX19hbmltYXRpb25TdGFydFBvc2l0aW9uIiwiX3ByaXZhdGVfX3NwZWVkUHhQZXJNc2VjIiwiX3ByaXZhdGVfX2R1cmF0aW9uTXNlY3MiLCJfcHJpdmF0ZV9fZHVtcGluZ0NvZWZmIiwic3RhcnRQb3NpdGlvbiIsImR1cmF0aW9uTXNlY3MiLCJfcHJpdmF0ZV9fcHJvZ3Jlc3NEdXJhdGlvbiIsInByb2dyZXNzIiwibWluU3BlZWQiLCJjcmVhdGVCb3VuZENhbnZhcyIsInBhcmVudEVsZW1lbnQiLCJkb2MiLCJvd25lckRvY3VtZW50IiwiY2FudmFzIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwiYmluZGluZyIsImFsbG93UmVzaXplT2JzZXJ2ZXIiLCJ0cmFuc2Zvcm0iLCJjYW52YXNFbGVtZW50Q2xpZW50U2l6ZSIsInJlc2l6ZUNhbnZhc0VsZW1lbnQiLCJyZWxlYXNlQ2FudmFzIiwiZ2V0Q29udGV4dCIsImRyYXdGb3JlZ3JvdW5kIiwiZHJhd1NvdXJjZVBhbmVWaWV3cyIsInBhbmVWaWV3c0dldHRlciIsImRyYXdSZW5kZXJlckZuIiwicHJldmVudFNjcm9sbEJ5V2hlZWxDbGljayIsImVsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImJ1dHRvbiIsInByZXZlbnREZWZhdWx0IiwiTW91c2VFdmVudEhhbmRsZXIiLCJfcHJpdmF0ZV9fdW5zdWJzY3JpYmVPdXRzaWRlTW91c2VFdmVudHMiLCJfcHJpdmF0ZV9fdW5zdWJzY3JpYmVPdXRzaWRlVG91Y2hFdmVudHMiLCJfcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb3VzZW1vdmUiLCJfcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMiLCJfcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMiLCJfcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb2JpbGVTYWZhcmlFdmVudHMiLCJfcHJpdmF0ZV9fY2xlYXJMb25nVGFwVGltZW91dCIsIl9wcml2YXRlX19yZXNldENsaWNrVGltZW91dCIsIl9wcml2YXRlX19tb3VzZUVudGVySGFuZGxlciIsImVudGVyRXZlbnQiLCJib3VuZE1vdXNlTW92ZUhhbmRsZXIiLCJfcHJpdmF0ZV9fbW91c2VNb3ZlSGFuZGxlciIsIl9wcml2YXRlX190YXJnZXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiX3ByaXZhdGVfX2ZpcmVzVG91Y2hFdmVudHMiLCJjb21wYXRFdmVudCIsIl9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQiLCJfcHJpdmF0ZV9fcHJvY2Vzc01vdXNlRXZlbnQiLCJfcHJpdmF0ZV9faGFuZGxlciIsIl9pbnRlcm5hbF9tb3VzZUVudGVyRXZlbnQiLCJfcHJpdmF0ZV9fYWNjZXB0TW91c2VMZWF2ZSIsIl9wcml2YXRlX19jbGlja1RpbWVvdXRJZCIsIl9wcml2YXRlX19jbGlja0NvdW50IiwiX3ByaXZhdGVfX2NsaWNrUG9zaXRpb24iLCJORUdBVElWRV9JTkZJTklUWSIsIlBPU0lUSVZFX0lORklOSVRZIiwiX3ByaXZhdGVfX3Jlc2V0VGFwVGltZW91dCIsIl9wcml2YXRlX190YXBUaW1lb3V0SWQiLCJfcHJpdmF0ZV9fdGFwQ291bnQiLCJfcHJpdmF0ZV9fdGFwUG9zaXRpb24iLCJtb3ZlRXZlbnQiLCJfcHJpdmF0ZV9fbW91c2VQcmVzc2VkIiwiX3ByaXZhdGVfX3RvdWNoTW92ZVN0YXJ0UG9zaXRpb24iLCJfaW50ZXJuYWxfbW91c2VNb3ZlRXZlbnQiLCJfcHJpdmF0ZV9fdG91Y2hNb3ZlSGFuZGxlciIsInRvdWNoIiwidG91Y2hXaXRoSWQiLCJjaGFuZ2VkVG91Y2hlcyIsIl9wcml2YXRlX19hY3RpdmVUb3VjaElkIiwiX3ByaXZhdGVfX2xhc3RUb3VjaEV2ZW50VGltZVN0YW1wIiwiZXZlbnRUaW1lU3RhbXAiLCJfcHJpdmF0ZV9fc3RhcnRQaW5jaE1pZGRsZVBvaW50IiwiX3ByaXZhdGVfX3ByZXZlbnRUb3VjaERyYWdQcm9jZXNzIiwiX3ByaXZhdGVfX3BpbmNoUHJldmVudGVkIiwibW92ZUluZm8iLCJfcHJpdmF0ZV9fdG91Y2hNb3VzZU1vdmVXaXRoRG93bkluZm8iLCJnZXRQb3NpdGlvbiIsIl9pbnRlcm5hbF94T2Zmc2V0IiwiX2ludGVybmFsX3lPZmZzZXQiLCJfaW50ZXJuYWxfbWFuaGF0dGFuRGlzdGFuY2UiLCJtYW5oYXR0YW5EaXN0YW5jZSIsIl9wcml2YXRlX190b3VjaE1vdmVFeGNlZWRlZE1hbmhhdHRhbkRpc3RhbmNlIiwiY29ycmVjdGVkWE9mZnNldCIsImlzVmVydERyYWciLCJfaW50ZXJuYWxfdHJlYXRWZXJ0VG91Y2hEcmFnQXNQYWdlU2Nyb2xsIiwiaXNIb3J6RHJhZyIsIl9pbnRlcm5hbF90cmVhdEhvcnpUb3VjaERyYWdBc1BhZ2VTY3JvbGwiLCJfcHJpdmF0ZV9fY2FuY2VsVGFwIiwiX3ByaXZhdGVfX3Byb2Nlc3NUb3VjaEV2ZW50IiwiX2ludGVybmFsX3RvdWNoTW92ZUV2ZW50IiwiX3ByaXZhdGVfX21vdXNlTW92ZVdpdGhEb3duSGFuZGxlciIsIl9wcml2YXRlX19tb3VzZU1vdmVTdGFydFBvc2l0aW9uIiwiX3ByaXZhdGVfX2NhbmNlbENsaWNrIiwiX2ludGVybmFsX3ByZXNzZWRNb3VzZU1vdmVFdmVudCIsImN1cnJlbnRQb3NpdGlvbiIsIl9wcml2YXRlX190b3VjaEVuZEhhbmRsZXIiLCJ0b3VjaEVuZEV2ZW50IiwidG91Y2hlcyIsIl9pbnRlcm5hbF90b3VjaEVuZEV2ZW50IiwiX2ludGVybmFsX2RvdWJsZVRhcEV2ZW50IiwiX2ludGVybmFsX3RhcEV2ZW50IiwiX3ByaXZhdGVfX2xvbmdUYXBBY3RpdmUiLCJfcHJpdmF0ZV9fbW91c2VVcEhhbmRsZXIiLCJtb3VzZVVwRXZlbnQiLCJyb290RWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsIl9wcml2YXRlX19vbkZpcmVmb3hPdXRzaWRlTW91c2VVcCIsIl9pbnRlcm5hbF9tb3VzZVVwRXZlbnQiLCJfaW50ZXJuYWxfbW91c2VEb3VibGVDbGlja0V2ZW50IiwiX2ludGVybmFsX21vdXNlQ2xpY2tFdmVudCIsIl9wcml2YXRlX19sb25nVGFwVGltZW91dElkIiwiX3ByaXZhdGVfX3RvdWNoU3RhcnRIYW5kbGVyIiwiZG93bkV2ZW50IiwiaWRlbnRpZmllciIsImJvdW5kVG91Y2hNb3ZlV2l0aERvd25IYW5kbGVyIiwiYm91bmRUb3VjaEVuZEhhbmRsZXIiLCJwYXNzaXZlIiwiX3ByaXZhdGVfX2xvbmdUYXBIYW5kbGVyIiwiX2ludGVybmFsX3RvdWNoU3RhcnRFdmVudCIsIl9wcml2YXRlX19tb3VzZURvd25IYW5kbGVyIiwiYm91bmRNb3VzZU1vdmVXaXRoRG93bkhhbmRsZXIiLCJib3VuZE1vdXNlVXBIYW5kbGVyIiwiX2ludGVybmFsX21vdXNlRG93bkV2ZW50IiwiX3ByaXZhdGVfX2luaXQiLCJvdXRzaWRlSGFuZGxlciIsIl9pbnRlcm5hbF9tb3VzZURvd25PdXRzaWRlRXZlbnQiLCJjb21wb3NlZCIsImNvbnRhaW5zIiwiY29tcG9zZWRQYXRoIiwiX3ByaXZhdGVfX29uTW9iaWxlU2FmYXJpRG91YmxlQ2xpY2siLCJfcHJpdmF0ZV9fbW91c2VMZWF2ZUhhbmRsZXIiLCJfcHJpdmF0ZV9faW5pdFBpbmNoIiwiX2ludGVybmFsX3BpbmNoU3RhcnRFdmVudCIsIl9pbnRlcm5hbF9waW5jaEV2ZW50IiwiX2ludGVybmFsX3BpbmNoRW5kRXZlbnQiLCJfcHJpdmF0ZV9fY2hlY2tQaW5jaFN0YXRlIiwiY3VycmVudERpc3RhbmNlIiwiZ2V0RGlzdGFuY2UiLCJfcHJpdmF0ZV9fc3RhcnRQaW5jaERpc3RhbmNlIiwiX3ByaXZhdGVfX3N0b3BQaW5jaCIsIl9wcml2YXRlX19zdGFydFBpbmNoIiwiYm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50WCIsImNsaWVudFkiLCJfaW50ZXJuYWxfbW91c2VMZWF2ZUV2ZW50IiwiX2ludGVybmFsX2xvbmdUYXBFdmVudCIsInNvdXJjZUNhcGFiaWxpdGllcyIsImZpcmVzVG91Y2hFdmVudHMiLCJldmVudExpa2UiLCJwYWdlWCIsInBhZ2VZIiwic2NyZWVuWCIsInNjcmVlblkiLCJsb2NhbFgiLCJsb2NhbFkiLCJjdHJsS2V5IiwiYWx0S2V5Iiwic2hpZnRLZXkiLCJtZXRhS2V5IiwiX2ludGVybmFsX2lzVG91Y2giLCJzdGFydHNXaXRoIiwiX2ludGVybmFsX3NyY1R5cGUiLCJfaW50ZXJuYWxfdGFyZ2V0IiwiX2ludGVybmFsX3ZpZXciLCJfaW50ZXJuYWxfcHJldmVudERlZmF1bHQiLCJoYW5kbGVyIiwiZGJsQ2xpY2tFdmVudCIsImVsZW1lbnQiLCJ4RGlmZiIsInlEaWZmIiwiY2FuY2VsYWJsZSIsInRpbWVTdGFtcCIsImNvbXBhcmVQcmltaXRpdmVaT3JkZXIiLCJyZWZlcmVuY2UiLCJmaW5kQmVzdFByaW1pdGl2ZUhpdFRlc3QiLCJiZXN0UHJpbWl0aXZlSGl0IiwiYmVzdEhpdFNvdXJjZSIsInByaW1pdGl2ZUhpdFJlc3VsdHMiLCJoaXRSZXN1bHQiLCJfaW50ZXJuYWxfaGl0IiwiY29udmVydFByaW1pdGl2ZUhpdFJlc3VsdCIsInByaW1pdGl2ZUhpdCIsIl9pbnRlcm5hbF9vYmplY3QiLCJfaW50ZXJuYWxfY3Vyc29yU3R5bGUiLCJjdXJzb3JTdHlsZSIsImhpdFRlc3RQYW5lVmlldyIsImhpdFRlc3RQYW5lIiwiaXNCYWNrZ3JvdW5kIiwic291cmNlUmVzdWx0IiwiYnVpbGRQcmljZUF4aXNWaWV3c0dldHRlciIsInBzSWQiLCJQcmljZUF4aXNXaWRnZXQiLCJfcHJpdmF0ZV9fbW91c2VFdmVudEhhbmRsZXIiLCJfcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZyIsInVuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQiLCJfcHJpdmF0ZV9fdG9wQ2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyIiwiY2FudmFzRWxlbWVudCIsImRpc3Bvc2UiLCJfcHJpdmF0ZV9fY2FudmFzQmluZGluZyIsIl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIiLCJfaW50ZXJuYWxfZ2V0RWxlbWVudCIsIl9wcml2YXRlX19jZWxsIiwiX2ludGVybmFsX3JlbmRlcmVyT3B0aW9ucyIsImlzRm9udENoYW5nZWQiLCJfcHJpdmF0ZV9fd2lkdGhDYWNoZSIsIl9pbnRlcm5hbF9vcHRpbWFsV2lkdGgiLCJ0aWNrTWFya01heFdpZHRoIiwiX3ByaXZhdGVfX2Jhc2VGb250IiwiX3ByaXZhdGVfX2JhY2tMYWJlbHMiLCJfcHJpdmF0ZV9fc2l6ZSIsInRvcFZhbHVlIiwiYm90dG9tVmFsdWUiLCJyZXN1bHRUaWNrTWFya3NNYXhXaWR0aCIsIl9pbnRlcm5hbF9zZXRTaXplIiwibmV3U2l6ZSIsIl9wcml2YXRlX19pc1NldHRpbmdTaXplIiwiX2ludGVybmFsX2dldFdpZHRoIiwiX2ludGVybmFsX3N0YXRlIiwiX2ludGVybmFsX2NoYXJ0IiwiX2ludGVybmFsX3BhaW50IiwiX3ByaXZhdGVfX2FsaWduTGFiZWxzIiwiYXBwbHlTdWdnZXN0ZWRCaXRtYXBTaXplIiwiX3ByaXZhdGVfX2RyYXdCYWNrZ3JvdW5kIiwiX2ludGVybmFsX2RyYXdBZGRpdGlvbmFsU291cmNlcyIsIl9wcml2YXRlX19zb3VyY2VCb3R0b21QYW5lVmlld3MiLCJfcHJpdmF0ZV9fZHJhd1RpY2tNYXJrcyIsIl9wcml2YXRlX19zb3VyY2VQYW5lVmlld3MiLCJfcHJpdmF0ZV9fZHJhd0JhY2tMYWJlbHMiLCJ0b3BUYXJnZXQiLCJfcHJpdmF0ZV9fZHJhd0Nyb3NzaGFpckxhYmVsIiwiX3ByaXZhdGVfX3NvdXJjZVRvcFBhbmVWaWV3cyIsIl9pbnRlcm5hbF9nZXRCaXRtYXBTaXplIiwiX2ludGVybmFsX2RyYXdCaXRtYXAiLCJkcmF3SW1hZ2UiLCJfcHJpdmF0ZV9fbW91c2VEb3duRXZlbnQiLCJfcHJpdmF0ZV9fbW91c2Vkb3duIiwiX3ByaXZhdGVfX3ByZXNzZWRNb3VzZU1vdmVFdmVudCIsIl9wcml2YXRlX19tb3VzZURvd25PdXRzaWRlRXZlbnQiLCJfcHJpdmF0ZV9fbW91c2VVcEV2ZW50IiwiX3ByaXZhdGVfX21vdXNlRG91YmxlQ2xpY2tFdmVudCIsIl9wcml2YXRlX19tb3VzZUVudGVyRXZlbnQiLCJfcHJpdmF0ZV9fc2V0Q3Vyc29yIiwiX3ByaXZhdGVfX21vdXNlTGVhdmVFdmVudCIsImFkZFZpZXdzRm9yU291cmNlcyIsImJvcmRlclNpemUiLCJfcHJpdmF0ZV9faXNMZWZ0IiwicHJpY2VTY2FsZU9wdGlvbnMiLCJ0aWNrTWFya0xlZnRYIiwidGlja0hlaWdodCIsInRpY2tMZW5ndGgiLCJyZWN0IiwidGV4dExlZnRYIiwieU1pZENvcnJlY3Rpb25zIiwib3JkZXJlZFNvdXJjZXMiLCJwYW5lU3RhdGUiLCJpc0RlZmF1bHQiLCJjZW50ZXJTb3VyY2UiLCJ1cGRhdGVGb3JTb3VyY2VzIiwic291cmNlVmlld3MiLCJhbGlnbkxhYmVscyIsIl9wcml2YXRlX19maXhMYWJlbE92ZXJsYXAiLCJsIiwicHJldkZpeGVkQ29vcmRpbmF0ZSIsInJvIiwiY3Vyc29yIiwiX3ByaXZhdGVfX3ByZXZPcHRpbWFsV2lkdGgiLCJyZW5kZXJlck9wdGlvbnNQcm92aWRlciIsImRvY3VtZW50Iiwib3ZlcmZsb3ciLCJzdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCIsInpJbmRleCIsInRvcENhbnZhcyIsInNvdXJjZUJvdHRvbVBhbmVWaWV3cyQxIiwic291cmNlUGFuZVZpZXdzJDEiLCJzb3VyY2VMYWJlbFBhbmVWaWV3cyIsInNvdXJjZVRvcFBhbmVWaWV3cyQxIiwiUGFuZVdpZGdldCIsIl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0IiwiX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0IiwiX3ByaXZhdGVfX3N0YXRlIiwiX2ludGVybmFsX3NldFN0YXRlIiwicHJvdG90eXBlIiwiX3ByaXZhdGVfX29uU3RhdGVEZXN0cm95ZWQiLCJfaW50ZXJuYWxfdXBkYXRlUHJpY2VBeGlzV2lkZ2V0c1N0YXRlcyIsIl9wcml2YXRlX19jaGFydCIsIl9wcml2YXRlX19yb3dFbGVtZW50IiwiX3ByaXZhdGVfX3JlY3JlYXRlUHJpY2VBeGlzV2lkZ2V0cyIsIl9pbnRlcm5hbF91cGRhdGVQcmljZUF4aXNXaWRnZXRzIiwic3RyZXRjaEZhY3RvciIsIl9wcml2YXRlX19vbk1vdXNlRXZlbnQiLCJfcHJpdmF0ZV9fc2V0Q3Jvc3NoYWlyUG9zaXRpb24iLCJfcHJpdmF0ZV9fbW91c2VUb3VjaERvd25FdmVudCIsIl9pbnRlcm5hbF9zZXRDdXJzb3JTdHlsZSIsIl9wcml2YXRlX19maXJlQ2xpY2tlZERlbGVnYXRlIiwiX3ByaXZhdGVfX2ZpcmVNb3VzZUNsaWNrRGVsZWdhdGUiLCJfcHJpdmF0ZV9fZGJsQ2xpY2tlZCIsIl9wcml2YXRlX19wcmVzc2VkTW91c2VUb3VjaE1vdmVFdmVudCIsIl9wcml2YXRlX19sb25nVGFwIiwiX3ByaXZhdGVfX2VuZFNjcm9sbCIsIl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQiLCJfcHJpdmF0ZV9fc3RhcnRUcmFja2luZ01vZGUiLCJfcHJpdmF0ZV9fY2xlYXJDcm9zc2hhaXJQb3NpdGlvbiIsIl9pbnRlcm5hbF9jbGlja2VkIiwiX3ByaXZhdGVfX2NsaWNrZWQiLCJfaW50ZXJuYWxfZGJsQ2xpY2tlZCIsIl9wcml2YXRlX19wcmV2UGluY2hTY2FsZSIsIm1pZGRsZVBvaW50Iiwiem9vbVNjYWxlIiwiX3ByaXZhdGVfX2V4aXRUcmFja2luZ01vZGVPbk5leHRUcnkiLCJfcHJpdmF0ZV9faW5pdENyb3NzaGFpclBvc2l0aW9uIiwib3JpZ1BvaW50IiwibmV3WCIsIm5ld1kiLCJ0cmFja2luZ01vZGUiLCJleGl0TW9kZSIsIl9wcml2YXRlX190cnlFeGl0VHJhY2tpbmdNb2RlIiwic3RhdGUiLCJfaW50ZXJuYWxfc2V0UHJpY2VBeGlzU2l6ZSIsInByaWNlQXhpc1dpZGdldCIsIl9pbnRlcm5hbF9nZXRTaXplIiwiX3ByaXZhdGVfX3BhbmVDZWxsIiwiX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VTY2FsZXMiLCJfcHJpdmF0ZV9fZHJhd1NvdXJjZXMiLCJfcHJpdmF0ZV9fZHJhd0dyaWQiLCJfcHJpdmF0ZV9fZHJhd1dhdGVybWFyayIsIl9wcml2YXRlX19kcmF3Q3Jvc3NoYWlyIiwiX2ludGVybmFsX2xlZnRQcmljZUF4aXNXaWRnZXQiLCJfaW50ZXJuYWxfcmlnaHRQcmljZUF4aXNXaWRnZXQiLCJkZWxlZ2F0ZSIsIl9wcml2YXRlX19kcmF3U291cmNlSW1wbCIsImRyYXdGbiIsImhvdmVyZWRTb3VyY2UiLCJvYmplY0lkIiwiY2hhcnQiLCJsZWZ0QXhpc1Zpc2libGUiLCJyaWdodEF4aXNWaXNpYmxlIiwiX3ByaXZhdGVfX2xlZnRBeGlzQ2VsbCIsInJlbW92ZUNoaWxkIiwiX3ByaXZhdGVfX3JpZ2h0QXhpc0NlbGwiLCJfcHJpdmF0ZV9fcHJldmVudFNjcm9sbCIsIl9wcml2YXRlX19jb3JyZWN0WENvb3JkIiwiX3ByaXZhdGVfX2NvcnJlY3RZQ29vcmQiLCJzdGFydFRyYWNrUG9pbnQiLCJjcm9zc0hhaXJQb3NpdGlvbiIsIl9wcml2YXRlX19pc1Njcm9sbGluZyIsIl9wcml2YXRlX19zdGFydFNjcm9sbGluZ1BvcyIsIl9wcml2YXRlX19zY3JvbGxYQW5pbWF0aW9uIiwic3RhcnRBbmltYXRpb25UaW1lIiwiYWN0aXZlRWxlbWVudCIsImJvZHkiLCJibHVyIiwic2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9uIiwicmVtb3ZlQWxsUmFuZ2VzIiwiY2hhcnRPcHRpb25zIiwic2Nyb2xsT3B0aW9ucyIsImtpbmV0aWNTY3JvbGxPcHRpb25zIiwia2luZXRpY1Njcm9sbCIsIl9pbnRlcm5hbF9sb2NhbFgiLCJfaW50ZXJuYWxfbG9jYWxZIiwibW91c2UiLCJwYWRkaW5nIiwicGFuZVdyYXBwZXIiLCJQcmljZUF4aXNTdHViIiwiX3ByaXZhdGVfX2JvcmRlclZpc2libGUiLCJob3J6Qm9yZGVyU2l6ZSIsInZlcnRCb3JkZXJTaXplIiwiX3ByaXZhdGVfX2JvdHRvbUNvbG9yIiwiYnVpbGRUaW1lQXhpc1ZpZXdzR2V0dGVyIiwic291cmNlUGFuZVZpZXdzIiwic291cmNlVG9wUGFuZVZpZXdzIiwic291cmNlQm90dG9tUGFuZVZpZXdzIiwiVGltZUF4aXNXaWRnZXQiLCJfcHJpdmF0ZV9fbGVmdFN0dWIiLCJfcHJpdmF0ZV9fcmlnaHRTdHViIiwiX3ByaXZhdGVfX2VsZW1lbnQiLCJfaW50ZXJuYWxfbGVmdFN0dWIiLCJfaW50ZXJuYWxfcmlnaHRTdHViIiwiX3ByaXZhdGVfX21vdXNlRG93biIsIl9pbnRlcm5hbF9zaXplQ2hhbmdlZCIsIl9wcml2YXRlX19zaXplQ2hhbmdlZCIsIl9pbnRlcm5hbF9zZXRTaXplcyIsInRpbWVBeGlzU2l6ZSIsImxlZnRTdHViV2lkdGgiLCJyaWdodFN0dWJXaWR0aCIsIl9pbnRlcm5hbF9vcHRpbWFsSGVpZ2h0IiwiX3ByaXZhdGVfX2dldFJlbmRlcmVyT3B0aW9ucyIsIl9pbnRlcm5hbF9sYWJlbEJvdHRvbU9mZnNldCIsIl9wcml2YXRlX19kcmF3QWRkaXRpb25hbFNvdXJjZXMiLCJfcHJpdmF0ZV9fZHJhd0xhYmVscyIsImF4aXNWaWV3c0dldHRlciIsIl9wcml2YXRlX19saW5lQ29sb3IiLCJ0aWNrTGVuIiwiX3ByaXZhdGVfX2FsaWduVGlja01hcmtMYWJlbENvb3JkaW5hdGUiLCJfcHJpdmF0ZV9fYmFzZUJvbGRGb250IiwibGFiZWxUZXh0IiwibGVmdFRleHRDb29yZGluYXRlIiwibmV3Rm9udCIsIl9wcml2YXRlX19yZWNyZWF0ZVN0dWJzIiwiX3ByaXZhdGVfX2xlZnRTdHViQ2VsbCIsIl9wcml2YXRlX19yaWdodFN0dWJDZWxsIiwiYm9yZGVyVmlzaWJsZUdldHRlciIsImJvdHRvbUNvbG9yR2V0dGVyIiwiY2hhcnRXaWRnZXQiLCJfcHJpdmF0ZV9fZHYiLCJ3aW5kb3dzQ2hyb21lIiwiQ2hhcnRXaWRnZXQiLCJfaW50ZXJuYWxfcGFuZVdpZGdldHMiLCJfcHJpdmF0ZV9fcGFuZVdpZGdldHMiLCJfaW50ZXJuYWxfdGltZUF4aXNXaWRnZXQiLCJfcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQiLCJfcHJpdmF0ZV9fc2V0TW91c2VXaGVlbEV2ZW50TGlzdGVuZXIiLCJfcHJpdmF0ZV9fZHJhd1JhZklkIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJwYW5lV2lkZ2V0IiwiX3ByaXZhdGVfX3RhYmxlRWxlbWVudCIsIl9wcml2YXRlX191bmluc3RhbGxPYnNlcnZlciIsIl9pbnRlcm5hbF9yZXNpemUiLCJmb3JjZVJlcGFpbnQiLCJzaXplSGludCIsImhlaWdodFN0ciIsIndpZHRoU3RyIiwiX3ByaXZhdGVfX2RyYXdJbXBsIiwiaW52YWxpZGF0ZU1hc2siLCJjdXJyZW50bHlIYXNNb3VzZVdoZWVsTGlzdGVuZXIiLCJzaG91bGRTdWJzY3JpYmVNb3VzZVdoZWVsIiwic2hvdWxkSGF2ZU1vdXNlV2hlZWxMaXN0ZW5lciIsIl9wcml2YXRlX191cGRhdGVUaW1lQXhpc1Zpc2liaWxpdHkiLCJfcHJpdmF0ZV9fYXBwbHlBdXRvU2l6ZU9wdGlvbnMiLCJfaW50ZXJuYWxfdGFrZVNjcmVlbnNob3QiLCJfcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2siLCJzY3JlZXNob3RCaXRtYXBTaXplIiwiX3ByaXZhdGVfX3RyYXZlcnNlTGF5b3V0Iiwic2NyZWVuc2hvdENhbnZhcyIsIl9pbnRlcm5hbF9nZXRQcmljZUF4aXNXaWR0aCIsIl9wcml2YXRlX19pc0xlZnRBeGlzVmlzaWJsZSIsIl9wcml2YXRlX19pc1JpZ2h0QXhpc1Zpc2libGUiLCJfaW50ZXJuYWxfYXV0b1NpemVBY3RpdmUiLCJhdXRvU2l6ZSIsIl9wcml2YXRlX19vYnNlcnZlciIsIl9pbnRlcm5hbF9lbGVtZW50IiwiX3ByaXZhdGVfX2N1cnNvclN0eWxlT3ZlcnJpZGUiLCJzZXRQcm9wZXJ0eSIsInJlbW92ZVByb3BlcnR5IiwiX2ludGVybmFsX2dldEN1cnNvck92ZXJyaWRlU3R5bGUiLCJfaW50ZXJuYWxfcGFuZVNpemUiLCJfcHJpdmF0ZV9faW5zdGFsbE9ic2VydmVyIiwiZmlyc3RQYW5lIiwiZHJhd1ByaWNlQXhpc2VzIiwidGFyZ2V0WCIsInRhcmdldFkiLCJsZWZ0QXhpc0JpdG1hcFdpZHRoIiwiZmlyc3RQYW5lQml0bWFwV2lkdGgiLCJyaWdodEF4aXNCaXRtYXBXaWR0aCIsImRyYXdTdHViIiwic3R1YiIsInRpbWVBeGlzQml0bWFwU2l6ZSIsIl9wcml2YXRlX19hZGp1c3RTaXplSW1wbCIsInRvdGFsU3RyZXRjaCIsImxlZnRQcmljZUF4aXNXaWR0aCIsInJpZ2h0UHJpY2VBeGlzV2lkdGgiLCJtaW5pbXVtV2lkdGgiLCJwYW5lV2lkdGgiLCJzZXBhcmF0b3JzSGVpZ2h0IiwidGltZUF4aXNWaXNpYmxlIiwidGltZUF4aXNIZWlnaHQiLCJtaW5pbXVtSGVpZ2h0Iiwib3RoZXJXaWRnZXRIZWlnaHQiLCJ0b3RhbFBhbmVIZWlnaHQiLCJzdHJldGNoUGl4ZWxzIiwiYWNjdW11bGF0ZWRIZWlnaHQiLCJwYW5lSGVpZ2h0IiwiY2FsY3VsYXRlUGFuZUhlaWdodCIsIl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkdGgiLCJfcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWR0aCIsIl9wcml2YXRlX19vbldoZWVsQm91bmQiLCJfcHJpdmF0ZV9fZGV0ZXJtaW5lV2hlZWxTcGVlZEFkanVzdG1lbnQiLCJkZWx0YU1vZGUiLCJET01fREVMVEFfUEFHRSIsIkRPTV9ERUxUQV9MSU5FIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIl9wcml2YXRlX19vbk1vdXNld2hlZWwiLCJkZWx0YVgiLCJkZWx0YVkiLCJzY3JvbGxTcGVlZEFkanVzdG1lbnQiLCJzY3JvbGxQb3NpdGlvbiIsImludmFsaWRhdGlvblR5cGUiLCJfcHJpdmF0ZV9fdXBkYXRlR3VpIiwiX3ByaXZhdGVfX2FwcGx5TW9tZW50YXJ5QXV0b1NjYWxlIiwiX3ByaXZhdGVfX2FwcGx5VGltZVNjYWxlSW52YWxpZGF0aW9ucyIsInBhbmVzIiwiX3ByaXZhdGVfX2RyYXdQbGFubmVkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX3ByaXZhdGVfX3N5bmNHdWlXaXRoTW9kZWwiLCJ0YXJnZXRQYW5lV2lkZ2V0c0NvdW50IiwiYWN0dWFsUGFuZVdpZGdldHNDb3VudCIsInBvcCIsIl9wcml2YXRlX19vblBhbmVXaWRnZXRDbGlja2VkIiwiX3ByaXZhdGVfX29uUGFuZVdpZGdldERibENsaWNrZWQiLCJpbnNlcnRCZWZvcmUiLCJfcHJpdmF0ZV9fZ2V0TW91c2VFdmVudFBhcmFtc0ltcGwiLCJjbGllbnRUaW1lIiwiaG92ZXJlZFNlcmllcyIsImhvdmVyZWRPYmplY3QiLCJfaW50ZXJuYWxfb3JpZ2luYWxUaW1lIiwiX2ludGVybmFsX3BvaW50IiwiX2ludGVybmFsX2hvdmVyZWRTZXJpZXMiLCJfaW50ZXJuYWxfc2VyaWVzRGF0YSIsIl9pbnRlcm5hbF9ob3ZlcmVkT2JqZWN0IiwiX2ludGVybmFsX3RvdWNoTW91c2VFdmVudERhdGEiLCJfcHJpdmF0ZV9fb25QYW5lV2lkZ2V0Q3Jvc3NoYWlyTW92ZWQiLCJkaXNwbGF5IiwiUmVzaXplT2JzZXJ2ZXIiLCJlbnRyaWVzIiwiY29udGFpbmVyRW50cnkiLCJlbnRyeSIsIl9wcml2YXRlX19jb250YWluZXIiLCJjb250ZW50UmVjdCIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwiY29udGFpbmVyIiwiY2xhc3NMaXN0IiwiZGlyZWN0aW9uIiwiZGlzYWJsZVNlbGVjdGlvbiIsInNldEF0dHJpYnV0ZSIsInVzZWRPYnNlcnZlciIsImNvbnRhaW5lclJlY3QiLCJ1c2VyU2VsZWN0Iiwid2Via2l0VXNlclNlbGVjdCIsIm1zVXNlclNlbGVjdCIsIk1velVzZXJTZWxlY3QiLCJ3ZWJraXRUYXBIaWdobGlnaHRDb2xvciIsIkJvb2xlYW4iLCJpc1doaXRlc3BhY2VEYXRhIiwib3BlbiIsImlzRnVsZmlsbGVkRGF0YSIsIl9fcmVzdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZ2V0Q29sb3JlZExpbmVCYXNlZFNlcmllc1Bsb3RSb3ciLCJnZXRBcmVhU2VyaWVzUGxvdFJvdyIsImdldEJhc2VsaW5lU2VyaWVzUGxvdFJvdyIsImdldEJhclNlcmllc1Bsb3RSb3ciLCJjbG9zZSIsImdldENhbmRsZXN0aWNrU2VyaWVzUGxvdFJvdyIsImdldEN1c3RvbVNlcmllc1Bsb3RSb3ciLCJkYXRhVG9QbG90Um93IiwiZXhjbHVkZWRUaW1lIiwiaXNTZXJpZXNQbG90Um93Iiwid3JhcEN1c3RvbVZhbHVlcyIsImN1c3RvbVZhbHVlcyIsIl9pbnRlcm5hbF9jdXN0b21WYWx1ZXMiLCJpc1doaXRlc3BhY2VEYXRhV2l0aEN1c3RvbUNoZWNrIiwiY3VzdG9tSXNXaGl0ZXNwYWNlIiwid3JhcFdoaXRlc3BhY2VEYXRhIiwiY3JlYXRlUGxvdFJvd0ZuIiwiZ2V0U2VyaWVzUGxvdFJvd0NyZWF0b3IiLCJzZXJpZXNQbG90Um93Rm5NYXAiLCJjcmVhdGVFbXB0eVRpbWVQb2ludERhdGEiLCJfaW50ZXJuYWxfbWFwcGluZyIsInNlcmllc1Jvd3NGaXJzdEFuZExhc3RUaW1lIiwic2VyaWVzUm93cyIsIl9pbnRlcm5hbF9maXJzdFRpbWUiLCJfaW50ZXJuYWxfbGFzdFRpbWUiLCJzZXJpZXNVcGRhdGVJbmZvIiwicHJldlNlcmllc1Jvd3MiLCJmaXJzdEFuZExhc3RUaW1lIiwicHJldkZpcnN0QW5kTGFzdFRpbWUiLCJ0aW1lU2NhbGVQb2ludFRpbWUiLCJtZXJnZWRQb2ludERhdGEiLCJzYXZlT3JpZ2luYWxUaW1lIiwiRGF0YUxheWVyIiwiX3ByaXZhdGVfX3BvaW50RGF0YUJ5VGltZVBvaW50IiwiX3ByaXZhdGVfX3Nlcmllc1Jvd3NCeVNlcmllcyIsIl9wcml2YXRlX19zZXJpZXNMYXN0VGltZVBvaW50IiwiX3ByaXZhdGVfX3NvcnRlZFRpbWVQb2ludHMiLCJfaW50ZXJuYWxfc2V0U2VyaWVzRGF0YSIsIm5lZWRDbGVhbnVwUG9pbnRzIiwiaXNUaW1lU2NhbGVBZmZlY3RlZCIsInBvaW50RGF0YSIsIm9yaWdpbmFsVGltZXMiLCJ0aW1lQ29udmVydGVyIiwiY3JlYXRlUGxvdFJvdyIsImN1c3RvbVdoaXRlc3BhY2VDaGVja2VyIiwiaG9yekl0ZW1LZXkiLCJ0aW1lUG9pbnREYXRhIiwiX3ByaXZhdGVfX2NsZWFudXBQb2ludHNEYXRhIiwiX3ByaXZhdGVfX3NldFJvd3NUb1NlcmllcyIsIm5ld1RpbWVTY2FsZVBvaW50cyIsInQxIiwidDIiLCJfcHJpdmF0ZV9fcmVwbGFjZVRpbWVTY2FsZVBvaW50cyIsIl9wcml2YXRlX19nZXRVcGRhdGVSZXNwb25zZSIsIl9pbnRlcm5hbF91cGRhdGVTZXJpZXNEYXRhIiwiZXh0ZW5kZWREYXRhIiwibGFzdFNlcmllc1RpbWUiLCJwb2ludERhdGFBdFRpbWUiLCJhZmZlY3RzVGltZVNjYWxlIiwiX3ByaXZhdGVfX3VwZGF0ZUxhc3RTZXJpZXNSb3ciLCJpbmZvIiwibmV3UG9pbnQiLCJpbnNlcnRJbmRleCIsImFzc2lnbkluZGV4VG9Qb2ludERhdGEiLCJsYXN0U2VyaWVzUm93IiwibmV3VGltZVBvaW50cyIsIm9sZFBvaW50IiwiX3ByaXZhdGVfX2dldEJhc2VJbmRleCIsInVwZGF0ZWRTZXJpZXMiLCJkYXRhVXBkYXRlUmVzcG9uc2UiLCJfaW50ZXJuYWxfc2VyaWVzIiwiX2ludGVybmFsX2luZm8iLCJfaW50ZXJuYWxfcG9pbnRzIiwiX2ludGVybmFsX2ZpcnN0Q2hhbmdlZFBvaW50SW5kZXgiLCJzZXJpZXNSb3ciLCJzaW5nbGVWYWx1ZURhdGEiLCJsaW5lRGF0YSIsImFyZWFEYXRhIiwiYmFzZWxpbmVEYXRhIiwib2hsY0RhdGEiLCJiYXJEYXRhIiwiY2FuZGxlc3RpY2tEYXRhIiwiZ2V0U2VyaWVzRGF0YUNyZWF0b3IiLCJzZXJpZXNQbG90Um93VG9EYXRhTWFwIiwiY3VzdG9tRGF0YSIsImNyb3NzaGFpck9wdGlvbnNEZWZhdWx0cyIsImdyaWRPcHRpb25zRGVmYXVsdHMiLCJsYXlvdXRPcHRpb25zRGVmYXVsdHMiLCJwcmljZVNjYWxlT3B0aW9uc0RlZmF1bHRzIiwidGltZVNjYWxlT3B0aW9uc0RlZmF1bHRzIiwid2F0ZXJtYXJrT3B0aW9uc0RlZmF1bHRzIiwiY2hhcnRPcHRpb25zRGVmYXVsdHMiLCJsYW5ndWFnZSIsIlByaWNlU2NhbGVBcGkiLCJhcHBseU9wdGlvbnMiLCJfcHJpdmF0ZV9fY2hhcnRXaWRnZXQiLCJfcHJpdmF0ZV9fcHJpY2VTY2FsZUlkIiwiY2hlY2tQcmljZUxpbmVPcHRpb25zIiwiY2hlY2tJdGVtc0FyZU9yZGVyZWQiLCJhbGxvd0R1cGxpY2F0ZXMiLCJjaGVja1Jlc3VsdCIsImNoZWNrU2VyaWVzVmFsdWVzVHlwZSIsImdldENoZWNrZXIiLCJjaGVja0Jhckl0ZW0iLCJjaGVja0xpbmVJdGVtIiwiY2hlY2tDdXN0b21JdGVtIiwiYmFySXRlbSIsImxpbmVJdGVtIiwiY29udmVydFNlcmllc01hcmtlciIsInNtIiwibmV3VGltZSIsInByaWNlTGluZU9wdGlvbnNEZWZhdWx0cyIsIlByaWNlTGluZSIsIl9pbnRlcm5hbF9wcmljZUxpbmUiLCJTZXJpZXNBcGkiLCJfcHJpdmF0ZV9fZGF0YUNoYW5nZWREZWxlZ2F0ZSIsInByaWNlVG9Db29yZGluYXRlIiwiY29vcmRpbmF0ZVRvUHJpY2UiLCJiYXJzSW5Mb2dpY2FsUmFuZ2UiLCJjb3JyZWN0ZWRSYW5nZSIsImRhdGFGaXJzdEJhckluUmFuZ2UiLCJkYXRhTGFzdEJhckluUmFuZ2UiLCJkYXRhRmlyc3RJbmRleCIsImRhdGFMYXN0SW5kZXgiLCJiYXJzQmVmb3JlIiwiYmFyc0FmdGVyIiwic2V0RGF0YSIsIl9pbnRlcm5hbF9fZGF0YVVwZGF0ZXNDb25zdW1lciIsIl9pbnRlcm5hbF9hcHBseU5ld0RhdGEiLCJfcHJpdmF0ZV9fb25EYXRhQ2hhbmdlZCIsIl9pbnRlcm5hbF91cGRhdGVEYXRhIiwiZGF0YUJ5SW5kZXgiLCJsb2dpY2FsSW5kZXgiLCJtaXNtYXRjaERpcmVjdGlvbiIsImNyZWF0b3IiLCJzZXJpZXNDcmVhdG9yIiwicm93cyIsInN1YnNjcmliZURhdGFDaGFuZ2VkIiwidW5zdWJzY3JpYmVEYXRhQ2hhbmdlZCIsInNldE1hcmtlcnMiLCJjb252ZXJ0ZWRNYXJrZXJzIiwibWFya2VycyIsImludGVybmFsSXRlbSIsIl9wcml2YXRlX19wcmljZVNjYWxlQXBpUHJvdmlkZXIiLCJjcmVhdGVQcmljZUxpbmUiLCJzdHJpY3RPcHRpb25zIiwicmVtb3ZlUHJpY2VMaW5lIiwiYXR0YWNoUHJpbWl0aXZlIiwiYXR0YWNoZWQiLCJfaW50ZXJuYWxfX2NoYXJ0QXBpIiwicmVxdWVzdFVwZGF0ZSIsImRldGFjaFByaW1pdGl2ZSIsImRldGFjaGVkIiwiZGF0YVVwZGF0ZXNDb25zdW1lciIsInByaWNlU2NhbGVBcGlQcm92aWRlciIsImNoYXJ0QXBpIiwiVGltZVNjYWxlQXBpIiwiX3ByaXZhdGVfX3RpbWVSYW5nZUNoYW5nZWQiLCJzY3JvbGxUb1Bvc2l0aW9uIiwiYW5pbWF0ZWQiLCJzY3JvbGxUb1JlYWxUaW1lIiwiZ2V0VmlzaWJsZVJhbmdlIiwidGltZVJhbmdlIiwic2V0VmlzaWJsZVJhbmdlIiwiY29udmVydGVkUmFuZ2UiLCJnZXRWaXNpYmxlTG9naWNhbFJhbmdlIiwic2V0VmlzaWJsZUxvZ2ljYWxSYW5nZSIsInJlc2V0VGltZVNjYWxlIiwiZml0Q29udGVudCIsImxvZ2ljYWxUb0Nvb3JkaW5hdGUiLCJjb29yZGluYXRlVG9Mb2dpY2FsIiwidGltZVRvQ29vcmRpbmF0ZSIsImNvb3JkaW5hdGVUb1RpbWUiLCJzdWJzY3JpYmVWaXNpYmxlVGltZVJhbmdlQ2hhbmdlIiwidW5zdWJzY3JpYmVWaXNpYmxlVGltZVJhbmdlQ2hhbmdlIiwic3Vic2NyaWJlVmlzaWJsZUxvZ2ljYWxSYW5nZUNoYW5nZSIsInVuc3Vic2NyaWJlVmlzaWJsZUxvZ2ljYWxSYW5nZUNoYW5nZSIsInN1YnNjcmliZVNpemVDaGFuZ2UiLCJ1bnN1YnNjcmliZVNpemVDaGFuZ2UiLCJfcHJpdmF0ZV9fb25WaXNpYmxlQmFyc0NoYW5nZWQiLCJfcHJpdmF0ZV9fb25WaXNpYmxlTG9naWNhbFJhbmdlQ2hhbmdlZCIsIl9wcml2YXRlX19vblNpemVDaGFuZ2VkIiwidGltZUF4aXNXaWRnZXQiLCJwYXRjaFByaWNlRm9ybWF0IiwicHJpY2VGb3JtYXRCdWlsdEluIiwibWlncmF0ZUhhbmRsZVNjYWxlU2Nyb2xsT3B0aW9ucyIsInRvSW50ZXJuYWxPcHRpb25zIiwiQ2hhcnRBcGkiLCJyZW1vdmUiLCJfcHJpdmF0ZV9fdGltZVNjYWxlQXBpIiwiX3ByaXZhdGVfX3Nlcmllc01hcCIsIl9wcml2YXRlX19zZXJpZXNNYXBSZXZlcnNlZCIsIl9wcml2YXRlX19jbGlja2VkRGVsZWdhdGUiLCJfcHJpdmF0ZV9fZGJsQ2xpY2tlZERlbGVnYXRlIiwiX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkRGVsZWdhdGUiLCJfcHJpdmF0ZV9fZGF0YUxheWVyIiwicmVzaXplIiwiYXV0b1NpemVBY3RpdmUiLCJhZGRDdXN0b21TZXJpZXMiLCJkZWZhdWx0cyIsImRlZmF1bHRPcHRpb25zIiwiX3ByaXZhdGVfX2FkZFNlcmllc0ltcGwiLCJhZGRBcmVhU2VyaWVzIiwiYWRkQmFzZWxpbmVTZXJpZXMiLCJhZGRCYXJTZXJpZXMiLCJhZGRDYW5kbGVzdGlja1NlcmllcyIsImFkZEhpc3RvZ3JhbVNlcmllcyIsImFkZExpbmVTZXJpZXMiLCJyZW1vdmVTZXJpZXMiLCJzZXJpZXNBcGkiLCJfcHJpdmF0ZV9fc2VuZFVwZGF0ZVRvQ2hhcnQiLCJzdWJzY3JpYmVDbGljayIsInVuc3Vic2NyaWJlQ2xpY2siLCJzdWJzY3JpYmVDcm9zc2hhaXJNb3ZlIiwidW5zdWJzY3JpYmVDcm9zc2hhaXJNb3ZlIiwic3Vic2NyaWJlRGJsQ2xpY2siLCJ1bnN1YnNjcmliZURibENsaWNrIiwidGFrZVNjcmVlbnNob3QiLCJjaGFydEVsZW1lbnQiLCJwYW5lU2l6ZSIsInNldENyb3NzaGFpclBvc2l0aW9uIiwiY2xlYXJDcm9zc2hhaXJQb3NpdGlvbiIsInN0eWxlRGVmYXVsdHMiLCJfcHJpdmF0ZV9fbWFwU2VyaWVzVG9BcGkiLCJfcHJpdmF0ZV9fY29udmVydE1vdXNlUGFyYW1zIiwicGFyYW0iLCJob3ZlcmVkT2JqZWN0SWQiLCJzb3VyY2VFdmVudCIsImludGVybmFsT3B0aW9ucyIsInBhcmFtU3VwcGxpZXIiLCJjcmVhdGVDaGFydEV4IiwiaHRtbEVsZW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImNyZWF0ZUNoYXJ0IiwiY3VzdG9tU2VyaWVzRGVmYXVsdE9wdGlvbnMiLCJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\n"));

/***/ })

});