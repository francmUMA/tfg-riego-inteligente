"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/map/page",{

/***/ "(app-pages-browser)/./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n// do not edit .js files directly - edit src/index.jst\nmodule.exports = function equal(a, b) {\n    if (a === b) return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        if (a.constructor !== b.constructor) return false;\n        var length, i, keys;\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;\n            return true;\n        }\n        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) return false;\n        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n        for(i = length; i-- !== 0;){\n            var key = keys[i];\n            if (!equal(a[key], b[key])) return false;\n        }\n        return true;\n    }\n    // true if both NaN, false otherwise\n    return a !== a && b !== b;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxzREFBc0Q7QUFJdERBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxNQUFNQyxDQUFDLEVBQUVDLENBQUM7SUFDbEMsSUFBSUQsTUFBTUMsR0FBRyxPQUFPO0lBRXBCLElBQUlELEtBQUtDLEtBQUssT0FBT0QsS0FBSyxZQUFZLE9BQU9DLEtBQUssVUFBVTtRQUMxRCxJQUFJRCxFQUFFRSxXQUFXLEtBQUtELEVBQUVDLFdBQVcsRUFBRSxPQUFPO1FBRTVDLElBQUlDLFFBQVFDLEdBQUdDO1FBQ2YsSUFBSUMsTUFBTUMsT0FBTyxDQUFDUCxJQUFJO1lBQ3BCRyxTQUFTSCxFQUFFRyxNQUFNO1lBQ2pCLElBQUlBLFVBQVVGLEVBQUVFLE1BQU0sRUFBRSxPQUFPO1lBQy9CLElBQUtDLElBQUlELFFBQVFDLFFBQVEsR0FDdkIsSUFBSSxDQUFDTCxNQUFNQyxDQUFDLENBQUNJLEVBQUUsRUFBRUgsQ0FBQyxDQUFDRyxFQUFFLEdBQUcsT0FBTztZQUNqQyxPQUFPO1FBQ1Q7UUFJQSxJQUFJSixFQUFFRSxXQUFXLEtBQUtNLFFBQVEsT0FBT1IsRUFBRVMsTUFBTSxLQUFLUixFQUFFUSxNQUFNLElBQUlULEVBQUVVLEtBQUssS0FBS1QsRUFBRVMsS0FBSztRQUNqRixJQUFJVixFQUFFVyxPQUFPLEtBQUtDLE9BQU9DLFNBQVMsQ0FBQ0YsT0FBTyxFQUFFLE9BQU9YLEVBQUVXLE9BQU8sT0FBT1YsRUFBRVUsT0FBTztRQUM1RSxJQUFJWCxFQUFFYyxRQUFRLEtBQUtGLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxFQUFFLE9BQU9kLEVBQUVjLFFBQVEsT0FBT2IsRUFBRWEsUUFBUTtRQUVoRlQsT0FBT08sT0FBT1AsSUFBSSxDQUFDTDtRQUNuQkcsU0FBU0UsS0FBS0YsTUFBTTtRQUNwQixJQUFJQSxXQUFXUyxPQUFPUCxJQUFJLENBQUNKLEdBQUdFLE1BQU0sRUFBRSxPQUFPO1FBRTdDLElBQUtDLElBQUlELFFBQVFDLFFBQVEsR0FDdkIsSUFBSSxDQUFDUSxPQUFPQyxTQUFTLENBQUNFLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDZixHQUFHSSxJQUFJLENBQUNELEVBQUUsR0FBRyxPQUFPO1FBRWhFLElBQUtBLElBQUlELFFBQVFDLFFBQVEsR0FBSTtZQUMzQixJQUFJYSxNQUFNWixJQUFJLENBQUNELEVBQUU7WUFFakIsSUFBSSxDQUFDTCxNQUFNQyxDQUFDLENBQUNpQixJQUFJLEVBQUVoQixDQUFDLENBQUNnQixJQUFJLEdBQUcsT0FBTztRQUNyQztRQUVBLE9BQU87SUFDVDtJQUVBLG9DQUFvQztJQUNwQyxPQUFPakIsTUFBSUEsS0FBS0MsTUFBSUE7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcz8wYmM1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJlcXVhbCIsImEiLCJiIiwiY29uc3RydWN0b3IiLCJsZW5ndGgiLCJpIiwia2V5cyIsIkFycmF5IiwiaXNBcnJheSIsIlJlZ0V4cCIsInNvdXJjZSIsImZsYWdzIiwidmFsdWVPZiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fast-deep-equal/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/ui/dashboard/map/MapComponent.jsx":
/*!***************************************************!*\
  !*** ./src/app/ui/dashboard/map/MapComponent.jsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vis.gl/react-google-maps */ \"(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\nconst App = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_1__.APIProvider, {\n        apiKey: process.env.GOOGLE_MAPS_API_KEY,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_1__.Map, {\n            zoom: 10,\n            center: {\n                lat: 53.54992,\n                lng: 10.00678\n            }\n        }, void 0, false, {\n            fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/ui/dashboard/map/MapComponent.jsx\",\n            lineNumber: 5,\n            columnNumber: 5\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/dev-francm/Documents/tfg-riego-inteligente/frontend/src/app/ui/dashboard/map/MapComponent.jsx\",\n        lineNumber: 4,\n        columnNumber: 3\n    }, undefined);\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdWkvZGFzaGJvYXJkL21hcC9NYXBDb21wb25lbnQuanN4IiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJEO0FBRTNELE1BQU1FLE1BQU0sa0JBQ1YsOERBQUNGLGtFQUFXQTtRQUFDRyxRQUFRQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLG1CQUFtQjtrQkFDbEQsNEVBQUNMLDBEQUFHQTtZQUFDTSxNQUFNO1lBQUlDLFFBQVE7Z0JBQUNDLEtBQUs7Z0JBQVVDLEtBQUs7WUFBUTs7Ozs7Ozs7Ozs7S0FGbERSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvdWkvZGFzaGJvYXJkL21hcC9NYXBDb21wb25lbnQuanN4P2YwMzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtBUElQcm92aWRlciwgTWFwfSBmcm9tICdAdmlzLmdsL3JlYWN0LWdvb2dsZS1tYXBzJztcblxuY29uc3QgQXBwID0gKCkgPT4gKFxuICA8QVBJUHJvdmlkZXIgYXBpS2V5PXtwcm9jZXNzLmVudi5HT09HTEVfTUFQU19BUElfS0VZfT5cbiAgICA8TWFwIHpvb209ezEwfSBjZW50ZXI9e3tsYXQ6IDUzLjU0OTkyLCBsbmc6IDEwLjAwNjc4fX0gLz5cbiAgPC9BUElQcm92aWRlcj5cbik7Il0sIm5hbWVzIjpbIkFQSVByb3ZpZGVyIiwiTWFwIiwiQXBwIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIkdPT0dMRV9NQVBTX0FQSV9LRVkiLCJ6b29tIiwiY2VudGVyIiwibGF0IiwibG5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/ui/dashboard/map/MapComponent.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIProvider: function() { return /* binding */ APIProvider; },\n/* harmony export */   APIProviderContext: function() { return /* binding */ APIProviderContext; },\n/* harmony export */   AdvancedMarker: function() { return /* binding */ AdvancedMarker; },\n/* harmony export */   AdvancedMarkerContext: function() { return /* binding */ AdvancedMarkerContext; },\n/* harmony export */   ControlPosition: function() { return /* binding */ ControlPosition; },\n/* harmony export */   GoogleMapsContext: function() { return /* binding */ GoogleMapsContext; },\n/* harmony export */   InfoWindow: function() { return /* binding */ InfoWindow; },\n/* harmony export */   Map: function() { return /* binding */ Map; },\n/* harmony export */   MapControl: function() { return /* binding */ MapControl; },\n/* harmony export */   Marker: function() { return /* binding */ Marker; },\n/* harmony export */   Pin: function() { return /* binding */ Pin; },\n/* harmony export */   isLatLngLiteral: function() { return /* binding */ isLatLngLiteral; },\n/* harmony export */   latLngEquals: function() { return /* binding */ latLngEquals; },\n/* harmony export */   limitTiltRange: function() { return /* binding */ limitTiltRange; },\n/* harmony export */   toLatLngLiteral: function() { return /* binding */ toLatLngLiteral; },\n/* harmony export */   useAdvancedMarkerRef: function() { return /* binding */ useAdvancedMarkerRef; },\n/* harmony export */   useApiIsLoaded: function() { return /* binding */ useApiIsLoaded; },\n/* harmony export */   useApiLoadingStatus: function() { return /* binding */ useApiLoadingStatus; },\n/* harmony export */   useDirectionsService: function() { return /* binding */ useDirectionsService; },\n/* harmony export */   useMap: function() { return /* binding */ useMap; },\n/* harmony export */   useMapsLibrary: function() { return /* binding */ useMapsLibrary; },\n/* harmony export */   useMarkerRef: function() { return /* binding */ useMarkerRef; },\n/* harmony export */   useStreetViewPanorama: function() { return /* binding */ useStreetViewPanorama; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-deep-equal */ \"(app-pages-browser)/./node_modules/fast-deep-equal/index.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$(), _s13 = $RefreshSig$(), _s14 = $RefreshSig$(), _s15 = $RefreshSig$(), _s16 = $RefreshSig$(), _s17 = $RefreshSig$(), _s18 = $RefreshSig$(), _s19 = $RefreshSig$(), _s20 = $RefreshSig$(), _s21 = $RefreshSig$(), _s22 = $RefreshSig$(), _s23 = $RefreshSig$(), _s24 = $RefreshSig$(), _s25 = $RefreshSig$(), _s26 = $RefreshSig$(), _s27 = $RefreshSig$();\n\n\n\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nconst APILoadingStatus = {\n    NOT_LOADED: \"NOT_LOADED\",\n    LOADING: \"LOADING\",\n    LOADED: \"LOADED\",\n    FAILED: \"FAILED\",\n    AUTH_FAILURE: \"AUTH_FAILURE\"\n};\nconst MAPS_API_BASE_URL = \"https://maps.googleapis.com/maps/api/js\";\n/**\n * A GoogleMapsApiLoader to reliably load and unload the Google Maps JavaScript API.\n *\n * The actual loading and unloading is delayed into the microtask queue, to\n * allow using the API in an useEffect hook, without worrying about multiple API loads.\n */ class GoogleMapsApiLoader {\n    /**\n   * Loads the Google Maps API with the specified parameters.\n   * Since the Maps library can only be loaded once per page, this will\n   * produce a warning when called multiple times with different\n   * parameters.\n   *\n   * The returned promise resolves when loading completes\n   * and rejects in case of an error or when the loading was aborted.\n   */ static async load(params, onLoadingStatusChange) {\n        var _window$google;\n        const libraries = params.libraries ? params.libraries.split(\",\") : [];\n        const serializedParams = this.serializeParams(params);\n        // note: if google.maps.importLibrary was defined externally, the params\n        //   will be ignored. If it was defined by a previous call to this\n        //   method, we will check that the key and other parameters have not been\n        //   changed in between calls.\n        if (!((_window$google = window.google) != null && (_window$google = _window$google.maps) != null && _window$google.importLibrary)) {\n            this.serializedApiParams = serializedParams;\n            this.initImportLibrary(params, onLoadingStatusChange);\n        } else {\n            // if serializedApiParams isn't defined the library was loaded externally\n            // and we can only assume that went alright.\n            if (!this.serializedApiParams) {\n                this.loadingStatus = APILoadingStatus.LOADED;\n            }\n            onLoadingStatusChange(this.loadingStatus);\n        }\n        if (this.serializedApiParams && this.serializedApiParams !== serializedParams) {\n            console.warn(\"The maps API has already been loaded with different \" + \"parameters and will not be loaded again. Refresh the page for \" + \"new values to have effect.\");\n        }\n        for (const lib of [\n            \"maps\",\n            ...libraries\n        ]){\n            await google.maps.importLibrary(lib);\n        }\n    }\n    static serializeParams(params) {\n        return [\n            params.v,\n            params.key,\n            params.language,\n            params.region,\n            params.authReferrerPolicy,\n            params.solutionChannel\n        ].join(\"/\");\n    }\n    static initImportLibrary(params, onLoadingStatusChange) {\n        if (!window.google) window.google = {};\n        if (!window.google.maps) window.google.maps = {};\n        if (window.google.maps[\"importLibrary\"]) {\n            console.warn(\"initImportLibrary can only be called once.\", params);\n            return;\n        }\n        let apiPromise = null;\n        const loadApi = (library)=>{\n            if (apiPromise) return apiPromise;\n            apiPromise = new Promise((resolve, reject)=>{\n                var _document$querySelect;\n                const scriptElement = document.createElement(\"script\");\n                const urlParams = new URLSearchParams();\n                for (const [key, value] of Object.entries(params)){\n                    const urlParamName = key.replace(/[A-Z]/g, (t)=>\"_\" + t[0].toLowerCase());\n                    urlParams.set(urlParamName, value);\n                }\n                urlParams.set(\"libraries\", library);\n                urlParams.set(\"loading\", \"async\");\n                urlParams.set(\"callback\", \"__googleMapsCallback__\");\n                scriptElement.async = true;\n                scriptElement.src = MAPS_API_BASE_URL + \"?\" + urlParams.toString();\n                window.__googleMapsCallback__ = ()=>{\n                    this.loadingStatus = APILoadingStatus.LOADED;\n                    onLoadingStatusChange(this.loadingStatus);\n                    resolve();\n                };\n                window.gm_authFailure = ()=>{\n                    this.loadingStatus = APILoadingStatus.AUTH_FAILURE;\n                    onLoadingStatusChange(this.loadingStatus);\n                };\n                scriptElement.onerror = ()=>{\n                    this.loadingStatus = APILoadingStatus.FAILED;\n                    onLoadingStatusChange(this.loadingStatus);\n                    reject(new Error(\"The Google Maps JavaScript API could not load.\"));\n                };\n                scriptElement.nonce = ((_document$querySelect = document.querySelector(\"script[nonce]\")) == null ? void 0 : _document$querySelect.nonce) || \"\";\n                this.loadingStatus = APILoadingStatus.LOADING;\n                onLoadingStatusChange(this.loadingStatus);\n                document.head.append(scriptElement);\n            });\n            return apiPromise;\n        };\n        // for the first load, we declare an importLibrary function that will\n        // be overwritten once the api is loaded.\n        google.maps.importLibrary = (libraryName)=>loadApi(libraryName).then(()=>google.maps.importLibrary(libraryName));\n    }\n}\nGoogleMapsApiLoader.loadingStatus = APILoadingStatus.NOT_LOADED;\nGoogleMapsApiLoader.serializedApiParams = void 0;\nconst _excluded$3 = [\n    \"onLoad\",\n    \"apiKey\",\n    \"version\",\n    \"libraries\"\n], _excluded2 = [\n    \"children\"\n];\nconst APIProviderContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * local hook to set up the map-instance management context.\n */ function useMapInstances() {\n    _s();\n    const [mapInstances, setMapInstances] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const addMapInstance = function(mapInstance) {\n        let id = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"default\";\n        setMapInstances((instances)=>_extends({}, instances, {\n                [id]: mapInstance\n            }));\n    };\n    const removeMapInstance = function() {\n        let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"default\";\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        setMapInstances((_ref)=>{\n            let remaining = _objectWithoutPropertiesLoose(_ref, [\n                id\n            ].map(_toPropertyKey));\n            return remaining;\n        });\n    };\n    const clearMapInstances = ()=>{\n        setMapInstances({});\n    };\n    return {\n        mapInstances,\n        addMapInstance,\n        removeMapInstance,\n        clearMapInstances\n    };\n}\n_s(useMapInstances, \"hsntVWRr8sQi9gSPNtNDFGcwkPA=\");\n/**\n * local hook to handle the loading of the maps API, returns the current loading status\n * @param props\n */ function useGoogleMapsApiLoader(props) {\n    _s1();\n    const { onLoad, apiKey, version, libraries = [] } = props, otherApiParams = _objectWithoutPropertiesLoose(props, _excluded$3);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(GoogleMapsApiLoader.loadingStatus);\n    const [loadedLibraries, addLoadedLibrary] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((loadedLibraries, action)=>{\n        return _extends({}, loadedLibraries, {\n            [action.name]: action.value\n        });\n    }, {});\n    const librariesString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>libraries == null ? void 0 : libraries.join(\",\"), [\n        libraries\n    ]);\n    const serializedParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>JSON.stringify(_extends({\n            apiKey,\n            version\n        }, otherApiParams)), [\n        apiKey,\n        version,\n        otherApiParams\n    ]);\n    const importLibrary = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (name)=>{\n        var _google;\n        if (loadedLibraries[name]) {\n            return loadedLibraries[name];\n        }\n        if (!((_google = google) != null && (_google = _google.maps) != null && _google.importLibrary)) {\n            throw new Error(\"[api-provider-internal] importLibrary was called before \" + \"google.maps.importLibrary was defined.\");\n        }\n        const res = await window.google.maps.importLibrary(name);\n        addLoadedLibrary({\n            name,\n            value: res\n        });\n        return res;\n    }, [\n        loadedLibraries\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        (async ()=>{\n            try {\n                const params = _extends({\n                    key: apiKey\n                }, otherApiParams);\n                if (version) params.v = version;\n                if ((librariesString == null ? void 0 : librariesString.length) > 0) params.libraries = librariesString;\n                await GoogleMapsApiLoader.load(params, (status)=>setStatus(status));\n                for (const name of [\n                    \"core\",\n                    \"maps\",\n                    ...libraries\n                ]){\n                    await importLibrary(name);\n                }\n                if (onLoad) {\n                    onLoad();\n                }\n            } catch (error) {\n                console.error(\"<ApiProvider> failed to load Google Maps API\", error);\n            }\n        })();\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        apiKey,\n        librariesString,\n        serializedParams\n    ]);\n    return {\n        status,\n        loadedLibraries,\n        importLibrary\n    };\n}\n_s1(useGoogleMapsApiLoader, \"tAqGGf6QjsgSH4cSRTniCSFuVJo=\");\n/**\n * Component to wrap the Google Maps React components and load the Google Maps JavaScript API\n */ const APIProvider = (props)=>{\n    _s2();\n    const { children } = props, loaderProps = _objectWithoutPropertiesLoose(props, _excluded2);\n    const { mapInstances, addMapInstance, removeMapInstance, clearMapInstances } = useMapInstances();\n    const { status, loadedLibraries, importLibrary } = useGoogleMapsApiLoader(loaderProps);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(APIProviderContext.Provider, {\n        value: {\n            mapInstances,\n            addMapInstance,\n            removeMapInstance,\n            clearMapInstances,\n            status,\n            loadedLibraries,\n            importLibrary\n        }\n    }, children);\n};\n_s2(APIProvider, \"DbcSElydWmQ6t+8RZeznJnaF8Pc=\", false, function() {\n    return [\n        useMapInstances,\n        useGoogleMapsApiLoader\n    ];\n});\n_c = APIProvider;\n/**\n * Sets up effects to bind event-handlers for all event-props in MapEventProps.\n * @internal\n */ function useMapEvents(map, props) {\n    // note: calling a useEffect hook from within a loop is prohibited by the\n    // rules of hooks, but it's ok here since it's unconditional and the number\n    // and order of iterations is always strictly the same.\n    // (see https://legacy.reactjs.org/docs/hooks-rules.html)\n    for (const propName of eventPropNames){\n        // fixme: this cast is essentially a 'trust me, bro' for typescript, but\n        //   a proper solution seems way too complicated right now\n        const handler = props[propName];\n        const eventType = propNameToEventType[propName];\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            if (!map) return;\n            if (!handler) return;\n            const listener = google.maps.event.addListener(map, eventType, (ev)=>{\n                handler(createMapEvent(eventType, map, ev));\n            });\n            return ()=>listener.remove();\n        }, [\n            map,\n            eventType,\n            handler\n        ]);\n    }\n}\n/**\n * Create the wrapped map-events used for the event-props.\n * @param type the event type as it is specified to the maps api\n * @param map the map instance the event originates from\n * @param srcEvent the source-event if there is one.\n */ function createMapEvent(type, map, srcEvent) {\n    const ev = {\n        type,\n        map,\n        detail: {},\n        stoppable: false,\n        stop: ()=>{}\n    };\n    if (cameraEventTypes.includes(type)) {\n        const camEvent = ev;\n        const center = map.getCenter();\n        const zoom = map.getZoom();\n        const heading = map.getHeading() || 0;\n        const tilt = map.getTilt() || 0;\n        const bounds = map.getBounds();\n        if (!center || !bounds || !Number.isFinite(zoom)) {\n            console.warn(\"[createEvent] at least one of the values from the map \" + \"returned undefined. This is not expected to happen. Please \" + \"report an issue at https://github.com/visgl/react-google-maps/issues/new\");\n        }\n        camEvent.detail = {\n            center: (center == null ? void 0 : center.toJSON()) || {\n                lat: 0,\n                lng: 0\n            },\n            zoom: zoom || 0,\n            heading: heading,\n            tilt: tilt,\n            bounds: (bounds == null ? void 0 : bounds.toJSON()) || {\n                north: 90,\n                east: 180,\n                south: -90,\n                west: -180\n            }\n        };\n        return camEvent;\n    } else if (mouseEventTypes.includes(type)) {\n        var _srcEvent$latLng;\n        if (!srcEvent) throw new Error(\"[createEvent] mouse events must provide a srcEvent\");\n        const mouseEvent = ev;\n        mouseEvent.domEvent = srcEvent.domEvent;\n        mouseEvent.stoppable = true;\n        mouseEvent.stop = ()=>srcEvent.stop();\n        mouseEvent.detail = {\n            latLng: ((_srcEvent$latLng = srcEvent.latLng) == null ? void 0 : _srcEvent$latLng.toJSON()) || null,\n            placeId: srcEvent.placeId\n        };\n        return mouseEvent;\n    }\n    return ev;\n}\n/**\n * maps the camelCased names of event-props to the corresponding event-types\n * used in the maps API.\n */ const propNameToEventType = {\n    onBoundsChanged: \"bounds_changed\",\n    onCenterChanged: \"center_changed\",\n    onClick: \"click\",\n    onContextmenu: \"contextmenu\",\n    onDblclick: \"dblclick\",\n    onDrag: \"drag\",\n    onDragend: \"dragend\",\n    onDragstart: \"dragstart\",\n    onHeadingChanged: \"heading_changed\",\n    onIdle: \"idle\",\n    onIsFractionalZoomEnabledChanged: \"isfractionalzoomenabled_changed\",\n    onMapCapabilitiesChanged: \"mapcapabilities_changed\",\n    onMapTypeIdChanged: \"maptypeid_changed\",\n    onMousemove: \"mousemove\",\n    onMouseout: \"mouseout\",\n    onMouseover: \"mouseover\",\n    onProjectionChanged: \"projection_changed\",\n    onRenderingTypeChanged: \"renderingtype_changed\",\n    onTilesLoaded: \"tilesloaded\",\n    onTiltChanged: \"tilt_changed\",\n    onZoomChanged: \"zoom_changed\",\n    // note: onCameraChanged is an alias for the bounds_changed event,\n    // since that is going to be fired in every situation where the camera is\n    // updated.\n    onCameraChanged: \"bounds_changed\"\n};\nconst cameraEventTypes = [\n    \"bounds_changed\",\n    \"center_changed\",\n    \"heading_changed\",\n    \"projection_changed\",\n    \"tilt_changed\",\n    \"zoom_changed\"\n];\nconst mouseEventTypes = [\n    \"click\",\n    \"contextmenu\",\n    \"dblclick\",\n    \"mousemove\",\n    \"mouseout\",\n    \"mouseover\"\n];\nconst eventPropNames = Object.keys(propNameToEventType);\nfunction useDeepCompareEffect(effect, deps) {\n    _s3();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    if (!ref.current || !fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__(deps, ref.current)) {\n        ref.current = deps;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(effect, ref.current);\n}\n_s3(useDeepCompareEffect, \"8uVE59eA/r6b92xF80p7sH8rXLk=\");\nconst mapOptionKeys = new Set([\n    \"backgroundColor\",\n    \"clickableIcons\",\n    \"controlSize\",\n    \"disableDefaultUI\",\n    \"disableDoubleClickZoom\",\n    \"draggable\",\n    \"draggableCursor\",\n    \"draggingCursor\",\n    \"fullscreenControl\",\n    \"fullscreenControlOptions\",\n    \"gestureHandling\",\n    \"isFractionalZoomEnabled\",\n    \"keyboardShortcuts\",\n    \"mapTypeControl\",\n    \"mapTypeControlOptions\",\n    \"mapTypeId\",\n    \"maxZoom\",\n    \"minZoom\",\n    \"noClear\",\n    \"panControl\",\n    \"panControlOptions\",\n    \"restriction\",\n    \"rotateControl\",\n    \"rotateControlOptions\",\n    \"scaleControl\",\n    \"scaleControlOptions\",\n    \"scrollwheel\",\n    \"streetView\",\n    \"streetViewControl\",\n    \"streetViewControlOptions\",\n    \"styles\",\n    \"zoomControl\",\n    \"zoomControlOptions\"\n]);\n/**\n * Internal hook to update the map-options when props are changed.\n *\n * @param map the map instance\n * @param mapProps the props to update the map-instance with\n * @internal\n */ function useMapOptions(map, mapProps) {\n    _s4();\n    /* eslint-disable react-hooks/exhaustive-deps --\n   *\n   * The following effects aren't triggered when the map is changed.\n   * In that case, the values will be or have been passed to the map\n   * constructor via mapOptions.\n   */ const mapOptions = {};\n    const keys = Object.keys(mapProps);\n    for (const key of keys){\n        if (!mapOptionKeys.has(key)) continue;\n        mapOptions[key] = mapProps[key];\n    }\n    // update the map options when mapOptions is changed\n    // Note: due to the destructuring above, mapOptions will be seen as changed\n    //   with every re-render, so we're assuming the maps-api will properly\n    //   deal with unchanged option-values passed into setOptions.\n    useDeepCompareEffect(()=>{\n        if (!map) return;\n        map.setOptions(mapOptions);\n    }, [\n        mapOptions\n    ]);\n/* eslint-enable react-hooks/exhaustive-deps */ }\n_s4(useMapOptions, \"9P7jum8Mqo4RIt9ebKErbOvo2AQ=\", false, function() {\n    return [\n        useDeepCompareEffect\n    ];\n});\nfunction useForceUpdate() {\n    _s5();\n    const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((x)=>x + 1, 0);\n    return forceUpdate;\n}\n_s5(useForceUpdate, \"OYvExaf+rzzVf06crq8byWAi7Rk=\");\nfunction handleBoundsChange(map, ref) {\n    const center = map.getCenter();\n    const zoom = map.getZoom();\n    const heading = map.getHeading() || 0;\n    const tilt = map.getTilt() || 0;\n    const bounds = map.getBounds();\n    if (!center || !bounds || !Number.isFinite(zoom)) {\n        console.warn(\"[useTrackedCameraState] at least one of the values from the map \" + \"returned undefined. This is not expected to happen. Please \" + \"report an issue at https://github.com/visgl/react-google-maps/issues/new\");\n    }\n    // fixme: do we need the `undefined` cases for the camera-params? When are they used in the maps API?\n    Object.assign(ref.current, {\n        center: (center == null ? void 0 : center.toJSON()) || {\n            lat: 0,\n            lng: 0\n        },\n        zoom: zoom || 0,\n        heading: heading,\n        tilt: tilt\n    });\n}\n/**\n * Creates a mutable ref object to track the last known state of the map camera.\n * This is used in `useMapCameraParams` to reduce stuttering in normal operation\n * by avoiding updates of the map camera with values that have already been processed.\n */ function useTrackedCameraStateRef(map) {\n    _s6();\n    const forceUpdate = useForceUpdate();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        center: {\n            lat: 0,\n            lng: 0\n        },\n        heading: 0,\n        tilt: 0,\n        zoom: 0\n    });\n    // Record camera state with every bounds_changed event dispatched by the map.\n    // This data is used to prevent feeding these values back to the\n    // map-instance when a typical \"controlled component\" setup (state variable is\n    // fed into and updated by the map).\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        const listener = google.maps.event.addListener(map, \"bounds_changed\", ()=>{\n            handleBoundsChange(map, ref);\n            // When an event is occured, we have to update during the next cycle.\n            // The application could decide to ignore the event and not update any\n            // camera props of the map, meaning that in that case we will have to\n            // 'undo' the change to the camera.\n            forceUpdate();\n        });\n        return ()=>listener.remove();\n    }, [\n        map,\n        forceUpdate\n    ]);\n    return ref;\n}\n_s6(useTrackedCameraStateRef, \"ZmjndRMGldGtdD0sNNTfC29J5s8=\", false, function() {\n    return [\n        useForceUpdate\n    ];\n});\nfunction useApiLoadingStatus() {\n    _s7();\n    var _useContext;\n    return ((_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext)) == null ? void 0 : _useContext.status) || APILoadingStatus.NOT_LOADED;\n}\n_s7(useApiLoadingStatus, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n/**\n * Internal hook that updates the camera when deck.gl viewState changes.\n * @internal\n */ function useDeckGLCameraUpdate(map, props) {\n    _s8();\n    const { viewport, viewState } = props;\n    const isDeckGlControlled = !!viewport;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map || !viewState) return;\n        const { latitude, longitude, bearing: heading, pitch: tilt, zoom } = viewState;\n        map.moveCamera({\n            center: {\n                lat: latitude,\n                lng: longitude\n            },\n            heading,\n            tilt,\n            zoom: zoom + 1\n        });\n    }, [\n        map,\n        viewState\n    ]);\n    return isDeckGlControlled;\n}\n_s8(useDeckGLCameraUpdate, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\nfunction isLatLngLiteral(obj) {\n    if (!obj || typeof obj !== \"object\") return false;\n    if (!(\"lat\" in obj && \"lng\" in obj)) return false;\n    return Number.isFinite(obj.lat) && Number.isFinite(obj.lng);\n}\nfunction latLngEquals(a, b) {\n    if (!a || !b) return false;\n    const A = toLatLngLiteral(a);\n    const B = toLatLngLiteral(b);\n    if (A.lat !== B.lat || A.lng !== B.lng) return false;\n    return true;\n}\nfunction toLatLngLiteral(obj) {\n    if (isLatLngLiteral(obj)) return obj;\n    return obj.toJSON();\n}\nfunction useMapCameraParams(map, cameraStateRef, mapProps) {\n    _s9();\n    const center = mapProps.center ? toLatLngLiteral(mapProps.center) : null;\n    let lat = null;\n    let lng = null;\n    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n        lat = center.lat;\n        lng = center.lng;\n    }\n    const zoom = Number.isFinite(mapProps.zoom) ? mapProps.zoom : null;\n    const heading = Number.isFinite(mapProps.heading) ? mapProps.heading : null;\n    const tilt = Number.isFinite(mapProps.tilt) ? mapProps.tilt : null;\n    // the following effect runs for every render of the map component and checks\n    // if there are differences between the known state of the map instance\n    // (cameraStateRef, which is updated by all bounds_changed events) and the\n    // desired state in the props.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map) return;\n        const nextCamera = {};\n        let needsUpdate = false;\n        if (lat !== null && lng !== null && (cameraStateRef.current.center.lat !== lat || cameraStateRef.current.center.lng !== lng)) {\n            nextCamera.center = {\n                lat,\n                lng\n            };\n            needsUpdate = true;\n        }\n        if (zoom !== null && cameraStateRef.current.zoom !== zoom) {\n            nextCamera.zoom = zoom;\n            needsUpdate = true;\n        }\n        if (heading !== null && cameraStateRef.current.heading !== heading) {\n            nextCamera.heading = heading;\n            needsUpdate = true;\n        }\n        if (tilt !== null && cameraStateRef.current.tilt !== tilt) {\n            nextCamera.tilt = tilt;\n            needsUpdate = true;\n        }\n        if (needsUpdate) {\n            map.moveCamera(nextCamera);\n        }\n    });\n}\n_s9(useMapCameraParams, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\nconst AuthFailureMessage = ()=>{\n    const style = {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        zIndex: 999,\n        display: \"flex\",\n        flexFlow: \"column nowrap\",\n        textAlign: \"center\",\n        justifyContent: \"center\",\n        fontSize: \".8rem\",\n        color: \"rgba(0,0,0,0.6)\",\n        background: \"#dddddd\",\n        padding: \"1rem 1.5rem\"\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        style: style\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Error: AuthFailure\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"A problem with your API key prevents the map from rendering correctly. Please make sure the value of the \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", null, \"APIProvider.apiKey\"), \" prop is correct. Check the error-message in the console for further details.\"));\n};\n_c1 = AuthFailureMessage;\nfunction useCallbackRef() {\n    _s10();\n    const [el, setEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>setEl(value), [\n        setEl\n    ]);\n    return [\n        el,\n        ref\n    ];\n}\n_s10(useCallbackRef, \"VloTnEpYwfVP5sjWXc1w8xQWZ+Q=\");\n/**\n * Hook to check if the Google Maps API is loaded\n */ function useApiIsLoaded() {\n    _s11();\n    const status = useApiLoadingStatus();\n    return status === APILoadingStatus.LOADED;\n}\n_s11(useApiIsLoaded, \"SdrWm+4Nu53O23DKCYwlLCyijMQ=\", false, function() {\n    return [\n        useApiLoadingStatus\n    ];\n});\nconst _excluded$2 = [\n    \"id\",\n    \"defaultBounds\",\n    \"defaultCenter\",\n    \"defaultZoom\",\n    \"defaultHeading\",\n    \"defaultTilt\"\n];\n/**\n * The main hook takes care of creating map-instances and registering them in\n * the api-provider context.\n * @return a tuple of the map-instance created (or null) and the callback\n *   ref that will be used to pass the map-container into this hook.\n * @internal\n */ function useMapInstance(props, context) {\n    _s12();\n    const apiIsLoaded = useApiIsLoaded();\n    const [map, setMap] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [container, containerRef] = useCallbackRef();\n    const { id, defaultBounds, defaultCenter, defaultZoom, defaultHeading, defaultTilt } = props, mapOptions = _objectWithoutPropertiesLoose(props, _excluded$2);\n    // apply default camera props if available and not overwritten by controlled props\n    if (!mapOptions.center && defaultCenter) mapOptions.center = defaultCenter;\n    if (!mapOptions.zoom && Number.isFinite(defaultZoom)) mapOptions.zoom = defaultZoom;\n    if (!mapOptions.heading && Number.isFinite(defaultHeading)) mapOptions.heading = defaultHeading;\n    if (!mapOptions.tilt && Number.isFinite(defaultTilt)) mapOptions.tilt = defaultTilt;\n    // create the map instance and register it in the context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!container || !apiIsLoaded) return;\n        const { addMapInstance, removeMapInstance } = context;\n        const newMap = new google.maps.Map(container, mapOptions);\n        setMap(newMap);\n        addMapInstance(newMap, id);\n        if (defaultBounds) {\n            newMap.fitBounds(defaultBounds);\n        }\n        // FIXME: When the mapId is changed,  we need to maintain the current camera params.\n        return ()=>{\n            if (!container || !apiIsLoaded) return;\n            // remove all event-listeners to minimize memory-leaks\n            google.maps.event.clearInstanceListeners(newMap);\n            setMap(null);\n            removeMapInstance(id);\n        };\n    }, // some dependencies are ignored in the list below:\n    //  - defaultBounds and the default* camera props will only be used once, and\n    //    changes should be ignored\n    //  - mapOptions has special hooks that take care of updating the options\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        container,\n        apiIsLoaded,\n        id,\n        props.mapId\n    ]);\n    return [\n        map,\n        containerRef\n    ];\n}\n_s12(useMapInstance, \"yj9kZ+vWzlw2L5hG73Qzo1/Ycr0=\", false, function() {\n    return [\n        useApiIsLoaded,\n        useCallbackRef\n    ];\n});\nconst GoogleMapsContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst Map = (props)=>{\n    _s13();\n    const { children, id, className, style } = props;\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    const loadingStatus = useApiLoadingStatus();\n    if (!context) {\n        throw new Error(\"<Map> can only be used inside an <ApiProvider> component.\");\n    }\n    const [map, mapRef] = useMapInstance(props, context);\n    const cameraStateRef = useTrackedCameraStateRef(map);\n    useMapCameraParams(map, cameraStateRef, props);\n    useMapEvents(map, props);\n    useMapOptions(map, props);\n    const isDeckGlControlled = useDeckGLCameraUpdate(map, props);\n    const isControlledExternally = !!props.controlled;\n    // disable interactions with the map for externally controlled maps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        // fixme: this doesn't seem to belong here (and it's mostly there for convenience anyway).\n        //   The reasoning is that a deck.gl canvas will be put on top of the map, rendering\n        //   any default map controls pretty much useless\n        if (isDeckGlControlled) {\n            map.setOptions({\n                disableDefaultUI: true\n            });\n        }\n        // disable all control-inputs when the map is controlled externally\n        if (isDeckGlControlled || isControlledExternally) {\n            map.setOptions({\n                gestureHandling: \"none\",\n                keyboardShortcuts: false\n            });\n        }\n        return ()=>{\n            map.setOptions({\n                gestureHandling: props.gestureHandling,\n                keyboardShortcuts: props.keyboardShortcuts\n            });\n        };\n    }, [\n        map,\n        isDeckGlControlled,\n        isControlledExternally,\n        props.gestureHandling,\n        props.keyboardShortcuts\n    ]);\n    // setup a stable cameraOptions object that can be used as dependency\n    const center = props.center ? toLatLngLiteral(props.center) : null;\n    let lat = null;\n    let lng = null;\n    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n        lat = center.lat;\n        lng = center.lng;\n    }\n    const cameraOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var _lat, _lng, _props$zoom, _props$heading, _props$tilt;\n        return {\n            center: {\n                lat: (_lat = lat) != null ? _lat : 0,\n                lng: (_lng = lng) != null ? _lng : 0\n            },\n            zoom: (_props$zoom = props.zoom) != null ? _props$zoom : 0,\n            heading: (_props$heading = props.heading) != null ? _props$heading : 0,\n            tilt: (_props$tilt = props.tilt) != null ? _props$tilt : 0\n        };\n    }, [\n        lat,\n        lng,\n        props.zoom,\n        props.heading,\n        props.tilt\n    ]);\n    // externally controlled mode: reject all camera changes that don't correspond to changes in props\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map || !isControlledExternally) return;\n        map.moveCamera(cameraOptions);\n        const listener = map.addListener(\"bounds_changed\", ()=>{\n            map.moveCamera(cameraOptions);\n        });\n        return ()=>listener.remove();\n    }, [\n        map,\n        isControlledExternally,\n        cameraOptions\n    ]);\n    const combinedStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>_extends({\n            width: \"100%\",\n            height: \"100%\",\n            // when using deckgl, the map should be sent to the back\n            zIndex: isDeckGlControlled ? -1 : 0\n        }, style), [\n        style,\n        isDeckGlControlled\n    ]);\n    if (loadingStatus === APILoadingStatus.AUTH_FAILURE) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            style: _extends({\n                position: \"relative\"\n            }, className ? {} : combinedStyle),\n            className: className\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AuthFailureMessage, null));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n        ref: mapRef,\n        \"data-testid\": \"map\",\n        style: className ? undefined : combinedStyle,\n        className: className\n    }, id ? {\n        id\n    } : {}), map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleMapsContext.Provider, {\n        value: {\n            map\n        }\n    }, children) : null);\n};\n_s13(Map, \"ZrK+g6VmCZU9bacdT0VUYJspqbk=\", false, function() {\n    return [\n        useApiLoadingStatus,\n        useMapInstance,\n        useTrackedCameraStateRef,\n        useMapCameraParams,\n        useMapEvents,\n        useMapOptions,\n        useDeckGLCameraUpdate\n    ];\n});\n_c2 = Map;\nMap.deckGLViewProps = true;\nfunction useMapsLibrary(name) {\n    _s14();\n    const apiIsLoaded = useApiIsLoaded();\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!apiIsLoaded || !ctx) return;\n        // Trigger loading the libraries via our proxy-method.\n        // The returned promise is ignored, since importLibrary will update loadedLibraries\n        // list in the context, triggering a re-render.\n        void ctx.importLibrary(name);\n    }, [\n        apiIsLoaded,\n        ctx,\n        name\n    ]);\n    return (ctx == null ? void 0 : ctx.loadedLibraries[name]) || null;\n}\n_s14(useMapsLibrary, \"E3X53atPXTwKH7JamUeR87Uqn9c=\", false, function() {\n    return [\n        useApiIsLoaded\n    ];\n});\n/* eslint-disable complexity */ const AdvancedMarkerContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useAdvancedMarker(props) {\n    _s15();\n    var _useContext;\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [contentContainer, setContentContainer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const map = (_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n    const markerLibrary = useMapsLibrary(\"marker\");\n    const { children, className, onClick, onDrag, onDragStart, onDragEnd, collisionBehavior, draggable, position, title, zIndex } = props;\n    const numChilds = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children);\n    // create marker instance and add it to the map when map becomes available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map || !markerLibrary) return;\n        const newMarker = new markerLibrary.AdvancedMarkerElement();\n        newMarker.map = map;\n        setMarker(newMarker);\n        // create container for marker content if there are children\n        if (numChilds > 0) {\n            const el = document.createElement(\"div\");\n            if (className) el.className = className;\n            newMarker.content = el;\n            setContentContainer(el);\n        }\n        return ()=>{\n            newMarker.map = null;\n            setMarker(null);\n            setContentContainer(null);\n        };\n    // We do not want to re-render the whole marker when the className changes\n    // because that causes a short flickering of the marker.\n    // The className update is handled in the useEffect below.\n    // Excluding the className from the dependency array onm purpose here\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        map,\n        markerLibrary,\n        numChilds\n    ]);\n    // update className of advanced marker element\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!contentContainer) return;\n        contentContainer.className = className != null ? className : \"\";\n    }, [\n        contentContainer,\n        className\n    ]);\n    // bind all marker events\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        const gme = google.maps.event;\n        if (onClick) gme.addListener(marker, \"click\", onClick);\n        if (onDrag) gme.addListener(marker, \"drag\", onDrag);\n        if (onDragStart) gme.addListener(marker, \"dragstart\", onDragStart);\n        if (onDragEnd) gme.addListener(marker, \"dragend\", onDragEnd);\n        if ((onDrag || onDragStart || onDragEnd) && !draggable) {\n            console.warn(\"You need to set the marker to draggable to listen to drag-events.\");\n        }\n        const m = marker;\n        return ()=>{\n            gme.clearInstanceListeners(m);\n        };\n    }, [\n        marker,\n        draggable,\n        onClick,\n        onDragStart,\n        onDrag,\n        onDragEnd\n    ]);\n    // update other marker props when changed\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        if (position !== undefined) marker.position = position;\n        if (draggable !== undefined) marker.gmpDraggable = draggable;\n        if (collisionBehavior !== undefined) marker.collisionBehavior = collisionBehavior;\n        if (zIndex !== undefined) marker.zIndex = zIndex;\n        if (typeof title === \"string\") marker.title = title;\n    }, [\n        marker,\n        position,\n        draggable,\n        collisionBehavior,\n        zIndex,\n        title\n    ]);\n    return [\n        marker,\n        contentContainer\n    ];\n}\n_s15(useAdvancedMarker, \"6C7+R3ZhiqIRurq1X/GY9NwsLEc=\", false, function() {\n    return [\n        useMapsLibrary\n    ];\n});\nconst AdvancedMarker = /*#__PURE__*/ _s16((0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c3 = _s16((props, ref)=>{\n    _s16();\n    const { children } = props;\n    const [marker, contentContainer] = useAdvancedMarker(props);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>marker, [\n        marker\n    ]);\n    if (!marker) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AdvancedMarkerContext.Provider, {\n        value: {\n            marker\n        }\n    }, contentContainer !== null && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, contentContainer));\n}, \"R8BJBe3cv/IK378lR54wKf/yxFc=\", false, function() {\n    return [\n        useAdvancedMarker\n    ];\n})), \"R8BJBe3cv/IK378lR54wKf/yxFc=\", false, function() {\n    return [\n        useAdvancedMarker\n    ];\n});\n_c4 = AdvancedMarker;\nfunction useAdvancedMarkerRef() {\n    _s17();\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m)=>{\n        setMarker(m);\n    }, []);\n    return [\n        refCallback,\n        marker\n    ];\n}\n_s17(useAdvancedMarkerRef, \"FBQ4v4HcC4JdZrPyl/BGQ2M+tPY=\");\nconst _excluded$1 = [\n    \"children\",\n    \"anchor\",\n    \"onCloseClick\"\n];\n/**\n * Component to render a Google Maps Info Window\n */ const InfoWindow = (props)=>{\n    _s18();\n    var _useContext;\n    const { children, anchor, onCloseClick } = props, infoWindowOptions = _objectWithoutPropertiesLoose(props, _excluded$1);\n    const map = (_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n    const infoWindowRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [contentContainer, setContentContainer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // create infowindow once map is available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        const newInfowindow = new google.maps.InfoWindow(infoWindowOptions);\n        // Add content to info window\n        const el = document.createElement(\"div\");\n        newInfowindow.setContent(el);\n        infoWindowRef.current = newInfowindow;\n        setContentContainer(el);\n        // Cleanup info window and event listeners on unmount\n        return ()=>{\n            google.maps.event.clearInstanceListeners(newInfowindow);\n            newInfowindow.close();\n            el.remove();\n            setContentContainer(null);\n        };\n    // We don't want to re-render a whole new infowindow\n    // when the options change to prevent flickering.\n    // Update of infoWindow options is handled in the useEffect below.\n    // Excluding infoWindowOptions from dependency array on purpose here.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        map,\n        children\n    ]);\n    // Update infoWindowOptions\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _infoWindowRef$curren;\n        (_infoWindowRef$curren = infoWindowRef.current) == null || _infoWindowRef$curren.setOptions(infoWindowOptions);\n    }, [\n        infoWindowOptions\n    ]);\n    // Handle the close click callback\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!infoWindowRef.current) return;\n        let listener = null;\n        if (onCloseClick) {\n            listener = google.maps.event.addListener(infoWindowRef.current, \"closeclick\", onCloseClick);\n        }\n        return ()=>{\n            if (listener) listener.remove();\n        };\n    }, [\n        onCloseClick\n    ]);\n    // Open info window after content container is set\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // anchor === null means an anchor is defined but not ready yet.\n        if (!contentContainer || !infoWindowRef.current || anchor === null) return;\n        const openOptions = {\n            map\n        };\n        if (anchor) {\n            openOptions.anchor = anchor;\n        }\n        infoWindowRef.current.open(openOptions);\n    }, [\n        contentContainer,\n        infoWindowRef,\n        anchor,\n        map\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, contentContainer !== null && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, contentContainer));\n};\n_s18(InfoWindow, \"Itbn5xIDJk95nuGa0zkYYXGlWs0=\");\n_c5 = InfoWindow;\nconst shownMessages = new Set();\nfunction logErrorOnce() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    const key = JSON.stringify(args);\n    if (!shownMessages.has(key)) {\n        shownMessages.add(key);\n        console.error(...args);\n    }\n}\n/**\n * Retrieves a map-instance from the context. This is either an instance\n * identified by id or the parent map instance if no id is specified.\n * Returns null if neither can be found.\n */ const useMap = function() {\n    let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    _s19();\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    const { map } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext) || {};\n    if (ctx === null) {\n        logErrorOnce(\"useMap(): failed to retrieve APIProviderContext. \" + \"Make sure that the <APIProvider> component exists and that the \" + \"component you are calling `useMap()` from is a sibling of the \" + \"<APIProvider>.\");\n        return null;\n    }\n    const { mapInstances } = ctx;\n    // if an id is specified, the corresponding map or null is returned\n    if (id !== null) return mapInstances[id] || null;\n    // otherwise, return the closest ancestor\n    if (map) return map;\n    // finally, return the default map instance\n    return mapInstances[\"default\"] || null;\n};\n_s19(useMap, \"02oyNIqv7n0uhMRysGwaojH8Xj0=\");\n/**\n * Copy of the `google.maps.ControlPosition` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */ const ControlPosition = {\n    TOP_LEFT: 1,\n    TOP_CENTER: 2,\n    TOP: 2,\n    TOP_RIGHT: 3,\n    LEFT_CENTER: 4,\n    LEFT_TOP: 5,\n    LEFT: 5,\n    LEFT_BOTTOM: 6,\n    RIGHT_TOP: 7,\n    RIGHT: 7,\n    RIGHT_CENTER: 8,\n    RIGHT_BOTTOM: 9,\n    BOTTOM_LEFT: 10,\n    BOTTOM_CENTER: 11,\n    BOTTOM: 11,\n    BOTTOM_RIGHT: 12,\n    CENTER: 13,\n    BLOCK_START_INLINE_START: 14,\n    BLOCK_START_INLINE_CENTER: 15,\n    BLOCK_START_INLINE_END: 16,\n    INLINE_START_BLOCK_CENTER: 17,\n    INLINE_START_BLOCK_START: 18,\n    INLINE_START_BLOCK_END: 19,\n    INLINE_END_BLOCK_START: 20,\n    INLINE_END_BLOCK_CENTER: 21,\n    INLINE_END_BLOCK_END: 22,\n    BLOCK_END_INLINE_START: 23,\n    BLOCK_END_INLINE_CENTER: 24,\n    BLOCK_END_INLINE_END: 25\n};\nconst MapControl = (param)=>{\n    let { children, position } = param;\n    _s20();\n    const controlContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>document.createElement(\"div\"), []);\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        const controls = map.controls[position];\n        controls.push(controlContainer);\n        return ()=>{\n            const index = controls.getArray().indexOf(controlContainer);\n            controls.removeAt(index);\n        };\n    }, [\n        controlContainer,\n        map,\n        position\n    ]);\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, controlContainer);\n};\n_s20(MapControl, \"GWhrPCjHyQkJZ2cqIea0Zsdo0OI=\", false, function() {\n    return [\n        useMap\n    ];\n});\n_c6 = MapControl;\nconst _excluded = [\n    \"onClick\",\n    \"onDrag\",\n    \"onDragStart\",\n    \"onDragEnd\",\n    \"onMouseOver\",\n    \"onMouseOut\"\n];\nfunction useMarker(props) {\n    _s21();\n    var _useContext;\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const map = (_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n    const { onClick, onDrag, onDragStart, onDragEnd, onMouseOver, onMouseOut } = props, markerOptions = _objectWithoutPropertiesLoose(props, _excluded);\n    const { position, draggable } = markerOptions;\n    // create marker instance and add to the map once the map is available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) {\n            if (map === undefined) console.error(\"<Marker> has to be inside a Map component.\");\n            return;\n        }\n        const newMarker = new google.maps.Marker(markerOptions);\n        newMarker.setMap(map);\n        setMarker(newMarker);\n        return ()=>{\n            newMarker.setMap(null);\n            setMarker(null);\n        };\n    // We do not want to re-render the whole marker when the options change.\n    // Marker options update is handled in a useEffect below.\n    // Excluding markerOptions from dependency array on purpose here.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        map\n    ]);\n    // attach and re-attach event-handlers when any of the properties change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        const m = marker;\n        // Add event listeners\n        const gme = google.maps.event;\n        if (onClick) gme.addListener(m, \"click\", onClick);\n        if (onDrag) gme.addListener(m, \"drag\", onDrag);\n        if (onDragStart) gme.addListener(m, \"dragstart\", onDragStart);\n        if (onDragEnd) gme.addListener(m, \"dragend\", onDragEnd);\n        if (onMouseOver) gme.addListener(m, \"mouseover\", onMouseOver);\n        if (onMouseOut) gme.addListener(m, \"mouseout\", onMouseOut);\n        marker.setDraggable(Boolean(draggable));\n        return ()=>{\n            gme.clearInstanceListeners(m);\n        };\n    }, [\n        marker,\n        draggable,\n        onClick,\n        onDrag,\n        onDragStart,\n        onDragEnd,\n        onMouseOver,\n        onMouseOut\n    ]);\n    // update markerOptions (note the dependencies aren't properly checked\n    // here, we just assume that setOptions is smart enough to not waste a\n    // lot of time updating values that didn't change)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        if (markerOptions) marker.setOptions(markerOptions);\n    }, [\n        marker,\n        markerOptions\n    ]);\n    // update position when changed\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Should not update position when draggable\n        if (draggable || !position || !marker) return;\n        marker.setPosition(position);\n    }, [\n        draggable,\n        position,\n        marker\n    ]);\n    return marker;\n}\n_s21(useMarker, \"EYRPhFgbuX4PXl9TTxdummpV/TA=\");\n/**\n * Component to render a Google Maps Marker on a map\n */ const Marker = /*#__PURE__*/ _s22((0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c7 = _s22((props, ref)=>{\n    _s22();\n    const marker = useMarker(props);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>marker, [\n        marker\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n}, \"X8uSd1rl6ws6EwUC+zm+JeM+A3k=\", false, function() {\n    return [\n        useMarker\n    ];\n})), \"X8uSd1rl6ws6EwUC+zm+JeM+A3k=\", false, function() {\n    return [\n        useMarker\n    ];\n});\n_c8 = Marker;\nfunction useMarkerRef() {\n    _s23();\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m)=>{\n        setMarker(m);\n    }, []);\n    return [\n        refCallback,\n        marker\n    ];\n}\n_s23(useMarkerRef, \"FBQ4v4HcC4JdZrPyl/BGQ2M+tPY=\");\n/**\n * Component to render a google maps marker Pin View\n */ const Pin = (props)=>{\n    _s24();\n    var _useContext;\n    const advancedMarker = (_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AdvancedMarkerContext)) == null ? void 0 : _useContext.marker;\n    const glyphContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>document.createElement(\"div\"), []);\n    // Create Pin View instance\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!advancedMarker) {\n            if (advancedMarker === undefined) {\n                console.error(\"The <Pin> component can only be used inside <AdvancedMarker>.\");\n            }\n            return;\n        }\n        if (props.glyph && props.children) {\n            logErrorOnce(\"The <Pin> component only uses children to render the glyph if both the glyph property and children are present.\");\n        }\n        if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(props.children) > 1) {\n            logErrorOnce(\"Passing multiple children to the <Pin> component might lead to unexpected results.\");\n        }\n        const pinViewOptions = _extends({}, props);\n        const pinElement = new google.maps.marker.PinElement(pinViewOptions);\n        // Set glyph to glyph container if children are present (rendered via portal).\n        // If both props.glyph and props.children are present, props.children takes priority.\n        if (props.children) {\n            pinElement.glyph = glyphContainer;\n        }\n        // Set content of Advanced Marker View to the Pin View element\n        advancedMarker.content = pinElement.element;\n    }, [\n        advancedMarker,\n        glyphContainer,\n        props\n    ]);\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(props.children, glyphContainer);\n};\n_s24(Pin, \"USBKEQcWQZODuZ3cwquju/JeJfU=\");\n_c9 = Pin;\n/**\n * A typescript assertion function used in cases where typescript has to be\n * convinced that the object in question can not be null.\n *\n * @param value\n * @param message\n */ function assertNotNull(value) {\n    let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"assertion failed\";\n    if (value === null || value === undefined) {\n        throw Error(message);\n    }\n}\nconst useDirectionsRenderer = (mapId, renderOnMap, renderOptions)=>{\n    _s25();\n    const map = useMap(mapId);\n    // create the renderer instance\n    const directionsRenderer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!map || !renderOnMap) return null;\n        const renderer = new google.maps.DirectionsRenderer(renderOptions);\n        renderer.setMap(map);\n        return renderer;\n    }, // note: no dependency on renderOptions since those are handled in the\n    // next effect.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        map,\n        renderOnMap\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!directionsRenderer) return;\n        directionsRenderer.setOptions(renderOptions || {});\n    }, // note: directionsRenderer dependency isn't needed since the\n    // renderOptions will be set on initialization when creating the renderer.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        renderOptions\n    ]);\n    return directionsRenderer;\n};\n_s25(useDirectionsRenderer, \"3wy+fUkykJDr4Y8iWR/dYrQGq1Q=\", false, function() {\n    return [\n        useMap\n    ];\n});\n/**\n * Hook to get Google Maps Places Directions Service instance\n */ const useDirectionsService = function() {\n    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    _s26();\n    const { mapId = null, renderOnMap, renderOptions } = props;\n    const isApiLoaded = useApiIsLoaded();\n    // Creates a Directions Service instance\n    const directionsService = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        // Wait for Google Maps API to be loaded\n        if (!isApiLoaded) return null;\n        return new google.maps.DirectionsService();\n    }, [\n        isApiLoaded\n    ]);\n    // create the renderer instance\n    const directionsRenderer = useDirectionsRenderer(mapId, renderOnMap, renderOptions);\n    // Custom Directions route request followed by directions rendering\n    const renderRoute = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (request)=>{\n        // findAndRenderRoute() isn't callable when either directions\n        // service or renderer aren't ready\n        assertNotNull(directionsService);\n        assertNotNull(directionsRenderer);\n        const result = await directionsService.route(request);\n        directionsRenderer.setDirections(result);\n        return result;\n    }, [\n        directionsService,\n        directionsRenderer\n    ]);\n    // Renders directions route of given index\n    const setRenderedRouteIndex = (index)=>{\n        assertNotNull(directionsRenderer);\n        directionsRenderer.setRouteIndex(index);\n    };\n    return {\n        directionsService,\n        directionsRenderer,\n        renderRoute: directionsService && directionsRenderer ? renderRoute : null,\n        setRenderedRouteIndex: directionsService && directionsRenderer ? setRenderedRouteIndex : null\n    };\n};\n_s26(useDirectionsService, \"YJIw7HvloTjyYW2ZfRczPSqrqwo=\", false, function() {\n    return [\n        useApiIsLoaded,\n        useDirectionsRenderer\n    ];\n});\n/* eslint-disable complexity */ /**\n * Hook to get Street View Panorama\n */ const useStreetViewPanorama = function() {\n    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    _s27();\n    const { mapId, divElement, position, pov, zoom } = props;\n    const googleMapsAPIIsLoaded = useApiIsLoaded();\n    const map = useMap(mapId);\n    const [streetViewPanorama, setStreetViewPanorama] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Creates a Street View instance\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!googleMapsAPIIsLoaded) return;\n        let pano = null;\n        if (divElement) {\n            pano = new google.maps.StreetViewPanorama(divElement);\n        } else if (map) {\n            pano = map.getStreetView();\n        }\n        setStreetViewPanorama(pano);\n        if (!pano) return;\n        if (pov) pano.setPov(pov);\n        if (position) pano.setPosition(position);\n        if (zoom || zoom === 0) pano.setZoom(zoom);\n        return ()=>{\n            setStreetViewPanorama(null);\n            if (map) map.setStreetView(null);\n        };\n    }, // fixme: implement extra hook to update FOV when props change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        googleMapsAPIIsLoaded,\n        map,\n        divElement\n    ]);\n    return streetViewPanorama;\n};\n_s27(useStreetViewPanorama, \"0IJItcYnpOv9/QM79l5KEmmOans=\", false, function() {\n    return [\n        useApiIsLoaded,\n        useMap\n    ];\n});\nconst mapLinear = (x, a1, a2, b1, b2)=>b1 + (x - a1) * (b2 - b1) / (a2 - a1);\nconst getMapMaxTilt = (zoom)=>{\n    if (zoom <= 10) {\n        return 30;\n    }\n    if (zoom >= 15.5) {\n        return 67.5;\n    }\n    // range [10...14]\n    if (zoom <= 14) {\n        return mapLinear(zoom, 10, 14, 30, 45);\n    }\n    // range [14...15.5]\n    return mapLinear(zoom, 14, 15.5, 45, 67.5);\n};\n/**\n * Function to limit the tilt range of the google maps map when updating the view state\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst limitTiltRange = (param)=>{\n    let { viewState } = param;\n    const pitch = viewState.pitch;\n    const gmZoom = viewState.zoom + 1;\n    const maxTilt = getMapMaxTilt(gmZoom);\n    return _extends({}, viewState, {\n        fovy: 25,\n        pitch: Math.min(maxTilt, pitch)\n    });\n};\n //# sourceMappingURL=index.modern.mjs.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9;\n$RefreshReg$(_c, \"APIProvider\");\n$RefreshReg$(_c1, \"AuthFailureMessage\");\n$RefreshReg$(_c2, \"Map\");\n$RefreshReg$(_c3, \"AdvancedMarker$forwardRef\");\n$RefreshReg$(_c4, \"AdvancedMarker\");\n$RefreshReg$(_c5, \"InfoWindow\");\n$RefreshReg$(_c6, \"MapControl\");\n$RefreshReg$(_c7, \"Marker$forwardRef\");\n$RefreshReg$(_c8, \"Marker\");\n$RefreshReg$(_c9, \"Pin\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdmlzLmdsL3JlYWN0LWdvb2dsZS1tYXBzL2Rpc3QvaW5kZXgubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUs7QUFDNUg7QUFDQztBQUUxQyxTQUFTYyxhQUFhQyxDQUFDLEVBQUVDLENBQUM7SUFDeEIsSUFBSSxZQUFZLE9BQU9ELEtBQUssQ0FBQ0EsR0FBRyxPQUFPQTtJQUN2QyxJQUFJRSxJQUFJRixDQUFDLENBQUNHLE9BQU9DLFdBQVcsQ0FBQztJQUM3QixJQUFJLEtBQUssTUFBTUYsR0FBRztRQUNoQixJQUFJRyxJQUFJSCxFQUFFSSxJQUFJLENBQUNOLEdBQUdDLEtBQUs7UUFDdkIsSUFBSSxZQUFZLE9BQU9JLEdBQUcsT0FBT0E7UUFDakMsTUFBTSxJQUFJRSxVQUFVO0lBQ3RCO0lBQ0EsT0FBTyxDQUFDLGFBQWFOLElBQUlPLFNBQVNDLE1BQUssRUFBR1Q7QUFDNUM7QUFDQSxTQUFTVSxlQUFlVixDQUFDO0lBQ3ZCLElBQUlLLElBQUlOLGFBQWFDLEdBQUc7SUFDeEIsT0FBTyxZQUFZLE9BQU9LLElBQUlBLElBQUlHLE9BQU9IO0FBQzNDO0FBQ0EsU0FBU007SUFDUEEsV0FBV0MsT0FBT0MsTUFBTSxHQUFHRCxPQUFPQyxNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQ2hFLElBQUssSUFBSVYsSUFBSSxHQUFHQSxJQUFJVyxVQUFVQyxNQUFNLEVBQUVaLElBQUs7WUFDekMsSUFBSWEsU0FBU0YsU0FBUyxDQUFDWCxFQUFFO1lBQ3pCLElBQUssSUFBSWMsT0FBT0QsT0FBUTtnQkFDdEIsSUFBSU4sT0FBT1EsU0FBUyxDQUFDQyxjQUFjLENBQUNmLElBQUksQ0FBQ1ksUUFBUUMsTUFBTTtvQkFDckRKLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQzNCO1lBQ0Y7UUFDRjtRQUNBLE9BQU9K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Q0Y7QUFFOFcsQ0FDOVcseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdmlzLmdsL3JlYWN0LWdvb2dsZS1tYXBzL2Rpc3QvaW5kZXgubW9kZXJuLm1qcz9lN2MxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlUmVkdWNlciwgdXNlTWVtbywgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VDb250ZXh0LCB1c2VMYXlvdXRFZmZlY3QsIGZvcndhcmRSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUsIENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBpc0RlZXBFcXVhbCBmcm9tICdmYXN0LWRlZXAtZXF1YWwnO1xuXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogU3RyaW5nKGkpO1xufVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5jb25zdCBBUElMb2FkaW5nU3RhdHVzID0ge1xuICBOT1RfTE9BREVEOiAnTk9UX0xPQURFRCcsXG4gIExPQURJTkc6ICdMT0FESU5HJyxcbiAgTE9BREVEOiAnTE9BREVEJyxcbiAgRkFJTEVEOiAnRkFJTEVEJyxcbiAgQVVUSF9GQUlMVVJFOiAnQVVUSF9GQUlMVVJFJ1xufTtcblxuY29uc3QgTUFQU19BUElfQkFTRV9VUkwgPSAnaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzJztcbi8qKlxuICogQSBHb29nbGVNYXBzQXBpTG9hZGVyIHRvIHJlbGlhYmx5IGxvYWQgYW5kIHVubG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkuXG4gKlxuICogVGhlIGFjdHVhbCBsb2FkaW5nIGFuZCB1bmxvYWRpbmcgaXMgZGVsYXllZCBpbnRvIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHRvXG4gKiBhbGxvdyB1c2luZyB0aGUgQVBJIGluIGFuIHVzZUVmZmVjdCBob29rLCB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IG11bHRpcGxlIEFQSSBsb2Fkcy5cbiAqL1xuY2xhc3MgR29vZ2xlTWFwc0FwaUxvYWRlciB7XG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgR29vZ2xlIE1hcHMgQVBJIHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLlxuICAgKiBTaW5jZSB0aGUgTWFwcyBsaWJyYXJ5IGNhbiBvbmx5IGJlIGxvYWRlZCBvbmNlIHBlciBwYWdlLCB0aGlzIHdpbGxcbiAgICogcHJvZHVjZSBhIHdhcm5pbmcgd2hlbiBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnRcbiAgICogcGFyYW1ldGVycy5cbiAgICpcbiAgICogVGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMgd2hlbiBsb2FkaW5nIGNvbXBsZXRlc1xuICAgKiBhbmQgcmVqZWN0cyBpbiBjYXNlIG9mIGFuIGVycm9yIG9yIHdoZW4gdGhlIGxvYWRpbmcgd2FzIGFib3J0ZWQuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgbG9hZChwYXJhbXMsIG9uTG9hZGluZ1N0YXR1c0NoYW5nZSkge1xuICAgIHZhciBfd2luZG93JGdvb2dsZTtcbiAgICBjb25zdCBsaWJyYXJpZXMgPSBwYXJhbXMubGlicmFyaWVzID8gcGFyYW1zLmxpYnJhcmllcy5zcGxpdCgnLCcpIDogW107XG4gICAgY29uc3Qgc2VyaWFsaXplZFBhcmFtcyA9IHRoaXMuc2VyaWFsaXplUGFyYW1zKHBhcmFtcyk7XG4gICAgLy8gbm90ZTogaWYgZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeSB3YXMgZGVmaW5lZCBleHRlcm5hbGx5LCB0aGUgcGFyYW1zXG4gICAgLy8gICB3aWxsIGJlIGlnbm9yZWQuIElmIGl0IHdhcyBkZWZpbmVkIGJ5IGEgcHJldmlvdXMgY2FsbCB0byB0aGlzXG4gICAgLy8gICBtZXRob2QsIHdlIHdpbGwgY2hlY2sgdGhhdCB0aGUga2V5IGFuZCBvdGhlciBwYXJhbWV0ZXJzIGhhdmUgbm90IGJlZW5cbiAgICAvLyAgIGNoYW5nZWQgaW4gYmV0d2VlbiBjYWxscy5cbiAgICBpZiAoISgoX3dpbmRvdyRnb29nbGUgPSB3aW5kb3cuZ29vZ2xlKSAhPSBudWxsICYmIChfd2luZG93JGdvb2dsZSA9IF93aW5kb3ckZ29vZ2xlLm1hcHMpICE9IG51bGwgJiYgX3dpbmRvdyRnb29nbGUuaW1wb3J0TGlicmFyeSkpIHtcbiAgICAgIHRoaXMuc2VyaWFsaXplZEFwaVBhcmFtcyA9IHNlcmlhbGl6ZWRQYXJhbXM7XG4gICAgICB0aGlzLmluaXRJbXBvcnRMaWJyYXJ5KHBhcmFtcywgb25Mb2FkaW5nU3RhdHVzQ2hhbmdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgc2VyaWFsaXplZEFwaVBhcmFtcyBpc24ndCBkZWZpbmVkIHRoZSBsaWJyYXJ5IHdhcyBsb2FkZWQgZXh0ZXJuYWxseVxuICAgICAgLy8gYW5kIHdlIGNhbiBvbmx5IGFzc3VtZSB0aGF0IHdlbnQgYWxyaWdodC5cbiAgICAgIGlmICghdGhpcy5zZXJpYWxpemVkQXBpUGFyYW1zKSB7XG4gICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuTE9BREVEO1xuICAgICAgfVxuICAgICAgb25Mb2FkaW5nU3RhdHVzQ2hhbmdlKHRoaXMubG9hZGluZ1N0YXR1cyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMgJiYgdGhpcy5zZXJpYWxpemVkQXBpUGFyYW1zICE9PSBzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFRoZSBtYXBzIEFQSSBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZCB3aXRoIGRpZmZlcmVudCBgICsgYHBhcmFtZXRlcnMgYW5kIHdpbGwgbm90IGJlIGxvYWRlZCBhZ2Fpbi4gUmVmcmVzaCB0aGUgcGFnZSBmb3IgYCArIGBuZXcgdmFsdWVzIHRvIGhhdmUgZWZmZWN0LmApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxpYiBvZiBbJ21hcHMnLCAuLi5saWJyYXJpZXNdKSB7XG4gICAgICBhd2FpdCBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5KGxpYik7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBzZXJpYWxpemVQYXJhbXMocGFyYW1zKSB7XG4gICAgcmV0dXJuIFtwYXJhbXMudiwgcGFyYW1zLmtleSwgcGFyYW1zLmxhbmd1YWdlLCBwYXJhbXMucmVnaW9uLCBwYXJhbXMuYXV0aFJlZmVycmVyUG9saWN5LCBwYXJhbXMuc29sdXRpb25DaGFubmVsXS5qb2luKCcvJyk7XG4gIH1cbiAgc3RhdGljIGluaXRJbXBvcnRMaWJyYXJ5KHBhcmFtcywgb25Mb2FkaW5nU3RhdHVzQ2hhbmdlKSB7XG4gICAgaWYgKCF3aW5kb3cuZ29vZ2xlKSB3aW5kb3cuZ29vZ2xlID0ge307XG4gICAgaWYgKCF3aW5kb3cuZ29vZ2xlLm1hcHMpIHdpbmRvdy5nb29nbGUubWFwcyA9IHt9O1xuICAgIGlmICh3aW5kb3cuZ29vZ2xlLm1hcHNbJ2ltcG9ydExpYnJhcnknXSkge1xuICAgICAgY29uc29sZS53YXJuKCdpbml0SW1wb3J0TGlicmFyeSBjYW4gb25seSBiZSBjYWxsZWQgb25jZS4nLCBwYXJhbXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYXBpUHJvbWlzZSA9IG51bGw7XG4gICAgY29uc3QgbG9hZEFwaSA9IGxpYnJhcnkgPT4ge1xuICAgICAgaWYgKGFwaVByb21pc2UpIHJldHVybiBhcGlQcm9taXNlO1xuICAgICAgYXBpUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdmFyIF9kb2N1bWVudCRxdWVyeVNlbGVjdDtcbiAgICAgICAgY29uc3Qgc2NyaXB0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICAgICAgICBjb25zdCB1cmxQYXJhbU5hbWUgPSBrZXkucmVwbGFjZSgvW0EtWl0vZywgdCA9PiAnXycgKyB0WzBdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIHVybFBhcmFtcy5zZXQodXJsUGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXJsUGFyYW1zLnNldCgnbGlicmFyaWVzJywgbGlicmFyeSk7XG4gICAgICAgIHVybFBhcmFtcy5zZXQoJ2xvYWRpbmcnLCAnYXN5bmMnKTtcbiAgICAgICAgdXJsUGFyYW1zLnNldCgnY2FsbGJhY2snLCAnX19nb29nbGVNYXBzQ2FsbGJhY2tfXycpO1xuICAgICAgICBzY3JpcHRFbGVtZW50LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0RWxlbWVudC5zcmMgPSBNQVBTX0FQSV9CQVNFX1VSTCArIGA/YCArIHVybFBhcmFtcy50b1N0cmluZygpO1xuICAgICAgICB3aW5kb3cuX19nb29nbGVNYXBzQ2FsbGJhY2tfXyA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkxPQURFRDtcbiAgICAgICAgICBvbkxvYWRpbmdTdGF0dXNDaGFuZ2UodGhpcy5sb2FkaW5nU3RhdHVzKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5nbV9hdXRoRmFpbHVyZSA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkFVVEhfRkFJTFVSRTtcbiAgICAgICAgICBvbkxvYWRpbmdTdGF0dXNDaGFuZ2UodGhpcy5sb2FkaW5nU3RhdHVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2NyaXB0RWxlbWVudC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuRkFJTEVEO1xuICAgICAgICAgIG9uTG9hZGluZ1N0YXR1c0NoYW5nZSh0aGlzLmxvYWRpbmdTdGF0dXMpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSBjb3VsZCBub3QgbG9hZC4nKSk7XG4gICAgICAgIH07XG4gICAgICAgIHNjcmlwdEVsZW1lbnQubm9uY2UgPSAoKF9kb2N1bWVudCRxdWVyeVNlbGVjdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdFtub25jZV0nKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kb2N1bWVudCRxdWVyeVNlbGVjdC5ub25jZSkgfHwgJyc7XG4gICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuTE9BRElORztcbiAgICAgICAgb25Mb2FkaW5nU3RhdHVzQ2hhbmdlKHRoaXMubG9hZGluZ1N0YXR1cyk7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kKHNjcmlwdEVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXBpUHJvbWlzZTtcbiAgICB9O1xuICAgIC8vIGZvciB0aGUgZmlyc3QgbG9hZCwgd2UgZGVjbGFyZSBhbiBpbXBvcnRMaWJyYXJ5IGZ1bmN0aW9uIHRoYXQgd2lsbFxuICAgIC8vIGJlIG92ZXJ3cml0dGVuIG9uY2UgdGhlIGFwaSBpcyBsb2FkZWQuXG4gICAgZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeSA9IGxpYnJhcnlOYW1lID0+IGxvYWRBcGkobGlicmFyeU5hbWUpLnRoZW4oKCkgPT4gZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeShsaWJyYXJ5TmFtZSkpO1xuICB9XG59XG5Hb29nbGVNYXBzQXBpTG9hZGVyLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLk5PVF9MT0FERUQ7XG5Hb29nbGVNYXBzQXBpTG9hZGVyLnNlcmlhbGl6ZWRBcGlQYXJhbXMgPSB2b2lkIDA7XG5cbmNvbnN0IF9leGNsdWRlZCQzID0gW1wib25Mb2FkXCIsIFwiYXBpS2V5XCIsIFwidmVyc2lvblwiLCBcImxpYnJhcmllc1wiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImNoaWxkcmVuXCJdO1xuY29uc3QgQVBJUHJvdmlkZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbi8qKlxuICogbG9jYWwgaG9vayB0byBzZXQgdXAgdGhlIG1hcC1pbnN0YW5jZSBtYW5hZ2VtZW50IGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcEluc3RhbmNlcygpIHtcbiAgY29uc3QgW21hcEluc3RhbmNlcywgc2V0TWFwSW5zdGFuY2VzXSA9IHVzZVN0YXRlKHt9KTtcbiAgY29uc3QgYWRkTWFwSW5zdGFuY2UgPSAobWFwSW5zdGFuY2UsIGlkID0gJ2RlZmF1bHQnKSA9PiB7XG4gICAgc2V0TWFwSW5zdGFuY2VzKGluc3RhbmNlcyA9PiBfZXh0ZW5kcyh7fSwgaW5zdGFuY2VzLCB7XG4gICAgICBbaWRdOiBtYXBJbnN0YW5jZVxuICAgIH0pKTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlTWFwSW5zdGFuY2UgPSAoaWQgPSAnZGVmYXVsdCcpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgc2V0TWFwSW5zdGFuY2VzKF9yZWYgPT4ge1xuICAgICAgbGV0IHJlbWFpbmluZyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtpZF0ubWFwKF90b1Byb3BlcnR5S2V5KSk7XG4gICAgICByZXR1cm4gcmVtYWluaW5nO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBjbGVhck1hcEluc3RhbmNlcyA9ICgpID0+IHtcbiAgICBzZXRNYXBJbnN0YW5jZXMoe30pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1hcEluc3RhbmNlcyxcbiAgICBhZGRNYXBJbnN0YW5jZSxcbiAgICByZW1vdmVNYXBJbnN0YW5jZSxcbiAgICBjbGVhck1hcEluc3RhbmNlc1xuICB9O1xufVxuLyoqXG4gKiBsb2NhbCBob29rIHRvIGhhbmRsZSB0aGUgbG9hZGluZyBvZiB0aGUgbWFwcyBBUEksIHJldHVybnMgdGhlIGN1cnJlbnQgbG9hZGluZyBzdGF0dXNcbiAqIEBwYXJhbSBwcm9wc1xuICovXG5mdW5jdGlvbiB1c2VHb29nbGVNYXBzQXBpTG9hZGVyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICAgIG9uTG9hZCxcbiAgICAgIGFwaUtleSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBsaWJyYXJpZXMgPSBbXVxuICAgIH0gPSBwcm9wcyxcbiAgICBvdGhlckFwaVBhcmFtcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkMyk7XG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZShHb29nbGVNYXBzQXBpTG9hZGVyLmxvYWRpbmdTdGF0dXMpO1xuICBjb25zdCBbbG9hZGVkTGlicmFyaWVzLCBhZGRMb2FkZWRMaWJyYXJ5XSA9IHVzZVJlZHVjZXIoKGxvYWRlZExpYnJhcmllcywgYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2FkZWRMaWJyYXJpZXMsIHtcbiAgICAgIFthY3Rpb24ubmFtZV06IGFjdGlvbi52YWx1ZVxuICAgIH0pO1xuICB9LCB7fSk7XG4gIGNvbnN0IGxpYnJhcmllc1N0cmluZyA9IHVzZU1lbW8oKCkgPT4gbGlicmFyaWVzID09IG51bGwgPyB2b2lkIDAgOiBsaWJyYXJpZXMuam9pbignLCcpLCBbbGlicmFyaWVzXSk7XG4gIGNvbnN0IHNlcmlhbGl6ZWRQYXJhbXMgPSB1c2VNZW1vKCgpID0+IEpTT04uc3RyaW5naWZ5KF9leHRlbmRzKHtcbiAgICBhcGlLZXksXG4gICAgdmVyc2lvblxuICB9LCBvdGhlckFwaVBhcmFtcykpLCBbYXBpS2V5LCB2ZXJzaW9uLCBvdGhlckFwaVBhcmFtc10pO1xuICBjb25zdCBpbXBvcnRMaWJyYXJ5ID0gdXNlQ2FsbGJhY2soYXN5bmMgbmFtZSA9PiB7XG4gICAgdmFyIF9nb29nbGU7XG4gICAgaWYgKGxvYWRlZExpYnJhcmllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIGxvYWRlZExpYnJhcmllc1tuYW1lXTtcbiAgICB9XG4gICAgaWYgKCEoKF9nb29nbGUgPSBnb29nbGUpICE9IG51bGwgJiYgKF9nb29nbGUgPSBfZ29vZ2xlLm1hcHMpICE9IG51bGwgJiYgX2dvb2dsZS5pbXBvcnRMaWJyYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbYXBpLXByb3ZpZGVyLWludGVybmFsXSBpbXBvcnRMaWJyYXJ5IHdhcyBjYWxsZWQgYmVmb3JlICcgKyAnZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeSB3YXMgZGVmaW5lZC4nKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgd2luZG93Lmdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkobmFtZSk7XG4gICAgYWRkTG9hZGVkTGlicmFyeSh7XG4gICAgICBuYW1lLFxuICAgICAgdmFsdWU6IHJlc1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH0sIFtsb2FkZWRMaWJyYXJpZXNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gX2V4dGVuZHMoe1xuICAgICAgICAgIGtleTogYXBpS2V5XG4gICAgICAgIH0sIG90aGVyQXBpUGFyYW1zKTtcbiAgICAgICAgaWYgKHZlcnNpb24pIHBhcmFtcy52ID0gdmVyc2lvbjtcbiAgICAgICAgaWYgKChsaWJyYXJpZXNTdHJpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IGxpYnJhcmllc1N0cmluZy5sZW5ndGgpID4gMCkgcGFyYW1zLmxpYnJhcmllcyA9IGxpYnJhcmllc1N0cmluZztcbiAgICAgICAgYXdhaXQgR29vZ2xlTWFwc0FwaUxvYWRlci5sb2FkKHBhcmFtcywgc3RhdHVzID0+IHNldFN0YXR1cyhzdGF0dXMpKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIFsnY29yZScsICdtYXBzJywgLi4ubGlicmFyaWVzXSkge1xuICAgICAgICAgIGF3YWl0IGltcG9ydExpYnJhcnkobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgIG9uTG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCc8QXBpUHJvdmlkZXI+IGZhaWxlZCB0byBsb2FkIEdvb2dsZSBNYXBzIEFQSScsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFthcGlLZXksIGxpYnJhcmllc1N0cmluZywgc2VyaWFsaXplZFBhcmFtc10pO1xuICByZXR1cm4ge1xuICAgIHN0YXR1cyxcbiAgICBsb2FkZWRMaWJyYXJpZXMsXG4gICAgaW1wb3J0TGlicmFyeVxuICB9O1xufVxuLyoqXG4gKiBDb21wb25lbnQgdG8gd3JhcCB0aGUgR29vZ2xlIE1hcHMgUmVhY3QgY29tcG9uZW50cyBhbmQgbG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUElcbiAqL1xuY29uc3QgQVBJUHJvdmlkZXIgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IHByb3BzLFxuICAgIGxvYWRlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZDIpO1xuICBjb25zdCB7XG4gICAgbWFwSW5zdGFuY2VzLFxuICAgIGFkZE1hcEluc3RhbmNlLFxuICAgIHJlbW92ZU1hcEluc3RhbmNlLFxuICAgIGNsZWFyTWFwSW5zdGFuY2VzXG4gIH0gPSB1c2VNYXBJbnN0YW5jZXMoKTtcbiAgY29uc3Qge1xuICAgIHN0YXR1cyxcbiAgICBsb2FkZWRMaWJyYXJpZXMsXG4gICAgaW1wb3J0TGlicmFyeVxuICB9ID0gdXNlR29vZ2xlTWFwc0FwaUxvYWRlcihsb2FkZXJQcm9wcyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBUElQcm92aWRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZToge1xuICAgICAgbWFwSW5zdGFuY2VzLFxuICAgICAgYWRkTWFwSW5zdGFuY2UsXG4gICAgICByZW1vdmVNYXBJbnN0YW5jZSxcbiAgICAgIGNsZWFyTWFwSW5zdGFuY2VzLFxuICAgICAgc3RhdHVzLFxuICAgICAgbG9hZGVkTGlicmFyaWVzLFxuICAgICAgaW1wb3J0TGlicmFyeVxuICAgIH1cbiAgfSwgY2hpbGRyZW4pO1xufTtcblxuLyoqXG4gKiBTZXRzIHVwIGVmZmVjdHMgdG8gYmluZCBldmVudC1oYW5kbGVycyBmb3IgYWxsIGV2ZW50LXByb3BzIGluIE1hcEV2ZW50UHJvcHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlTWFwRXZlbnRzKG1hcCwgcHJvcHMpIHtcbiAgLy8gbm90ZTogY2FsbGluZyBhIHVzZUVmZmVjdCBob29rIGZyb20gd2l0aGluIGEgbG9vcCBpcyBwcm9oaWJpdGVkIGJ5IHRoZVxuICAvLyBydWxlcyBvZiBob29rcywgYnV0IGl0J3Mgb2sgaGVyZSBzaW5jZSBpdCdzIHVuY29uZGl0aW9uYWwgYW5kIHRoZSBudW1iZXJcbiAgLy8gYW5kIG9yZGVyIG9mIGl0ZXJhdGlvbnMgaXMgYWx3YXlzIHN0cmljdGx5IHRoZSBzYW1lLlxuICAvLyAoc2VlIGh0dHBzOi8vbGVnYWN5LnJlYWN0anMub3JnL2RvY3MvaG9va3MtcnVsZXMuaHRtbClcbiAgZm9yIChjb25zdCBwcm9wTmFtZSBvZiBldmVudFByb3BOYW1lcykge1xuICAgIC8vIGZpeG1lOiB0aGlzIGNhc3QgaXMgZXNzZW50aWFsbHkgYSAndHJ1c3QgbWUsIGJybycgZm9yIHR5cGVzY3JpcHQsIGJ1dFxuICAgIC8vICAgYSBwcm9wZXIgc29sdXRpb24gc2VlbXMgd2F5IHRvbyBjb21wbGljYXRlZCByaWdodCBub3dcbiAgICBjb25zdCBoYW5kbGVyID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGNvbnN0IGV2ZW50VHlwZSA9IHByb3BOYW1lVG9FdmVudFR5cGVbcHJvcE5hbWVdO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoIW1hcCkgcmV0dXJuO1xuICAgICAgaWYgKCFoYW5kbGVyKSByZXR1cm47XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgZXZlbnRUeXBlLCBldiA9PiB7XG4gICAgICAgIGhhbmRsZXIoY3JlYXRlTWFwRXZlbnQoZXZlbnRUeXBlLCBtYXAsIGV2KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lci5yZW1vdmUoKTtcbiAgICB9LCBbbWFwLCBldmVudFR5cGUsIGhhbmRsZXJdKTtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGUgdGhlIHdyYXBwZWQgbWFwLWV2ZW50cyB1c2VkIGZvciB0aGUgZXZlbnQtcHJvcHMuXG4gKiBAcGFyYW0gdHlwZSB0aGUgZXZlbnQgdHlwZSBhcyBpdCBpcyBzcGVjaWZpZWQgdG8gdGhlIG1hcHMgYXBpXG4gKiBAcGFyYW0gbWFwIHRoZSBtYXAgaW5zdGFuY2UgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbVxuICogQHBhcmFtIHNyY0V2ZW50IHRoZSBzb3VyY2UtZXZlbnQgaWYgdGhlcmUgaXMgb25lLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNYXBFdmVudCh0eXBlLCBtYXAsIHNyY0V2ZW50KSB7XG4gIGNvbnN0IGV2ID0ge1xuICAgIHR5cGUsXG4gICAgbWFwLFxuICAgIGRldGFpbDoge30sXG4gICAgc3RvcHBhYmxlOiBmYWxzZSxcbiAgICBzdG9wOiAoKSA9PiB7fVxuICB9O1xuICBpZiAoY2FtZXJhRXZlbnRUeXBlcy5pbmNsdWRlcyh0eXBlKSkge1xuICAgIGNvbnN0IGNhbUV2ZW50ID0gZXY7XG4gICAgY29uc3QgY2VudGVyID0gbWFwLmdldENlbnRlcigpO1xuICAgIGNvbnN0IHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuICAgIGNvbnN0IGhlYWRpbmcgPSBtYXAuZ2V0SGVhZGluZygpIHx8IDA7XG4gICAgY29uc3QgdGlsdCA9IG1hcC5nZXRUaWx0KCkgfHwgMDtcbiAgICBjb25zdCBib3VuZHMgPSBtYXAuZ2V0Qm91bmRzKCk7XG4gICAgaWYgKCFjZW50ZXIgfHwgIWJvdW5kcyB8fCAhTnVtYmVyLmlzRmluaXRlKHpvb20pKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tjcmVhdGVFdmVudF0gYXQgbGVhc3Qgb25lIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgbWFwICcgKyAncmV0dXJuZWQgdW5kZWZpbmVkLiBUaGlzIGlzIG5vdCBleHBlY3RlZCB0byBoYXBwZW4uIFBsZWFzZSAnICsgJ3JlcG9ydCBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vdmlzZ2wvcmVhY3QtZ29vZ2xlLW1hcHMvaXNzdWVzL25ldycpO1xuICAgIH1cbiAgICBjYW1FdmVudC5kZXRhaWwgPSB7XG4gICAgICBjZW50ZXI6IChjZW50ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNlbnRlci50b0pTT04oKSkgfHwge1xuICAgICAgICBsYXQ6IDAsXG4gICAgICAgIGxuZzogMFxuICAgICAgfSxcbiAgICAgIHpvb206IHpvb20gfHwgMCxcbiAgICAgIGhlYWRpbmc6IGhlYWRpbmcsXG4gICAgICB0aWx0OiB0aWx0LFxuICAgICAgYm91bmRzOiAoYm91bmRzID09IG51bGwgPyB2b2lkIDAgOiBib3VuZHMudG9KU09OKCkpIHx8IHtcbiAgICAgICAgbm9ydGg6IDkwLFxuICAgICAgICBlYXN0OiAxODAsXG4gICAgICAgIHNvdXRoOiAtOTAsXG4gICAgICAgIHdlc3Q6IC0xODBcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBjYW1FdmVudDtcbiAgfSBlbHNlIGlmIChtb3VzZUV2ZW50VHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICB2YXIgX3NyY0V2ZW50JGxhdExuZztcbiAgICBpZiAoIXNyY0V2ZW50KSB0aHJvdyBuZXcgRXJyb3IoJ1tjcmVhdGVFdmVudF0gbW91c2UgZXZlbnRzIG11c3QgcHJvdmlkZSBhIHNyY0V2ZW50Jyk7XG4gICAgY29uc3QgbW91c2VFdmVudCA9IGV2O1xuICAgIG1vdXNlRXZlbnQuZG9tRXZlbnQgPSBzcmNFdmVudC5kb21FdmVudDtcbiAgICBtb3VzZUV2ZW50LnN0b3BwYWJsZSA9IHRydWU7XG4gICAgbW91c2VFdmVudC5zdG9wID0gKCkgPT4gc3JjRXZlbnQuc3RvcCgpO1xuICAgIG1vdXNlRXZlbnQuZGV0YWlsID0ge1xuICAgICAgbGF0TG5nOiAoKF9zcmNFdmVudCRsYXRMbmcgPSBzcmNFdmVudC5sYXRMbmcpID09IG51bGwgPyB2b2lkIDAgOiBfc3JjRXZlbnQkbGF0TG5nLnRvSlNPTigpKSB8fCBudWxsLFxuICAgICAgcGxhY2VJZDogc3JjRXZlbnQucGxhY2VJZFxuICAgIH07XG4gICAgcmV0dXJuIG1vdXNlRXZlbnQ7XG4gIH1cbiAgcmV0dXJuIGV2O1xufVxuLyoqXG4gKiBtYXBzIHRoZSBjYW1lbENhc2VkIG5hbWVzIG9mIGV2ZW50LXByb3BzIHRvIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50LXR5cGVzXG4gKiB1c2VkIGluIHRoZSBtYXBzIEFQSS5cbiAqL1xuY29uc3QgcHJvcE5hbWVUb0V2ZW50VHlwZSA9IHtcbiAgb25Cb3VuZHNDaGFuZ2VkOiAnYm91bmRzX2NoYW5nZWQnLFxuICBvbkNlbnRlckNoYW5nZWQ6ICdjZW50ZXJfY2hhbmdlZCcsXG4gIG9uQ2xpY2s6ICdjbGljaycsXG4gIG9uQ29udGV4dG1lbnU6ICdjb250ZXh0bWVudScsXG4gIG9uRGJsY2xpY2s6ICdkYmxjbGljaycsXG4gIG9uRHJhZzogJ2RyYWcnLFxuICBvbkRyYWdlbmQ6ICdkcmFnZW5kJyxcbiAgb25EcmFnc3RhcnQ6ICdkcmFnc3RhcnQnLFxuICBvbkhlYWRpbmdDaGFuZ2VkOiAnaGVhZGluZ19jaGFuZ2VkJyxcbiAgb25JZGxlOiAnaWRsZScsXG4gIG9uSXNGcmFjdGlvbmFsWm9vbUVuYWJsZWRDaGFuZ2VkOiAnaXNmcmFjdGlvbmFsem9vbWVuYWJsZWRfY2hhbmdlZCcsXG4gIG9uTWFwQ2FwYWJpbGl0aWVzQ2hhbmdlZDogJ21hcGNhcGFiaWxpdGllc19jaGFuZ2VkJyxcbiAgb25NYXBUeXBlSWRDaGFuZ2VkOiAnbWFwdHlwZWlkX2NoYW5nZWQnLFxuICBvbk1vdXNlbW92ZTogJ21vdXNlbW92ZScsXG4gIG9uTW91c2VvdXQ6ICdtb3VzZW91dCcsXG4gIG9uTW91c2VvdmVyOiAnbW91c2VvdmVyJyxcbiAgb25Qcm9qZWN0aW9uQ2hhbmdlZDogJ3Byb2plY3Rpb25fY2hhbmdlZCcsXG4gIG9uUmVuZGVyaW5nVHlwZUNoYW5nZWQ6ICdyZW5kZXJpbmd0eXBlX2NoYW5nZWQnLFxuICBvblRpbGVzTG9hZGVkOiAndGlsZXNsb2FkZWQnLFxuICBvblRpbHRDaGFuZ2VkOiAndGlsdF9jaGFuZ2VkJyxcbiAgb25ab29tQ2hhbmdlZDogJ3pvb21fY2hhbmdlZCcsXG4gIC8vIG5vdGU6IG9uQ2FtZXJhQ2hhbmdlZCBpcyBhbiBhbGlhcyBmb3IgdGhlIGJvdW5kc19jaGFuZ2VkIGV2ZW50LFxuICAvLyBzaW5jZSB0aGF0IGlzIGdvaW5nIHRvIGJlIGZpcmVkIGluIGV2ZXJ5IHNpdHVhdGlvbiB3aGVyZSB0aGUgY2FtZXJhIGlzXG4gIC8vIHVwZGF0ZWQuXG4gIG9uQ2FtZXJhQ2hhbmdlZDogJ2JvdW5kc19jaGFuZ2VkJ1xufTtcbmNvbnN0IGNhbWVyYUV2ZW50VHlwZXMgPSBbJ2JvdW5kc19jaGFuZ2VkJywgJ2NlbnRlcl9jaGFuZ2VkJywgJ2hlYWRpbmdfY2hhbmdlZCcsICdwcm9qZWN0aW9uX2NoYW5nZWQnLCAndGlsdF9jaGFuZ2VkJywgJ3pvb21fY2hhbmdlZCddO1xuY29uc3QgbW91c2VFdmVudFR5cGVzID0gWydjbGljaycsICdjb250ZXh0bWVudScsICdkYmxjbGljaycsICdtb3VzZW1vdmUnLCAnbW91c2VvdXQnLCAnbW91c2VvdmVyJ107XG5jb25zdCBldmVudFByb3BOYW1lcyA9IE9iamVjdC5rZXlzKHByb3BOYW1lVG9FdmVudFR5cGUpO1xuXG5mdW5jdGlvbiB1c2VEZWVwQ29tcGFyZUVmZmVjdChlZmZlY3QsIGRlcHMpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKHVuZGVmaW5lZCk7XG4gIGlmICghcmVmLmN1cnJlbnQgfHwgIWlzRGVlcEVxdWFsKGRlcHMsIHJlZi5jdXJyZW50KSkge1xuICAgIHJlZi5jdXJyZW50ID0gZGVwcztcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIHVzZUVmZmVjdChlZmZlY3QsIHJlZi5jdXJyZW50KTtcbn1cblxuY29uc3QgbWFwT3B0aW9uS2V5cyA9IG5ldyBTZXQoWydiYWNrZ3JvdW5kQ29sb3InLCAnY2xpY2thYmxlSWNvbnMnLCAnY29udHJvbFNpemUnLCAnZGlzYWJsZURlZmF1bHRVSScsICdkaXNhYmxlRG91YmxlQ2xpY2tab29tJywgJ2RyYWdnYWJsZScsICdkcmFnZ2FibGVDdXJzb3InLCAnZHJhZ2dpbmdDdXJzb3InLCAnZnVsbHNjcmVlbkNvbnRyb2wnLCAnZnVsbHNjcmVlbkNvbnRyb2xPcHRpb25zJywgJ2dlc3R1cmVIYW5kbGluZycsICdpc0ZyYWN0aW9uYWxab29tRW5hYmxlZCcsICdrZXlib2FyZFNob3J0Y3V0cycsICdtYXBUeXBlQ29udHJvbCcsICdtYXBUeXBlQ29udHJvbE9wdGlvbnMnLCAnbWFwVHlwZUlkJywgJ21heFpvb20nLCAnbWluWm9vbScsICdub0NsZWFyJywgJ3BhbkNvbnRyb2wnLCAncGFuQ29udHJvbE9wdGlvbnMnLCAncmVzdHJpY3Rpb24nLCAncm90YXRlQ29udHJvbCcsICdyb3RhdGVDb250cm9sT3B0aW9ucycsICdzY2FsZUNvbnRyb2wnLCAnc2NhbGVDb250cm9sT3B0aW9ucycsICdzY3JvbGx3aGVlbCcsICdzdHJlZXRWaWV3JywgJ3N0cmVldFZpZXdDb250cm9sJywgJ3N0cmVldFZpZXdDb250cm9sT3B0aW9ucycsICdzdHlsZXMnLCAnem9vbUNvbnRyb2wnLCAnem9vbUNvbnRyb2xPcHRpb25zJ10pO1xuLyoqXG4gKiBJbnRlcm5hbCBob29rIHRvIHVwZGF0ZSB0aGUgbWFwLW9wdGlvbnMgd2hlbiBwcm9wcyBhcmUgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0gbWFwIHRoZSBtYXAgaW5zdGFuY2VcbiAqIEBwYXJhbSBtYXBQcm9wcyB0aGUgcHJvcHMgdG8gdXBkYXRlIHRoZSBtYXAtaW5zdGFuY2Ugd2l0aFxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcE9wdGlvbnMobWFwLCBtYXBQcm9wcykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgLS1cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBlZmZlY3RzIGFyZW4ndCB0cmlnZ2VyZWQgd2hlbiB0aGUgbWFwIGlzIGNoYW5nZWQuXG4gICAqIEluIHRoYXQgY2FzZSwgdGhlIHZhbHVlcyB3aWxsIGJlIG9yIGhhdmUgYmVlbiBwYXNzZWQgdG8gdGhlIG1hcFxuICAgKiBjb25zdHJ1Y3RvciB2aWEgbWFwT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0IG1hcE9wdGlvbnMgPSB7fTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG1hcFByb3BzKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGlmICghbWFwT3B0aW9uS2V5cy5oYXMoa2V5KSkgY29udGludWU7XG4gICAgbWFwT3B0aW9uc1trZXldID0gbWFwUHJvcHNba2V5XTtcbiAgfVxuICAvLyB1cGRhdGUgdGhlIG1hcCBvcHRpb25zIHdoZW4gbWFwT3B0aW9ucyBpcyBjaGFuZ2VkXG4gIC8vIE5vdGU6IGR1ZSB0byB0aGUgZGVzdHJ1Y3R1cmluZyBhYm92ZSwgbWFwT3B0aW9ucyB3aWxsIGJlIHNlZW4gYXMgY2hhbmdlZFxuICAvLyAgIHdpdGggZXZlcnkgcmUtcmVuZGVyLCBzbyB3ZSdyZSBhc3N1bWluZyB0aGUgbWFwcy1hcGkgd2lsbCBwcm9wZXJseVxuICAvLyAgIGRlYWwgd2l0aCB1bmNoYW5nZWQgb3B0aW9uLXZhbHVlcyBwYXNzZWQgaW50byBzZXRPcHRpb25zLlxuICB1c2VEZWVwQ29tcGFyZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXApIHJldHVybjtcbiAgICBtYXAuc2V0T3B0aW9ucyhtYXBPcHRpb25zKTtcbiAgfSwgW21hcE9wdGlvbnNdKTtcbiAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgKi9cbn1cblxuZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVJlZHVjZXIoeCA9PiB4ICsgMSwgMCk7XG4gIHJldHVybiBmb3JjZVVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQm91bmRzQ2hhbmdlKG1hcCwgcmVmKSB7XG4gIGNvbnN0IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcbiAgY29uc3Qgem9vbSA9IG1hcC5nZXRab29tKCk7XG4gIGNvbnN0IGhlYWRpbmcgPSBtYXAuZ2V0SGVhZGluZygpIHx8IDA7XG4gIGNvbnN0IHRpbHQgPSBtYXAuZ2V0VGlsdCgpIHx8IDA7XG4gIGNvbnN0IGJvdW5kcyA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgaWYgKCFjZW50ZXIgfHwgIWJvdW5kcyB8fCAhTnVtYmVyLmlzRmluaXRlKHpvb20pKSB7XG4gICAgY29uc29sZS53YXJuKCdbdXNlVHJhY2tlZENhbWVyYVN0YXRlXSBhdCBsZWFzdCBvbmUgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBtYXAgJyArICdyZXR1cm5lZCB1bmRlZmluZWQuIFRoaXMgaXMgbm90IGV4cGVjdGVkIHRvIGhhcHBlbi4gUGxlYXNlICcgKyAncmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9yZWFjdC1nb29nbGUtbWFwcy9pc3N1ZXMvbmV3Jyk7XG4gIH1cbiAgLy8gZml4bWU6IGRvIHdlIG5lZWQgdGhlIGB1bmRlZmluZWRgIGNhc2VzIGZvciB0aGUgY2FtZXJhLXBhcmFtcz8gV2hlbiBhcmUgdGhleSB1c2VkIGluIHRoZSBtYXBzIEFQST9cbiAgT2JqZWN0LmFzc2lnbihyZWYuY3VycmVudCwge1xuICAgIGNlbnRlcjogKGNlbnRlciA9PSBudWxsID8gdm9pZCAwIDogY2VudGVyLnRvSlNPTigpKSB8fCB7XG4gICAgICBsYXQ6IDAsXG4gICAgICBsbmc6IDBcbiAgICB9LFxuICAgIHpvb206IHpvb20gfHwgMCxcbiAgICBoZWFkaW5nOiBoZWFkaW5nLFxuICAgIHRpbHQ6IHRpbHRcbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtdXRhYmxlIHJlZiBvYmplY3QgdG8gdHJhY2sgdGhlIGxhc3Qga25vd24gc3RhdGUgb2YgdGhlIG1hcCBjYW1lcmEuXG4gKiBUaGlzIGlzIHVzZWQgaW4gYHVzZU1hcENhbWVyYVBhcmFtc2AgdG8gcmVkdWNlIHN0dXR0ZXJpbmcgaW4gbm9ybWFsIG9wZXJhdGlvblxuICogYnkgYXZvaWRpbmcgdXBkYXRlcyBvZiB0aGUgbWFwIGNhbWVyYSB3aXRoIHZhbHVlcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZC5cbiAqL1xuZnVuY3Rpb24gdXNlVHJhY2tlZENhbWVyYVN0YXRlUmVmKG1hcCkge1xuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZih7XG4gICAgY2VudGVyOiB7XG4gICAgICBsYXQ6IDAsXG4gICAgICBsbmc6IDBcbiAgICB9LFxuICAgIGhlYWRpbmc6IDAsXG4gICAgdGlsdDogMCxcbiAgICB6b29tOiAwXG4gIH0pO1xuICAvLyBSZWNvcmQgY2FtZXJhIHN0YXRlIHdpdGggZXZlcnkgYm91bmRzX2NoYW5nZWQgZXZlbnQgZGlzcGF0Y2hlZCBieSB0aGUgbWFwLlxuICAvLyBUaGlzIGRhdGEgaXMgdXNlZCB0byBwcmV2ZW50IGZlZWRpbmcgdGhlc2UgdmFsdWVzIGJhY2sgdG8gdGhlXG4gIC8vIG1hcC1pbnN0YW5jZSB3aGVuIGEgdHlwaWNhbCBcImNvbnRyb2xsZWQgY29tcG9uZW50XCIgc2V0dXAgKHN0YXRlIHZhcmlhYmxlIGlzXG4gIC8vIGZlZCBpbnRvIGFuZCB1cGRhdGVkIGJ5IHRoZSBtYXApLlxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwKSByZXR1cm47XG4gICAgY29uc3QgbGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdib3VuZHNfY2hhbmdlZCcsICgpID0+IHtcbiAgICAgIGhhbmRsZUJvdW5kc0NoYW5nZShtYXAsIHJlZik7XG4gICAgICAvLyBXaGVuIGFuIGV2ZW50IGlzIG9jY3VyZWQsIHdlIGhhdmUgdG8gdXBkYXRlIGR1cmluZyB0aGUgbmV4dCBjeWNsZS5cbiAgICAgIC8vIFRoZSBhcHBsaWNhdGlvbiBjb3VsZCBkZWNpZGUgdG8gaWdub3JlIHRoZSBldmVudCBhbmQgbm90IHVwZGF0ZSBhbnlcbiAgICAgIC8vIGNhbWVyYSBwcm9wcyBvZiB0aGUgbWFwLCBtZWFuaW5nIHRoYXQgaW4gdGhhdCBjYXNlIHdlIHdpbGwgaGF2ZSB0b1xuICAgICAgLy8gJ3VuZG8nIHRoZSBjaGFuZ2UgdG8gdGhlIGNhbWVyYS5cbiAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVyLnJlbW92ZSgpO1xuICB9LCBbbWFwLCBmb3JjZVVwZGF0ZV0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5mdW5jdGlvbiB1c2VBcGlMb2FkaW5nU3RhdHVzKCkge1xuICB2YXIgX3VzZUNvbnRleHQ7XG4gIHJldHVybiAoKF91c2VDb250ZXh0ID0gdXNlQ29udGV4dChBUElQcm92aWRlckNvbnRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogX3VzZUNvbnRleHQuc3RhdHVzKSB8fCBBUElMb2FkaW5nU3RhdHVzLk5PVF9MT0FERUQ7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgaG9vayB0aGF0IHVwZGF0ZXMgdGhlIGNhbWVyYSB3aGVuIGRlY2suZ2wgdmlld1N0YXRlIGNoYW5nZXMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlRGVja0dMQ2FtZXJhVXBkYXRlKG1hcCwgcHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHZpZXdwb3J0LFxuICAgIHZpZXdTdGF0ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGlzRGVja0dsQ29udHJvbGxlZCA9ICEhdmlld3BvcnQ7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXAgfHwgIXZpZXdTdGF0ZSkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgYmVhcmluZzogaGVhZGluZyxcbiAgICAgIHBpdGNoOiB0aWx0LFxuICAgICAgem9vbVxuICAgIH0gPSB2aWV3U3RhdGU7XG4gICAgbWFwLm1vdmVDYW1lcmEoe1xuICAgICAgY2VudGVyOiB7XG4gICAgICAgIGxhdDogbGF0aXR1ZGUsXG4gICAgICAgIGxuZzogbG9uZ2l0dWRlXG4gICAgICB9LFxuICAgICAgaGVhZGluZyxcbiAgICAgIHRpbHQsXG4gICAgICB6b29tOiB6b29tICsgMVxuICAgIH0pO1xuICB9LCBbbWFwLCB2aWV3U3RhdGVdKTtcbiAgcmV0dXJuIGlzRGVja0dsQ29udHJvbGxlZDtcbn1cblxuZnVuY3Rpb24gaXNMYXRMbmdMaXRlcmFsKG9iaikge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICBpZiAoISgnbGF0JyBpbiBvYmogJiYgJ2xuZycgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG9iai5sYXQpICYmIE51bWJlci5pc0Zpbml0ZShvYmoubG5nKTtcbn1cbmZ1bmN0aW9uIGxhdExuZ0VxdWFscyhhLCBiKSB7XG4gIGlmICghYSB8fCAhYikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBBID0gdG9MYXRMbmdMaXRlcmFsKGEpO1xuICBjb25zdCBCID0gdG9MYXRMbmdMaXRlcmFsKGIpO1xuICBpZiAoQS5sYXQgIT09IEIubGF0IHx8IEEubG5nICE9PSBCLmxuZykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRvTGF0TG5nTGl0ZXJhbChvYmopIHtcbiAgaWYgKGlzTGF0TG5nTGl0ZXJhbChvYmopKSByZXR1cm4gb2JqO1xuICByZXR1cm4gb2JqLnRvSlNPTigpO1xufVxuXG5mdW5jdGlvbiB1c2VNYXBDYW1lcmFQYXJhbXMobWFwLCBjYW1lcmFTdGF0ZVJlZiwgbWFwUHJvcHMpIHtcbiAgY29uc3QgY2VudGVyID0gbWFwUHJvcHMuY2VudGVyID8gdG9MYXRMbmdMaXRlcmFsKG1hcFByb3BzLmNlbnRlcikgOiBudWxsO1xuICBsZXQgbGF0ID0gbnVsbDtcbiAgbGV0IGxuZyA9IG51bGw7XG4gIGlmIChjZW50ZXIgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sYXQpICYmIE51bWJlci5pc0Zpbml0ZShjZW50ZXIubG5nKSkge1xuICAgIGxhdCA9IGNlbnRlci5sYXQ7XG4gICAgbG5nID0gY2VudGVyLmxuZztcbiAgfVxuICBjb25zdCB6b29tID0gTnVtYmVyLmlzRmluaXRlKG1hcFByb3BzLnpvb20pID8gbWFwUHJvcHMuem9vbSA6IG51bGw7XG4gIGNvbnN0IGhlYWRpbmcgPSBOdW1iZXIuaXNGaW5pdGUobWFwUHJvcHMuaGVhZGluZykgPyBtYXBQcm9wcy5oZWFkaW5nIDogbnVsbDtcbiAgY29uc3QgdGlsdCA9IE51bWJlci5pc0Zpbml0ZShtYXBQcm9wcy50aWx0KSA/IG1hcFByb3BzLnRpbHQgOiBudWxsO1xuICAvLyB0aGUgZm9sbG93aW5nIGVmZmVjdCBydW5zIGZvciBldmVyeSByZW5kZXIgb2YgdGhlIG1hcCBjb21wb25lbnQgYW5kIGNoZWNrc1xuICAvLyBpZiB0aGVyZSBhcmUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUga25vd24gc3RhdGUgb2YgdGhlIG1hcCBpbnN0YW5jZVxuICAvLyAoY2FtZXJhU3RhdGVSZWYsIHdoaWNoIGlzIHVwZGF0ZWQgYnkgYWxsIGJvdW5kc19jaGFuZ2VkIGV2ZW50cykgYW5kIHRoZVxuICAvLyBkZXNpcmVkIHN0YXRlIGluIHRoZSBwcm9wcy5cbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcCkgcmV0dXJuO1xuICAgIGNvbnN0IG5leHRDYW1lcmEgPSB7fTtcbiAgICBsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICBpZiAobGF0ICE9PSBudWxsICYmIGxuZyAhPT0gbnVsbCAmJiAoY2FtZXJhU3RhdGVSZWYuY3VycmVudC5jZW50ZXIubGF0ICE9PSBsYXQgfHwgY2FtZXJhU3RhdGVSZWYuY3VycmVudC5jZW50ZXIubG5nICE9PSBsbmcpKSB7XG4gICAgICBuZXh0Q2FtZXJhLmNlbnRlciA9IHtcbiAgICAgICAgbGF0LFxuICAgICAgICBsbmdcbiAgICAgIH07XG4gICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh6b29tICE9PSBudWxsICYmIGNhbWVyYVN0YXRlUmVmLmN1cnJlbnQuem9vbSAhPT0gem9vbSkge1xuICAgICAgbmV4dENhbWVyYS56b29tID0gem9vbTtcbiAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhlYWRpbmcgIT09IG51bGwgJiYgY2FtZXJhU3RhdGVSZWYuY3VycmVudC5oZWFkaW5nICE9PSBoZWFkaW5nKSB7XG4gICAgICBuZXh0Q2FtZXJhLmhlYWRpbmcgPSBoZWFkaW5nO1xuICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGlsdCAhPT0gbnVsbCAmJiBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LnRpbHQgIT09IHRpbHQpIHtcbiAgICAgIG5leHRDYW1lcmEudGlsdCA9IHRpbHQ7XG4gICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgbWFwLm1vdmVDYW1lcmEobmV4dENhbWVyYSk7XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgQXV0aEZhaWx1cmVNZXNzYWdlID0gKCkgPT4ge1xuICBjb25zdCBzdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICBib3R0b206IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgekluZGV4OiA5OTksXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGZsZXhGbG93OiAnY29sdW1uIG5vd3JhcCcsXG4gICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgZm9udFNpemU6ICcuOHJlbScsXG4gICAgY29sb3I6ICdyZ2JhKDAsMCwwLDAuNiknLFxuICAgIGJhY2tncm91bmQ6ICcjZGRkZGRkJyxcbiAgICBwYWRkaW5nOiAnMXJlbSAxLjVyZW0nXG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHN0eWxlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaDJcIiwgbnVsbCwgXCJFcnJvcjogQXV0aEZhaWx1cmVcIiksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIkEgcHJvYmxlbSB3aXRoIHlvdXIgQVBJIGtleSBwcmV2ZW50cyB0aGUgbWFwIGZyb20gcmVuZGVyaW5nIGNvcnJlY3RseS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgdmFsdWUgb2YgdGhlIFwiLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwgbnVsbCwgXCJBUElQcm92aWRlci5hcGlLZXlcIiksIFwiIHByb3AgaXMgY29ycmVjdC4gQ2hlY2sgdGhlIGVycm9yLW1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgZm9yIGZ1cnRoZXIgZGV0YWlscy5cIikpO1xufTtcblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2tSZWYoKSB7XG4gIGNvbnN0IFtlbCwgc2V0RWxdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHJlZiA9IHVzZUNhbGxiYWNrKHZhbHVlID0+IHNldEVsKHZhbHVlKSwgW3NldEVsXSk7XG4gIHJldHVybiBbZWwsIHJlZl07XG59XG5cbi8qKlxuICogSG9vayB0byBjaGVjayBpZiB0aGUgR29vZ2xlIE1hcHMgQVBJIGlzIGxvYWRlZFxuICovXG5mdW5jdGlvbiB1c2VBcGlJc0xvYWRlZCgpIHtcbiAgY29uc3Qgc3RhdHVzID0gdXNlQXBpTG9hZGluZ1N0YXR1cygpO1xuICByZXR1cm4gc3RhdHVzID09PSBBUElMb2FkaW5nU3RhdHVzLkxPQURFRDtcbn1cblxuY29uc3QgX2V4Y2x1ZGVkJDIgPSBbXCJpZFwiLCBcImRlZmF1bHRCb3VuZHNcIiwgXCJkZWZhdWx0Q2VudGVyXCIsIFwiZGVmYXVsdFpvb21cIiwgXCJkZWZhdWx0SGVhZGluZ1wiLCBcImRlZmF1bHRUaWx0XCJdO1xuLyoqXG4gKiBUaGUgbWFpbiBob29rIHRha2VzIGNhcmUgb2YgY3JlYXRpbmcgbWFwLWluc3RhbmNlcyBhbmQgcmVnaXN0ZXJpbmcgdGhlbSBpblxuICogdGhlIGFwaS1wcm92aWRlciBjb250ZXh0LlxuICogQHJldHVybiBhIHR1cGxlIG9mIHRoZSBtYXAtaW5zdGFuY2UgY3JlYXRlZCAob3IgbnVsbCkgYW5kIHRoZSBjYWxsYmFja1xuICogICByZWYgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcGFzcyB0aGUgbWFwLWNvbnRhaW5lciBpbnRvIHRoaXMgaG9vay5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VNYXBJbnN0YW5jZShwcm9wcywgY29udGV4dCkge1xuICBjb25zdCBhcGlJc0xvYWRlZCA9IHVzZUFwaUlzTG9hZGVkKCk7XG4gIGNvbnN0IFttYXAsIHNldE1hcF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2NvbnRhaW5lciwgY29udGFpbmVyUmVmXSA9IHVzZUNhbGxiYWNrUmVmKCk7XG4gIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgZGVmYXVsdEJvdW5kcyxcbiAgICAgIGRlZmF1bHRDZW50ZXIsXG4gICAgICBkZWZhdWx0Wm9vbSxcbiAgICAgIGRlZmF1bHRIZWFkaW5nLFxuICAgICAgZGVmYXVsdFRpbHRcbiAgICB9ID0gcHJvcHMsXG4gICAgbWFwT3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkMik7XG4gIC8vIGFwcGx5IGRlZmF1bHQgY2FtZXJhIHByb3BzIGlmIGF2YWlsYWJsZSBhbmQgbm90IG92ZXJ3cml0dGVuIGJ5IGNvbnRyb2xsZWQgcHJvcHNcbiAgaWYgKCFtYXBPcHRpb25zLmNlbnRlciAmJiBkZWZhdWx0Q2VudGVyKSBtYXBPcHRpb25zLmNlbnRlciA9IGRlZmF1bHRDZW50ZXI7XG4gIGlmICghbWFwT3B0aW9ucy56b29tICYmIE51bWJlci5pc0Zpbml0ZShkZWZhdWx0Wm9vbSkpIG1hcE9wdGlvbnMuem9vbSA9IGRlZmF1bHRab29tO1xuICBpZiAoIW1hcE9wdGlvbnMuaGVhZGluZyAmJiBOdW1iZXIuaXNGaW5pdGUoZGVmYXVsdEhlYWRpbmcpKSBtYXBPcHRpb25zLmhlYWRpbmcgPSBkZWZhdWx0SGVhZGluZztcbiAgaWYgKCFtYXBPcHRpb25zLnRpbHQgJiYgTnVtYmVyLmlzRmluaXRlKGRlZmF1bHRUaWx0KSkgbWFwT3B0aW9ucy50aWx0ID0gZGVmYXVsdFRpbHQ7XG4gIC8vIGNyZWF0ZSB0aGUgbWFwIGluc3RhbmNlIGFuZCByZWdpc3RlciBpdCBpbiB0aGUgY29udGV4dFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY29udGFpbmVyIHx8ICFhcGlJc0xvYWRlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZE1hcEluc3RhbmNlLFxuICAgICAgcmVtb3ZlTWFwSW5zdGFuY2VcbiAgICB9ID0gY29udGV4dDtcbiAgICBjb25zdCBuZXdNYXAgPSBuZXcgZ29vZ2xlLm1hcHMuTWFwKGNvbnRhaW5lciwgbWFwT3B0aW9ucyk7XG4gICAgc2V0TWFwKG5ld01hcCk7XG4gICAgYWRkTWFwSW5zdGFuY2UobmV3TWFwLCBpZCk7XG4gICAgaWYgKGRlZmF1bHRCb3VuZHMpIHtcbiAgICAgIG5ld01hcC5maXRCb3VuZHMoZGVmYXVsdEJvdW5kcyk7XG4gICAgfVxuICAgIC8vIEZJWE1FOiBXaGVuIHRoZSBtYXBJZCBpcyBjaGFuZ2VkLCAgd2UgbmVlZCB0byBtYWludGFpbiB0aGUgY3VycmVudCBjYW1lcmEgcGFyYW1zLlxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIWNvbnRhaW5lciB8fCAhYXBpSXNMb2FkZWQpIHJldHVybjtcbiAgICAgIC8vIHJlbW92ZSBhbGwgZXZlbnQtbGlzdGVuZXJzIHRvIG1pbmltaXplIG1lbW9yeS1sZWFrc1xuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuY2xlYXJJbnN0YW5jZUxpc3RlbmVycyhuZXdNYXApO1xuICAgICAgc2V0TWFwKG51bGwpO1xuICAgICAgcmVtb3ZlTWFwSW5zdGFuY2UoaWQpO1xuICAgIH07XG4gIH0sXG4gIC8vIHNvbWUgZGVwZW5kZW5jaWVzIGFyZSBpZ25vcmVkIGluIHRoZSBsaXN0IGJlbG93OlxuICAvLyAgLSBkZWZhdWx0Qm91bmRzIGFuZCB0aGUgZGVmYXVsdCogY2FtZXJhIHByb3BzIHdpbGwgb25seSBiZSB1c2VkIG9uY2UsIGFuZFxuICAvLyAgICBjaGFuZ2VzIHNob3VsZCBiZSBpZ25vcmVkXG4gIC8vICAtIG1hcE9wdGlvbnMgaGFzIHNwZWNpYWwgaG9va3MgdGhhdCB0YWtlIGNhcmUgb2YgdXBkYXRpbmcgdGhlIG9wdGlvbnNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbY29udGFpbmVyLCBhcGlJc0xvYWRlZCwgaWQsIHByb3BzLm1hcElkXSk7XG4gIHJldHVybiBbbWFwLCBjb250YWluZXJSZWZdO1xufVxuXG5jb25zdCBHb29nbGVNYXBzQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBNYXAgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBpZCxcbiAgICBjbGFzc05hbWUsXG4gICAgc3R5bGVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBUElQcm92aWRlckNvbnRleHQpO1xuICBjb25zdCBsb2FkaW5nU3RhdHVzID0gdXNlQXBpTG9hZGluZ1N0YXR1cygpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJzxNYXA+IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIDxBcGlQcm92aWRlcj4gY29tcG9uZW50LicpO1xuICB9XG4gIGNvbnN0IFttYXAsIG1hcFJlZl0gPSB1c2VNYXBJbnN0YW5jZShwcm9wcywgY29udGV4dCk7XG4gIGNvbnN0IGNhbWVyYVN0YXRlUmVmID0gdXNlVHJhY2tlZENhbWVyYVN0YXRlUmVmKG1hcCk7XG4gIHVzZU1hcENhbWVyYVBhcmFtcyhtYXAsIGNhbWVyYVN0YXRlUmVmLCBwcm9wcyk7XG4gIHVzZU1hcEV2ZW50cyhtYXAsIHByb3BzKTtcbiAgdXNlTWFwT3B0aW9ucyhtYXAsIHByb3BzKTtcbiAgY29uc3QgaXNEZWNrR2xDb250cm9sbGVkID0gdXNlRGVja0dMQ2FtZXJhVXBkYXRlKG1hcCwgcHJvcHMpO1xuICBjb25zdCBpc0NvbnRyb2xsZWRFeHRlcm5hbGx5ID0gISFwcm9wcy5jb250cm9sbGVkO1xuICAvLyBkaXNhYmxlIGludGVyYWN0aW9ucyB3aXRoIHRoZSBtYXAgZm9yIGV4dGVybmFsbHkgY29udHJvbGxlZCBtYXBzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXApIHJldHVybjtcbiAgICAvLyBmaXhtZTogdGhpcyBkb2Vzbid0IHNlZW0gdG8gYmVsb25nIGhlcmUgKGFuZCBpdCdzIG1vc3RseSB0aGVyZSBmb3IgY29udmVuaWVuY2UgYW55d2F5KS5cbiAgICAvLyAgIFRoZSByZWFzb25pbmcgaXMgdGhhdCBhIGRlY2suZ2wgY2FudmFzIHdpbGwgYmUgcHV0IG9uIHRvcCBvZiB0aGUgbWFwLCByZW5kZXJpbmdcbiAgICAvLyAgIGFueSBkZWZhdWx0IG1hcCBjb250cm9scyBwcmV0dHkgbXVjaCB1c2VsZXNzXG4gICAgaWYgKGlzRGVja0dsQ29udHJvbGxlZCkge1xuICAgICAgbWFwLnNldE9wdGlvbnMoe1xuICAgICAgICBkaXNhYmxlRGVmYXVsdFVJOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gZGlzYWJsZSBhbGwgY29udHJvbC1pbnB1dHMgd2hlbiB0aGUgbWFwIGlzIGNvbnRyb2xsZWQgZXh0ZXJuYWxseVxuICAgIGlmIChpc0RlY2tHbENvbnRyb2xsZWQgfHwgaXNDb250cm9sbGVkRXh0ZXJuYWxseSkge1xuICAgICAgbWFwLnNldE9wdGlvbnMoe1xuICAgICAgICBnZXN0dXJlSGFuZGxpbmc6ICdub25lJyxcbiAgICAgICAga2V5Ym9hcmRTaG9ydGN1dHM6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG1hcC5zZXRPcHRpb25zKHtcbiAgICAgICAgZ2VzdHVyZUhhbmRsaW5nOiBwcm9wcy5nZXN0dXJlSGFuZGxpbmcsXG4gICAgICAgIGtleWJvYXJkU2hvcnRjdXRzOiBwcm9wcy5rZXlib2FyZFNob3J0Y3V0c1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW21hcCwgaXNEZWNrR2xDb250cm9sbGVkLCBpc0NvbnRyb2xsZWRFeHRlcm5hbGx5LCBwcm9wcy5nZXN0dXJlSGFuZGxpbmcsIHByb3BzLmtleWJvYXJkU2hvcnRjdXRzXSk7XG4gIC8vIHNldHVwIGEgc3RhYmxlIGNhbWVyYU9wdGlvbnMgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgZGVwZW5kZW5jeVxuICBjb25zdCBjZW50ZXIgPSBwcm9wcy5jZW50ZXIgPyB0b0xhdExuZ0xpdGVyYWwocHJvcHMuY2VudGVyKSA6IG51bGw7XG4gIGxldCBsYXQgPSBudWxsO1xuICBsZXQgbG5nID0gbnVsbDtcbiAgaWYgKGNlbnRlciAmJiBOdW1iZXIuaXNGaW5pdGUoY2VudGVyLmxhdCkgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sbmcpKSB7XG4gICAgbGF0ID0gY2VudGVyLmxhdDtcbiAgICBsbmcgPSBjZW50ZXIubG5nO1xuICB9XG4gIGNvbnN0IGNhbWVyYU9wdGlvbnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICB2YXIgX2xhdCwgX2xuZywgX3Byb3BzJHpvb20sIF9wcm9wcyRoZWFkaW5nLCBfcHJvcHMkdGlsdDtcbiAgICByZXR1cm4ge1xuICAgICAgY2VudGVyOiB7XG4gICAgICAgIGxhdDogKF9sYXQgPSBsYXQpICE9IG51bGwgPyBfbGF0IDogMCxcbiAgICAgICAgbG5nOiAoX2xuZyA9IGxuZykgIT0gbnVsbCA/IF9sbmcgOiAwXG4gICAgICB9LFxuICAgICAgem9vbTogKF9wcm9wcyR6b29tID0gcHJvcHMuem9vbSkgIT0gbnVsbCA/IF9wcm9wcyR6b29tIDogMCxcbiAgICAgIGhlYWRpbmc6IChfcHJvcHMkaGVhZGluZyA9IHByb3BzLmhlYWRpbmcpICE9IG51bGwgPyBfcHJvcHMkaGVhZGluZyA6IDAsXG4gICAgICB0aWx0OiAoX3Byb3BzJHRpbHQgPSBwcm9wcy50aWx0KSAhPSBudWxsID8gX3Byb3BzJHRpbHQgOiAwXG4gICAgfTtcbiAgfSwgW2xhdCwgbG5nLCBwcm9wcy56b29tLCBwcm9wcy5oZWFkaW5nLCBwcm9wcy50aWx0XSk7XG4gIC8vIGV4dGVybmFsbHkgY29udHJvbGxlZCBtb2RlOiByZWplY3QgYWxsIGNhbWVyYSBjaGFuZ2VzIHRoYXQgZG9uJ3QgY29ycmVzcG9uZCB0byBjaGFuZ2VzIGluIHByb3BzXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXAgfHwgIWlzQ29udHJvbGxlZEV4dGVybmFsbHkpIHJldHVybjtcbiAgICBtYXAubW92ZUNhbWVyYShjYW1lcmFPcHRpb25zKTtcbiAgICBjb25zdCBsaXN0ZW5lciA9IG1hcC5hZGRMaXN0ZW5lcignYm91bmRzX2NoYW5nZWQnLCAoKSA9PiB7XG4gICAgICBtYXAubW92ZUNhbWVyYShjYW1lcmFPcHRpb25zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXIucmVtb3ZlKCk7XG4gIH0sIFttYXAsIGlzQ29udHJvbGxlZEV4dGVybmFsbHksIGNhbWVyYU9wdGlvbnNdKTtcbiAgY29uc3QgY29tYmluZWRTdHlsZSA9IHVzZU1lbW8oKCkgPT4gX2V4dGVuZHMoe1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgLy8gd2hlbiB1c2luZyBkZWNrZ2wsIHRoZSBtYXAgc2hvdWxkIGJlIHNlbnQgdG8gdGhlIGJhY2tcbiAgICB6SW5kZXg6IGlzRGVja0dsQ29udHJvbGxlZCA/IC0xIDogMFxuICB9LCBzdHlsZSksIFtzdHlsZSwgaXNEZWNrR2xDb250cm9sbGVkXSk7XG4gIGlmIChsb2FkaW5nU3RhdHVzID09PSBBUElMb2FkaW5nU3RhdHVzLkFVVEhfRkFJTFVSRSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBzdHlsZTogX2V4dGVuZHMoe1xuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgfSwgY2xhc3NOYW1lID8ge30gOiBjb21iaW5lZFN0eWxlKSxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXV0aEZhaWx1cmVNZXNzYWdlLCBudWxsKSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICByZWY6IG1hcFJlZixcbiAgICBcImRhdGEtdGVzdGlkXCI6ICdtYXAnLFxuICAgIHN0eWxlOiBjbGFzc05hbWUgPyB1bmRlZmluZWQgOiBjb21iaW5lZFN0eWxlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0sIGlkID8ge1xuICAgIGlkXG4gIH0gOiB7fSksIG1hcCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEdvb2dsZU1hcHNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIG1hcFxuICAgIH1cbiAgfSwgY2hpbGRyZW4pIDogbnVsbCk7XG59O1xuTWFwLmRlY2tHTFZpZXdQcm9wcyA9IHRydWU7XG5cbmZ1bmN0aW9uIHVzZU1hcHNMaWJyYXJ5KG5hbWUpIHtcbiAgY29uc3QgYXBpSXNMb2FkZWQgPSB1c2VBcGlJc0xvYWRlZCgpO1xuICBjb25zdCBjdHggPSB1c2VDb250ZXh0KEFQSVByb3ZpZGVyQ29udGV4dCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFhcGlJc0xvYWRlZCB8fCAhY3R4KSByZXR1cm47XG4gICAgLy8gVHJpZ2dlciBsb2FkaW5nIHRoZSBsaWJyYXJpZXMgdmlhIG91ciBwcm94eS1tZXRob2QuXG4gICAgLy8gVGhlIHJldHVybmVkIHByb21pc2UgaXMgaWdub3JlZCwgc2luY2UgaW1wb3J0TGlicmFyeSB3aWxsIHVwZGF0ZSBsb2FkZWRMaWJyYXJpZXNcbiAgICAvLyBsaXN0IGluIHRoZSBjb250ZXh0LCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyLlxuICAgIHZvaWQgY3R4LmltcG9ydExpYnJhcnkobmFtZSk7XG4gIH0sIFthcGlJc0xvYWRlZCwgY3R4LCBuYW1lXSk7XG4gIHJldHVybiAoY3R4ID09IG51bGwgPyB2b2lkIDAgOiBjdHgubG9hZGVkTGlicmFyaWVzW25hbWVdKSB8fCBudWxsO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG5jb25zdCBBZHZhbmNlZE1hcmtlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gdXNlQWR2YW5jZWRNYXJrZXIocHJvcHMpIHtcbiAgdmFyIF91c2VDb250ZXh0O1xuICBjb25zdCBbbWFya2VyLCBzZXRNYXJrZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjb250ZW50Q29udGFpbmVyLCBzZXRDb250ZW50Q29udGFpbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBtYXAgPSAoX3VzZUNvbnRleHQgPSB1c2VDb250ZXh0KEdvb2dsZU1hcHNDb250ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF91c2VDb250ZXh0Lm1hcDtcbiAgY29uc3QgbWFya2VyTGlicmFyeSA9IHVzZU1hcHNMaWJyYXJ5KCdtYXJrZXInKTtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZSxcbiAgICBvbkNsaWNrLFxuICAgIG9uRHJhZyxcbiAgICBvbkRyYWdTdGFydCxcbiAgICBvbkRyYWdFbmQsXG4gICAgY29sbGlzaW9uQmVoYXZpb3IsXG4gICAgZHJhZ2dhYmxlLFxuICAgIHBvc2l0aW9uLFxuICAgIHRpdGxlLFxuICAgIHpJbmRleFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IG51bUNoaWxkcyA9IENoaWxkcmVuLmNvdW50KGNoaWxkcmVuKTtcbiAgLy8gY3JlYXRlIG1hcmtlciBpbnN0YW5jZSBhbmQgYWRkIGl0IHRvIHRoZSBtYXAgd2hlbiBtYXAgYmVjb21lcyBhdmFpbGFibGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcCB8fCAhbWFya2VyTGlicmFyeSkgcmV0dXJuO1xuICAgIGNvbnN0IG5ld01hcmtlciA9IG5ldyBtYXJrZXJMaWJyYXJ5LkFkdmFuY2VkTWFya2VyRWxlbWVudCgpO1xuICAgIG5ld01hcmtlci5tYXAgPSBtYXA7XG4gICAgc2V0TWFya2VyKG5ld01hcmtlcik7XG4gICAgLy8gY3JlYXRlIGNvbnRhaW5lciBmb3IgbWFya2VyIGNvbnRlbnQgaWYgdGhlcmUgYXJlIGNoaWxkcmVuXG4gICAgaWYgKG51bUNoaWxkcyA+IDApIHtcbiAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBpZiAoY2xhc3NOYW1lKSBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICBuZXdNYXJrZXIuY29udGVudCA9IGVsO1xuICAgICAgc2V0Q29udGVudENvbnRhaW5lcihlbCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBuZXdNYXJrZXIubWFwID0gbnVsbDtcbiAgICAgIHNldE1hcmtlcihudWxsKTtcbiAgICAgIHNldENvbnRlbnRDb250YWluZXIobnVsbCk7XG4gICAgfTtcbiAgICAvLyBXZSBkbyBub3Qgd2FudCB0byByZS1yZW5kZXIgdGhlIHdob2xlIG1hcmtlciB3aGVuIHRoZSBjbGFzc05hbWUgY2hhbmdlc1xuICAgIC8vIGJlY2F1c2UgdGhhdCBjYXVzZXMgYSBzaG9ydCBmbGlja2VyaW5nIG9mIHRoZSBtYXJrZXIuXG4gICAgLy8gVGhlIGNsYXNzTmFtZSB1cGRhdGUgaXMgaGFuZGxlZCBpbiB0aGUgdXNlRWZmZWN0IGJlbG93LlxuICAgIC8vIEV4Y2x1ZGluZyB0aGUgY2xhc3NOYW1lIGZyb20gdGhlIGRlcGVuZGVuY3kgYXJyYXkgb25tIHB1cnBvc2UgaGVyZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW21hcCwgbWFya2VyTGlicmFyeSwgbnVtQ2hpbGRzXSk7XG4gIC8vIHVwZGF0ZSBjbGFzc05hbWUgb2YgYWR2YW5jZWQgbWFya2VyIGVsZW1lbnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNvbnRlbnRDb250YWluZXIpIHJldHVybjtcbiAgICBjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSAhPSBudWxsID8gY2xhc3NOYW1lIDogJyc7XG4gIH0sIFtjb250ZW50Q29udGFpbmVyLCBjbGFzc05hbWVdKTtcbiAgLy8gYmluZCBhbGwgbWFya2VyIGV2ZW50c1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFya2VyKSByZXR1cm47XG4gICAgY29uc3QgZ21lID0gZ29vZ2xlLm1hcHMuZXZlbnQ7XG4gICAgaWYgKG9uQ2xpY2spIGdtZS5hZGRMaXN0ZW5lcihtYXJrZXIsICdjbGljaycsIG9uQ2xpY2spO1xuICAgIGlmIChvbkRyYWcpIGdtZS5hZGRMaXN0ZW5lcihtYXJrZXIsICdkcmFnJywgb25EcmFnKTtcbiAgICBpZiAob25EcmFnU3RhcnQpIGdtZS5hZGRMaXN0ZW5lcihtYXJrZXIsICdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCk7XG4gICAgaWYgKG9uRHJhZ0VuZCkgZ21lLmFkZExpc3RlbmVyKG1hcmtlciwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpO1xuICAgIGlmICgob25EcmFnIHx8IG9uRHJhZ1N0YXJ0IHx8IG9uRHJhZ0VuZCkgJiYgIWRyYWdnYWJsZSkge1xuICAgICAgY29uc29sZS53YXJuKCdZb3UgbmVlZCB0byBzZXQgdGhlIG1hcmtlciB0byBkcmFnZ2FibGUgdG8gbGlzdGVuIHRvIGRyYWctZXZlbnRzLicpO1xuICAgIH1cbiAgICBjb25zdCBtID0gbWFya2VyO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBnbWUuY2xlYXJJbnN0YW5jZUxpc3RlbmVycyhtKTtcbiAgICB9O1xuICB9LCBbbWFya2VyLCBkcmFnZ2FibGUsIG9uQ2xpY2ssIG9uRHJhZ1N0YXJ0LCBvbkRyYWcsIG9uRHJhZ0VuZF0pO1xuICAvLyB1cGRhdGUgb3RoZXIgbWFya2VyIHByb3BzIHdoZW4gY2hhbmdlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFya2VyKSByZXR1cm47XG4gICAgaWYgKHBvc2l0aW9uICE9PSB1bmRlZmluZWQpIG1hcmtlci5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIGlmIChkcmFnZ2FibGUgIT09IHVuZGVmaW5lZCkgbWFya2VyLmdtcERyYWdnYWJsZSA9IGRyYWdnYWJsZTtcbiAgICBpZiAoY29sbGlzaW9uQmVoYXZpb3IgIT09IHVuZGVmaW5lZCkgbWFya2VyLmNvbGxpc2lvbkJlaGF2aW9yID0gY29sbGlzaW9uQmVoYXZpb3I7XG4gICAgaWYgKHpJbmRleCAhPT0gdW5kZWZpbmVkKSBtYXJrZXIuekluZGV4ID0gekluZGV4O1xuICAgIGlmICh0eXBlb2YgdGl0bGUgPT09ICdzdHJpbmcnKSBtYXJrZXIudGl0bGUgPSB0aXRsZTtcbiAgfSwgW21hcmtlciwgcG9zaXRpb24sIGRyYWdnYWJsZSwgY29sbGlzaW9uQmVoYXZpb3IsIHpJbmRleCwgdGl0bGVdKTtcbiAgcmV0dXJuIFttYXJrZXIsIGNvbnRlbnRDb250YWluZXJdO1xufVxuY29uc3QgQWR2YW5jZWRNYXJrZXIgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlblxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFttYXJrZXIsIGNvbnRlbnRDb250YWluZXJdID0gdXNlQWR2YW5jZWRNYXJrZXIocHJvcHMpO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gbWFya2VyLCBbbWFya2VyXSk7XG4gIGlmICghbWFya2VyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFkdmFuY2VkTWFya2VyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB7XG4gICAgICBtYXJrZXJcbiAgICB9XG4gIH0sIGNvbnRlbnRDb250YWluZXIgIT09IG51bGwgJiYgY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250ZW50Q29udGFpbmVyKSk7XG59KTtcbmZ1bmN0aW9uIHVzZUFkdmFuY2VkTWFya2VyUmVmKCkge1xuICBjb25zdCBbbWFya2VyLCBzZXRNYXJrZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHJlZkNhbGxiYWNrID0gdXNlQ2FsbGJhY2sobSA9PiB7XG4gICAgc2V0TWFya2VyKG0pO1xuICB9LCBbXSk7XG4gIHJldHVybiBbcmVmQ2FsbGJhY2ssIG1hcmtlcl07XG59XG5cbmNvbnN0IF9leGNsdWRlZCQxID0gW1wiY2hpbGRyZW5cIiwgXCJhbmNob3JcIiwgXCJvbkNsb3NlQ2xpY2tcIl07XG4vKipcbiAqIENvbXBvbmVudCB0byByZW5kZXIgYSBHb29nbGUgTWFwcyBJbmZvIFdpbmRvd1xuICovXG5jb25zdCBJbmZvV2luZG93ID0gcHJvcHMgPT4ge1xuICB2YXIgX3VzZUNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgYW5jaG9yLFxuICAgICAgb25DbG9zZUNsaWNrXG4gICAgfSA9IHByb3BzLFxuICAgIGluZm9XaW5kb3dPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCQxKTtcbiAgY29uc3QgbWFwID0gKF91c2VDb250ZXh0ID0gdXNlQ29udGV4dChHb29nbGVNYXBzQ29udGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfdXNlQ29udGV4dC5tYXA7XG4gIGNvbnN0IGluZm9XaW5kb3dSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtjb250ZW50Q29udGFpbmVyLCBzZXRDb250ZW50Q29udGFpbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICAvLyBjcmVhdGUgaW5mb3dpbmRvdyBvbmNlIG1hcCBpcyBhdmFpbGFibGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcCkgcmV0dXJuO1xuICAgIGNvbnN0IG5ld0luZm93aW5kb3cgPSBuZXcgZ29vZ2xlLm1hcHMuSW5mb1dpbmRvdyhpbmZvV2luZG93T3B0aW9ucyk7XG4gICAgLy8gQWRkIGNvbnRlbnQgdG8gaW5mbyB3aW5kb3dcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIG5ld0luZm93aW5kb3cuc2V0Q29udGVudChlbCk7XG4gICAgaW5mb1dpbmRvd1JlZi5jdXJyZW50ID0gbmV3SW5mb3dpbmRvdztcbiAgICBzZXRDb250ZW50Q29udGFpbmVyKGVsKTtcbiAgICAvLyBDbGVhbnVwIGluZm8gd2luZG93IGFuZCBldmVudCBsaXN0ZW5lcnMgb24gdW5tb3VudFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBnb29nbGUubWFwcy5ldmVudC5jbGVhckluc3RhbmNlTGlzdGVuZXJzKG5ld0luZm93aW5kb3cpO1xuICAgICAgbmV3SW5mb3dpbmRvdy5jbG9zZSgpO1xuICAgICAgZWwucmVtb3ZlKCk7XG4gICAgICBzZXRDb250ZW50Q29udGFpbmVyKG51bGwpO1xuICAgIH07XG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZS1yZW5kZXIgYSB3aG9sZSBuZXcgaW5mb3dpbmRvd1xuICAgIC8vIHdoZW4gdGhlIG9wdGlvbnMgY2hhbmdlIHRvIHByZXZlbnQgZmxpY2tlcmluZy5cbiAgICAvLyBVcGRhdGUgb2YgaW5mb1dpbmRvdyBvcHRpb25zIGlzIGhhbmRsZWQgaW4gdGhlIHVzZUVmZmVjdCBiZWxvdy5cbiAgICAvLyBFeGNsdWRpbmcgaW5mb1dpbmRvd09wdGlvbnMgZnJvbSBkZXBlbmRlbmN5IGFycmF5IG9uIHB1cnBvc2UgaGVyZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFttYXAsIGNoaWxkcmVuXSk7XG4gIC8vIFVwZGF0ZSBpbmZvV2luZG93T3B0aW9uc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBfaW5mb1dpbmRvd1JlZiRjdXJyZW47XG4gICAgKF9pbmZvV2luZG93UmVmJGN1cnJlbiA9IGluZm9XaW5kb3dSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfaW5mb1dpbmRvd1JlZiRjdXJyZW4uc2V0T3B0aW9ucyhpbmZvV2luZG93T3B0aW9ucyk7XG4gIH0sIFtpbmZvV2luZG93T3B0aW9uc10pO1xuICAvLyBIYW5kbGUgdGhlIGNsb3NlIGNsaWNrIGNhbGxiYWNrXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpbmZvV2luZG93UmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBsZXQgbGlzdGVuZXIgPSBudWxsO1xuICAgIGlmIChvbkNsb3NlQ2xpY2spIHtcbiAgICAgIGxpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5mb1dpbmRvd1JlZi5jdXJyZW50LCAnY2xvc2VjbGljaycsIG9uQ2xvc2VDbGljayk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAobGlzdGVuZXIpIGxpc3RlbmVyLnJlbW92ZSgpO1xuICAgIH07XG4gIH0sIFtvbkNsb3NlQ2xpY2tdKTtcbiAgLy8gT3BlbiBpbmZvIHdpbmRvdyBhZnRlciBjb250ZW50IGNvbnRhaW5lciBpcyBzZXRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBhbmNob3IgPT09IG51bGwgbWVhbnMgYW4gYW5jaG9yIGlzIGRlZmluZWQgYnV0IG5vdCByZWFkeSB5ZXQuXG4gICAgaWYgKCFjb250ZW50Q29udGFpbmVyIHx8ICFpbmZvV2luZG93UmVmLmN1cnJlbnQgfHwgYW5jaG9yID09PSBudWxsKSByZXR1cm47XG4gICAgY29uc3Qgb3Blbk9wdGlvbnMgPSB7XG4gICAgICBtYXBcbiAgICB9O1xuICAgIGlmIChhbmNob3IpIHtcbiAgICAgIG9wZW5PcHRpb25zLmFuY2hvciA9IGFuY2hvcjtcbiAgICB9XG4gICAgaW5mb1dpbmRvd1JlZi5jdXJyZW50Lm9wZW4ob3Blbk9wdGlvbnMpO1xuICB9LCBbY29udGVudENvbnRhaW5lciwgaW5mb1dpbmRvd1JlZiwgYW5jaG9yLCBtYXBdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjb250ZW50Q29udGFpbmVyICE9PSBudWxsICYmIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGVudENvbnRhaW5lcikpO1xufTtcblxuY29uc3Qgc2hvd25NZXNzYWdlcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGxvZ0Vycm9yT25jZSguLi5hcmdzKSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xuICBpZiAoIXNob3duTWVzc2FnZXMuaGFzKGtleSkpIHtcbiAgICBzaG93bk1lc3NhZ2VzLmFkZChrZXkpO1xuICAgIGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBtYXAtaW5zdGFuY2UgZnJvbSB0aGUgY29udGV4dC4gVGhpcyBpcyBlaXRoZXIgYW4gaW5zdGFuY2VcbiAqIGlkZW50aWZpZWQgYnkgaWQgb3IgdGhlIHBhcmVudCBtYXAgaW5zdGFuY2UgaWYgbm8gaWQgaXMgc3BlY2lmaWVkLlxuICogUmV0dXJucyBudWxsIGlmIG5laXRoZXIgY2FuIGJlIGZvdW5kLlxuICovXG5jb25zdCB1c2VNYXAgPSAoaWQgPSBudWxsKSA9PiB7XG4gIGNvbnN0IGN0eCA9IHVzZUNvbnRleHQoQVBJUHJvdmlkZXJDb250ZXh0KTtcbiAgY29uc3Qge1xuICAgIG1hcFxuICB9ID0gdXNlQ29udGV4dChHb29nbGVNYXBzQ29udGV4dCkgfHwge307XG4gIGlmIChjdHggPT09IG51bGwpIHtcbiAgICBsb2dFcnJvck9uY2UoJ3VzZU1hcCgpOiBmYWlsZWQgdG8gcmV0cmlldmUgQVBJUHJvdmlkZXJDb250ZXh0LiAnICsgJ01ha2Ugc3VyZSB0aGF0IHRoZSA8QVBJUHJvdmlkZXI+IGNvbXBvbmVudCBleGlzdHMgYW5kIHRoYXQgdGhlICcgKyAnY29tcG9uZW50IHlvdSBhcmUgY2FsbGluZyBgdXNlTWFwKClgIGZyb20gaXMgYSBzaWJsaW5nIG9mIHRoZSAnICsgJzxBUElQcm92aWRlcj4uJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qge1xuICAgIG1hcEluc3RhbmNlc1xuICB9ID0gY3R4O1xuICAvLyBpZiBhbiBpZCBpcyBzcGVjaWZpZWQsIHRoZSBjb3JyZXNwb25kaW5nIG1hcCBvciBudWxsIGlzIHJldHVybmVkXG4gIGlmIChpZCAhPT0gbnVsbCkgcmV0dXJuIG1hcEluc3RhbmNlc1tpZF0gfHwgbnVsbDtcbiAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gdGhlIGNsb3Nlc3QgYW5jZXN0b3JcbiAgaWYgKG1hcCkgcmV0dXJuIG1hcDtcbiAgLy8gZmluYWxseSwgcmV0dXJuIHRoZSBkZWZhdWx0IG1hcCBpbnN0YW5jZVxuICByZXR1cm4gbWFwSW5zdGFuY2VzWydkZWZhdWx0J10gfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQ29weSBvZiB0aGUgYGdvb2dsZS5tYXBzLkNvbnRyb2xQb3NpdGlvbmAgY29uc3RhbnRzLlxuICogVGhleSBoYXZlIHRvIGJlIGR1cGxpY2F0ZWQgaGVyZSBzaW5jZSB3ZSBjYW4ndCB3YWl0IGZvciB0aGUgbWFwcyBBUEkgdG8gbG9hZCB0byBiZSBhYmxlIHRvIHVzZSB0aGVtLlxuICovXG5jb25zdCBDb250cm9sUG9zaXRpb24gPSB7XG4gIFRPUF9MRUZUOiAxLFxuICBUT1BfQ0VOVEVSOiAyLFxuICBUT1A6IDIsXG4gIFRPUF9SSUdIVDogMyxcbiAgTEVGVF9DRU5URVI6IDQsXG4gIExFRlRfVE9QOiA1LFxuICBMRUZUOiA1LFxuICBMRUZUX0JPVFRPTTogNixcbiAgUklHSFRfVE9QOiA3LFxuICBSSUdIVDogNyxcbiAgUklHSFRfQ0VOVEVSOiA4LFxuICBSSUdIVF9CT1RUT006IDksXG4gIEJPVFRPTV9MRUZUOiAxMCxcbiAgQk9UVE9NX0NFTlRFUjogMTEsXG4gIEJPVFRPTTogMTEsXG4gIEJPVFRPTV9SSUdIVDogMTIsXG4gIENFTlRFUjogMTMsXG4gIEJMT0NLX1NUQVJUX0lOTElORV9TVEFSVDogMTQsXG4gIEJMT0NLX1NUQVJUX0lOTElORV9DRU5URVI6IDE1LFxuICBCTE9DS19TVEFSVF9JTkxJTkVfRU5EOiAxNixcbiAgSU5MSU5FX1NUQVJUX0JMT0NLX0NFTlRFUjogMTcsXG4gIElOTElORV9TVEFSVF9CTE9DS19TVEFSVDogMTgsXG4gIElOTElORV9TVEFSVF9CTE9DS19FTkQ6IDE5LFxuICBJTkxJTkVfRU5EX0JMT0NLX1NUQVJUOiAyMCxcbiAgSU5MSU5FX0VORF9CTE9DS19DRU5URVI6IDIxLFxuICBJTkxJTkVfRU5EX0JMT0NLX0VORDogMjIsXG4gIEJMT0NLX0VORF9JTkxJTkVfU1RBUlQ6IDIzLFxuICBCTE9DS19FTkRfSU5MSU5FX0NFTlRFUjogMjQsXG4gIEJMT0NLX0VORF9JTkxJTkVfRU5EOiAyNVxufTtcbmNvbnN0IE1hcENvbnRyb2wgPSAoe1xuICBjaGlsZHJlbixcbiAgcG9zaXRpb25cbn0pID0+IHtcbiAgY29uc3QgY29udHJvbENvbnRhaW5lciA9IHVzZU1lbW8oKCkgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIFtdKTtcbiAgY29uc3QgbWFwID0gdXNlTWFwKCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXApIHJldHVybjtcbiAgICBjb25zdCBjb250cm9scyA9IG1hcC5jb250cm9sc1twb3NpdGlvbl07XG4gICAgY29udHJvbHMucHVzaChjb250cm9sQ29udGFpbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBjb250cm9scy5nZXRBcnJheSgpLmluZGV4T2YoY29udHJvbENvbnRhaW5lcik7XG4gICAgICBjb250cm9scy5yZW1vdmVBdChpbmRleCk7XG4gICAgfTtcbiAgfSwgW2NvbnRyb2xDb250YWluZXIsIG1hcCwgcG9zaXRpb25dKTtcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udHJvbENvbnRhaW5lcik7XG59O1xuXG5jb25zdCBfZXhjbHVkZWQgPSBbXCJvbkNsaWNrXCIsIFwib25EcmFnXCIsIFwib25EcmFnU3RhcnRcIiwgXCJvbkRyYWdFbmRcIiwgXCJvbk1vdXNlT3ZlclwiLCBcIm9uTW91c2VPdXRcIl07XG5mdW5jdGlvbiB1c2VNYXJrZXIocHJvcHMpIHtcbiAgdmFyIF91c2VDb250ZXh0O1xuICBjb25zdCBbbWFya2VyLCBzZXRNYXJrZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IG1hcCA9IChfdXNlQ29udGV4dCA9IHVzZUNvbnRleHQoR29vZ2xlTWFwc0NvbnRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogX3VzZUNvbnRleHQubWFwO1xuICBjb25zdCB7XG4gICAgICBvbkNsaWNrLFxuICAgICAgb25EcmFnLFxuICAgICAgb25EcmFnU3RhcnQsXG4gICAgICBvbkRyYWdFbmQsXG4gICAgICBvbk1vdXNlT3ZlcixcbiAgICAgIG9uTW91c2VPdXRcbiAgICB9ID0gcHJvcHMsXG4gICAgbWFya2VyT3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQpO1xuICBjb25zdCB7XG4gICAgcG9zaXRpb24sXG4gICAgZHJhZ2dhYmxlXG4gIH0gPSBtYXJrZXJPcHRpb25zO1xuICAvLyBjcmVhdGUgbWFya2VyIGluc3RhbmNlIGFuZCBhZGQgdG8gdGhlIG1hcCBvbmNlIHRoZSBtYXAgaXMgYXZhaWxhYmxlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXApIHtcbiAgICAgIGlmIChtYXAgPT09IHVuZGVmaW5lZCkgY29uc29sZS5lcnJvcignPE1hcmtlcj4gaGFzIHRvIGJlIGluc2lkZSBhIE1hcCBjb21wb25lbnQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld01hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIobWFya2VyT3B0aW9ucyk7XG4gICAgbmV3TWFya2VyLnNldE1hcChtYXApO1xuICAgIHNldE1hcmtlcihuZXdNYXJrZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBuZXdNYXJrZXIuc2V0TWFwKG51bGwpO1xuICAgICAgc2V0TWFya2VyKG51bGwpO1xuICAgIH07XG4gICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gcmUtcmVuZGVyIHRoZSB3aG9sZSBtYXJrZXIgd2hlbiB0aGUgb3B0aW9ucyBjaGFuZ2UuXG4gICAgLy8gTWFya2VyIG9wdGlvbnMgdXBkYXRlIGlzIGhhbmRsZWQgaW4gYSB1c2VFZmZlY3QgYmVsb3cuXG4gICAgLy8gRXhjbHVkaW5nIG1hcmtlck9wdGlvbnMgZnJvbSBkZXBlbmRlbmN5IGFycmF5IG9uIHB1cnBvc2UgaGVyZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFttYXBdKTtcbiAgLy8gYXR0YWNoIGFuZCByZS1hdHRhY2ggZXZlbnQtaGFuZGxlcnMgd2hlbiBhbnkgb2YgdGhlIHByb3BlcnRpZXMgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXIpIHJldHVybjtcbiAgICBjb25zdCBtID0gbWFya2VyO1xuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICBjb25zdCBnbWUgPSBnb29nbGUubWFwcy5ldmVudDtcbiAgICBpZiAob25DbGljaykgZ21lLmFkZExpc3RlbmVyKG0sICdjbGljaycsIG9uQ2xpY2spO1xuICAgIGlmIChvbkRyYWcpIGdtZS5hZGRMaXN0ZW5lcihtLCAnZHJhZycsIG9uRHJhZyk7XG4gICAgaWYgKG9uRHJhZ1N0YXJ0KSBnbWUuYWRkTGlzdGVuZXIobSwgJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KTtcbiAgICBpZiAob25EcmFnRW5kKSBnbWUuYWRkTGlzdGVuZXIobSwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpO1xuICAgIGlmIChvbk1vdXNlT3ZlcikgZ21lLmFkZExpc3RlbmVyKG0sICdtb3VzZW92ZXInLCBvbk1vdXNlT3Zlcik7XG4gICAgaWYgKG9uTW91c2VPdXQpIGdtZS5hZGRMaXN0ZW5lcihtLCAnbW91c2VvdXQnLCBvbk1vdXNlT3V0KTtcbiAgICBtYXJrZXIuc2V0RHJhZ2dhYmxlKEJvb2xlYW4oZHJhZ2dhYmxlKSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGdtZS5jbGVhckluc3RhbmNlTGlzdGVuZXJzKG0pO1xuICAgIH07XG4gIH0sIFttYXJrZXIsIGRyYWdnYWJsZSwgb25DbGljaywgb25EcmFnLCBvbkRyYWdTdGFydCwgb25EcmFnRW5kLCBvbk1vdXNlT3Zlciwgb25Nb3VzZU91dF0pO1xuICAvLyB1cGRhdGUgbWFya2VyT3B0aW9ucyAobm90ZSB0aGUgZGVwZW5kZW5jaWVzIGFyZW4ndCBwcm9wZXJseSBjaGVja2VkXG4gIC8vIGhlcmUsIHdlIGp1c3QgYXNzdW1lIHRoYXQgc2V0T3B0aW9ucyBpcyBzbWFydCBlbm91Z2ggdG8gbm90IHdhc3RlIGFcbiAgLy8gbG90IG9mIHRpbWUgdXBkYXRpbmcgdmFsdWVzIHRoYXQgZGlkbid0IGNoYW5nZSlcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcmtlcikgcmV0dXJuO1xuICAgIGlmIChtYXJrZXJPcHRpb25zKSBtYXJrZXIuc2V0T3B0aW9ucyhtYXJrZXJPcHRpb25zKTtcbiAgfSwgW21hcmtlciwgbWFya2VyT3B0aW9uc10pO1xuICAvLyB1cGRhdGUgcG9zaXRpb24gd2hlbiBjaGFuZ2VkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gU2hvdWxkIG5vdCB1cGRhdGUgcG9zaXRpb24gd2hlbiBkcmFnZ2FibGVcbiAgICBpZiAoZHJhZ2dhYmxlIHx8ICFwb3NpdGlvbiB8fCAhbWFya2VyKSByZXR1cm47XG4gICAgbWFya2VyLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgfSwgW2RyYWdnYWJsZSwgcG9zaXRpb24sIG1hcmtlcl0pO1xuICByZXR1cm4gbWFya2VyO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdG8gcmVuZGVyIGEgR29vZ2xlIE1hcHMgTWFya2VyIG9uIGEgbWFwXG4gKi9cbmNvbnN0IE1hcmtlciA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgbWFya2VyID0gdXNlTWFya2VyKHByb3BzKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IG1hcmtlciwgW21hcmtlcl0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwpO1xufSk7XG5mdW5jdGlvbiB1c2VNYXJrZXJSZWYoKSB7XG4gIGNvbnN0IFttYXJrZXIsIHNldE1hcmtlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgcmVmQ2FsbGJhY2sgPSB1c2VDYWxsYmFjayhtID0+IHtcbiAgICBzZXRNYXJrZXIobSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFtyZWZDYWxsYmFjaywgbWFya2VyXTtcbn1cblxuLyoqXG4gKiBDb21wb25lbnQgdG8gcmVuZGVyIGEgZ29vZ2xlIG1hcHMgbWFya2VyIFBpbiBWaWV3XG4gKi9cbmNvbnN0IFBpbiA9IHByb3BzID0+IHtcbiAgdmFyIF91c2VDb250ZXh0O1xuICBjb25zdCBhZHZhbmNlZE1hcmtlciA9IChfdXNlQ29udGV4dCA9IHVzZUNvbnRleHQoQWR2YW5jZWRNYXJrZXJDb250ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF91c2VDb250ZXh0Lm1hcmtlcjtcbiAgY29uc3QgZ2x5cGhDb250YWluZXIgPSB1c2VNZW1vKCgpID0+IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBbXSk7XG4gIC8vIENyZWF0ZSBQaW4gVmlldyBpbnN0YW5jZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghYWR2YW5jZWRNYXJrZXIpIHtcbiAgICAgIGlmIChhZHZhbmNlZE1hcmtlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSA8UGluPiBjb21wb25lbnQgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgPEFkdmFuY2VkTWFya2VyPi4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmdseXBoICYmIHByb3BzLmNoaWxkcmVuKSB7XG4gICAgICBsb2dFcnJvck9uY2UoJ1RoZSA8UGluPiBjb21wb25lbnQgb25seSB1c2VzIGNoaWxkcmVuIHRvIHJlbmRlciB0aGUgZ2x5cGggaWYgYm90aCB0aGUgZ2x5cGggcHJvcGVydHkgYW5kIGNoaWxkcmVuIGFyZSBwcmVzZW50LicpO1xuICAgIH1cbiAgICBpZiAoQ2hpbGRyZW4uY291bnQocHJvcHMuY2hpbGRyZW4pID4gMSkge1xuICAgICAgbG9nRXJyb3JPbmNlKCdQYXNzaW5nIG11bHRpcGxlIGNoaWxkcmVuIHRvIHRoZSA8UGluPiBjb21wb25lbnQgbWlnaHQgbGVhZCB0byB1bmV4cGVjdGVkIHJlc3VsdHMuJyk7XG4gICAgfVxuICAgIGNvbnN0IHBpblZpZXdPcHRpb25zID0gX2V4dGVuZHMoe30sIHByb3BzKTtcbiAgICBjb25zdCBwaW5FbGVtZW50ID0gbmV3IGdvb2dsZS5tYXBzLm1hcmtlci5QaW5FbGVtZW50KHBpblZpZXdPcHRpb25zKTtcbiAgICAvLyBTZXQgZ2x5cGggdG8gZ2x5cGggY29udGFpbmVyIGlmIGNoaWxkcmVuIGFyZSBwcmVzZW50IChyZW5kZXJlZCB2aWEgcG9ydGFsKS5cbiAgICAvLyBJZiBib3RoIHByb3BzLmdseXBoIGFuZCBwcm9wcy5jaGlsZHJlbiBhcmUgcHJlc2VudCwgcHJvcHMuY2hpbGRyZW4gdGFrZXMgcHJpb3JpdHkuXG4gICAgaWYgKHByb3BzLmNoaWxkcmVuKSB7XG4gICAgICBwaW5FbGVtZW50LmdseXBoID0gZ2x5cGhDb250YWluZXI7XG4gICAgfVxuICAgIC8vIFNldCBjb250ZW50IG9mIEFkdmFuY2VkIE1hcmtlciBWaWV3IHRvIHRoZSBQaW4gVmlldyBlbGVtZW50XG4gICAgYWR2YW5jZWRNYXJrZXIuY29udGVudCA9IHBpbkVsZW1lbnQuZWxlbWVudDtcbiAgfSwgW2FkdmFuY2VkTWFya2VyLCBnbHlwaENvbnRhaW5lciwgcHJvcHNdKTtcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbChwcm9wcy5jaGlsZHJlbiwgZ2x5cGhDb250YWluZXIpO1xufTtcblxuLyoqXG4gKiBBIHR5cGVzY3JpcHQgYXNzZXJ0aW9uIGZ1bmN0aW9uIHVzZWQgaW4gY2FzZXMgd2hlcmUgdHlwZXNjcmlwdCBoYXMgdG8gYmVcbiAqIGNvbnZpbmNlZCB0aGF0IHRoZSBvYmplY3QgaW4gcXVlc3Rpb24gY2FuIG5vdCBiZSBudWxsLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Tm90TnVsbCh2YWx1ZSwgbWVzc2FnZSA9ICdhc3NlcnRpb24gZmFpbGVkJykge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbmNvbnN0IHVzZURpcmVjdGlvbnNSZW5kZXJlciA9IChtYXBJZCwgcmVuZGVyT25NYXAsIHJlbmRlck9wdGlvbnMpID0+IHtcbiAgY29uc3QgbWFwID0gdXNlTWFwKG1hcElkKTtcbiAgLy8gY3JlYXRlIHRoZSByZW5kZXJlciBpbnN0YW5jZVxuICBjb25zdCBkaXJlY3Rpb25zUmVuZGVyZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIW1hcCB8fCAhcmVuZGVyT25NYXApIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IGdvb2dsZS5tYXBzLkRpcmVjdGlvbnNSZW5kZXJlcihyZW5kZXJPcHRpb25zKTtcbiAgICByZW5kZXJlci5zZXRNYXAobWFwKTtcbiAgICByZXR1cm4gcmVuZGVyZXI7XG4gIH0sXG4gIC8vIG5vdGU6IG5vIGRlcGVuZGVuY3kgb24gcmVuZGVyT3B0aW9ucyBzaW5jZSB0aG9zZSBhcmUgaGFuZGxlZCBpbiB0aGVcbiAgLy8gbmV4dCBlZmZlY3QuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW21hcCwgcmVuZGVyT25NYXBdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWRpcmVjdGlvbnNSZW5kZXJlcikgcmV0dXJuO1xuICAgIGRpcmVjdGlvbnNSZW5kZXJlci5zZXRPcHRpb25zKHJlbmRlck9wdGlvbnMgfHwge30pO1xuICB9LFxuICAvLyBub3RlOiBkaXJlY3Rpb25zUmVuZGVyZXIgZGVwZW5kZW5jeSBpc24ndCBuZWVkZWQgc2luY2UgdGhlXG4gIC8vIHJlbmRlck9wdGlvbnMgd2lsbCBiZSBzZXQgb24gaW5pdGlhbGl6YXRpb24gd2hlbiBjcmVhdGluZyB0aGUgcmVuZGVyZXIuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW3JlbmRlck9wdGlvbnNdKTtcbiAgcmV0dXJuIGRpcmVjdGlvbnNSZW5kZXJlcjtcbn07XG4vKipcbiAqIEhvb2sgdG8gZ2V0IEdvb2dsZSBNYXBzIFBsYWNlcyBEaXJlY3Rpb25zIFNlcnZpY2UgaW5zdGFuY2VcbiAqL1xuY29uc3QgdXNlRGlyZWN0aW9uc1NlcnZpY2UgPSAocHJvcHMgPSB7fSkgPT4ge1xuICBjb25zdCB7XG4gICAgbWFwSWQgPSBudWxsLFxuICAgIHJlbmRlck9uTWFwLFxuICAgIHJlbmRlck9wdGlvbnNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBpc0FwaUxvYWRlZCA9IHVzZUFwaUlzTG9hZGVkKCk7XG4gIC8vIENyZWF0ZXMgYSBEaXJlY3Rpb25zIFNlcnZpY2UgaW5zdGFuY2VcbiAgY29uc3QgZGlyZWN0aW9uc1NlcnZpY2UgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAvLyBXYWl0IGZvciBHb29nbGUgTWFwcyBBUEkgdG8gYmUgbG9hZGVkXG4gICAgaWYgKCFpc0FwaUxvYWRlZCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5EaXJlY3Rpb25zU2VydmljZSgpO1xuICB9LCBbaXNBcGlMb2FkZWRdKTtcbiAgLy8gY3JlYXRlIHRoZSByZW5kZXJlciBpbnN0YW5jZVxuICBjb25zdCBkaXJlY3Rpb25zUmVuZGVyZXIgPSB1c2VEaXJlY3Rpb25zUmVuZGVyZXIobWFwSWQsIHJlbmRlck9uTWFwLCByZW5kZXJPcHRpb25zKTtcbiAgLy8gQ3VzdG9tIERpcmVjdGlvbnMgcm91dGUgcmVxdWVzdCBmb2xsb3dlZCBieSBkaXJlY3Rpb25zIHJlbmRlcmluZ1xuICBjb25zdCByZW5kZXJSb3V0ZSA9IHVzZUNhbGxiYWNrKGFzeW5jIHJlcXVlc3QgPT4ge1xuICAgIC8vIGZpbmRBbmRSZW5kZXJSb3V0ZSgpIGlzbid0IGNhbGxhYmxlIHdoZW4gZWl0aGVyIGRpcmVjdGlvbnNcbiAgICAvLyBzZXJ2aWNlIG9yIHJlbmRlcmVyIGFyZW4ndCByZWFkeVxuICAgIGFzc2VydE5vdE51bGwoZGlyZWN0aW9uc1NlcnZpY2UpO1xuICAgIGFzc2VydE5vdE51bGwoZGlyZWN0aW9uc1JlbmRlcmVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkaXJlY3Rpb25zU2VydmljZS5yb3V0ZShyZXF1ZXN0KTtcbiAgICBkaXJlY3Rpb25zUmVuZGVyZXIuc2V0RGlyZWN0aW9ucyhyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIFtkaXJlY3Rpb25zU2VydmljZSwgZGlyZWN0aW9uc1JlbmRlcmVyXSk7XG4gIC8vIFJlbmRlcnMgZGlyZWN0aW9ucyByb3V0ZSBvZiBnaXZlbiBpbmRleFxuICBjb25zdCBzZXRSZW5kZXJlZFJvdXRlSW5kZXggPSBpbmRleCA9PiB7XG4gICAgYXNzZXJ0Tm90TnVsbChkaXJlY3Rpb25zUmVuZGVyZXIpO1xuICAgIGRpcmVjdGlvbnNSZW5kZXJlci5zZXRSb3V0ZUluZGV4KGluZGV4KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBkaXJlY3Rpb25zU2VydmljZSxcbiAgICBkaXJlY3Rpb25zUmVuZGVyZXIsXG4gICAgcmVuZGVyUm91dGU6IGRpcmVjdGlvbnNTZXJ2aWNlICYmIGRpcmVjdGlvbnNSZW5kZXJlciA/IHJlbmRlclJvdXRlIDogbnVsbCxcbiAgICBzZXRSZW5kZXJlZFJvdXRlSW5kZXg6IGRpcmVjdGlvbnNTZXJ2aWNlICYmIGRpcmVjdGlvbnNSZW5kZXJlciA/IHNldFJlbmRlcmVkUm91dGVJbmRleCA6IG51bGxcbiAgfTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbi8qKlxuICogSG9vayB0byBnZXQgU3RyZWV0IFZpZXcgUGFub3JhbWFcbiAqL1xuY29uc3QgdXNlU3RyZWV0Vmlld1Bhbm9yYW1hID0gKHByb3BzID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIG1hcElkLFxuICAgIGRpdkVsZW1lbnQsXG4gICAgcG9zaXRpb24sXG4gICAgcG92LFxuICAgIHpvb21cbiAgfSA9IHByb3BzO1xuICBjb25zdCBnb29nbGVNYXBzQVBJSXNMb2FkZWQgPSB1c2VBcGlJc0xvYWRlZCgpO1xuICBjb25zdCBtYXAgPSB1c2VNYXAobWFwSWQpO1xuICBjb25zdCBbc3RyZWV0Vmlld1Bhbm9yYW1hLCBzZXRTdHJlZXRWaWV3UGFub3JhbWFdID0gdXNlU3RhdGUobnVsbCk7XG4gIC8vIENyZWF0ZXMgYSBTdHJlZXQgVmlldyBpbnN0YW5jZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZ29vZ2xlTWFwc0FQSUlzTG9hZGVkKSByZXR1cm47XG4gICAgbGV0IHBhbm8gPSBudWxsO1xuICAgIGlmIChkaXZFbGVtZW50KSB7XG4gICAgICBwYW5vID0gbmV3IGdvb2dsZS5tYXBzLlN0cmVldFZpZXdQYW5vcmFtYShkaXZFbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKG1hcCkge1xuICAgICAgcGFubyA9IG1hcC5nZXRTdHJlZXRWaWV3KCk7XG4gICAgfVxuICAgIHNldFN0cmVldFZpZXdQYW5vcmFtYShwYW5vKTtcbiAgICBpZiAoIXBhbm8pIHJldHVybjtcbiAgICBpZiAocG92KSBwYW5vLnNldFBvdihwb3YpO1xuICAgIGlmIChwb3NpdGlvbikgcGFuby5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgaWYgKHpvb20gfHwgem9vbSA9PT0gMCkgcGFuby5zZXRab29tKHpvb20pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzZXRTdHJlZXRWaWV3UGFub3JhbWEobnVsbCk7XG4gICAgICBpZiAobWFwKSBtYXAuc2V0U3RyZWV0VmlldyhudWxsKTtcbiAgICB9O1xuICB9LFxuICAvLyBmaXhtZTogaW1wbGVtZW50IGV4dHJhIGhvb2sgdG8gdXBkYXRlIEZPViB3aGVuIHByb3BzIGNoYW5nZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtnb29nbGVNYXBzQVBJSXNMb2FkZWQsIG1hcCwgZGl2RWxlbWVudF0pO1xuICByZXR1cm4gc3RyZWV0Vmlld1Bhbm9yYW1hO1xufTtcblxuY29uc3QgbWFwTGluZWFyID0gKHgsIGExLCBhMiwgYjEsIGIyKSA9PiBiMSArICh4IC0gYTEpICogKGIyIC0gYjEpIC8gKGEyIC0gYTEpO1xuY29uc3QgZ2V0TWFwTWF4VGlsdCA9IHpvb20gPT4ge1xuICBpZiAoem9vbSA8PSAxMCkge1xuICAgIHJldHVybiAzMDtcbiAgfVxuICBpZiAoem9vbSA+PSAxNS41KSB7XG4gICAgcmV0dXJuIDY3LjU7XG4gIH1cbiAgLy8gcmFuZ2UgWzEwLi4uMTRdXG4gIGlmICh6b29tIDw9IDE0KSB7XG4gICAgcmV0dXJuIG1hcExpbmVhcih6b29tLCAxMCwgMTQsIDMwLCA0NSk7XG4gIH1cbiAgLy8gcmFuZ2UgWzE0Li4uMTUuNV1cbiAgcmV0dXJuIG1hcExpbmVhcih6b29tLCAxNCwgMTUuNSwgNDUsIDY3LjUpO1xufTtcbi8qKlxuICogRnVuY3Rpb24gdG8gbGltaXQgdGhlIHRpbHQgcmFuZ2Ugb2YgdGhlIGdvb2dsZSBtYXBzIG1hcCB3aGVuIHVwZGF0aW5nIHRoZSB2aWV3IHN0YXRlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBsaW1pdFRpbHRSYW5nZSA9ICh7XG4gIHZpZXdTdGF0ZVxufSkgPT4ge1xuICBjb25zdCBwaXRjaCA9IHZpZXdTdGF0ZS5waXRjaDtcbiAgY29uc3QgZ21ab29tID0gdmlld1N0YXRlLnpvb20gKyAxO1xuICBjb25zdCBtYXhUaWx0ID0gZ2V0TWFwTWF4VGlsdChnbVpvb20pO1xuICByZXR1cm4gX2V4dGVuZHMoe30sIHZpZXdTdGF0ZSwge1xuICAgIGZvdnk6IDI1LFxuICAgIHBpdGNoOiBNYXRoLm1pbihtYXhUaWx0LCBwaXRjaClcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBBUElQcm92aWRlciwgQVBJUHJvdmlkZXJDb250ZXh0LCBBZHZhbmNlZE1hcmtlciwgQWR2YW5jZWRNYXJrZXJDb250ZXh0LCBDb250cm9sUG9zaXRpb24sIEdvb2dsZU1hcHNDb250ZXh0LCBJbmZvV2luZG93LCBNYXAsIE1hcENvbnRyb2wsIE1hcmtlciwgUGluLCBpc0xhdExuZ0xpdGVyYWwsIGxhdExuZ0VxdWFscywgbGltaXRUaWx0UmFuZ2UsIHRvTGF0TG5nTGl0ZXJhbCwgdXNlQWR2YW5jZWRNYXJrZXJSZWYsIHVzZUFwaUlzTG9hZGVkLCB1c2VBcGlMb2FkaW5nU3RhdHVzLCB1c2VEaXJlY3Rpb25zU2VydmljZSwgdXNlTWFwLCB1c2VNYXBzTGlicmFyeSwgdXNlTWFya2VyUmVmLCB1c2VTdHJlZXRWaWV3UGFub3JhbWEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1vZGVybi5tanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZVJlZHVjZXIiLCJ1c2VNZW1vIiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VDb250ZXh0IiwidXNlTGF5b3V0RWZmZWN0IiwiZm9yd2FyZFJlZiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJDaGlsZHJlbiIsImNyZWF0ZVBvcnRhbCIsImlzRGVlcEVxdWFsIiwiX3RvUHJpbWl0aXZlIiwidCIsInIiLCJlIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJpIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIl90b1Byb3BlcnR5S2V5IiwiX2V4dGVuZHMiLCJPYmplY3QiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJhcHBseSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZXhjbHVkZWQiLCJzb3VyY2VLZXlzIiwia2V5cyIsImluZGV4T2YiLCJBUElMb2FkaW5nU3RhdHVzIiwiTk9UX0xPQURFRCIsIkxPQURJTkciLCJMT0FERUQiLCJGQUlMRUQiLCJBVVRIX0ZBSUxVUkUiLCJNQVBTX0FQSV9CQVNFX1VSTCIsIkdvb2dsZU1hcHNBcGlMb2FkZXIiLCJsb2FkIiwicGFyYW1zIiwib25Mb2FkaW5nU3RhdHVzQ2hhbmdlIiwiX3dpbmRvdyRnb29nbGUiLCJsaWJyYXJpZXMiLCJzcGxpdCIsInNlcmlhbGl6ZWRQYXJhbXMiLCJzZXJpYWxpemVQYXJhbXMiLCJ3aW5kb3ciLCJnb29nbGUiLCJtYXBzIiwiaW1wb3J0TGlicmFyeSIsInNlcmlhbGl6ZWRBcGlQYXJhbXMiLCJpbml0SW1wb3J0TGlicmFyeSIsImxvYWRpbmdTdGF0dXMiLCJjb25zb2xlIiwid2FybiIsImxpYiIsInYiLCJsYW5ndWFnZSIsInJlZ2lvbiIsImF1dGhSZWZlcnJlclBvbGljeSIsInNvbHV0aW9uQ2hhbm5lbCIsImpvaW4iLCJhcGlQcm9taXNlIiwibG9hZEFwaSIsImxpYnJhcnkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIl9kb2N1bWVudCRxdWVyeVNlbGVjdCIsInNjcmlwdEVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ1cmxQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ2YWx1ZSIsImVudHJpZXMiLCJ1cmxQYXJhbU5hbWUiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJzZXQiLCJhc3luYyIsInNyYyIsInRvU3RyaW5nIiwiX19nb29nbGVNYXBzQ2FsbGJhY2tfXyIsImdtX2F1dGhGYWlsdXJlIiwib25lcnJvciIsIkVycm9yIiwibm9uY2UiLCJxdWVyeVNlbGVjdG9yIiwiaGVhZCIsImFwcGVuZCIsImxpYnJhcnlOYW1lIiwidGhlbiIsIl9leGNsdWRlZCQzIiwiX2V4Y2x1ZGVkMiIsIkFQSVByb3ZpZGVyQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VNYXBJbnN0YW5jZXMiLCJtYXBJbnN0YW5jZXMiLCJzZXRNYXBJbnN0YW5jZXMiLCJhZGRNYXBJbnN0YW5jZSIsIm1hcEluc3RhbmNlIiwiaWQiLCJpbnN0YW5jZXMiLCJyZW1vdmVNYXBJbnN0YW5jZSIsIl9yZWYiLCJyZW1haW5pbmciLCJtYXAiLCJjbGVhck1hcEluc3RhbmNlcyIsInVzZUdvb2dsZU1hcHNBcGlMb2FkZXIiLCJwcm9wcyIsIm9uTG9hZCIsImFwaUtleSIsInZlcnNpb24iLCJvdGhlckFwaVBhcmFtcyIsInN0YXR1cyIsInNldFN0YXR1cyIsImxvYWRlZExpYnJhcmllcyIsImFkZExvYWRlZExpYnJhcnkiLCJhY3Rpb24iLCJuYW1lIiwibGlicmFyaWVzU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsIl9nb29nbGUiLCJyZXMiLCJlcnJvciIsIkFQSVByb3ZpZGVyIiwiY2hpbGRyZW4iLCJsb2FkZXJQcm9wcyIsIlByb3ZpZGVyIiwidXNlTWFwRXZlbnRzIiwicHJvcE5hbWUiLCJldmVudFByb3BOYW1lcyIsImhhbmRsZXIiLCJldmVudFR5cGUiLCJwcm9wTmFtZVRvRXZlbnRUeXBlIiwibGlzdGVuZXIiLCJldmVudCIsImFkZExpc3RlbmVyIiwiZXYiLCJjcmVhdGVNYXBFdmVudCIsInJlbW92ZSIsInR5cGUiLCJzcmNFdmVudCIsImRldGFpbCIsInN0b3BwYWJsZSIsInN0b3AiLCJjYW1lcmFFdmVudFR5cGVzIiwiaW5jbHVkZXMiLCJjYW1FdmVudCIsImNlbnRlciIsImdldENlbnRlciIsInpvb20iLCJnZXRab29tIiwiaGVhZGluZyIsImdldEhlYWRpbmciLCJ0aWx0IiwiZ2V0VGlsdCIsImJvdW5kcyIsImdldEJvdW5kcyIsImlzRmluaXRlIiwidG9KU09OIiwibGF0IiwibG5nIiwibm9ydGgiLCJlYXN0Iiwic291dGgiLCJ3ZXN0IiwibW91c2VFdmVudFR5cGVzIiwiX3NyY0V2ZW50JGxhdExuZyIsIm1vdXNlRXZlbnQiLCJkb21FdmVudCIsImxhdExuZyIsInBsYWNlSWQiLCJvbkJvdW5kc0NoYW5nZWQiLCJvbkNlbnRlckNoYW5nZWQiLCJvbkNsaWNrIiwib25Db250ZXh0bWVudSIsIm9uRGJsY2xpY2siLCJvbkRyYWciLCJvbkRyYWdlbmQiLCJvbkRyYWdzdGFydCIsIm9uSGVhZGluZ0NoYW5nZWQiLCJvbklkbGUiLCJvbklzRnJhY3Rpb25hbFpvb21FbmFibGVkQ2hhbmdlZCIsIm9uTWFwQ2FwYWJpbGl0aWVzQ2hhbmdlZCIsIm9uTWFwVHlwZUlkQ2hhbmdlZCIsIm9uTW91c2Vtb3ZlIiwib25Nb3VzZW91dCIsIm9uTW91c2VvdmVyIiwib25Qcm9qZWN0aW9uQ2hhbmdlZCIsIm9uUmVuZGVyaW5nVHlwZUNoYW5nZWQiLCJvblRpbGVzTG9hZGVkIiwib25UaWx0Q2hhbmdlZCIsIm9uWm9vbUNoYW5nZWQiLCJvbkNhbWVyYUNoYW5nZWQiLCJ1c2VEZWVwQ29tcGFyZUVmZmVjdCIsImVmZmVjdCIsImRlcHMiLCJyZWYiLCJ1bmRlZmluZWQiLCJjdXJyZW50IiwibWFwT3B0aW9uS2V5cyIsIlNldCIsInVzZU1hcE9wdGlvbnMiLCJtYXBQcm9wcyIsIm1hcE9wdGlvbnMiLCJoYXMiLCJzZXRPcHRpb25zIiwidXNlRm9yY2VVcGRhdGUiLCJmb3JjZVVwZGF0ZSIsIngiLCJoYW5kbGVCb3VuZHNDaGFuZ2UiLCJ1c2VUcmFja2VkQ2FtZXJhU3RhdGVSZWYiLCJ1c2VBcGlMb2FkaW5nU3RhdHVzIiwiX3VzZUNvbnRleHQiLCJ1c2VEZWNrR0xDYW1lcmFVcGRhdGUiLCJ2aWV3cG9ydCIsInZpZXdTdGF0ZSIsImlzRGVja0dsQ29udHJvbGxlZCIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiYmVhcmluZyIsInBpdGNoIiwibW92ZUNhbWVyYSIsImlzTGF0TG5nTGl0ZXJhbCIsIm9iaiIsImxhdExuZ0VxdWFscyIsImEiLCJiIiwiQSIsInRvTGF0TG5nTGl0ZXJhbCIsIkIiLCJ1c2VNYXBDYW1lcmFQYXJhbXMiLCJjYW1lcmFTdGF0ZVJlZiIsIm5leHRDYW1lcmEiLCJuZWVkc1VwZGF0ZSIsIkF1dGhGYWlsdXJlTWVzc2FnZSIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwiYm90dG9tIiwicmlnaHQiLCJ6SW5kZXgiLCJkaXNwbGF5IiwiZmxleEZsb3ciLCJ0ZXh0QWxpZ24iLCJqdXN0aWZ5Q29udGVudCIsImZvbnRTaXplIiwiY29sb3IiLCJiYWNrZ3JvdW5kIiwicGFkZGluZyIsInVzZUNhbGxiYWNrUmVmIiwiZWwiLCJzZXRFbCIsInVzZUFwaUlzTG9hZGVkIiwiX2V4Y2x1ZGVkJDIiLCJ1c2VNYXBJbnN0YW5jZSIsImNvbnRleHQiLCJhcGlJc0xvYWRlZCIsInNldE1hcCIsImNvbnRhaW5lciIsImNvbnRhaW5lclJlZiIsImRlZmF1bHRCb3VuZHMiLCJkZWZhdWx0Q2VudGVyIiwiZGVmYXVsdFpvb20iLCJkZWZhdWx0SGVhZGluZyIsImRlZmF1bHRUaWx0IiwibmV3TWFwIiwiTWFwIiwiZml0Qm91bmRzIiwiY2xlYXJJbnN0YW5jZUxpc3RlbmVycyIsIm1hcElkIiwiR29vZ2xlTWFwc0NvbnRleHQiLCJjbGFzc05hbWUiLCJtYXBSZWYiLCJpc0NvbnRyb2xsZWRFeHRlcm5hbGx5IiwiY29udHJvbGxlZCIsImRpc2FibGVEZWZhdWx0VUkiLCJnZXN0dXJlSGFuZGxpbmciLCJrZXlib2FyZFNob3J0Y3V0cyIsImNhbWVyYU9wdGlvbnMiLCJfbGF0IiwiX2xuZyIsIl9wcm9wcyR6b29tIiwiX3Byb3BzJGhlYWRpbmciLCJfcHJvcHMkdGlsdCIsImNvbWJpbmVkU3R5bGUiLCJ3aWR0aCIsImhlaWdodCIsImRlY2tHTFZpZXdQcm9wcyIsInVzZU1hcHNMaWJyYXJ5IiwiY3R4IiwiQWR2YW5jZWRNYXJrZXJDb250ZXh0IiwidXNlQWR2YW5jZWRNYXJrZXIiLCJtYXJrZXIiLCJzZXRNYXJrZXIiLCJjb250ZW50Q29udGFpbmVyIiwic2V0Q29udGVudENvbnRhaW5lciIsIm1hcmtlckxpYnJhcnkiLCJvbkRyYWdTdGFydCIsIm9uRHJhZ0VuZCIsImNvbGxpc2lvbkJlaGF2aW9yIiwiZHJhZ2dhYmxlIiwidGl0bGUiLCJudW1DaGlsZHMiLCJjb3VudCIsIm5ld01hcmtlciIsIkFkdmFuY2VkTWFya2VyRWxlbWVudCIsImNvbnRlbnQiLCJnbWUiLCJtIiwiZ21wRHJhZ2dhYmxlIiwiQWR2YW5jZWRNYXJrZXIiLCJ1c2VBZHZhbmNlZE1hcmtlclJlZiIsInJlZkNhbGxiYWNrIiwiX2V4Y2x1ZGVkJDEiLCJJbmZvV2luZG93IiwiYW5jaG9yIiwib25DbG9zZUNsaWNrIiwiaW5mb1dpbmRvd09wdGlvbnMiLCJpbmZvV2luZG93UmVmIiwibmV3SW5mb3dpbmRvdyIsInNldENvbnRlbnQiLCJjbG9zZSIsIl9pbmZvV2luZG93UmVmJGN1cnJlbiIsIm9wZW5PcHRpb25zIiwib3BlbiIsIkZyYWdtZW50Iiwic2hvd25NZXNzYWdlcyIsImxvZ0Vycm9yT25jZSIsImFyZ3MiLCJhZGQiLCJ1c2VNYXAiLCJDb250cm9sUG9zaXRpb24iLCJUT1BfTEVGVCIsIlRPUF9DRU5URVIiLCJUT1AiLCJUT1BfUklHSFQiLCJMRUZUX0NFTlRFUiIsIkxFRlRfVE9QIiwiTEVGVCIsIkxFRlRfQk9UVE9NIiwiUklHSFRfVE9QIiwiUklHSFQiLCJSSUdIVF9DRU5URVIiLCJSSUdIVF9CT1RUT00iLCJCT1RUT01fTEVGVCIsIkJPVFRPTV9DRU5URVIiLCJCT1RUT00iLCJCT1RUT01fUklHSFQiLCJDRU5URVIiLCJCTE9DS19TVEFSVF9JTkxJTkVfU1RBUlQiLCJCTE9DS19TVEFSVF9JTkxJTkVfQ0VOVEVSIiwiQkxPQ0tfU1RBUlRfSU5MSU5FX0VORCIsIklOTElORV9TVEFSVF9CTE9DS19DRU5URVIiLCJJTkxJTkVfU1RBUlRfQkxPQ0tfU1RBUlQiLCJJTkxJTkVfU1RBUlRfQkxPQ0tfRU5EIiwiSU5MSU5FX0VORF9CTE9DS19TVEFSVCIsIklOTElORV9FTkRfQkxPQ0tfQ0VOVEVSIiwiSU5MSU5FX0VORF9CTE9DS19FTkQiLCJCTE9DS19FTkRfSU5MSU5FX1NUQVJUIiwiQkxPQ0tfRU5EX0lOTElORV9DRU5URVIiLCJCTE9DS19FTkRfSU5MSU5FX0VORCIsIk1hcENvbnRyb2wiLCJjb250cm9sQ29udGFpbmVyIiwiY29udHJvbHMiLCJwdXNoIiwiaW5kZXgiLCJnZXRBcnJheSIsInJlbW92ZUF0IiwiX2V4Y2x1ZGVkIiwidXNlTWFya2VyIiwib25Nb3VzZU92ZXIiLCJvbk1vdXNlT3V0IiwibWFya2VyT3B0aW9ucyIsIk1hcmtlciIsInNldERyYWdnYWJsZSIsIkJvb2xlYW4iLCJzZXRQb3NpdGlvbiIsInVzZU1hcmtlclJlZiIsIlBpbiIsImFkdmFuY2VkTWFya2VyIiwiZ2x5cGhDb250YWluZXIiLCJnbHlwaCIsInBpblZpZXdPcHRpb25zIiwicGluRWxlbWVudCIsIlBpbkVsZW1lbnQiLCJlbGVtZW50IiwiYXNzZXJ0Tm90TnVsbCIsIm1lc3NhZ2UiLCJ1c2VEaXJlY3Rpb25zUmVuZGVyZXIiLCJyZW5kZXJPbk1hcCIsInJlbmRlck9wdGlvbnMiLCJkaXJlY3Rpb25zUmVuZGVyZXIiLCJyZW5kZXJlciIsIkRpcmVjdGlvbnNSZW5kZXJlciIsInVzZURpcmVjdGlvbnNTZXJ2aWNlIiwiaXNBcGlMb2FkZWQiLCJkaXJlY3Rpb25zU2VydmljZSIsIkRpcmVjdGlvbnNTZXJ2aWNlIiwicmVuZGVyUm91dGUiLCJyZXF1ZXN0IiwicmVzdWx0Iiwicm91dGUiLCJzZXREaXJlY3Rpb25zIiwic2V0UmVuZGVyZWRSb3V0ZUluZGV4Iiwic2V0Um91dGVJbmRleCIsInVzZVN0cmVldFZpZXdQYW5vcmFtYSIsImRpdkVsZW1lbnQiLCJwb3YiLCJnb29nbGVNYXBzQVBJSXNMb2FkZWQiLCJzdHJlZXRWaWV3UGFub3JhbWEiLCJzZXRTdHJlZXRWaWV3UGFub3JhbWEiLCJwYW5vIiwiU3RyZWV0Vmlld1Bhbm9yYW1hIiwiZ2V0U3RyZWV0VmlldyIsInNldFBvdiIsInNldFpvb20iLCJzZXRTdHJlZXRWaWV3IiwibWFwTGluZWFyIiwiYTEiLCJhMiIsImIxIiwiYjIiLCJnZXRNYXBNYXhUaWx0IiwibGltaXRUaWx0UmFuZ2UiLCJnbVpvb20iLCJtYXhUaWx0IiwiZm92eSIsIk1hdGgiLCJtaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs\n"));

/***/ })

});